'use strict';

/* globals fin */
var Point = require('rectangular').Point;
var behaviors = fin.Hypergrid.behaviors;

module.exports = {
    /**
     * @desc Clear out all state settings, data (rows), and schema (columns) of a grid instance.
     * @param {object} [options]
     * @param {object} [options.subgrids] - Consumed by {@link Behavior#reset}.
     * If omitted, previously established subgrids list is reused.
     * @param {object} [options.pipeline] - Consumed by {@link dataModels.JSON#reset}.
     * If omitted, previously established pipeline is reused.
     * @param {object} [options.controllers] - Consumed by {@link dataModels.JSON#reset}.
     * If omitted, previously established controllers list is reused.
     * @memberOf Hypergrid#
     */
    reset: function(options) {
        this.clearState();

        this.removeAllEventListeners();

        this.lastEdgeSelection = [0, 0];
        this.selectionModel.reset();
        this.renderOverridesCache = {};
        this.clearMouseDown();
        this.dragExtent = new Point(0, 0);

        this.numRows = 0;
        this.numColumns = 0;

        this.vScrollValue = 0;
        this.hScrollValue = 0;

        this.cancelEditing();

        this.sbPrevVScrollValue = null;
        this.sbPrevHScrollValue = null;

        this.hoverCell = null;
        this.scrollingNow = false;
        this.lastEdgeSelection = [0, 0];

        options = options || {};
        this.behavior.reset({
            subgrids: options.subgrids,
            pipeline: options.pipeline,
            controllers: options.controllers
        });

        this.renderer.reset();
        this.canvas.resize();
        this.behaviorChanged();

        this.refreshProperties();
    },


    /**
     * @memberOf Hypergrid#
     * @summary Set the Behavior (model) object for this grid control.
     * @desc This can be done dynamically.
     * @param {object} options - _(See {@link behaviors.JSON#setData}.)_
     * @param {Behavior} [options.behavior=behaviors.JSON] - The behavior (model) can be either a constructor or an instance.
     * @param {dataRowObject[]} [options.data] - _(See {@link behaviors.JSON#setData}.)_
     * @param {pipelineSchema} [options.pipeline] - New pipeline description.
     */
    setBehavior: function(options) {
        if (!this.behavior) {
            // If we get here it means:
            // 1. Called from constructor because behavior included in options object.
            // 2. Called from `setData` _and_ wasn't called explicitly since instantiation
            var Behavior = options.Behavior || behaviors.JSON;
            this.behavior = new Behavior(this, options);
            this.initCanvas();
            this.initScrollbars();
            this.refreshProperties();
            this.behavior.reindex();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @param {object} [pipelines] - New pipeline description. _(See {@link dataModels.JSON#setPipeline}.)_
     * @param {object} [options] - _(See {@link dataModels.JSON#setPipeline}.)_
     */
    setPipeline: function(DataSources, options){
        this.behavior.setPipeline(DataSources, options);
    },

    /**
     * @summary Get the given data controller.
     * @param {string} type
     * @returns {null|undefined|*} The data controller or:
     * * `null` means unknown data controller.
     * * `undefined` means the data source handles this data controller but the data controller is undefined.
     * @memberOf Hypergrid#
     */
    getController: function(type) {
        return this.behavior.getController(type);
    },

    /**
     * @summary Set the given data controller(s).
     * @desc The data model needs to be able to accept the specified data controller type(s). If it fails to accept the specified data controller(s), an error condition is raised.
     *
     * (To ignore the error, place the call in a `try...catch`. From there you could call {@link Base#notify|notify} to report it as a warning or an alert instead.)
     *
     * Setting data controller(s) triggers a shape change.
     * @param {string} typeOrHashOfTypes - One of:
     * * **object** - Hash of multiple data controllers, by type.
     * * **string** - Type of the single data controller given in `controller`.
     * @param {dataControlInterface} [controller] - Only required when 'hash' is a string; omit when `hash` is an object.
     * @returns {object} - Hash of all results, by type. Each member will be:
     * * The given data controller for that type when defined.
     * * A new "null" data controller, generated by the data model when the given data controller for that type was `undefined`.
     * * `undefined` - The data controller was unknown to the data model.
     * @memberOf Hypergrid#
     */
    setController: function(typeOrHashOfTypes, controller) {
        var results = this.behavior.setController(typeOrHashOfTypes, controller),
            rejections = Object.keys(results).filter(function(name) {
                return !results[name];
            }).toString();

        if (rejections) {
            throw 'Unexpected data controller(s): ' + rejections;
        }

        return results;
    },

    prop: function(type, columnIndex, keyOrHash, value) {
        return this.behavior.prop.apply(this.behavior, arguments);
    },

    get charMap() {
        return this.behavior.charMap;
    }

};

