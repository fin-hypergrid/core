(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var cssInjector = require('css-injector');

var stylesheets = {
    grid: [
        'div#grid-container {',
        '    position: relative;',
        '    display: inline-block;',
        '    -webkit-user-select: none;',
        '    -moz-user-select: none;',
        '    -ms-user-select: none;',
        '    -o-user-select: none;',
        '    user-select: none;',
        '    overflow: hidden; }',
        'visible { opacity: 0.75; }',
        'hidden { opacity: 0.0; }',
        'editor {',
        '    position: absolute;',
        '    display: none;',
        '    border: solid 2px black;',
        '    outline: 0;',
        '    padding: 0;',
        '    z-index: 1000; }'
    ],
    'list-dragon': [
        'div.dragon-list, li.dragon-pop {',
        '    font-family: Roboto, sans-serif;',
        '    text-transform: capitalize; }',
        'div.dragon-list {',
        '    position: absolute;',
        '    top: 4%;',
        '    left: 4%;',
        '    height: 92%;',
        '    width: 20%; }',
        'div.dragon-list:nth-child(2) { left: 28%; }',
        'div.dragon-list:nth-child(3) { left: 52%; }',
        'div.dragon-list:nth-child(4) { left: 76%; }',
        'div.dragon-list > div, div.dragon-list > ul > li, li.dragon-pop { line-height: 46px; }',
        'div.dragon-list > ul { top: 46px; }',
        'div.dragon-list > ul > li:not(:last-child)::before, li.dragon-pop::before {',
        '    content: \'\\2b24\';', // BLACK LARGE CIRCLE
        '    color: #b6b6b6;',
        '    font-size: 30px;',
        '    margin: 8px 14px 8px 8px; }',
        'li.dragon-pop { opacity:.8; }'
    ]
};

function addStylesheet(key, referenceElement) {
    cssInjector(stylesheets[key], key, referenceElement);
}

module.exports = addStylesheet;

},{"css-injector":4}],2:[function(require,module,exports){
module.exports = { // This file generated by gulp-imagine-64 at 5:36:37 PM on 3/8/2016
	"calendar": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAc0lEQVR4nIXQwQkCMRSE4U9ZLMCT9Xjaq2AfNhfYU5oQLMAOtoN48EWei5iBIRPe/yYQ3qrhf1lFG7iKcEaJxSfukUvMWgdHavt0uWHtg2QwxXnAnJZ2uOLyVZtybzzhgWNmfoFl0/YB87NbzR1cjP9xeQHSDC6mcL1xFQAAAABJRU5ErkJggg=="
	},
	"checked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAYJJREFUOE+NkstLglEQxf0fahG0iFrUxm2ElFDYLohCqCDaCAkWPaxIRbFFEJEaGEKLDCoMETRFUAMLyaIHBUG6sSKIMtKFqEhLT818ZUgmDhzu3DPn9z0uV1RrmUwmyGQyqNVqfFvViwBxu5RFPZuLSyGMKhz/qlEsRV19K8xm6y+w7bpBPFnAferjj3bdQX6DpHcAUwavAHUN2RGIZxBJZHH2mC/TUeydwwTZvBegLENNgw7sX6Wh1FswNmPEmjPCDyGRRwCtW9E3tMgdAtQw7GZjYcNX+gza2wJ3ZXsSZUuQ0vWCOV8SHfJJ/uluhbHUj1v8PKNMszIoQNRMHCShD6Wh8zyhrbOPwz8w+STKlCCJ7oRNUzQH63kBs5thBghePXxlj2aUoSxDPcuXPNiLAc5EEZ6HIkbmV2DYiXBPHs0o079+K0DTVj/s11mE00A0L+g4VcDp10qKZMAzytBhMaTRaPmYg885DlcSzSij0eoEiIouoUqlqqqaL2rlEok+Ad4vlfzPoVDsAAAAAElFTkSuQmCC"
	},
	"down-rectangle": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAECAYAAABcDxXOAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAABpJREFUGFdjgIL/eDAKIKgABggqgAE0BQwMAPTlD/Fpi0JfAAAAAElFTkSuQmCC"
	},
	"filter-off": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAChSURBVChTzZHBCoUgFET9TqEiskgyWoutQvRLRIr+cR7XQAjiJW/1BgZmMUevXsY5xy9OoDEGMcYiUzeB67qibVuwQjVNA6311V+WBeM4vsLDMEApde/1fY9pmtI453neHEKAlBJd1z0fXtc16PbjODK07zvmeUZVVd8nooc75zJIOX3Gm6i0bVsGKf8xKIRIuyJTLgJJ3nvQzsjW2geIsQ/pr9hMVrSncAAAAABJRU5ErkJggg=="
	},
	"filter-on": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAACoSURBVChTY3BqfP2fHAzWmDbj7f8p294RhVOBasEa02e+/e/VBmQQCTxaX/9PnvYGoj5ywpv/Qd2ENft3vv4f1gfVBAP+nW/+h/a+ATtn1q73KHjytvdgg3070DTBgHvL6/8g22fsQGiaDmSHA21xaybgIpDHixa8hWssnA8NDEIApCh3LkIjiD2INYJCL2X6W3B8gdhEaQQBUOCA4gyE8+e9xaKJgQEA/74BNE3cElkAAAAASUVORK5CYII="
	},
	"unchecked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAARBJREFUOE+9krtug1AQRPldSio7FQ1tZImOkoKOBomGT0EURC5ino54yTw90WywQhTkIkVWGoF2zuxdrlD+t0zThKZpT0Vmxb8CQRCg6zr0fb8rer7vfwcPxxdcrx+YpgnzPGNZlh9ibxxHlGUJshLSdV0at9tNpg7DIBrX5+OkPM9BVkKGYSBJEtR1jbZrBdiqbVtUVYU0TUFWQq+nE+I4xvvlImGaW7FHjwxZCVmWhbfzGVmWoSgKWXUr9uiRISshx3FkEldomubXauzRI0NWQp7nyUR+NG/rfr/jUXxnjx5vmKyEbNuWox9Xvid6ZMhK6HA4wnVdhGGIKIp2RY8MWQmx+JuoqvpUZFb8L6UonyYL3uOtrFH+AAAAAElFTkSuQmCC"
	},
	"up-down-spin": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGJJREFUOE+lkwEKACEIBH2Zb/PnHsoGeaVJDUjGOgRRpKpkiIj+y4MME3eDR7kaKOVNsJyMNjIHzGy9YnW6J7qIcrriQimeCqORNABd0fpRTkt8uVUj7EsxC6vs/q3e/Q6iD2bwnByjPXHNAAAAAElFTkSuQmCC"
	},
	"up-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGFJREFUOE+lkkEKQCEIRD2ZJ3Ph3iN4WD9GflpYhj0YYowpGgJmbikd3gjMDFokwbuT1iAiurG5nomgqo5QaPo9ERQRI6Jf7sfGjudy2je23+i0Wl2oQ85TOdlfrJQOazF8br+rqTXQKn0AAAAASUVORK5CYII="
	},
};

},{}],3:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

var images = require('./images'); // this is the file generated by gulpfile.js (and ignored by git)

_(images).each(function(image, key) {
    var element = new Image();
    element.src = 'data:' + image.type + ';base64,' + image.data;
    images[key] = element;
});

images.checkbox = function(state) {
    return images[state ? 'checked' : 'unchecked'];
};

images.filter = function(state) {
    return images[state ? 'filter-on' : 'filter-off'];
};

module.exports = images;

},{"./images":2,"object-iterators":24}],4:[function(require,module,exports){
'use strict';

/* eslint-env browser */

/** @namespace cssInjector */

/**
 * @summary Insert base stylesheet into DOM
 *
 * @desc Creates a new `<style>...</style>` element from the named text string(s) and inserts it but only if it does not already exist in the specified container as per `referenceElement`.
 *
 * > Caveat: If stylesheet is for use in a shadow DOM, you must specify a local `referenceElement`.
 *
 * @returns A reference to the newly created `<style>...</style>` element.
 *
 * @param {string|string[]} cssRules
 * @param {string} [ID]
 * @param {undefined|null|Element|string} [referenceElement] - Container for insertion. Overloads:
 * * `undefined` type (or omitted): injects stylesheet at top of `<head>...</head>` element
 * * `null` value: injects stylesheet at bottom of `<head>...</head>` element
 * * `Element` type: injects stylesheet immediately before given element, wherever it is found.
 * * `string` type: injects stylesheet immediately before given first element found that matches the given css selector.
 *
 * @memberOf cssInjector
 */
function cssInjector(cssRules, ID, referenceElement) {
    if (typeof referenceElement === 'string') {
        referenceElement = document.querySelector(referenceElement);
        if (!referenceElement) {
            throw 'Cannot find reference element for CSS injection.';
        }
    } else if (referenceElement && !(referenceElement instanceof Element)) {
        throw 'Given value not a reference element.';
    }

    var container = referenceElement && referenceElement.parentNode || document.head || document.getElementsByTagName('head')[0];

    if (ID) {
        ID = cssInjector.idPrefix + ID;

        if (container.querySelector('#' + ID)) {
            return; // stylesheet already in DOM
        }
    }

    var style = document.createElement('style');
    style.type = 'text/css';
    if (ID) {
        style.id = ID;
    }
    if (cssRules instanceof Array) {
        cssRules = cssRules.join('\n');
    }
    cssRules = '\n' + cssRules + '\n';
    if (style.styleSheet) {
        style.styleSheet.cssText = cssRules;
    } else {
        style.appendChild(document.createTextNode(cssRules));
    }

    if (referenceElement === undefined) {
        referenceElement = container.firstChild;
    }

    container.insertBefore(style, referenceElement);

    return style;
}

/**
 * @summary Optional prefix for `<style>` tag IDs.
 * @desc Defaults to `'injected-stylesheet-'`.
 * @type {string}
 * @memberOf cssInjector
 */
cssInjector.idPrefix = 'injected-stylesheet-';

// Interface
module.exports = cssInjector;

},{}],5:[function(require,module,exports){
'use strict';

/** @namespace extend-me **/

/** @summary Extends an existing constructor into a new constructor.
 *
 * @returns {ChildConstructor} A new constructor, extended from the given context, possibly with some prototype additions.
 *
 * @desc Extends "objects" (constructors), with optional additional code, optional prototype additions, and optional prototype member aliases.
 *
 * > CAVEAT: Not to be confused with Underscore-style .extend() which is something else entirely. I've used the name "extend" here because other packages (like Backbone.js) use it this way. You are free to call it whatever you want when you "require" it, such as `var inherits = require('extend')`.
 *
 * Provide a constructor as the context and any prototype additions you require in the first argument.
 *
 * For example, if you wish to be able to extend `BaseConstructor` to a new constructor with prototype overrides and/or additions, basic usage is:
 *
 * ```javascript
 * var Base = require('extend-me').Base;
 * var BaseConstructor = Base.extend(basePrototype); // mixes in .extend
 * var ChildConstructor = BaseConstructor.extend(childPrototypeOverridesAndAdditions);
 * var GrandchildConstructor = ChildConstructor.extend(grandchildPrototypeOverridesAndAdditions);
 * ```
 *
 * This function (`extend()`) is added to the new extended object constructor as a property `.extend`, essentially making the object constructor itself easily "extendable." (Note: This is a property of each constructor and not a method of its prototype!)
 *
 * @param {string} [extendedClassName] - This is simply added to the prototype as $$CLASS_NAME. Useful for debugging because all derived constructors appear to have the same name ("Constructor") in the debugger. This property is ignored unless `extend.debug` is explicitly set to a truthy value.
 *
 * @param {extendedPrototypeAdditionsObject} [prototypeAdditions] - Object with members to copy to new constructor's prototype. Most members will be copied to the prototype. Some members, however, have special meanings as explained in the {@link extendedPrototypeAdditionsObject|type definition} (and may or may not be copied to the prototype).
 *
 * @property {boolean} [debug] - See parameter `extendedClassName` _(above)_.
 *
 * @property {object} Base - A convenient base class from which all other classes can be extended.
 *
 * @memberOf extend-me
 */
function extend(extendedClassName, prototypeAdditions) {
    switch (arguments.length) {
        case 0:
            prototypeAdditions = {};
            break;
        case 1:
            prototypeAdditions = extendedClassName;
            if (typeof prototypeAdditions !== 'object') {
                throw 'Single parameter overload must be object.';
            }
            extendedClassName = undefined;
            break;
        case 2:
            if (typeof extendedClassName !== 'string' || typeof prototypeAdditions !== 'object') {
                throw 'Two parameter overload must be string, object.';
            }
            break;
        default:
            throw 'Too many parameters';
    }

    function Constructor() {
        if (prototypeAdditions.preInitialize) {
            prototypeAdditions.preInitialize.apply(this, arguments);
        }

        initializePrototypeChain.apply(this, arguments);

        if (prototypeAdditions.postInitialize) {
            prototypeAdditions.postInitialize.apply(this, arguments);
        }
    }

    Constructor.extend = extend;

    var prototype = Constructor.prototype = Object.create(this.prototype);
    prototype.constructor = Constructor;

    if (extendedClassName && extend.debug) {
        prototype.$$CLASS_NAME = extendedClassName;
    }

    for (var key in prototypeAdditions) {
        if (prototypeAdditions.hasOwnProperty(key)) {
            var value = prototypeAdditions[key];
            switch (key) {
                case 'initializeOwn':
                    // already called above; not needed in prototype
                    break;
                case 'aliases':
                    for (var alias in value) {
                        if (value.hasOwnProperty(alias)) {
                            makeAlias(value[alias], alias);
                        }
                    }
                    break;
                default:
                    if (typeof value === 'string' && value[0] === '#') {
                        makeAlias(value, key.substr(1));
                    } else {
                        prototype[key] = value;
                    }
            }
        }
    }

    return Constructor;

    function makeAlias(value, key) { // eslint-disable-line no-shadow
        prototype[key] = prototypeAdditions[value];
    }
}

extend.Base = function () {};
extend.Base.extend = extend;

/** @typedef {function} extendedConstructor
 * @property prototype.super - A reference to the prototype this constructor was extended from.
 * @property [extend] - If `prototypeAdditions.extendable` was truthy, this will be a reference to {@link extend.extend|extend}.
 */

/** @typedef {object} extendedPrototypeAdditionsObject
 * @property {function} [initialize] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after similar function in all ancestors called with same signature.
 * @property {function} [initializeOwn] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after (all) the `initialize` function(s).
 * @property {object} [aliases] - Hash of aliases for prototype members in form `{ key: 'member', ... }` where `key` is the name of an alieas and `'member'` is the name of an existing member in the prototype. Each such key is added to the prototype as a reference to the named member. (The `aliases` object itself is *not* added to prototype.) Alternatively:
 * @property {string} [keys] - Arbitrary property names defined here with string values starting with a `#` character will alias the actual properties named in the strings (following the `#`). This is an alternative to providing an `aliases` hash, perhaps simpler (though subtler). (Use arbitrary identifiers here; don't use the name `keys`!)
 * @property {*} [arbitraryProperties] - Any additional arbitrary properties defined here will be added to the new constructor's prototype. (Use arbitrary identifiers here; don't use the name `aribitraryProperties`!)
 */

/** @summary Call all `initialize` methods found in prototype chain.
 * @desc This recursive routine is called by the constructor.
 * 1. Walks back the prototype chain to `Object`'s prototype
 * 2. Walks forward to new object, calling any `initialize` methods it finds along the way with the same context and arguments with which the constructor was called.
 * @private
 * @memberOf extend-me
 */
function initializePrototypeChain() {
    var term = this,
        args = arguments;
    recur(term);

    function recur(obj) {
        var proto = Object.getPrototypeOf(obj);
        if (proto.constructor !== Object) {
            recur(proto);
            if (proto.hasOwnProperty('initialize')) {
                proto.initialize.apply(term, args);
            }
        }
    }
}

module.exports = extend;

},{}],6:[function(require,module,exports){
'use strict';

var _ = require('object-iterators');
var popMenu = require('pop-menu');

var FilterNode = require('./js/FilterNode');
var FilterTree = require('./js/FilterTree');

var conditionals = require('./js/conditionals');
var copy = require('./js/copy-input');
var template = require('./js/template');

// expose some objects for plug-in access

FilterTree.conditionals = conditionals;
FilterTree.FilterTreeError = FilterNode.FilterTreeError;

// FOLLOWING PROPERTIES ARE *** TEMPORARY ***,
// FOR THE DEMO TO ACCESS THESE NODE MODULES.

FilterTree._ = _;
FilterTree.popMenu = popMenu;
FilterTree.copy = copy;
FilterTree.template = template;


module.exports = FilterTree;

},{"./js/FilterNode":8,"./js/FilterTree":9,"./js/conditionals":10,"./js/copy-input":11,"./js/template":14,"object-iterators":24,"pop-menu":25}],7:[function(require,module,exports){
/* eslint-env browser */
/* eslint-disable key-spacing */

'use strict';

var popMenu = require('pop-menu');

var FilterNode = require('./FilterNode');
var template = require('./template');
var conditionals = require('./conditionals');


/** @typedef {object} converter
 * @property {function} to - Returns input value converted to type. Fails silently.
 * @property {function} not - Tests input value against type, returning `false if type or `true` if not type.
 */
/** @type {converter} */
var numberConverter = { to: Number, not: isNaN };

/** @type {converter} */
var dateConverter = { to: function(s) { return new Date(s); }, not: isNaN };

/** @constructor
 * @summary An object that represents a terminal node in a filter tree.
 * @desc Specifically, the terminal node in a filter tree represents a simple dyadic conditional expression.
 * in the form _field-property operator-property argument-property_ where:
 *
 * * _field-property_ is the name of a column, selected from a drop-down;
 * * _operator-property_ is an operator from an extensible list of operators, also selected from a drop-down; and
 * * _argument-property_ is a constant typed into a text box.
 *
 * The default operator list is defined in conditionals.js and includes equality (=), inequality (<, ≤, ≠, ≥, >), and various pattern operators (such as LIKE, NOT LIKE, etc.)
 */
var FilterLeaf = FilterNode.extend('FilterLeaf', {

    name: 'column = value',

    destroy: function() {
        if (this.view) {
            for (var key in this.view) {
                this.view[key].removeEventListener('change', this.onChange);
            }
        }
    },

    /** @summary Create a new view in `this.view`.
     * @desc This new "view" is a group of HTML `Element` controls that completely describe the conditional expression this object represents. This method creates the following object properties:
     *
     * * `this.el` - a `<span>...</span>` element to contain the controls as child nodes
     * * `this.view` - a hash containing direct references to the controls.
     *
     * The view for this base `FilterLeaf` object consists of the following controls:
     *
     * * `this.view.column` - A drop-down with options from `this.schema`. Value is the name of the column being tested (i.e., the column to which this conditional expression applies).
     * * `this.view.operator` - A drop-down with options from {@link columnOpMenu}, {@link typeOpMenu}, or {@link treeOpMenu}. Value is the string representation of the operator.
     * * `this.view.literal` - A text box.
     *
     *  > Prototypes extended from `FilterLeaf` may have different controls as needed. The only required control is `column`, which all such "editors" must support.
     * @memberOf FilterLeaf.prototype
     */
    createView: function() {
        var el = this.el = document.createElement('span');

        el.className = 'filter-tree-editor filter-tree-default';

        if (this.state.column) {
            // State includes column:
            // Operator menu is built later in loadState; we don't need to build it now. The call to
            // getOpMenu below with undefined columnName returns [] resulting in an empty drop-down.
        } else {
            // When state does NOT include column, it's because either:
            // a. column is unknown and no op menu will be empty until user chooses a column; or
            // b. column is hard-coded when there's only one possible column as inferable from schema:
            var schema = this.schema && this.schema.length === 1 && this.schema[0],
                columnName = schema && (schema.name || schema);
        }

        this.view = {
            column: this.makeElement(this.schema, 'column', this.sortColumnMenu),
            operator: this.makeElement(getOpMenu.call(this, columnName), 'operator'),
            literal: this.makeElement()
        };

        el.appendChild(document.createElement('br'));
    },

    loadState: function() {
        var state = this.state;

        if (state) {
            var value, el, i, b, selected, notes = [];
            for (var key in state) {
                if (!FilterNode.optionsSchema[key]) {
                    value = this[key] = state[key];
                    el = this.view[key];
                    switch (el.type) {
                        case 'checkbox':
                        case 'radio':
                            el = document.querySelectorAll('input[name=\'' + el.name + '\']');
                            for (i = 0; i < el.length; i++) {
                                el[i].checked = value.indexOf(el[i].value) >= 0;
                            }
                            break;
                        case 'select-multiple':
                            el = el.options;
                            for (i = 0, b = false; i < el.length; i++, b = b || selected) {
                                selected = value.indexOf(el[i].value) >= 0;
                                el[i].selected = selected;
                            }
                            FilterNode.setWarningClass(el, b);
                            break;
                        default:
                            el.value = value;
                            if (FilterNode.setWarningClass(el) !== value) {
                                notes.push({ key: key, value: value });
                            } else if (key === 'column') {
                                makeOpMenu.call(this, value);
                            }
                    }
                }
            }
            if (notes.length) {
                var multiple = notes.length > 1,
                    footnotes = template(multiple ? 'notes' : 'note'),
                    inner = footnotes.querySelector('.footnote');
                notes.forEach(function(note) {
                    var footnote = multiple ? document.createElement('li') : inner;
                    note = template('optionMissing', note.key, note.value);
                    while (note.length) { footnote.appendChild(note[0]); }
                    if (multiple) { inner.appendChild(footnote); }
                });
            }
            this.notesEl = footnotes;
        }
    },

    /**
     * @property {converter} number
     * @property {converter} date
     */
    converters: {
        number: numberConverter,
        int: numberConverter, // pseudo-type: really just a Number
        float: numberConverter, // pseudo-type: really just a Number
        date: dateConverter
    },

    /**
     * Throws error if invalid expression.
     * Caught by {@link FilterTree#invalid|FilterTree.prototype.invalid()}.
     *
     * Also performs the following compilation actions:
     * * Copies all `this.view`' values from the DOM to similarly named properties of `this`.
     * * Pre-sets `this.op` and `this.converter` for use in `test`'s tree walk.
     *
     * @param {boolean} [options.focus=true] - Move focus to offending control.
     * @returns {undefined} if valid
     * @memberOf FilterLeaf.prototype
     */
    invalid: function(options) {
        var elementName, field;

        for (elementName in this.view) {
            var el = this.view[elementName],
                value = controlValue(el).trim();

            if (value === '') {
                var focus = options && options.focus;
                if (focus === undefined || focus) { clickIn(el); }
                throw new FilterNode.FilterTreeError('Blank ' + elementName + ' control.\nComplete the filter or delete it.', this);
            } else {
                // Copy each controls's value as a new similarly named property of this object.
                this[elementName] = value;
            }
        }

        this.op = conditionals.operators[this.operator];

        this.converter = this.converters[ // undefined if none of the following
            this.type || // the expression's type, if any
            this.op.type || // the expression's operator type, if any
            (field = popMenu.findItem(this.schema, this[this.view.column])) && field.type // the expression's column type, if any
        ];
    },

    p: function(dataRow) { return dataRow[this.column]; },
    q: function() { return this.literal; },

    test: function(dataRow) {
        var p, q, // untyped versions of args
            P, Q, // typed versions of p and q
            convert;

        return (
            //(p = valOrFunc(this.p(dataRow))) === undefined || // TODO: right now assuming all values are natively strings
            //(q = valOrFunc(this.q(dataRow))) === undefined
            (p = this.p(dataRow)) === undefined ||
            (q = this.q(dataRow)) === undefined
        )
            ? false
            : (
                (convert = this.converter) &&
                !convert.not(P = convert.to(p)) &&
                !convert.not(Q = convert.to(q))
            )
                ? this.op.test(P, Q)
                : this.op.test(p + '', q + '');
    },

    toJSON: function() {
        var state = {};
        if (this.editor) {
            state.editor = this.editor;
        }
        for (var key in this.view) {
            state[key] = this[key];
        }
        if (this.schema !== this.parent.schema) {
            state.schema = this.schema;
        }
        return state;
    },

    /**
     * @param {string} options.syntax - See {@link FilterTree#getState|subtree version} for more info.
     * > For `'object'` and `'JSON'` note that the subtree's version of `getState` will not call this leaf verison of `getState` because the former uses `unstrungify()` and `JSON.stringify()`, respectively, both of which recurse on their own.
     * @memberOf FilterLeaf.prototype
     */
    getState: function getState(options, suboptions) {
        var result = '',
            syntax = options && options.syntax || 'object';

        switch (syntax) {
            case 'object': // see note above
                result = this.toJSON();
                break;
            case 'JSON': // see note above
                result = JSON.stringify(this, null, suboptions && suboptions.space) || '';
                break;
            case 'SQL':
                result = this.getSyntax(conditionals.sqlOperators);
                break;
            case 'CQL':
                result = this.getSyntax(conditionals.filterCellOperators);
                if (result[0] === '=') {
                    result = result.substr(1);
                }
                break;
            default:
                throw new FilterNode.FilterTreeError('Unknown syntax option "' + syntax[0] + '"');
        }

        return result;
    },

    getSyntax: function(operators) {
        return operators[this.operator].make.call(operators, this.column, this.literal);
    },


    /** @summary HTML form controls factory.
     * @desc Creates and appends a text box or a drop-down.
     * > Defined on the FilterTree prototype for access by derived types (alternate filter editors).
     * @returns The new element.
     * @param {menuItem[]} [menu] - Overloads:
     * * If omitted, will create an `<input/>` (text box) element.
     * * If contains only a single option, will create a `<span>...</span>` element containing the string and a `<input type=hidden>` containing the value.
     * * Otherwise, creates a `<select>...</select>` element with these menu items.
     * @param {null|string} [prompt=''] - Adds an initial `<option>...</option>` element to the drop-down with this value, parenthesized, as its `text`; and empty string as its `value`. Omitting creates a blank prompt; `null` suppresses.
     * @memberOf FilterLeaf.prototype
     */
    makeElement: function(menu, prompt, sort) {
        var el, result, options,
            option = menu,
            tagName = menu ? 'SELECT' : 'INPUT';

        // determine if there would be only a single item in the dropdown
        while (option instanceof Array) {
            if (option.length === 1 && !popMenu.isGroupProxy(option[0])) {
                option = option[0];
            } else {
                option = undefined;
            }
        }

        if (option) {
            // hard text when single item
            el = template(
                'lockedColumn',
                option.alias || option.name || option,
                option.name || option.alias || option
            );
            result = el.querySelector('input');
        } else {
            options = {
                prompt: prompt,
                sort: sort,
                group: function(groupName) { return conditionals.groups[groupName]; }
            };
            el = popMenu.build(tagName, menu, options);
            if (el.type === 'text' && this.eventHandler) {
                this.el.addEventListener('keyup', this.eventHandler);
            }
            this.onChange = this.onChange || cleanUpAndMoveOn.bind(this);
            this.el.addEventListener('change', this.onChange);
            FilterNode.setWarningClass(el);
            result = el;
        }

        this.el.appendChild(el);

        return result;
    }
});

//function valOrFunc(vf) {
//var result = (typeof vf)[0] === 'f' ? vf() : vf;
//    return result || result === 0 ? result : '';
//}

/** `change` event handler for all form controls.
 * Rebuilds the operator drop-down as needed.
 * Removes error CSS class from control.
 * Adds warning CSS class from control if blank; removes if not blank.
 * Adds warning CSS class from control if blank; removes if not blank.
 * Moves focus to next non-blank sibling control.
 * @this Bound to this node.
 */
function cleanUpAndMoveOn(evt) {
    var el = evt.target;

    // remove `error` CSS class, which may have been added by `FilterLeaf.prototype.invalid`
    el.classList.remove('filter-tree-error');

    // set or remove 'warning' CSS class, as per el.value
    FilterNode.setWarningClass(el);

    if (el === this.view.column) {
        // rebuild operator list according to selected column name or type, restoring selected item
        makeOpMenu.call(this, el.value);
    }

    if (el.value) {
        // find next sibling control, if any
        if (!el.multiple) {
            while ((el = el.nextElementSibling) && (!('name' in el) || el.value.trim() !== '')); // eslint-disable-line curly
        }

        // and click in it (opens select list)
        if (el && el.value.trim() === '') {
            el.value = ''; // rid of any white space
            FilterNode.clickIn(el);
        }
    }

    if (this.eventHandler) {
        this.eventHandler(evt);
    }
}

function getOpMenu(columnName) {
    var column = popMenu.findItem(this.schema, columnName);
    return (
        !column && []
            ||
        column.opMenu
            ||
        this.typeOpMenu && this.typeOpMenu[column.type]
            ||
        this.treeOpMenu
    );
}

function makeOpMenu(columnName) {
    var opMenu = getOpMenu.call(this, columnName);

    if (opMenu !== this.oldOpMenu) {
        var newOpDrop = this.makeElement(opMenu, 'operator');

        newOpDrop.value = this.view.operator.value;
        this.el.replaceChild(newOpDrop, this.view.operator);
        this.view.operator = newOpDrop;

        FilterNode.setWarningClass(newOpDrop);

        this.opMenu = opMenu;
    }
}

function clickIn(el) {
    setTimeout(function() {
        el.classList.add('filter-tree-error');
        FilterNode.clickIn(el);
    }, 0);
}

function controlValue(el) {
    var value, i;

    switch (el.type) {
        case 'checkbox':
        case 'radio':
            el = document.querySelectorAll('input[name=\'' + el.name + '\']:enabled:checked');
            for (value = [], i = 0; i < el.length; i++) {
                value.push(el[i].value);
            }
            break;

        case 'select-multiple':
            el = el.options;
            for (value = [], i = 0; i < el.length; i++) {
                if (!el.disabled && el.selected) {
                    value.push(el[i].value);
                }
            }
            break;

        default:
            value = el.value;
    }

    return value;
}

module.exports = FilterLeaf;

},{"./FilterNode":8,"./conditionals":10,"./template":14,"pop-menu":25}],8:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');
var extend = require('extend-me'), Base = extend.Base; extend.debug = true;

var cssInjector = require('./css');
var template = require('./template');
var conditionals = require('./conditionals');
var sqlWhereParse = require('./sql-where-parse');


var CHILDREN_TAG = 'OL',
    CHILD_TAG = 'LI';

/** @typedef {object} FilterTreeOptionsObject
 *
 * @property {string[]} [schema] - A default list of column names for field drop-downs of all descendant terminal nodes. Overrides `options.state.schema` (see). May be defined for any node and pertains to all descendants of that node (including terminal nodes). If omitted (and no `ownSchema`), will use the nearest ancestor `schema` definition. However, descendants with their own definition of `types` will override any ancestor definition.
 *
 * > Typically only used by the caller for the top-level (root) tree.
 *
 * @property {string[]} [ownSchema] - A default list of column names for field drop-downs of immediate descendant terminal nodes _only_. Overrides `options.state.ownSchema` (see).
 *
 * Although both `options.schema` and `options.ownSchema` are notated as optional herein, by the time a terminal node tries to render a schema drop-down, a `schema` list _must_ be defined through (in order of priority):
 *
 * * Terminal node's own `options.schema` (or `options.state.schema`) definition.
 * * Terminal node's parent node's `option.ownSchema` (or `option.state.nodesFields`) definition.
 * * Any of terminal node's ancestor's `options.schema` (or `options.state.schema`) definition.
 *
 * @property {object|string} [state] - A data structure that describes a tree, subtree, or leaf (terminal node):
 *
 * * May describe a terminal node with properties:
 *   * `schema` - Overridden on instantiation by `options.schema`. If both unspecified, uses parent's definition.
 *   * `editor` - A string identifying the type of conditional. Must be in the parent node's {@link FilterTree#editors|editors} hash. If omitted, defaults to `'Default'`.
 *   * misc. - Other properties peculiar to this filter type (but typically including at least a `field` property).
 * * May describe a non-terminal node with properties:
 *   * `schema` - Overridden on instantiation by `options.schema`. If both unspecified, uses parent's definition.
 *   * `operator` - One of {@link treeOperators}.
 *   * `children` -  Array containing additional terminal and non-terminal nodes.
 *
 * If this `options.state` object is omitted altogether, loads an empty filter, which is a `FilterTree` node consisting the default `operator` value (`'op-and'`).
 *
 * The constructor auto-detects `state`'s type:
 *  * JSON string to be parsed by `JSON.parse()` into a plain object
 *  * SQL WHERE clause string to be parsed into a plain object
 *  * CSS selector of an Element whose `value` contains one of the above
 *  * plain object
 *
 * @property {function} [editor='Default'] - Type of simple expression; a key in the FilterTree.prototype.editors hash which maps to a simple expression constructor, which will be `FilterLeaf` or a constructor extended from `FilterLeaf`.
 *
 * @property {FilterTree} [parent] - Used internally to insert element when creating nested subtrees. Optional for the top level tree only. (Note that you are responsible for inserting the top-level `.el` into the DOM.)
 *
 * @property {string|HTMLElement} [cssStylesheetReferenceElement] - passed to cssInsert
 */

/**
 * @constructor
 *
 * @summary A node in a filter tree.
 *
 * @description A filter tree represents a _complex conditional expression_ and consists of a single instance of a {@link FilterTree} as the _root_ of an _n_-ary tree.
 *
 * In general, each instance of a `FilterNode` may be:
 * * a {@link FilterTree}, an object that represents a non-terminal node in a filter tree;
 * * a {@link FilterLeaf}, an object that represents a terminal node in a filter tree; or
 * * any other object extended from either of the above.
 *
 * The `FilterTree` object has polymorphic methods that operate on the entire tree using recursion. When the recursion reaches a terminal node, it calls the methods on the `FilterLeaf` object instead. Calling `test()` on the root tree therefore returns a boolean that determines if the row passes through the entire filter expression (`true`) or is blocked by it (`false`).
 *
 * The `FilterLeaf` object is the default type of simple expression, which is
 *
 * The programmer may define a new type of simple expression by extending from `FilterLeaf`. An example is the `FilterField` object. Such an implementation must include methods:
 *
 * * Save and subsequently reload the state of the conditional as entered by the user (`getState()` and `setState()`, respectively).
 * * Create the DOM objects that represent the UI filter editor and render them to the UI (`createView()` and `render()`, respectively).
 * * Filter a table by implementing one or more of the following:
 *   * Apply the conditional logic to available table row data (`test()`).
 *   * Apply the conditional logic to a remote data-store by generating a **SQL** or **Q** _WHERE_ clause (`toSQL()` and `toQ()`, respectively).
 *
 * @property {FilterNode} [parent] - Undefined means this is the root node.
 *
 * @property {FilterNode} root - Convenience reference to the root node.
 *
 * @property {menuItem[]} schema - Column schema used by descendant leaf nodes (including this node if it is a leaf node) to render a column choice drop-down.
 *
 * @property {string} [editor] - Name of filter editor used by descendant leaf nodes (including this node if it is a leaf node).
 *
 * @property {function} [eventHandler] - Event handler for UI events.
 *
 * @property {string} [template] - Identifies either:
 * 1. The type of a {@link FilterTree} node, used among other things to select a rendering template:
 *    * `undefined` (or omitted) - A generic filter tree node,
 *    * `'columnFilters'` - A special {@link FilterTree} containing _column filter_ subexpressions
 *    * `'columnFilter'` -  A special {@link FilterTree} containing homogeneous _column filter_ expressions (all referencing the same column on the left side of their dyadic expressions).
 * 2. The data type of a {@link FilterLeaf} (terminal) node.
 *
 * @property {menuItem[]} [treeOpMenu=conditionals.defaultOpMenu] -  Default operator menu for all descendant leaf nodes.
 *
 * @property {object} [typeOpMenu] - A hash of type names. Each member thus defined contains a specific operator menu for all descendant leaf nodes that:
 * 1. do not have their own operator menu (`opMenu` property) of their own; and
 * 2. whose columns resolve to that type.
 *
 * The type is determined by (in priority order):
 * 1. the `type` property of the {@link FilterLeaf}; or
 * 2. the `type` property of the element in the nearest node (including the leaf node itself) that has a defined `ownSchema` or `schema` array property with an element having a matching column name.
 *
 * @property {HTMLElement} el - The DOM element created by the `render` method to represent this node. Contains the `el`s for all child nodes (which are themselves pointed to by those nodes). This is always generated but is only in the page DOM if you put it there.
 */

var FilterNode = Base.extend({

    initialize: function(options) {
        var self = this,
            state = options && options.state && parseStateString(options.state),
            parent = options && options.parent;

        this.state = state;
        this.parent = parent;
        this.root = parent && parent.root || this;

        this.root.stylesheet = this.root.stylesheet ||
            cssInjector(options && options.cssStylesheetReferenceElement);

        // create each standard option from `options` or `state` or `parent` (wherever it's defined first, if anywhere)
        _(FilterNode.optionsSchema).each(function(optionSchema, key) {
            if (!self.hasOwnProperty(key) && !optionSchema.ignore) {
                var option = options && options[key] ||
                    state && state[key] ||
                    !optionSchema.own && (
                        parent && parent[key] || // reference parent value now so we don't have to search up the tree later
                        optionSchema.default
                    );

                if (option) {
                    self[key] = option;
                }
            }
        });

        // copy all remaining options directly to the new instance, overriding members of the same name in the prototype
        _(options).each(function(value, key) {
            if (!FilterNode.optionsSchema[key]) {
                self[key] = value;
            }
        });

        this.setState(state, options); // forward `options.beg` and `options.end` for use by `sqlWhereParse()`
    },

    /** Insert each subtree into its parent node along with a "delete" button.
     * > The root tree is has no parent and is inserted into the DOM by the instantiating code (without a delete button).
     */
    render: function() {
        if (this.parent) {
            var newListItem = document.createElement(CHILD_TAG);

            if (this.notesEl) {
                newListItem.appendChild(this.notesEl);
            }

            if (!(this.state && this.state.locked)) {
                var el = template('removeButton');
                el.addEventListener('click', this.remove.bind(this));
                newListItem.appendChild(el);
            }

            newListItem.appendChild(this.el);

            this.parent.el.querySelector(CHILDREN_TAG).appendChild(newListItem);
        }
    },

    setState: function(state, options) {
        var oldEl = this.el;
        this.state = parseStateString(state, options);
        this.createView();
        this.loadState();
        this.render();
        if (oldEl) {
            var newEl = this.el;
            if (this.parent) {
                oldEl = oldEl.parentNode;
                newEl = newEl.parentNode;
            }
            oldEl.parentNode.replaceChild(newEl, oldEl);
        }
    },

    /** Remove both:
     * * `this` filter node from it's `parent`'s `children` collection; and
     * * `this` filter node's `el`'s container (always a `<li>` element) from its parent element.
     */
    remove: function() {
        var node = this.parent;
        if (node) {
            if (this.eventHandler) {
                this.eventHandler({ type: 'delete' });
            }
            if (node.persist || node.children.length > 1) {
                this.el.parentNode.remove(); // always the containing <li> tag
                node.children.splice(node.children.indexOf(this), 1);
            } else {
                node.remove();
            }
        }
    }
});

FilterNode.optionsSchema = {

    cssStylesheetReferenceElement: { ignore: true },

    /** @summary Default column schema for column drop-downs of direct descendant leaf nodes only.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {string[]}
     * @memberOf FilterNode.prototype
     */
    ownSchema: { own: true },

    /** @summary Default column schema for column drop-downs of all descendant leaf nodes.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {menuItem[]}
     * @memberOf FilterNode.prototype
     */
    schema: {},

    /** @summary Type of filter editor.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {string}
     * @memberOf FilterNode.prototype
     */
    editor: {},

    /** @summary Event handler for UI events.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {string}
     * @memberOf FilterNode.prototype
     */
    eventHandler: {},

    type: { own: true },

    persist: { own: true },

    /** @summary Override operator list at any node.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {string[]}
     * @memberOf FilterNode.prototype
     */
    treeOpMenu: { default: conditionals.defaultOpMenu },

    typeOpMenu: {},

    sortColumnMenu: {}
};

FilterNode.setWarningClass = function(el, value) {
    if (arguments.length < 2) {
        value = el.value;
    }
    el.classList[value ? 'remove' : 'add']('filter-tree-warning');
    return value;
};

function FilterTreeError(message, node) {
    this.message = message;
    this.node = node;
}
FilterTreeError.prototype = Object.create(Error.prototype);
FilterTreeError.prototype.name = 'FilterTreeError';
FilterNode.FilterTreeError = FilterTreeError;

FilterNode.clickIn = function(el) {
    if (el) {
        if (el.tagName === 'SELECT') {
            setTimeout(function() { el.dispatchEvent(new MouseEvent('mousedown')); }, 0);
        } else {
            el.focus();
        }
    }
};

var reSelector = /^[#\.]?\w+(\s*[ \.\-|*+#:~^$>]+\s*\w+.*)?$/;
var reJSON = /^\s*[\[\{]/;

/**
 *
 * @param {undefined|string|object} state - May be one of:
 * * Filter-tree state object:
 *   Return as is.
 * * String representation of filter-tree state object (JSON or SQL, auto-detected):
 *   Parse the string and return an actual filter-tree state object.
 * * String CSS selector (auto-detected) of a HTML form control with a `value` containing the above:
 *   Parse `value` and return an actual filter-tree state object.
 * * `undefined` (or any other falsy value):
 *   Return as is. (Undefined state represents an new empty FilterNode object.)
 *
 * @param {object} [options.syntax] - May be `'JSON'` or `'SQL'` to override auto-detection
 *
 * @returns {object} filter-tree state object; or throws error if unknown or invalid syntax
 */
function parseStateString(state, options) {
    if (state) {
        if (typeof state === 'string') {
            if (reSelector.test(state)) {
                state = document.querySelector(state).value;
            }

            var syntax = options && options.syntax ||
                reJSON.test(state) && 'JSON';

            switch (syntax) {
                case 'JSON':
                    try {
                        state = JSON.parse(state);
                    } catch (error) {
                        throw new FilterTreeError('JSON parser: ' + error);
                    }
                    break;
                case 'SQL':
                    try {
                        state = sqlWhereParse(state, options);
                    } catch (error) {
                        throw new FilterTreeError('SQL WHERE clause parser: ' + error);
                    }
                    break;
            }
        }

        if (typeof state !== 'object') {
            throw new FilterTreeError('Unexpected input state.');
        }
    }

    return state;
}

module.exports = FilterNode;

},{"./conditionals":10,"./css":12,"./sql-where-parse":13,"./template":14,"extend-me":5,"object-iterators":24}],9:[function(require,module,exports){
/* eslint-env browser */

// This is the main file, usable as is, such as by /test/index.js.

// For npm: require this file
// For CDN: gulpfile.js browserifies this file with sourcemap to /build/filter-tree.js and uglified without sourcemap to /build/filter-tree.min.js. The CDN is https://joneit.github.io/filter-tree.

'use strict';

var popMenu = require('pop-menu');
var unstrungify = require('unstrungify');

var FilterNode = require('./FilterNode');
var TerminalNode = require('./FilterLeaf');
var template = require('./template');
var operators = require('./tree-operators');
var conditionals = require('./conditionals');


var ordinal = 0;

/** @constructor
 * @summary An object that represents a non-terminal node in a filter tree.
 * @desc A node representing a subexpression in the filter expression. May be thought of as a parenthesized subexpression in algebraic expression syntax. It's children may be either {@link FilterLeaf}* (terminal) nodes or other (nested) `FilterTree`* subexpressions. The same `operator` to be applied to all its `children`.
 *
 * \* Or other "class" objects extended therefrom.
 *
 * Has all the properties of {@link FilterNode} (see), plus the following additional properties:
 *
 * @property {string} [operator='op-and'] - One of:
 * * `'op-and'`
 * * `'op-or'`
 * * `'op-nor'`
 *
 * @property {FilterNode[]} children - A list of descendants of this node. May be any number including 0 (none; empty).
 *
 * @property {fieldItem[]} [ownSchema] - Column menu to be used only by leaf nodes that are children (direct descendants) of this node.
 *
 * Notes:
 * 1. A `FilterTree` may consist of a single leaf, in which case the `operator` is not used and may be left undefined. However, if a second child is added and the operator is still undefined, it will be set to the default (`'op-and'`).
 * 2. The order of the children is undefined as all operators are commutative. For the '`op-or`' operator, evaluation ceases on the first positive result and for efficiency, all simple conditional expressions will be evaluated before any complex subexpressions.
 * 3. A nested `FilterTree` is distinguished from a `Filter` by the presence of a `children` member.
 * 4. Nesting a `FilterTree` containing a single child is valid (albeit pointless).
 */
var FilterTree = FilterNode.extend('FilterTree', {

    /**
     * Hash of constructors for objects that extend from {@link FilterLeaf}, which is the `Default` member here.
     *
     * Add additional editors to this object (in the prototype) prior to instantiating a leaf node that refers to it.
     *
     * Alternatively, you could also override the entire object in your instance but if you do so, be sure to include the default editor, for example: `{ Default: FilterTree.prototype.editors.Default, ... }`. (One way of overriding would be to include such an object in an `editors` member of the options object passed to the constructor on instantiation. This works because all miscellaneous members are simply copied to the new instance. Not to be confused with the standard option `editor` which is a string containing a key from this hash and tells the leaf node what type to use.)
     */
    editors: {
        Default: TerminalNode
    },

    addEditor: function(key, overrides) {
        if (overrides) {
            this.editors[key] = TerminalNode.extend(overrides);
        } else {
            delete this.editors[key];
        }
    },

    createView: function() {
        this.el = template(
            this.type || 'subtree',
            ++ordinal,
            popMenu.formatItem(this.schema[0])
        );

        // Add the expression editors to the "add new" drop-down
        var addNewCtrl = this.el.querySelector(':scope>select');
        if (addNewCtrl) {
            var submenu, optgroup,
                editors = this.editors;

            if (addNewCtrl.length === 1 && this.editors.length === 1) {
                // this editor is the only option besides the null prompt option
                // so make it th eonly item i the drop-down
                submenu = addNewCtrl;
            } else {
                // there are already options and/or multiple editors
                submenu = optgroup = document.createElement('optgroup');
                optgroup.label = 'Conditional Expressions';
            }
            Object.keys(editors).forEach(function(key) {
                var name = editors[key].prototype.name || key;
                submenu.appendChild(new Option(name, key));
            });
            if (optgroup) {
                addNewCtrl.add(optgroup);
            }
            this.el.addEventListener('change', onchange.bind(this));
        }

        this.el.addEventListener('click', onTreeOpClick.bind(this));
    },

    loadState: function() {
        var state = this.state;

        this.operator = 'op-and';
        this.children = [];

        if (!state) {
            this.add();
        } else {
            // Validate `state.children` (required)
            if (!(state.children instanceof Array)) {
                throw new FilterNode.FilterTreeError('Expected `children` property to be an array.');
            }

            // Validate `state.operator` (if given)
            if (state.operator) {
                if (!operators[state.operator]) {
                    throw new FilterNode.FilterTreeError('Expected `operator` property to be one of: ' + Object.keys(operators));
                }

                this.operator = state.operator;
            }

            state.children.forEach(this.add.bind(this));
        }
    },

    render: function() {
        var radioButton = this.el.querySelector(':scope > label > input[value=' + this.operator + ']'),
            addFilterLink = this.el.querySelector('.filter-tree-add-conditional');

        if (radioButton) {
            radioButton.checked = true;
            onTreeOpClick.call(this, {
                target: radioButton
            });
        }

        // when multiple filter editors available, simulate click on the new "add conditional" link
        if (addFilterLink && !this.children.length && Object.keys(this.editors).length > 1) {
            this['filter-tree-add-conditional']({
                target: addFilterLink
            });
        }

        // proceed with render
        FilterNode.prototype.render.call(this);
    },

    /**
     * @summary Create a new node as per `state`.
     *
     * @param {object} [options={state:{}}] - May be one of:
     *
     * * an `options` object containing a `state` property
     * * a `state` object (in which case there is no `options` object)
     *
     * In any case, resulting `state` object may be either...
     * * A new subtree (has a `children` property):
     *   Add a new `FilterTree` node.
     * * A new leaf (no `children` property): add a new `FilterLeaf` node:
     *   * If there is an `editor` property:
     *     Add leaf using `this.editors[state.editor]`.
     *   * Otherwise (including the case where `state` is undefined):
     *     Add leaf using `this.editors.Default`.
     *
     * @param {boolean} [options.focus=false] Call invalid() after inserting to focus on first blank control (if any).
     *
     * @returns {FilterNode} The new node.
     */
    add: function(options) {
        var Constructor, newNode;

        options = options || {};

        if (!options.state) {
            options = { state: options };
        }

        if (options.state.children) {
            Constructor = this.constructor;
        } else {
            Constructor = this.editors[options.state.editor || 'Default'];
        }

        options.parent = this;
        newNode = new Constructor(options);
        this.children.push(newNode);

        if (options.focus) {
            // focus on blank control a beat after adding it
            setTimeout(function() { newNode.invalid({ alert: false }); }, 750);
        }

        return newNode;
    },

    /**
     * @param {boolean} [object.rethrow=false] - Throw (do not catch) `FilterTreeError`s.
     * @param {boolean} [object.alert=true] - Announce error via window.alert() before returning.
     * @param {boolean} [object.focus=true] - Place the focus on the offending control and give it error color.
     * @returns {undefined|FilterTreeError} `undefined` if valid; or the caught `FilterTreeError` if error.
     */
    invalid: function(options) {
        options = options || {};

        var alert = options.alert === undefined || options.alert,
            rethrow = options.rethrow,
            result;

        try {
            invalid.call(this, options);
        } catch (err) {
            result = err;

            // Throw when requested OR when unexpected (not a filter tree error)
            if (rethrow || !(err instanceof FilterNode.FilterTreeError)) {
                throw err;
            }

            if (alert) {
                window.alert(err.message); // eslint-disable-line no-alert
            }
        }

        return result;
    },

    test: function test(dataRow) {
        var operator = operators[this.operator],
            result = operator.seed,
            noChildrenDefined = true;

        this.children.find(function(child) {
            if (child) {
                noChildrenDefined = false;
                if (child instanceof TerminalNode) {
                    result = operator.reduce(result, child.test(dataRow));
                } else if (child.children.length) {
                    result = operator.reduce(result, test.call(child, dataRow));
                }
                return result === operator.abort;
            }

            return false;
        });

        return noChildrenDefined || (operator.negate ? !result : result);
    },

    /**
     * Get a representation of the filer (sub)tree state.
     * @param {string} [options.syntax='object'] - A case-sensitive string indicating the expected type and format of the return value:
     * * `'object'` (default) walks the tree using `{@link https://www.npmjs.com/package/unstrungify|unstrungify()}`, respecting `JSON.stringify()`'s "{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior|toJSON() behavior}," and returning a plain object suitable for resubmitting to {@link FilterNode#setState|setState}.
     * * `'JSON'` walks the tree using `{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior|JSON.stringify()}`, returning a JSON string by calling toJSON at every node. Suitable for text-based storage media.
     * * `'SQL'` walks the tree, returning a SQL where clause string. Suitable for creating SQL `SELECT` statements.
     * * `'CQL'` walks the tree, returning a string suitable for a Hypergrid filter cell. This syntax should only be called for from a subtree containing homogeneous column names and no subexpressions.
     * @param {number|string} [options.space] - When `options.syntax === 'JSON'`, forwarded to `JSON.stringify`'s third parameter, `space` (see).
     * @param {object} [options.sqlIdQts] - When `options.syntax === 'SQL'`, forwarded to `conditionals.pushSqlIdQts()`.
     * @returns {object|string} Returns object when `options.syntax === 'object'`; otherwise returns string.
     */
    getState: function getState(options) {
        var result = '',
            syntax = options && options.syntax || 'object';

        switch (syntax) {
            case 'object':
                result = unstrungify.call(this);
                break;

            case 'JSON':
                result = JSON.stringify(this, null, options && options.space) || '';
                break;

            case 'SQL':
                var lexeme = operators[this.operator].SQL,
                    qts = !this.parent && options && options.sqlIdQts;

                if (qts) {
                    conditionals.pushSqlIdQts(qts);
                }

                this.children.forEach(function(child, idx) {
                    var op = idx ? ' ' + lexeme.op + ' ' : '';
                    if (child) {
                        if (child instanceof TerminalNode) {
                            result += op + child.getState(options);
                        } else if (child.children.length) {
                            result += op + getState.call(child, options);
                        }
                    }
                });

                if (qts) {
                    conditionals.popSqlIdQts();
                }

                result = lexeme.beg + (result || 'NULL IS NULL') + lexeme.end;
                break;

            case 'CQL':
                var operator = operators[this.operator].filterCell.op;
                this.children.forEach(function(child, idx) {
                    if (child) {
                        if (child instanceof TerminalNode) {
                            if (idx) {
                                result += ' ' + operator + ' ';
                            }
                            result += child.getState(options);
                        } else if (child.children.length) {
                            throw new FilterNode.FilterTreeError('Expected conditional but found subexpression (not supported in filter cell syntax).');
                        }
                    }
                });
                break;

            default:
                throw new FilterNode.FilterTreeError('Unknown syntax option "' + syntax + '"');
        }

        return result;
    },

    toJSON: function toJSON() {
        var state = {
            operator: this.operator,
            children: []
        };

        this.children.forEach(function(child) {
            if (child) {
                if (child instanceof TerminalNode) {
                    state.children.push(child);
                } else {
                    var ready = toJSON.call(child);

                    for (var key in FilterNode.optionsSchema) {
                        if (
                            FilterNode.optionsSchema.hasOwnProperty(key) &&
                            child[key] && (
                                FilterNode.optionsSchema[key].own ||
                                child[key] !== child.parent[key]
                            )
                        ) {
                            ready[key] = child[key];
                        }
                    }

                    state.children.push(ready);
                }
            }
        });

        return state;
    }

});

// Some event handlers bound to FilterTree object

function onchange(evt) { // called in context
    var ctrl = evt.target;
    if (ctrl.parentElement === this.el) {
        if (ctrl.value === 'subexp') {
            this.children.push(new FilterTree({
                parent: this
            }));
        } else {
            this.add({
                state: { editor: ctrl.value },
                focus: true
            });
        }
        ctrl.selectedIndex = 0;
    }
}

function onTreeOpClick(evt) { // called in context
    var ctrl = evt.target;

    if (ctrl.className === 'filter-tree-op-choice') {
        this.operator = ctrl.value;

        // display strike-through
        var radioButtons = this.el.querySelectorAll('label>input.filter-tree-op-choice[name=' + ctrl.name + ']');
        Array.prototype.forEach.call(radioButtons, function(ctrl) {
            ctrl.parentElement.style.textDecoration = ctrl.checked ? 'none' : 'line-through';
        });

        // display operator between filters by adding operator string as a CSS class of this tree
        for (var key in operators) {
            this.el.classList.remove(key);
        }
        this.el.classList.add(this.operator);
    }
}

/**
 * Throws error if invalid expression tree.
 * Caught by {@link FilterTree#invalid|FilterTree.prototype.invalid()}.
 * @param {boolean} [options.focus=true] - Move focus to offending control.
 * @returns {undefined} if valid
 * @private
 */
function invalid(options) { // called in context
    //if (this instanceof FilterTree && !this.children.length) {
    //    throw new FilterNode.FilterTreeError('Empty subexpression (no filters).');
    //}

    this.children.forEach(function(child) {
        if (child instanceof TerminalNode) {
            child.invalid(options);
        } else if (child.children.length) {
            invalid.call(child, options);
        }
    });
}


module.exports = FilterTree;

},{"./FilterLeaf":7,"./FilterNode":8,"./conditionals":10,"./template":14,"./tree-operators":15,"pop-menu":25,"unstrungify":30}],10:[function(require,module,exports){
/** @module conditionals */

'use strict';

var Base = require('extend-me').Base;
var _ = require('object-iterators');
var regExpLIKE = require('regexp-like');

var IN = 'IN',
    NOT_IN = 'NOT ' + IN,
    LIKE = 'LIKE',
    NOT_LIKE = 'NOT ' + LIKE,
    LIKE_WILD_CARD = '%',
    SQT = '\'',
    SPC = ' ',
    NIL = '';

var idQt = [];
pushSqlIdQts({
    beg: '"',
    end: '"'
});
function pushSqlIdQts(qts) {
    return idQt.unshift(qts);
}
function popSqlIdQts() {
    return idQt.shift();
}
/**
 * @constructor
 */
var Operators = Base.extend({
    undefined: {
        test: function() { return true; },
        make: function() { return ''; }
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    '<': {
        test: function(a, b) { return a < b; },
        make: function(a, b) { return this.makeDiadic('<', a, b); }
    },
    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    '<=': {
        test: function(a, b) { return a <= b; },
        make: function(a, b) { return this.makeDiadic('<=', a, b); }
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    '=': {
        test: function(a, b) { return a === b; },
        make: function(a, b) { return this.makeDiadic('=', a, b); }
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    '>=': {
        test: function(a, b) { return a >= b; },
        make: function(a, b) { return this.makeDiadic('>=', a, b); }
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    '>': {
        test: function(a, b) { return a > b; },
        make: function(a, b) { return this.makeDiadic('>', a, b); }
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    '\u2260': {
        test: function(a, b) { return a !== b; },
        make: function(a, b) { return this.makeDiadic('<>', a, b); }
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    LIKE: {
        test: function(a, b) { return regExpLIKE.cached(b, true).test(a); },
        make: function(a, b) { return this.makeDiadic(LIKE, a, b); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    'NOT LIKE': {
        test: function(a, b) { return !regExpLIKE.cached(b, true).test(a); },
        make: function(a, b) { return this.makeDiadic(NOT_LIKE, a, b); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    IN: { // TODO: currently forcing string typing; rework calling code to respect column type
        test: function(a, b) { return inOp(a, b) >= 0; },
        make: function(a, b) { return this.makeIN(IN, a, b); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    'NOT IN': { // TODO: currently forcing string typing; rework calling code to respect column type
        test: function(a, b) { return inOp(a, b) < 0; },
        make: function(a, b) { return this.makeIN(NOT_IN, a, b); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    CONTAINS: {
        test: function(a, b) { return containsOp(a, b) >= 0; },
        make: function(a, b) { return this.makeLIKE(LIKE_WILD_CARD, LIKE_WILD_CARD, LIKE, a, b); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    'NOT CONTAINS': {
        test: function(a, b) { return containsOp(a, b) < 0; },
        make: function(a, b) { return this.makeLIKE(LIKE_WILD_CARD, LIKE_WILD_CARD, NOT_LIKE, a, b); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    BEGINS: {
        test: function(a, b) { b = (b + '').toLowerCase(); return beginsOp(a, b.length) === b; },
        make: function(a, b) { return this.makeLIKE(NIL, LIKE_WILD_CARD, LIKE, a, b); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    'NOT BEGINS': {
        test: function(a, b) { b = (b + '').toLowerCase(); return beginsOp(a, b.length) !== b; },
        make: function(a, b) { return this.makeLIKE(NIL, LIKE_WILD_CARD, NOT_LIKE, a, b); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    ENDS: {
        test: function(a, b) { b = (b + '').toLowerCase(); return endsOp(a, b.length) === b; },
        make: function(a, b) { return this.makeLIKE(LIKE_WILD_CARD, NIL, LIKE, a, b); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberof module:conditionals~Operators.prototype
     */
    'NOT ENDS': {
        test: function(a, b) { b = (b + '').toLowerCase(); return endsOp(a, b.length) !== b; },
        make: function(a, b) { return this.makeLIKE(LIKE_WILD_CARD, NIL, NOT_LIKE, a, b); },
        type: 'string'
    },

    /**
     * @memberof module:conditionals~Operators.prototype
     */
    makeLIKE: pureVirtualMethod.bind(this, 'makeLIKE'),

    /**
     * @memberof module:conditionals~Operators.prototype
     */
    makeIN: pureVirtualMethod.bind(this, 'makeIN'),

    /**
     * @memberof module:conditionals~Operators.prototype
     */
    makeDiadic: pureVirtualMethod.bind(this, 'makeDiadic')
});

// some synonyms
Operators.prototype['\u2264'] = Operators.prototype['<='];  // UNICODE 'LESS-THAN OR EQUAL TO'
Operators.prototype['\u2265'] = Operators.prototype['>='];  // UNICODE 'GREATER-THAN OR EQUAL TO'

function pureVirtualMethod(name) {
    throw 'Pure virtual method `Conditionals.prototype.' + name + '` has no implementation on this instance.';
}

function inOp(a, b) {
    return b
        .trim() // remove leading and trailing space chars
        .replace(/\s*,\s*/g, ',') // remove any white-space chars from around commas
        .split(',') // put in an array
        .indexOf((a + '')); // search array whole matches
}

function containsOp(a, b) {
    return (a + '').toLowerCase().indexOf((b + '').toLowerCase());
}

function beginsOp(a, length) {
    return (a + '').toLowerCase().substr(0, length);
}

function endsOp(a, length) {
    return (a + '').toLowerCase().substr(-length, length);
}

function sqEsc(string) {
    return string.replace(/'/g, SQT + SQT);
}

function getSqlString(string) {
    return SQT + sqEsc(string) + SQT;
}

function getSqlIdentifier(id) {
    return idQt[0].beg + id + idQt[0].end;
}

/**
 * @constructor
 * @extends Operators
 * @public
 */
var SqlOperators = Operators.extend({
    makeLIKE: function(beg, end, op, a, likePattern) {
        var escaped = likePattern.replace(/([\[_%\]])/g, '[$1]'); // escape all LIKE reserved chars
        return sqlIdentifier(a) + SPC + op + SPC + getSqlString(beg + escaped + end);
    },
    makeIN: function(op, a, b) {
        return sqlIdentifier(a) + SPC + op + SPC + '(' + SQT + sqEsc(b).replace(/\s*,\s*/g, SQT + ', ' + SQT) + SQT + ')';
    },
    makeDiadic: function(op, a, b) {
        return sqlIdentifier(a) + SPC + op + SPC + sqlLiteral(b);
    }
});

function sqlIdentifier(s) {
    return s.literal ? getSqlString(s.literal) : getSqlIdentifier(s.identifier ? s.identifier : s);
}

function sqlLiteral(s) {
    return s.identifier ? getSqlIdentifier(s.identifier) : getSqlString(s.literal ? s.literal : s);
}

/**
 * @constructor
 * @extends Operators
 */
var FilterCellOperators = Operators.extend({
    makeLIKE: function(beg, end, op, a, likePattern) {
        var escaped = likePattern.replace(/([\[_%\]])/g, '[$1]'); // escape all LIKE reserved chars
        return op.toLowerCase() + SPC + beg + escaped + end;
    },
    makeIN: function(op, a, b) {
        return op.toLowerCase() + SPC + b.replace(/\s*,\s*/g, ',');
    },
    makeDiadic: function(op, a, b) {
        return op + b;
    }
});

var groups = {
    equality: {
        label: 'Equality',
        submenu: ['=']
    },
    inequalities: {
        label: 'Inequalities',
        submenu: [
            '<',
            '\u2264', // UNICODE 'LESS-THAN OR EQUAL TO'; on a Mac, type option-comma (≤)
            '\u2260', // UNICODE 'NOT EQUALS'; on a Mac, type option-equals (≠)
            '\u2265', // UNICODE 'GREATER-THAN OR EQUAL TO'; on a Mac, type option-period (≥)
            '>'
        ]
    },
    sets: {
        label: 'Set scans',
        submenu: ['IN', 'NOT IN']
    },
    strings: {
        label: 'String scans',
        submenu: [
            'CONTAINS', 'NOT CONTAINS',
            'BEGINS', 'NOT BEGINS',
            'ENDS', 'NOT ENDS'
        ]
    },
    patterns: {
        label: 'Pattern scans',
        submenu: ['LIKE', 'NOT LIKE']
    }
};

// add a `name` prop to each group
_(groups).each(function(group, key) { group.name = key; });

module.exports = {
    /**
     * @type {module:conditionals~Operators}
     */
    operators: new Operators(),

    /**
     * @type {module:conditionals~SqlOperators}
     */
    sqlOperators: new SqlOperators(),

    /**
     * @type {module:conditionals~FilterCellOperators}
     */
    filterCellOperators: new FilterCellOperators(),

    /** Hash of logical operator groups for building your own operator drop-downs.
     * Each group is a {@link menuItem} object.*
     *
     * \* For these groups we're using the "array of strings" variant of `menuItem`.
     * @type {object}
     */
    groups: groups,

    /** Default operator menu when consisting of all of the groups in {@link module:conditionals.groups|groups}. This menu is used when none of the following is otherwise defined:
     * * The `opMenu` property of the column.*
     * * The entry in the node's `typeOpMenu` hash corresponding to the `type` property of the column.*
     * * The node's `treeOpMenu` object.
     *
     * \* The phrase _of the column_ as used here means in the element of the node's `schema` array named for the currently selected column.
     * @type {menuItem[]}
     */
    defaultOpMenu: [ // hierarchical menu of relational operators
        groups.equality,
        groups.inequalities,
        groups.sets,
        groups.strings,
        groups.patterns
    ],
    pushSqlIdQts: pushSqlIdQts,
    popSqlIdQts: popSqlIdQts
};

},{"extend-me":5,"object-iterators":24,"regexp-like":27}],11:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/**
 *
 * @param {HTMLElement} [containingEl=document]
 * @param {string} [prefix='']
 * @param {string} [separator='']
 * @param {string} [suffix='']
 * @param {function} [transformer=multiLineTrim] - Function to transform each input control's text value.
 */
function copyAll(containingEl, prefix, separator, suffix, transformer) {
    var texts = [], lastTextEl, text;

    Array.prototype.forEach.call((containingEl || document).querySelectorAll(copyAll.selector), function(textEl) {
        text = (transformer || multiLineTrim)(textEl.value);
        if (text) { texts.push(text); }
        lastTextEl = textEl;
    });

    if (lastTextEl) {
        copy(lastTextEl, (prefix || '') + texts.join(separator || '') + (suffix || ''));
    }
}

copyAll.selector = 'input:not([type]), input[type=text], textarea';

/**
 * 1. Trim the text in the given input element
 * 2. select it
 * 3. copy it to the clipboard
 * 4. deselect it
 * 5. return it
 * @param {HTMLElement|HTMLTextAreaElement} el
 * @param {string} [text=el.value] - Text to copy.
 * @returns {undefined|string} Trimmed text in element or undefined if unable to copy.
 */
function copy(el, text) {
    var result, lastText;

    if (text) {
        lastText = el.value;
        el.value = text;
    } else {
        text = el.value;
    }

    el.value = multiLineTrim(text);

    try {
        el.select();
        result = document.execCommand('copy');
    } catch (err) {
        result = false;
    } finally {
        if (lastText !== undefined) {
            el.value = lastText;
        }
        el.blur();
    }
    return result;
}

function multiLineTrim(s) {
    return s.replace(/^\s* (.*?)\s*$/, '$1');
}

copy.all = copyAll;
copy.multiLineTrim = multiLineTrim;

module.exports = copy;

},{}],12:[function(require,module,exports){
'use strict';

var cssInjector = require('css-injector');

var css; // defined by code inserted by gulpfile between following comments
/* inject:css */
css = '.filter-tree{font-family:sans-serif;font-size:10pt;line-height:1.5em}.filter-tree label{font-weight:400}.filter-tree input[type=checkbox],.filter-tree input[type=radio]{left:3px;margin-right:3px}.filter-tree ol{margin-top:0}.filter-tree>select{float:right;border:1px dotted grey;background-color:transparent;box-shadow:none}.filter-tree-remove-button{display:inline-block;width:15px;height:15px;border-radius:8px;background-color:#e88;font-size:11.5px;color:#fff;text-align:center;line-height:normal;font-style:normal;font-family:sans-serif;margin-right:4px;cursor:pointer}.filter-tree-remove-button:hover{background-color:transparent;color:#e88;font-weight:700;box-shadow:red 0 0 2px inset}.filter-tree-remove-button::before{content:\'\\d7\'}.filter-tree li::after{font-size:70%;font-style:italic;font-weight:700;color:#080}.filter-tree>ol>li:last-child::after{display:none}.op-and>ol,.op-nor>ol,.op-or>ol{padding-left:5px;margin-left:27px}.op-or>ol>li::after{margin-left:2.5em;content:\'— OR —\'}.op-and>ol>li::after{margin-left:2.5em;content:\'— AND —\'}.op-nor>ol>li::after{margin-left:2.5em;content:\'— NOR —\'}.filter-tree-editor>*{font-weight:700}.filter-tree-editor>span{font-size:smaller}.filter-tree-editor>input[type=text]{width:8em;padding:1px 5px 2px}.filter-tree-warning{background-color:#ffc!important;border-color:#edb!important;font-weight:400!important}.filter-tree-error{background-color:#fcc!important;border-color:#c99!important;font-weight:400!important}.filter-tree-default>:enabled{margin:0 .4em;background-color:#ddd;border:1px solid transparent}.filter-tree.filter-tree-type-column-filters>ol>li:not(:last-child){padding-bottom:.75em;border-bottom:3px double #080;margin-bottom:.75em}.filter-tree .footnotes{margin:0 0 6px;font-size:8pt;font-weight:400;line-height:normal;white-space:normal;color:#c00}.filter-tree .footnotes>p{margin:0}.filter-tree .footnotes>ul{margin:-3px 0 0;padding-left:17px;text-index:-6px}.filter-tree .footnotes>ul>li{margin:2px 0}.filter-tree .footnotes .field-name,.filter-tree .footnotes .field-value{font-weight:700;font-style:normal}.filter-tree .footnotes .field-value{font-family:monospace;color:#000;background-color:#ddd;padding:0 5px;margin:0 3px;border-radius:3px}.filter-tree-chooser{position:absolute;outline:0;box-shadow:5px 5px 10px grey;z-index:0;border:1px solid #000;border-radius:0 5px 5px;background-color:#ffffe0;font-style:italic;font-size:90%}.filter-tree-chooser>option{padding:4px 6px}.filter-tree-chooser>option:not(:last-child){border-bottom:1px dashed #666}';
/* endinject */

module.exports = cssInjector.bind(this, css, 'filter-tree-base');

},{"css-injector":4}],13:[function(require,module,exports){
'use strict';

var reName,
    reOp = /^((=|>=?|<[>=]?)|(NOT )?(LIKE|IN)\b)/i, // match[1]
    reLit = /^'(\d+)'/,
    reLitAnywhere = /'(\d+)'/,
    reIn = /^\((.*?)\)/,
    reBool = /^(AND|OR)\b/i,
    reGroup = /^(NOT ?)?\(/i;

var SQT = '\'';

var literals;

var idQt = [];
pushSqlIdQts({
    beg: '"',
    end: '"'
});
function pushSqlIdQts(qts) {
    reName = new RegExp('^(' + qts.beg + '(.+?)' + qts.end + '|([A-Z_][A-Z_@\\$#]*)\\b)', 'i'); // match[2] || match[3]
    return idQt.unshift(qts);

}
function popSqlIdQts() {
    return idQt.shift();
}

function parser(whereClause, options) {
    var whereTree;

    if (options) {
        pushSqlIdQts(options);
    }

    whereTree = walk(stripLiterals(whereClause));

    if (options) {
        popSqlIdQts();
    }

    return whereTree;
}
parser.pushSqlIdQts = pushSqlIdQts;
parser.popSqlIdQts = popSqlIdQts;

function walk(t) {
    var m, name, op, arg, bool, token, tokens = [];
    var i = 0;

    t = t.trim();

    while (i < t.length) {
        m = t.substr(i).match(reGroup);
        if (m) {
            var not = !!m[1];

            i += m[0].length;
            for (var j = i, v = 1; j < t.length && v; ++j) {
                if (t[j] === '(') {
                    ++v;
                } else if (t[j] === ')') {
                    --v;
                }
            }

            if (v) {
                throw 'Expected ")"';
            }
            token = walk(t.substr(i, j - 1 - i));
            if (typeof token !== 'object') {
                return token;
            }

            if (not) {
                if (token.operator !== 'op-or') {
                    throw 'Expected OR in NOT(...) subexpression but found ' + token.operator.substr(3).toUpperCase() + '.';
                }
                token.operator = 'op-nor';
            }

            i = j;
        } else {
            m = t.substr(i).match(reName);
            if (!m) {
                throw 'Expected identifier or quoted identifier.';
            }
            name = m[2] || m[3];
            if (!/^[A-Z_]/i.test(t[i])) { i += 2; }
            i += name.length;

            if (t[i] === ' ') { ++i; }
            m = t.substr(i).match(reOp);
            if (!m) {
                throw 'Expected relational operator.';
            }
            op = m[1].toUpperCase();
            i += op.length;

            if (t[i] === ' ') { ++i; }
            if (m[4] && m[4].toUpperCase() === 'IN') {
                m = t.substr(i).match(reIn);
                if (!m) {
                    throw 'Expected parenthesized list.';
                }
                arg = m[1];
                i += arg.length + 2;
                while ((m = arg.match(reLitAnywhere))) {
                    arg = arg.replace(reLitAnywhere, literals[m[1]]);
                }
            } else {
                m = t.substr(i).match(reLit);
                if (!m) {
                    throw 'Expected string literal.';
                }
                arg = m[1];
                i += arg.length + 2;
                arg = literals[arg];
            }

            token = {
                column: name,
                operator: op,
                literal: arg
            };
        }

        tokens.push(token);

        if (i < t.length) {
            if (t[i] === ' ') { ++i; }
            m = t.substr(i).match(reBool);
            if (!m) {
                throw 'Expected boolean opearator.';
            }
            bool = m[1].toLowerCase();
            i += bool.length;
            bool = 'op-' + bool;
            if (tokens.operator && tokens.operator !== bool) {
                throw 'Expected same boolean operator throughout subexpression.';
            }
            tokens.operator = bool;
        }

        if (t[i] === ' ') { ++i; }
    }

    return (
        tokens.length === 1
            ? tokens[0]
            : {
                operator: tokens.operator,
                children: tokens
            }
    );
}

function stripLiterals(t) {
    var i = 0, j = 0, k;

    literals = [];

    while ((j = t.indexOf(SQT, j)) >= 0) {
        k = j;
        do {
            k = t.indexOf(SQT, k + 1);
            if (k < 0) {
                throw 'Expected ' + SQT + ' (single quote).';
            }
        } while (t[++k] === SQT);
        literals.push(t.slice(++j, --k).replace(/''/g, SQT));
        t = t.substr(0, j) + i + t.substr(k);
        j = j + 1 + (i + '').length + 1;
        i++;
    }

    return t;
}

module.exports = parser;

},{}],14:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var templex = require('templex');

var templates = {

    subtree: function() {
/*
<span class="filter-tree">
    Match
    <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-or">any</label>
    <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-and">all</label>
    <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-nor">none</label>
    of the following:
    <select>
        <option value="">New expression&hellip;</option>
        <option value="subexp" style="border-bottom:1px solid black">Subexpression</option>
    </select>
    <ol></ol>
</span>
*/
    },

    columnFilter: function() {
/*
<span class="filter-tree">
    <strong><span>{2} </span>column filter subexpression:</strong><br>
    Match
    <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-or">any</label>
    <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-and">all</label>
    <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-nor">none</label>
    of the following:
    <select>
        <option value="">New expression&hellip;</option>
    </select>
    <ol></ol>
</span>
*/
    },

    columnFilters: function() {
/*
<span class="filter-tree filter-tree-type-column-filters">
    Match <strong>all</strong> of the following column filters:
    <ol></ol>
</span>
*/
    },

    lockedColumn: function() {
/*
<span>
    {1:encode}
    <input type="hidden" value="{2}">
</span>
*/
    },

    'column-CQL-syntax': function() {
/*
<li>
    <button type="button" class="copy"></button>
    <div class="filter-tree-remove-button" title="delete conditional"></div>
    {1}:
    <input name="{2}" class="{4}" value="{3:encode}">
</li>
*/
    },

    'column-SQL-syntax': function() {
/*
<li>
    <button type="button" class="copy"></button>
    <div class="filter-tree-remove-button" title="delete conditional"></div>
    {1}:
    <textarea name="{2}" rows="1" class="{4}">{3:encode}</textarea>
</li>
*/
    },

    removeButton: function() {
/*
<div class="filter-tree-remove-button" title="delete conditional"></div>
*/
    },

    note: function() {
/*
<div class="footnotes">
    <div class="footnote"></div>
    <p>Select a new value or delete the expression altogether.</p>
</div>
*/
    },

    notes: function() {
/*
<div class="footnotes">
   <p>Note the following error conditions:</p>
   <ul class="footnote"></ul>
   <p>Select new values or delete the expression altogether.</p>
</div>
*/
    },

    optionMissing: function() {
/*
The requested value of <span class="field-name">{1:encode}</span>
(<span class="field-value">{2:encode}</span>) is not valid.
*/
    }

};

var extract = /\/\*\s*([^]+?)\s+\*\//; // finds the string inside the /* ... */; the group excludes the whitespace
var encoders = /\{(\d+)\:encode\}/g;

function get(templateName) {
    var temp = document.createElement('div');
    var text = templates[templateName].toString().match(extract)[1];
    var args = Array.prototype.slice.call(arguments, 1);

    text = dress(text, encoders, function(key) {
        temp.textContent = args[key];
        args[key] = temp.innerHTML;
    });

    temp.innerHTML = templex.apply(this, [text].concat(args));

    // if only one HTMLElement, return it; otherwise entire list of nodes
    return temp.children.length === 1 && temp.childNodes.length === 1 ? temp.firstChild : temp.childNodes;
}

function dress(text, regex, transformer) {
    var keys, matches = {};

    regex.lastIndex = 0;
    while ((keys = regex.exec(text))) {
        matches[keys[1]] = true;
    }
    keys = Object.keys(matches);
    if (keys.length) {
        keys.forEach(transformer);
        text = text.replace(regex, '{$1}');
    }

    return text;
}

module.exports = get;

},{"templex":29}],15:[function(require,module,exports){
'use strict';

/** @typedef {function} operationReducer
 * @param {boolean} p
 * @param {boolean} q
 * @returns {boolean} The result of applying the operator to the two parameters.
 */

/**
 * @private
 * @type {operationReducer}
 */
function AND(p, q) {
    return p && q;
}

/**
 * @private
 * @type {operationReducer}
 */
function OR(p, q) {
    return p || q;
}

/** @typedef {obejct} treeOperator
 * @desc Each `treeOperator` object describes two things:
 *
 * 1. How to take the test results of _n_ child nodes by applying the operator to all the results to "reduce" it down to a single result.
 * 2. How to generate SQL WHERE clause syntax that applies the operator to _n_ child nodes.
 *
 * @property {operationReducer} reduce
 * @property {boolean} seed -
 * @property {boolean} abort -
 * @property {boolean} negate -
 * @property {string} SQL.op -
 * @property {string} SQL.beg -
 * @property {string} SQL.end -
 */

/** A hash of {@link treeOperator} objects.
 * @type {object}
 */
var treeOperators = {
    'op-and': {
        reduce: AND,
        seed: true,
        abort: false,
        negate: false,
        filterCell: {
            op: 'and'
        },
        SQL: {
            op: 'AND',
            beg: '(',
            end: ')'
        }
    },
    'op-or': {
        reduce: OR,
        seed: false,
        abort: true,
        negate: false,
        filterCell: {
            op: 'or'
        },
        SQL: {
            op: 'OR',
            beg: '(',
            end: ')'
        }
    },
    'op-nor': {
        reduce: OR,
        seed: false,
        abort: true,
        negate: true,
        filterCell: {
            op: 'nor'
        },
        SQL: {
            op: 'OR',
            beg: 'NOT (',
            end: ')'
        }
    }
};

module.exports = treeOperators;

},{}],16:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

var cssInjector = require('css-injector');

/**
 * @constructor FinBar
 * @summary Create a scrollbar object.
 * @desc Creating a scrollbar is a three-step process:
 *
 * 1. Instantiate the scrollbar object by calling this constructor function. Upon instantiation, the DOM element for the scrollbar (with a single child element for the scrollbar "thumb") is created but is not insert it into the DOM.
 * 2. After instantiation, it is the caller's responsibility to insert the scrollbar, {@link FinBar#bar|this.bar}, into the DOM.
 * 3. After insertion, the caller must call {@link FinBar#resize|resize()} at least once to size and position the scrollbar and its thumb. After that, `resize()` should also be called repeatedly on resize events (as the content element is being resized).
 *
 * Suggested configurations:
 * * _**Unbound**_<br/>
 * The scrollbar serves merely as a simple range (slider) control. Omit both `options.onchange` and `options.content`.
 * * _**Bound to virtual content element**_<br/>
 * Virtual content is projected into the element using a custom event handler supplied by the programmer in `options.onchange`. A typical use case would be to handle scrolling of the virtual content. Other use cases include data transformations, graphics transformations, _etc._
 * * _**Bound to real content**_<br/>
 * Set `options.content` to the "real" content element but omit `options.onchange`. This will cause the scrollbar to use the built-in event handler (`this.scrollRealContent`) which implements smooth scrolling of the content element within the container.
 *
 * @param {finbarOptions} [options={}] - Options object. See the type definition for member details.
 */
function FinBar(options) {

    // make bound versions of all the mouse event handler
    var bound = this._bound = {};
    for (key in handlersToBeBound) {
        bound[key] = handlersToBeBound[key].bind(this);
    }

    /**
     * @name thumb
     * @summary The generated scrollbar thumb element.
     * @desc The thumb element's parent element is always the {@link FinBar#bar|bar} element.
     *
     * This property is typically referenced internally only. The size and position of the thumb element is maintained by `_calcThumb()`.
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var thumb = document.createElement('div');
    thumb.classList.add('thumb');
    thumb.onclick = bound.shortStop;
    thumb.onmouseover = bound.onmouseover;
    this.thumb = thumb;

    /**
     * @name bar
     * @summary The generated scrollbar element.
     * @desc The caller inserts this element into the DOM (typically into the content container) and then calls its {@link FinBar#resize|resize()} method.
     *
     * Thus the node tree is typically:
     * * A **content container** element, which contains:
     *    * The content element(s)
     *    * This **scrollbar element**, which in turn contains:
     *        * The **thumb element**
     *
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var bar = document.createElement('div');

    bar.classList.add('finbar-vertical');

    bar.appendChild(thumb);
    if (this.paging) {
        bar.onclick = bound.onclick;
    }
    this.bar = bar;

    options = options || {};

    // presets
    this.orientation = 'vertical';
    this._min = this._index = 0;
    this._max = 100;

    // options
    for (var key in options) {
        if (options.hasOwnProperty(key)) {
            var option = options[key];
            switch (key) {

            case 'index':
                this._index = option;
                break;

            case 'range':
                validRange(option);
                this._min = option.min;
                this._max = option.max;
                this.contentSize = option.max - option.min + 1;
                break;

            default:
                if (
                    key.charAt(0) !== '_' &&
                    typeof FinBar.prototype[key] !== 'function'
                ) {
                    // override prototype defaults for standard ;
                    // extend with additional properties (for use in onchange event handlers)
                    this[key] = option;
                }
                break;

            }
        }
    }

    cssInjector(cssFinBars, 'finbar-base', options.cssStylesheetReferenceElement);
}

FinBar.prototype = {

    /**
     * @summary The scrollbar orientation.
     * @desc Set by the constructor to either `'vertical'` or `'horizontal'`. See the similarly named property in the {@link finbarOptions} object.
     *
     * Useful values are `'vertical'` (the default) or `'horizontal'`.
     *
     * Setting this property resets `this.oh` and `this.deltaProp` and changes the class names so as to reposition the scrollbar as per the CSS rules for the new orientation.
     * @default 'vertical'
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set orientation(orientation) {
        if (orientation === this._orientation) {
            return;
        }

        this._orientation = orientation;

        /**
         * @readonly
         * @name oh
         * @summary <u>O</u>rientation <u>h</u>ash for this scrollbar.
         * @desc Set by the `orientation` setter to either the vertical or the horizontal orientation hash. The property should always be synchronized with `orientation`; do not update directly!
         *
         * This object is used internally to access scrollbars' DOM element properties in a generalized way without needing to constantly query the scrollbar orientation. For example, instead of explicitly coding `this.bar.top` for a vertical scrollbar and `this.bar.left` for a horizontal scrollbar, simply code `this.bar[this.oh.leading]` instead. See the {@link orientationHashType} definition for details.
         *
         * This object is useful externally for coding generalized {@link finbarOnChange} event handler functions that serve both horizontal and vertical scrollbars.
         * @type {orientationHashType}
         * @memberOf FinBar.prototype
         */
        this.oh = orientationHashes[this._orientation];

        if (!this.oh) {
            error('Invalid value for `options._orientation.');
        }

        /**
         * @name deltaProp
         * @summary The name of the `WheelEvent` property this scrollbar should listen to.
         * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
         *
         * Useful values are `'deltaX'`, `'deltaY'`, or `'deltaZ'`. A value of `null` means to ignore mouse wheel events entirely.
         *
         * The mouse wheel is one-dimensional and only emits events with `deltaY` data. This property is provided so that you can override the default of `'deltaX'` with a value of `'deltaY'` on your horizontal scrollbar primarily to accommodate certain "panoramic" interface designs where the mouse wheel should control horizontal rather than vertical scrolling. Just give `{ deltaProp: 'deltaY' }` in your horizontal scrollbar instantiation.
         *
         * Caveat: Note that a 2-finger drag on an Apple trackpad emits events with _both_ `deltaX ` and `deltaY` data so you might want to delay making the above adjustment until you can determine that you are getting Y data only with no X data at all (which is a sure bet you on a mouse wheel rather than a trackpad).

         * @type {object|null}
         * @memberOf FinBar.prototype
         */
        this.deltaProp = this.oh.delta;

        this.bar.className = this.bar.className.replace(/(vertical|horizontal)/g, orientation);

        if (this.bar.style.cssText || this.thumb.style.cssText) {
            this.bar.removeAttribute('style');
            this.thumb.removeAttribute('style');
            this.resize();
        }
    },
    get orientation() {
        return this._orientation;
    },

    /**
     * @summary Callback for scroll events.
     * @desc Set by the constructor via the similarly named property in the {@link finbarOptions} object. After instantiation, `this.onchange` may be updated directly.
     *
     * This event handler is called whenever the value of the scrollbar is changed through user interaction. The typical use case is when the content is scrolled. It is called with the `FinBar` object as its context and the current value of the scrollbar (its index, rounded) as the only parameter.
     *
     * Set this property to `null` to stop emitting such events.
     * @type {function(number)|null}
     * @memberOf FinBar.prototype
     */
    onchange: null,

    /**
     * @summary Add a CSS class name to the bar element's class list.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * The bar element's class list will always include `finbar-vertical` (or `finbar-horizontal` based on the current orientation). Whenever this property is set to some value, first the old prefix+orientation is removed from the bar element's class list; then the new prefix+orientation is added to the bar element's class list. This property causes _an additional_ class name to be added to the bar element's class list. Therefore, this property will only add at most one additional class name to the list.
     *
     * To remove _classname-orientation_ from the bar element's class list, set this property to a falsy value, such as `null`.
     *
     * > NOTE: You only need to specify an additional class name when you need to have mulltiple different styles of scrollbars on the same page. If this is not a requirement, then you don't need to make a new class; you would just create some additional rules using the same selectors in the built-in stylesheet (../css/finbars.css):
     * *`div.finbar-vertical` (or `div.finbar-horizontal`) for the scrollbar
     * *`div.finbar-vertical > div` (or `div.finbar-horizontal > div`) for the "thumb."
     *
     * Of course, your rules should come after the built-ins.
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set classPrefix(prefix) {
        if (this._classPrefix) {
            this.bar.classList.remove(this._classPrefix + this.orientation);
        }

        this._classPrefix = prefix;

        if (prefix) {
            this.bar.classList.add(prefix + '-' + this.orientation);
        }
    },
    get classPrefix() {
        return this._classPrefix;
    },

    /**
     * @name increment
     * @summary Number of scrollbar index units representing a pageful. Used exclusively for paging up and down and for setting thumb size relative to content size.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * Can also be given as a parameter to the {@link FinBar#resize|resize} method, which is pertinent because content area size changes affect the definition of a "pageful." However, you only need to do this if this value is being used. It not used when:
     * * you define `paging.up` and `paging.down`
     * * your scrollbar is using `scrollRealContent`
     * @type {number}
     * @memberOf FinBar.prototype
     */
    increment: 1,

    /**
     * @name barStyles
     * @summary Scrollbar styles to be applied by {@link FinBar#resize|resize()}.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * This is a value to be assigned to {@link FinBar#styles|styles} on each call to {@link FinBar#resize|resize()}. That is, a hash of values to be copied to the scrollbar element's style object on resize; or `null` for none.
     *
     * @see {@link FinBar#style|style}
     * @type {finbarStyles|null}
     * @memberOf FinBar.prototype
     */
    barStyles: null,

    /**
     * @name style
     * @summary Additional scrollbar styles.
     * @desc See type definition for more details. These styles are applied directly to the scrollbar's `bar` element.
     *
     * Values are adjusted as follows before being applied to the element:
     * 1. Included "pseudo-property" names from the scrollbar's orientation hash, {@link FinBar#oh|oh}, are translated to actual property names before being applied.
     * 2. When there are margins, percentages are translated to absolute pixel values because CSS ignores margins in its percentage calculations.
     * 3. If you give a value without a unit (a raw number), "px" unit is appended.
     *
     * General notes:
     * 1. It is always preferable to specify styles via a stylesheet. Only set this property when you need to specifically override (a) stylesheet value(s).
     * 2. Can be set directly or via calls to the {@link FinBar#resize|resize} method.
     * 3. Should only be set after the scrollbar has been inserted into the DOM.
     * 4. Before applying these new values to the element, _all_ in-line style values are reset (by removing the element's `style` attribute), exposing inherited values (from stylesheets).
     * 5. Empty object has no effect.
     * 6. Falsey value in place of object has no effect.
     *
     * > CAVEAT: Do not attempt to treat the object you assign to this property as if it were `this.bar.style`. Specifically, changing this object after assigning it will have no effect on the scrollbar. You must assign it again if you want it to have an effect.
     *
     * @see {@link FinBar#barStyles|barStyles}
     * @type {finbarStyles}
     * @memberOf FinBar.prototype
     */
    set style(styles) {
        var keys = Object.keys(styles = extend({}, styles, this._auxStyles));

        if (keys.length) {
            var bar = this.bar,
                barRect = bar.getBoundingClientRect(),
                container = this.container || bar.parentElement,
                containerRect = container.getBoundingClientRect(),
                oh = this.oh;

            // Before applying new styles, revert all styles to values inherited from stylesheets
            bar.removeAttribute('style');

            keys.forEach(function (key) {
                var val = styles[key];

                if (key in oh) {
                    key = oh[key];
                }

                if (!isNaN(Number(val))) {
                    val = (val || 0) + 'px';
                } else if (/%$/.test(val)) {
                    // When bar size given as percentage of container, if bar has margins, restate size in pixels less margins.
                    // (If left as percentage, CSS's calculation will not exclude margins.)
                    var oriented = axis[key],
                        margins = barRect[oriented.marginLeading] + barRect[oriented.marginTrailing];
                    if (margins) {
                        val = parseInt(val, 10) / 100 * containerRect[oriented.size] - margins + 'px';
                    }
                }

                bar.style[key] = val;
            });
        }
    },

    /**
     * @readonly
     * @name paging
     * @summary Enable page up/dn clicks.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * If truthy, listen for clicks in page-up and page-down regions of scrollbar.
     *
     * If an object, call `.paging.up()` on page-up clicks and `.paging.down()` will be called on page-down clicks.
     *
     * Changing the truthiness of this value after instantiation currently has no effect.
     * @type {boolean|object}
     * @memberOf FinBar.prototype
     */
    paging: true,

    /**
     * @name range
     * @summary Setter for the minimum and maximum scroll values.
     * @desc Set by the constructor. These values are the limits for {@link FooBar#index|index}.
     *
     * The setter accepts an object with exactly two numeric properties: `.min` which must be less than `.max`. The values are extracted and the object is discarded.
     *
     * The getter returns a new object with `.min` and '.max`.
     *
     * @type {rangeType}
     * @memberOf FinBar.prototype
     */
    set range(range) {
        validRange(range);
        this._min = range.min;
        this._max = range.max;
        this.contentSize = range.max - range.min + 1;
        this.index = this.index; // re-clamp
    },
    get range() {
        return {
            min: this._min,
            max: this._max
        };
    },

    /**
     * @summary Index value of the scrollbar.
     * @desc This is the position of the scroll thumb.
     *
     * Setting this value clamps it to {@link FinBar#min|min}..{@link FinBar#max|max}, scroll the content, and moves thumb.
     *
     * Getting this value returns the current index. The returned value will be in the range `min`..`max`. It is intentionally not rounded.
     *
     * Use this value as an alternative to (or in addition to) using the {@link FinBar#onchange|onchange} callback function.
     *
     * @see {@link FinBar#_setScroll|_setScroll}
     * @type {number}
     * @memberOf FinBar.prototype
     */
    set index(idx) {
        idx = Math.min(this._max, Math.max(this._min, idx)); // clamp it
        this._setScroll(idx);
        // this._setThumbSize();
    },
    get index() {
        return this._index;
    },

    /**
     * @private
     * @summary Move the thumb.
     * @desc Also displays the index value in the test panel and invokes the callback.
     * @param idx - The new scroll index, a value in the range `min`..`max`.
     * @param [scaled=f(idx)] - The new thumb position in pixels and scaled relative to the containing {@link FinBar#bar|bar} element, i.e., a proportional number in the range `0`..`thumbMax`. When omitted, a function of `idx` is used.
     * @memberOf FinBar.prototype
     */
    _setScroll: function (idx, scaled) {
        this._index = idx;

        // Display the index value in the test panel
        if (this.testPanelItem && this.testPanelItem.index instanceof Element) {
            this.testPanelItem.index.innerHTML = Math.round(idx);
        }

        // Call the callback
        if (this.onchange) {
            this.onchange.call(this, Math.round(idx));
        }

        // Move the thumb
        if (scaled === undefined) {
            scaled = (idx - this._min) / (this._max - this._min) * this._thumbMax;
        }
        this.thumb.style[this.oh.leading] = scaled + 'px';
    },

    scrollRealContent: function (idx) {
        var containerRect = this.content.parentElement.getBoundingClientRect(),
            sizeProp = this.oh.size,
            maxScroll = Math.max(0, this.content[sizeProp] - containerRect[sizeProp]),
            //scroll = Math.min(idx, maxScroll);
            scroll = (idx - this._min) / (this._max - this._min) * maxScroll;
        //console.log('scroll: ' + scroll);
        this.content.style[this.oh.leading] = -scroll + 'px';
    },

    /**
     * @summary Recalculate thumb position.
     *
     * @desc This method recalculates the thumb size and position. Call it once after inserting your scrollbar into the DOM, and repeatedly while resizing the scrollbar (which typically happens when the scrollbar's parent is resized by user.
     *
     * > This function shifts args if first arg omitted.
     *
     * @param {number} [increment=this.increment] - Resets {@link FooBar#increment|increment} (see).
     *
     * @param {finbarStyles} [barStyles=this.barStyles] - (See type definition for details.) Scrollbar styles to be applied to the bar element.
     *
     * Only specify a `barStyles` object when you need to override stylesheet values. If provided, becomes the new default (`this.barStyles`), for use as a default on subsequent calls.
     *
     * It is generally the case that the scrollbar's new position is sufficiently described by the current styles. Therefore, it is unusual to need to provide a `barStyles` object on every call to `resize`.
     *
     * @returns {FinBar} Self for chaining.
     * @memberOf FinBar.prototype
     */
    resize: function (increment, barStyles) {
        var bar = this.bar;

        if (!bar.parentNode) {
            return; // not in DOM yet so nothing to do
        }

        var container = this.container || bar.parentElement,
            containerRect = container.getBoundingClientRect();

        // shift args if if 1st arg omitted
        if (typeof increment === 'object') {
            barStyles = increment;
            increment = undefined;
        }

        this.style = this.barStyles = barStyles || this.barStyles;

        // Bound to real content: Content was given but no onchange handler.
        // Set up .onchange, .containerSize, and .increment.
        // Note this only makes sense if your index unit is pixels.
        if (this.content) {
            if (!this.onchange) {
                this.onchange = this.scrollRealContent;
                this.contentSize = this.content[this.oh.size];
                this._min = 0;
                this._max = this.contentSize - 1;
            }
        }
        if (this.onchange === this.scrollRealContent) {
            this.containerSize = containerRect[this.oh.size];
            this.increment = this.containerSize / (this.contentSize - this.containerSize) * (this._max - this._min);
        } else {
            this.containerSize = 1;
            this.increment = increment || this.increment;
        }

        var index = this.index;
        this.testPanelItem = this.testPanelItem || this._addTestPanelItem();
        this._setThumbSize();
        this.index = index;

        if (this.deltaProp !== null) {
            container.addEventListener('wheel', this._bound.onwheel);
        }

        return this;
    },

    /**
     * @summary Shorten trailing end of scrollbar by thickness of some other scrollbar.
     * @desc In the "classical" scenario where vertical scroll bar is on the right and horizontal scrollbar is on the bottom, you want to shorten the "trailing end" (bottom and right ends, respectively) of at least one of them so they don't overlay.
     *
     * This convenience function is an programmatic alternative to hardcoding the correct style with the correct value in your stylesheet; or setting the correct style with the correct value in the {@link FinBar#barStyles|barStyles} object.
     *
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     *
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenBy: function (otherFinBar) { return this.shortenEndBy('trailing', otherFinBar); },

    /**
     * @summary Shorten leading end of scrollbar by thickness of some other scrollbar.
     * @desc Supports non-classical scrollbar scenarios where vertical scroll bar may be on left and horizontal scrollbar may be on top, in which case you want to shorten the "leading end" rather than the trailing end.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    foreshortenBy: function (otherFinBar) { return this.shortenEndBy('leading', otherFinBar); },

    /**
     * @summary Generalized shortening function.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     * @param {string} whichEnd - a CSS style property name or an orientation hash name that translates to a CSS style property name.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenEndBy: function (whichEnd, otherFinBar) {
        if (!otherFinBar) {
            delete this._auxStyles;
        } else if (otherFinBar instanceof FinBar && otherFinBar.orientation !== this.orientation) {
            var otherStyle = window.getComputedStyle(otherFinBar.bar),
                ooh = orientationHashes[otherFinBar.orientation];
            this._auxStyles = {};
            this._auxStyles[whichEnd] = otherStyle[ooh.thickness];
        }
        return this; // for chaining
    },

    /**
     * @private
     * @summary Sets the proportional thumb size and hides thumb when 100%.
     * @desc The thumb size has an absolute minimum of 20 (pixels).
     * @memberOf FinBar.prototype
     */
    _setThumbSize: function () {
        var oh = this.oh,
            thumbComp = window.getComputedStyle(this.thumb),
            thumbMarginLeading = parseInt(thumbComp[oh.marginLeading]),
            thumbMarginTrailing = parseInt(thumbComp[oh.marginTrailing]),
            thumbMargins = thumbMarginLeading + thumbMarginTrailing,
            barSize = this.bar.getBoundingClientRect()[oh.size],
            thumbSize = Math.max(20, barSize * this.containerSize / this.contentSize);

        if (this.containerSize < this.contentSize) {
            this.bar.style.visibility = 'visible';
            this.thumb.style[oh.size] = thumbSize + 'px';
        } else {
            this.bar.style.visibility = 'hidden';
        }

        /**
         * @private
         * @name _thumbMax
         * @summary Maximum offset of thumb's leading edge.
         * @desc This is the pixel offset within the scrollbar of the thumb when it is at its maximum position at the extreme end of its range.
         *
         * This value takes into account the newly calculated size of the thumb element (including its margins) and the inner size of the scrollbar (the thumb's containing element, including _its_ margins).
         *
         * NOTE: Scrollbar padding is not taken into account and assumed to be 0 in the current implementation and is assumed to be `0`; use thumb margins in place of scrollbar padding.
         * @type {number}
         * @memberOf FinBar.prototype
         */
        this._thumbMax = barSize - thumbSize - thumbMargins;

        this._thumbMarginLeading = thumbMarginLeading; // used in mousedown
    },

    /**
     * @summary Remove the scrollbar.
     * @desc Unhooks all the event handlers and then removes the element from the DOM. Always call this method prior to disposing of the scrollbar object.
     * @memberOf FinBar.prototype
     */
    remove: function () {
        this._removeEvt('mousedown');
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        (this.container || this.bar.parentElement)._removeEvt('wheel', this._bound.onwheel);

        this.bar.onclick =
            this.thumb.onclick =
                this.thumb.onmouseover =
                    this.thumb.transitionend =
                        this.thumb.onmouseout = null;

        this.bar.remove();
    },

    /**
     * @private
     * @function _addTestPanelItem
     * @summary Append a test panel element.
     * @desc If there is a test panel in the DOM (typically an `<ol>...</ol>` element) with class names of both `this.classPrefix` and `'test-panel'` (or, barring that, any element with class name `'test-panel'`), an `<li>...</li>` element will be created and appended to it. This new element will contain a span for each class name given.
     *
     * You should define a CSS selector `.listening` for these spans. This class will be added to the spans to alter their appearance when a listener is added with that class name (prefixed with 'on').
     *
     * (This is an internal function that is called once by the constructor on every instantiation.)
     * @returns {Element|undefined} The appended `<li>...</li>` element or `undefined` if there is no test panel.
     * @memberOf FinBar.prototype
     */
    _addTestPanelItem: function () {
        var testPanelItem,
            testPanelElement = document.querySelector('.' + this._classPrefix + '.test-panel') || document.querySelector('.test-panel');

        if (testPanelElement) {
            var testPanelItemPartNames = [ 'mousedown', 'mousemove', 'mouseup', 'index' ],
                item = document.createElement('li');

            testPanelItemPartNames.forEach(function (partName) {
                item.innerHTML += '<span class="' + partName + '">' + partName.replace('mouse', '') + '</span>';
            });

            testPanelElement.appendChild(item);

            testPanelItem = {};
            testPanelItemPartNames.forEach(function (partName) {
                testPanelItem[partName] = item.getElementsByClassName(partName)[0];
            });
        }

        return testPanelItem;
    },

    _addEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.add('listening'); }
        window.addEventListener(evtName, this._bound['on' + evtName]);
    },

    _removeEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.remove('listening'); }
        window.removeEventListener(evtName, this._bound['on' + evtName]);
    }
};

function extend(obj) {
    for (var i = 1; i < arguments.length; ++i) {
        var objn = arguments[i];
        if (objn) {
            for (var key in objn) {
                obj[key] = objn[key];
            }
        }
    }
    return obj;
}

function validRange(range) {
    var keys = Object.keys(range),
        valid =  keys.length === 2 &&
            typeof range.min === 'number' &&
            typeof range.max === 'number' &&
            range.min <= range.max;

    if (!valid) {
        error('Invalid .range object.');
    }
}

/**
 * @private
 * @name handlersToBeBound
 * @type {object}
 * @desc The functions defined in this object are all DOM event handlers that are bound by the FinBar constructor to each new instance. In other words, the `this` value of these handlers, once bound, refer to the FinBar object and not to the event emitter. "Do not consume raw."
 */
var handlersToBeBound = {
    shortStop: function (evt) {
        evt.stopPropagation();
    },

    onwheel: function (evt) {
        this.index += evt[this.deltaProp];
        evt.stopPropagation();
        evt.preventDefault();
    },

    onclick: function (evt) {
        var thumbBox = this.thumb.getBoundingClientRect(),
            goingUp = evt[this.oh.coordinate] < thumbBox[this.oh.leading];

        if (typeof this.paging === 'object') {
            this.index = this.paging[goingUp ? 'up' : 'down'](Math.round(this.index));
        } else {
            this.index += goingUp ? -this.increment : this.increment;
        }

        // make the thumb glow momentarily
        this.thumb.classList.add('hover');
        var self = this;
        this.thumb.addEventListener('transitionend', function waitForIt() {
            this.removeEventListener('transitionend', waitForIt);
            self._bound.onmouseup(evt);
        });

        evt.stopPropagation();
    },

    onmouseover: function () {
        this.thumb.classList.add('hover');
        this.thumb.onmouseout = this._bound.onmouseout;
        this._addEvt('mousedown');
    },

    onmouseout: function () {
        this._removeEvt('mousedown');
        this.thumb.onmouseover = this._bound.onmouseover;
        this.thumb.classList.remove('hover');
    },

    onmousedown: function (evt) {
        this._removeEvt('mousedown');
        this.thumb.onmouseover = this.thumb.onmouseout = null;

        var thumbBox = this.thumb.getBoundingClientRect();
        this.pinOffset = evt[this.oh.axis] - thumbBox[this.oh.leading] + this.bar.getBoundingClientRect()[this.oh.leading] + this._thumbMarginLeading;
        document.documentElement.style.cursor = 'default';

        this._addEvt('mousemove');
        this._addEvt('mouseup');

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmousemove: function (evt) {
        var scaled = Math.min(this._thumbMax, Math.max(0, evt[this.oh.axis] - this.pinOffset));
        var idx = scaled / this._thumbMax * (this._max - this._min) + this._min;

        this._setScroll(idx, scaled);

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmouseup: function (evt) {
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        document.documentElement.style.cursor = 'auto';

        var thumbBox = this.thumb.getBoundingClientRect();
        if (
            thumbBox.left <= evt.clientX && evt.clientX <= thumbBox.right &&
            thumbBox.top <= evt.clientY && evt.clientY <= thumbBox.bottom
        ) {
            this._bound.onmouseover(evt);
        } else {
            this._bound.onmouseout(evt);
        }

        evt.stopPropagation();
        evt.preventDefault();
    }
};

var orientationHashes = {
    vertical: {
        coordinate:     'clientY',
        axis:           'pageY',
        size:           'height',
        outside:        'right',
        inside:         'left',
        leading:        'top',
        trailing:       'bottom',
        marginLeading:  'marginTop',
        marginTrailing: 'marginBottom',
        thickness:      'width',
        delta:          'deltaY'
    },
    horizontal: {
        coordinate:     'clientX',
        axis:           'pageX',
        size:           'width',
        outside:        'bottom',
        inside:         'top',
        leading:        'left',
        trailing:       'right',
        marginLeading:  'marginLeft',
        marginTrailing: 'marginRight',
        thickness:      'height',
        delta:          'deltaX'
    }
};

var axis = {
    top:    'vertical',
    bottom: 'vertical',
    height: 'vertical',
    left:   'horizontal',
    right:  'horizontal',
    width:  'horizontal'
};

var cssFinBars; // definition inserted by gulpfile between following comments
/* inject:css */
cssFinBars = 'div.finbar-horizontal,div.finbar-vertical{position:absolute;margin:3px}div.finbar-horizontal>.thumb,div.finbar-vertical>.thumb{position:absolute;background-color:#d3d3d3;-webkit-box-shadow:0 0 1px #000;-moz-box-shadow:0 0 1px #000;box-shadow:0 0 1px #000;border-radius:4px;margin:2px;opacity:.4;transition:opacity .5s}div.finbar-horizontal>.thumb.hover,div.finbar-vertical>.thumb.hover{opacity:1;transition:opacity .5s}div.finbar-vertical{top:0;bottom:0;right:0;width:11px}div.finbar-vertical>.thumb{top:0;right:0;width:7px}div.finbar-horizontal{left:0;right:0;bottom:0;height:11px}div.finbar-horizontal>.thumb{left:0;bottom:0;height:7px}';
/* endinject */

function error(msg) {
    throw 'finbars: ' + msg;
}

// Interface
module.exports = FinBar;

},{"css-injector":4}],17:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var rectangular = require('rectangular');

var gestures = require('./js/polymergestures.dev.js');
var GraphicsContext = require('./js/GraphicsContext.js');

var RESIZE_POLLING_INTERVAL = 200,
    paintables = [],
    resizables = [],
    paintLoopRunning = true,
    resizeLoopRunning = true,
    charMap = makeCharMap();

function Canvas(div, component, options) {
    var self = this;

    this.div = div;
    this.component = component;

    options = options || {};
    this.doubleClickDelay = options.doubleClickDelay || 325;

    this.dragEndtime = Date.now();

    this.canvas = document.createElement('canvas');
    this.div.appendChild(this.canvas);

    this.canvas.style.outline = 'none';

    // this.focuser = document.createElement('button');
    // this.focuser.style.position = 'absolute';
    // this.focuser.style.top = '0px';
    // this.focuser.style.left = '0px';
    // this.focuser.style.zIndex = '-1';
    // this.focuser.style.outline = 'none';
    // this.div.appendChild(this.focuser);

    this.canvasCTX = this.canvas.getContext('2d');
    this.gc = new GraphicsContext(this.canvasCTX);

    this.buffer = document.createElement('canvas');
    this.bufferCTX = this.buffer.getContext('2d');
    this.bufferGC = new GraphicsContext(this.bufferCTX);

    this.mouseLocation = new rectangular.Point(-1, -1);
    this.dragstart = new rectangular.Point(-1, -1);
    //this.origin = new rectangular.Point(0, 0);
    this.bounds = new rectangular.Rectangle(0, 0, 0, 0);
    this.hasMouse = false;

    document.addEventListener('mousemove', function(e) {
        if (self.hasMouse || self.isDragging()) {
            self.finmousemove(e);
        }
    });
    document.addEventListener('mouseup', function(e) {
        self.finmouseup(e);
    });
    document.addEventListener('wheel', function(e) {
        self.finwheelmoved(e);
    });
    document.addEventListener('keydown', function(e) {
        self.finkeydown(e);
    });
    document.addEventListener('keyup', function(e) {
        self.finkeyup(e);
    });

    this.canvas.onmouseover = function() {
        self.hasMouse = true;
    };
    this.canvas.addEventListener('focus', function(e) {
        self.finfocusgained(e);
    });
    this.canvas.addEventListener('blur', function(e) {
        self.finfocuslost(e);
    });
    this.canvas.addEventListener('mousedown', function(e) {
        self.finmousedown(e);
    });
    this.canvas.addEventListener('mouseout', function(e) {
        self.hasMouse = false;
        self.finmouseout(e);
    });
    this.canvas.addEventListener('click', function(e) {
        self.finclick(e);
    });
    this.canvas.addEventListener('contextmenu', function(e) {
        self.fincontextmenu(e);
        e.preventDefault();
        return false;
    });

    gestures.addEventListener(this.canvas, 'tap', function(e) {
        self.fintap(e);
    });
    gestures.addEventListener(this.canvas, 'holdpulse', function(e) {
        self.finholdpulse(e);
    });
    gestures.addEventListener(this.canvas, 'flick', function(e) {
        self.finflick(e);
    });
    gestures.addEventListener(this.canvas, 'release', function(e) {
        self.finrelease(e);
    });
    gestures.addEventListener(this.canvas, 'trackstart', function(e) {
        self.fintrackstart(e);
    });
    gestures.addEventListener(this.canvas, 'track', function(e) {
        self.fintrack(e);
    });
    gestures.addEventListener(this.canvas, 'trackend', function(e) {
        self.fintrackend(e);
    });

    this.canvas.setAttribute('tabindex', 0);
    this.canvas.contentEditable = true;

    this.resize();

    this.beginResizing();
    this.beginPainting();
}

Canvas.prototype = {
    constructor: Canvas.prototype.constructor,
    div: null,
    component: null,
    gestures: gestures, // TODO: why do we need this? (was previously at bottom of file)
    canvas: null,
    canvasCTX: null,
    focuser: null,
    buffer: null,
    ctx: null,
    mouseLocation: null,
    holdPulseCount: -1,
    dragstart: null,
    origin: null,
    bounds: null,
    dirty: false,
    size: null,
    mousedown: false,
    dragging: false,
    repeatKeyCount: 0,
    repeatKey: null,
    repeatKeyStartTime: 0,
    currentKeys: [],
    hasMouse: false,
    lastDoubleClickTime: 0,
    dragEndTime: 0,
    lastRepaintTime: 0,

    addEventListener: function(name, callback) {
        this.canvas.addEventListener(name, callback);
    },

    stopPaintLoop: function() {
        paintLoopRunning = false;
    },

    restartPaintLoop: function() {
        if (paintLoopRunning) {
            return; // already running
        }
        paintLoopRunning = true;
        requestAnimationFrame(paintLoopFunction);
    },

    stopResizeLoop: function() {
        resizeLoopRunning = false;
    },

    restartResizeLoop: function() {
        if (resizeLoopRunning) {
            return; // already running
        }
        resizeLoopRunning = true;
        setInterval(resizablesLoopFunction, 200);
    },

    detached: function() {
        this.stopPainting();
        this.stopResizing();
    },

    useHiDPI: function() {
        return this.component.resolveProperty('useHiDPI');
    },

    useBitBlit: function() {
        return this.component.resolveProperty('useBitBlit');
    },

    getFPS: function() {
        var fps = this.component.resolveProperty('repaintIntervalRate');
        return fps ? parseInt(fps) : 0;
    },

    tickPaint: function(now) {
        var fps = this.getFPS();
        if (fps === 0) {
            return;
        }
        var interval = 1000 / fps;

        var elapsed = now - this.lastRepaintTime;
        if (elapsed > interval && this.dirty) {
            this.lastRepaintTime = now - (elapsed % interval);
            this.paintNow();
        }
    },

    beginPainting: function() {
        var self = this;
        this.dirty = true;
        this.tickPainter = function(now) {
            self.tickPaint(now);
        };
        paintables.push(this);
    },

    stopPainting: function() {
        paintables.splice(paintables.indexOf(this), 1);
    },

    beginResizing: function() {
        var self = this;
        this.tickResizer = function() {
            self.checksize();
        };
        resizables.push(this);
    },

    stopResizing: function() {
        resizables.splice(resizables.indexOf(this), 1);
    },

    start: function() {
        this.beginPainting();
        this.beginResizing();
    },

    stop: function() {
        this.stopPainting();
        this.stopResizing();
    },

    checksize: function() {
        //this is expensive lets do it at some modulo
        var sizeNow = this.div.getBoundingClientRect();
        if (sizeNow.width !== this.size.width || sizeNow.height !== this.size.height) {
            this.sizeChangedNotification();
        }
    },

    sizeChangedNotification: function() {
        this.resize();
    },

    resize: function() {
        var box = this.size = this.div.getBoundingClientRect();

        this.canvas.width = this.buffer.width = box.width;
        this.canvas.height = this.buffer.height = box.height;

        //fix ala sir spinka, see
        //http://www.html5rocks.com/en/tutorials/canvas/hidpi/
        //just add 'hdpi' as an attribute to the fin-canvas tag
        var ratio = 1;
        var useBitBlit = this.useBitBlit();
        var isHIDPI = window.devicePixelRatio && this.useHiDPI();
        if (isHIDPI) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = this.canvasCTX.webkitBackingStorePixelRatio ||
                this.canvasCTX.mozBackingStorePixelRatio ||
                this.canvasCTX.msBackingStorePixelRatio ||
                this.canvasCTX.oBackingStorePixelRatio ||
                this.canvasCTX.backingStorePixelRatio || 1;

            ratio = devicePixelRatio / backingStoreRatio;
            //this.canvasCTX.scale(ratio, ratio);
        }
        var width = this.canvas.getAttribute('width');
        var height = this.canvas.getAttribute('height');
        this.canvas.width = this.buffer.width = width * ratio;
        this.canvas.height = this.buffer.height = height * ratio;

        this.canvas.style.width = this.buffer.style.width = width + 'px';
        this.canvas.style.height = this.buffer.style.height = height + 'px';

        this.bufferCTX.scale(ratio, ratio);
        if (isHIDPI && !useBitBlit) {
            this.canvasCTX.scale(ratio, ratio);
        }

        //this.origin = new rectangular.Point(Math.round(this.size.left), Math.round(this.size.top));
        this.bounds = new rectangular.Rectangle(0, 0, box.width, box.height);
        //setTimeout(function() {
        var comp = this.component;
        if (comp) {
            comp.setBounds(this.bounds);
        }
        this.resizeNotification();
        this.paintNow();
        //});
    },

    resizeNotification: function() {
        //to be overridden
    },

    getBounds: function() {
        return this.bounds;
    },

    paintNow: function() {
        var self = this;
        this.safePaintImmediately(function(gc) {
            gc.clearRect(0, 0, self.canvas.width, self.canvas.height);

            var comp = self.component;
            if (comp) {
                comp.paint(gc);
            }

            self.dirty = false;
        });
    },

    safePaintImmediately: function(paintFunction) {
        var useBitBlit = this.useBitBlit(),
            gc = useBitBlit ? this.bufferGC : this.gc;
        try {
            gc.save();
            paintFunction(gc);
        } catch (e) {
            console.error(e);
        } finally {
            gc.restore();
        }
        if (useBitBlit) {
            this.flushBuffer();
        }
    },

    flushBuffer: function() {
        if (this.buffer.width > 0 && this.buffer.height > 0) {
            this.canvasCTX.drawImage(this.buffer, 0, 0);
        }
    },

    dispatchNewEvent: function(event, name, detail) {
        detail = {
            detail: detail || {}
        };
        detail.detail.primitiveEvent = event;
        return this.canvas.dispatchEvent(new CustomEvent(name, detail));
    },

    dispatchNewMouseKeysEvent: function(event, name, detail) {
        detail = detail || {};
        detail.mouse = this.mouseLocation;
        detail.keys = this.currentKeys;
        return this.dispatchNewEvent(event, name, detail);
    },

    finmousemove: function(e) {
        if (!this.isDragging() && this.mousedown) {
            this.beDragging();
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragstart', {
                isRightClick: this.isRightClick(e)
            });
            this.dragstart = new rectangular.Point(this.mouseLocation.x, this.mouseLocation.y);
        }
        this.mouseLocation = this.getLocal(e);
        //console.log(this.mouseLocation);
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-drag', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
        }
        if (this.bounds.contains(this.mouseLocation)) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousemove');
        }
    },

    finmousedown: function(e) {
        this.mouseLocation = this.mouseDownLocation = this.getLocal(e);
        this.mousedown = true;

        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousedown', {
            isRightClick: this.isRightClick(e)
        });
        this.takeFocus();
    },

    finmouseup: function(e) {
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragend', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
            this.beNotDragging();
            this.dragEndtime = Date.now();
        }
        this.mousedown = false;
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseup', {
            isRightClick: this.isRightClick(e)
        });
        //this.mouseLocation = new rectangular.Point(-1, -1);
    },

    finmouseout: function(e) {
        if (!this.mousedown) {
            this.mouseLocation = new rectangular.Point(-1, -1);
        }
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseout');
    },

    finwheelmoved: function(e) {
        if (this.isDragging() || !this.hasFocus()) {
            return;
        }
        e.preventDefault();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-wheelmoved', {
            isRightClick: this.isRightClick(e)
        });
    },

    finclick: function(e) {
        if (this.doubleClickTimer && Date.now() - this.lastClickTime < this.doubleClickDelay) {
            //this is a double click...
            clearTimeout(this.doubleClickTimer); // prevent click event
            this.doubleClickTimer = undefined;
            this.findblclick(e);
        } else {
            this.lastClickTime = Date.now();

            this.doubleClickTimer = setTimeout(function() {
                this.doubleClickTimer = undefined;
                this.mouseLocation = this.getLocal(e);
                this.dispatchNewMouseKeysEvent(e, 'fin-canvas-click', {
                    isRightClick: this.isRightClick(e)
                });
            }.bind(this), this.doubleClickDelay);
        }
    },

    finrelease: function(e) {
        this.holdPulseCount = 0;
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-release');
    },

    finflick: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-flick', {
            isRightClick: this.isRightClick(e)
        });
    },

    fintrackstart: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-trackstart');
    },

    fintrack: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-track');
    },

    fintrackend: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-trackend');
    },

    finhold: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-hold', {
            isRightClick: this.isRightClick(e)
        });
    },

    finholdpulse: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-holdpulse', {
            count: this.holdPulseCount++
        });
    },

    fintap: function(e) {
        //this nonsense is to hold a tap if it's really a double click
        var self = this;
        var now = Date.now();
        var dif = now - this.lastDoubleClickTime;
        if (dif < 300) {
            return;
        }
        //dragend is also causing a tap
        //lets fix this here
        if (now - this.dragEndtime < 100) {
            return;
        }
        setTimeout(function() {
            self._fintap(e);
        }, 180);
    },

    _fintap: function(e) {
        //this nonsense is to hold a tap if it's really a double click
        var now = Date.now();
        var dif = now - this.lastDoubleClickTime;
        if (dif < 300) {
            return;
        }

        if (this.mouseDownLocation) { // maybe no mousedown on a phone?
            this.mouseLocation = this.mouseDownLocation; // mouse may have moved since mousedown
            this.mouseDownLocation = undefined; // consume it (maybe not needed; once a mousedown always a mousedown)
        }

        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-tap', {
            isRightClick: this.isRightClick(e)
        });
    },

    findblclick: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.lastDoubleClickTime = Date.now();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dblclick', {
            isRightClick: this.isRightClick(e)
        });
        //console.log('dblclick', this.currentKeys);
    },

    getCharMap: function() { //TODO: This is static. Make it a property of the constructor.
        return charMap;
    },

    finkeydown: function(e) {
        if (!this.hasFocus()) {
            return;
        }

        //e.preventDefault();
        var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
        if (e.repeat) {
            if (this.repeatKey === keyChar) {
                this.repeatKeyCount++;
            } else {
                this.repeatKey = keyChar;
                this.repeatKeyStartTime = Date.now();
            }
        } else {
            this.repeatKey = null;
            this.repeatKeyCount = 0;
            this.repeatKeyStartTime = 0;
        }
        if (this.currentKeys.indexOf(keyChar) === -1) {
            this.currentKeys.push(keyChar);
        }
        //console.log(keyChar, e.keyCode);
        this.dispatchNewEvent(e, 'fin-canvas-keydown', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeatCount: this.repeatKeyCount,
            repeatStartTime: this.repeatKeyStartTime,
            shift: e.shiftKey,
            identifier: e.keyIdentifier,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finkeyup: function(e) {
        var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
        this.currentKeys.splice(this.currentKeys.indexOf(keyChar), 1);
        if (!this.hasFocus()) {
            return;
        }
        this.repeatKeyCount = 0;
        this.repeatKey = null;
        this.repeatKeyStartTime = 0;
        this.dispatchNewEvent(e, 'fin-canvas-keyup', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeat: e.repeat,
            shift: e.shiftKey,
            identifier: e.keyIdentifier,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finfocusgained: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-gained');
    },

    finfocuslost: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-lost');
    },

    fincontextmenu: function(e) {
        if (e.ctrlKey && this.currentKeys.indexOf('CTRL') === -1) {
            this.currentKeys.push('CTRL');
        }
        if (this.doubleRightClickTimer && Date.now() - this.lastClickTime < this.doubleClickDelay) {
            //this is a double click...
            clearTimeout(this.doubleRightClickTimer); // prevent context menu event
            this.doubleRightClickTimer = undefined;
            this.findblclick(e);
        } else {
            this.lastClickTime = Date.now();

            this.doubleRightClickTimer = setTimeout(function() {
                this.doubleRightClickTimer = undefined;
                this.dispatchNewMouseKeysEvent(e, 'fin-canvas-context-menu', {
                    isRightClick: this.isRightClick(e)
                });
            }.bind(this), this.doubleClickDelay);
        }
    },

    repaint: function() {
        var fps = this.getFPS();
        this.dirty = true;
        if (!paintLoopRunning || fps === 0) {
            this.paintNow();
        }
    },

    getMouseLocation: function() {
        return this.mouseLocation;
    },

    getOrigin: function() {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(rect.left, rect.top);
        return p;
    },

    getLocal: function(e) {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(e.clientX - rect.left, e.clientY - rect.top);
        return p;
    },

    hasFocus: function() {
        return document.activeElement === this.canvas;
    },

    takeFocus: function() {
        var self = this;
        if (!this.hasFocus()) {
            setTimeout(function() {
                self.canvas.focus();
            }, 10);
        }
    },

    beDragging: function() {
        this.dragging = true;
        this.disableDocumentElementSelection();
    },

    beNotDragging: function() {
        this.dragging = false;
        this.enableDocumentElementSelection();
    },

    isDragging: function() {
        return this.dragging;
    },

    disableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText + '-webkit-user-select: none';
    },

    enableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText.replace('-webkit-user-select: none', '');
    },

    setFocusable: function(truthy) {
        this.focuser.style.display = truthy ? '' : 'none';
    },

    isRightClick: function(e) {
        var isRightMB;
        e = e || window.event;

        if ('which' in e) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
            isRightMB = e.which === 3;
        } else if ('button' in e) { // IE, Opera
            isRightMB = e.button === 2;
        }
        return isRightMB;
    },

    dispatchEvent: function(e) {
        return this.canvas.dispatchEvent(e);
    }
};

function paintLoopFunction(now) {
    if (!paintLoopRunning) {
        return;
    }
    for (var i = 0; i < paintables.length; i++) {
        try {
            paintables[i].tickPainter(now);
        } catch (e) {
            console.error(e);
        }
    }
    requestAnimationFrame(paintLoopFunction);
}
requestAnimationFrame(paintLoopFunction);

function resizablesLoopFunction(now) {
    if (!resizeLoopRunning) {
        return;
    }
    for (var i = 0; i < resizables.length; i++) {
        try {
            resizables[i].tickResizer(now);
        } catch (e) {
            console.error(e);
        }
    }
}
setInterval(resizablesLoopFunction, RESIZE_POLLING_INTERVAL);

function makeCharMap() {
    var map = [];

    var empty = ['', ''];

    for (var i = 0; i < 256; i++) {
        map[i] = empty;
    }

    map[27] = ['ESC', 'ESCSHIFT'];
    map[192] = ['`', '~'];
    map[49] = ['1', '!'];
    map[50] = ['2', '@'];
    map[51] = ['3', '#'];
    map[52] = ['4', '$'];
    map[53] = ['5', '%'];
    map[54] = ['6', '^'];
    map[55] = ['7', '&'];
    map[56] = ['8', '*'];
    map[57] = ['9', '('];
    map[48] = ['0', ')'];
    map[189] = ['-', '_'];
    map[187] = ['=', '+'];
    map[8] = ['BACKSPACE', 'BACKSPACESHIFT'];
    map[46] = ['DELETE', 'DELETESHIFT'];
    map[9] = ['TAB', 'TABSHIFT'];
    map[81] = ['q', 'Q'];
    map[87] = ['w', 'W'];
    map[69] = ['e', 'E'];
    map[82] = ['r', 'R'];
    map[84] = ['t', 'T'];
    map[89] = ['y', 'Y'];
    map[85] = ['u', 'U'];
    map[73] = ['i', 'I'];
    map[79] = ['o', 'O'];
    map[80] = ['p', 'P'];
    map[219] = ['[', '{'];
    map[221] = [']', '}'];
    map[220] = ['\\', '|'];
    map[220] = ['CAPSLOCK', 'CAPSLOCKSHIFT'];
    map[65] = ['a', 'A'];
    map[83] = ['s', 'S'];
    map[68] = ['d', 'D'];
    map[70] = ['f', 'F'];
    map[71] = ['g', 'G'];
    map[72] = ['h', 'H'];
    map[74] = ['j', 'J'];
    map[75] = ['k', 'K'];
    map[76] = ['l', 'L'];
    map[186] = [';', ':'];
    map[222] = ['\'', '|'];
    map[13] = ['RETURN', 'RETURNSHIFT'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[90] = ['z', 'Z'];
    map[88] = ['x', 'X'];
    map[67] = ['c', 'C'];
    map[86] = ['v', 'V'];
    map[66] = ['b', 'B'];
    map[78] = ['n', 'N'];
    map[77] = ['m', 'M'];
    map[188] = [',', '<'];
    map[190] = ['.', '>'];
    map[191] = ['/', '?'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[17] = ['CTRL', 'CTRLSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[91] = ['COMMANDLEFT', 'COMMANDLEFTSHIFT'];
    map[32] = ['SPACE', 'SPACESHIFT'];
    map[93] = ['COMMANDRIGHT', 'COMMANDRIGHTSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[38] = ['UP', 'UPSHIFT'];
    map[37] = ['LEFT', 'LEFTSHIFT'];
    map[40] = ['DOWN', 'DOWNSHIFT'];
    map[39] = ['RIGHT', 'RIGHTSHIFT'];

    map[33] = ['PAGEUP', 'PAGEUPSHIFT'];
    map[34] = ['PAGEDOWN', 'PAGEDOWNSHIFT'];
    map[35] = ['PAGERIGHT', 'PAGERIGHTSHIFT']; // END
    map[36] = ['PAGELEFT', 'PAGELEFTSHIFT']; // HOME

    map[112] = ['F1', 'F1SHIFT'];
    map[113] = ['F2', 'F2SHIFT'];
    map[114] = ['F3', 'F3SHIFT'];
    map[115] = ['F4', 'F4SHIFT'];
    map[116] = ['F5', 'F5SHIFT'];
    map[117] = ['F6', 'F6SHIFT'];
    map[118] = ['F7', 'F7SHIFT'];
    map[119] = ['F8', 'F8SHIFT'];
    map[120] = ['F9', 'F9SHIFT'];
    map[121] = ['F10', 'F10SHIFT'];
    map[122] = ['F11', 'F1S1HIFT'];
    map[123] = ['F12', 'F121HIFT'];

    return map;
}

module.exports = Canvas;

},{"./js/GraphicsContext.js":18,"./js/polymergestures.dev.js":20,"rectangular":26}],18:[function(require,module,exports){
'use strict';

var consoleLogger = require('./gc-console-logger');

/**
 * @constructor
 * @param gc - The 2-D graphics context from your canvas
 * @param {boolean|apiLogger} [logger=true]
 * * `true` uses `gc-console-logger` function bound to 'gc.' as prefix
 * * string uses `gc-console-logger` function bound to string
 * * function used as is
 */
function GraphicsContext(gc, logger) {
    this.gc = gc;

    var self = this;
    var reWEBKIT = /^webkit/;

    switch (typeof logger) {

        case 'string':
            logger =  consoleLogger.bind(undefined, logger + '.');
            break;

        case 'boolean':
            if (logger === true) {
                logger = consoleLogger.bind(undefined, 'gc.');
            }
            break;

        case 'function':
            if (logger.length !== 3) {
                throw 'GraphicsContext: User-supplied API logger function does not accept three parameters.';
            }
            break;

        default:
            logger = false;
    }

    // Stub out all the prototype members of the canvas 2D graphics context:
    Object.keys(Object.getPrototypeOf(gc)).forEach(MakeStub);

    // Some older browsers (e.g., Chrome 40) did not have all members of canvas
    // 2D graphics context in the prototype so we make this additional call:
    Object.keys(gc).forEach(MakeStub);

    function MakeStub(key) {
        if (key in GraphicsContext.prototype || reWEBKIT.test(key)) {
            return;
        }
        if (typeof gc[key] === 'function') {
            self[key] = !logger ? gc[key].bind(gc) : function() {
                return logger(key, arguments, gc[key].apply(gc, arguments));
            };
        } else {
            Object.defineProperty(self, key, {
                get: function() {
                    var result = gc[key];
                    return logger ? logger(key, 'getter', result) : result;
                },
                set: function(value) {
                    gc[key] = logger ? logger(key, 'setter', value) : value;
                }
            });
        }
    }
}

module.exports = GraphicsContext;

},{"./gc-console-logger":19}],19:[function(require,module,exports){
'use strict';

var YIELDS = '\u27F9'; // LONG RIGHTWARDS DOUBLE ARROW

function consoleLogger(prefix, name, args, value) {
    var result = value;

    if (typeof value === 'string') {
        result = '"' + result + '"';
    }

    name = prefix + name;

    switch (args) {
        case 'getter':
            console.log(name, '=', result);
            break;

        case 'setter':
            console.log(name, YIELDS, result);
            break;

        default: // method call
            name += '(' + Array.prototype.slice.call(args).join(', ') + ')';
            if (result === undefined) {
                console.log(name);
            } else {
                console.log(name, YIELDS, result);
            }
    }

    return value;
}

module.exports = consoleLogger;

},{}],20:[function(require,module,exports){
/* eslint-disable */

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
//module.exports = {};

(function(scope) {
    var hasFullPath = false;

    // test for full event path support
    var pathTest = document.createElement('meta');
    if (pathTest.createShadowRoot) {
        var sr = pathTest.createShadowRoot();
        var s = document.createElement('span');
        sr.appendChild(s);
        pathTest.addEventListener('testpath', function(ev) {
            if (ev.path) {
                // if the span is in the event path, then path[0] is the real source for all events
                hasFullPath = ev.path[0] === s;
            }
            ev.stopPropagation();
        });
        var ev = new CustomEvent('testpath', {
            bubbles: true
        });
        // must add node to DOM to trigger event listener
        document.head.appendChild(pathTest);
        s.dispatchEvent(ev);
        pathTest.parentNode.removeChild(pathTest);
        sr = s = null;
    }
    pathTest = null;

    var target = {
        shadow: function(inEl) {
            if (inEl) {
                return inEl.shadowRoot || inEl.webkitShadowRoot;
            }
        },
        canTarget: function(shadow) {
            return shadow && Boolean(shadow.elementFromPoint);
        },
        targetingShadow: function(inEl) {
            var s = this.shadow(inEl);
            if (this.canTarget(s)) {
                return s;
            }
        },
        olderShadow: function(shadow) {
            var os = shadow.olderShadowRoot;
            if (!os) {
                var se = shadow.querySelector('shadow');
                if (se) {
                    os = se.olderShadowRoot;
                }
            }
            return os;
        },
        allShadows: function(element) {
            var shadows = [],
                s = this.shadow(element);
            while (s) {
                shadows.push(s);
                s = this.olderShadow(s);
            }
            return shadows;
        },
        searchRoot: function(inRoot, x, y) {
            var t, st, sr, os;
            if (inRoot) {
                t = inRoot.elementFromPoint(x, y);
                if (t) {
                    // found element, check if it has a ShadowRoot
                    sr = this.targetingShadow(t);
                } else if (inRoot !== document) {
                    // check for sibling roots
                    sr = this.olderShadow(inRoot);
                }
                // search other roots, fall back to light dom element
                return this.searchRoot(sr, x, y) || t;
            }
        },
        owner: function(element) {
            if (!element) {
                return document;
            }
            var s = element;
            // walk up until you hit the shadow root or document
            while (s.parentNode) {
                s = s.parentNode;
            }
            // the owner element is expected to be a Document or ShadowRoot
            if (s.nodeType != Node.DOCUMENT_NODE && s.nodeType != Node.DOCUMENT_FRAGMENT_NODE) {
                s = document;
            }
            return s;
        },
        findTarget: function(inEvent) {
            if (hasFullPath && inEvent.path && inEvent.path.length) {
                return inEvent.path[0];
            }
            var x = inEvent.clientX,
                y = inEvent.clientY;
            // if the listener is in the shadow root, it is much faster to start there
            var s = this.owner(inEvent.target);
            // if x, y is not in this root, fall back to document search
            if (!s.elementFromPoint(x, y)) {
                s = document;
            }
            return this.searchRoot(s, x, y);
        },
        findTouchAction: function(inEvent) {
            var n;
            if (hasFullPath && inEvent.path && inEvent.path.length) {
                var path = inEvent.path;
                for (var i = 0; i < path.length; i++) {
                    n = path[i];
                    if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
                        return n.getAttribute('touch-action');
                    }
                }
            } else {
                n = inEvent.target;
                while (n) {
                    if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
                        return n.getAttribute('touch-action');
                    }
                    n = n.parentNode || n.host;
                }
            }
            // auto is default
            return "auto";
        },
        LCA: function(a, b) {
            if (a === b) {
                return a;
            }
            if (a && !b) {
                return a;
            }
            if (b && !a) {
                return b;
            }
            if (!b && !a) {
                return document;
            }
            // fast case, a is a direct descendant of b or vice versa
            if (a.contains && a.contains(b)) {
                return a;
            }
            if (b.contains && b.contains(a)) {
                return b;
            }
            var adepth = this.depth(a);
            var bdepth = this.depth(b);
            var d = adepth - bdepth;
            if (d >= 0) {
                a = this.walk(a, d);
            } else {
                b = this.walk(b, -d);
            }
            while (a && b && a !== b) {
                a = a.parentNode || a.host;
                b = b.parentNode || b.host;
            }
            return a;
        },
        walk: function(n, u) {
            for (var i = 0; n && (i < u); i++) {
                n = n.parentNode || n.host;
            }
            return n;
        },
        depth: function(n) {
            var d = 0;
            while (n) {
                d++;
                n = n.parentNode || n.host;
            }
            return d;
        },
        deepContains: function(a, b) {
            var common = this.LCA(a, b);
            // if a is the common ancestor, it must "deeply" contain b
            return common === a;
        },
        insideNode: function(node, x, y) {
            var rect = node.getBoundingClientRect();
            return (rect.left <= x) && (x <= rect.right) && (rect.top <= y) && (y <= rect.bottom);
        },
        path: function(event) {
            var p;
            if (hasFullPath && event.path && event.path.length) {
                p = event.path;
            } else {
                p = [];
                var n = this.findTarget(event);
                while (n) {
                    p.push(n);
                    n = n.parentNode || n.host;
                }
            }
            return p;
        }
    };
    scope.targetFinding = target;
    /**
     * Given an event, finds the "deepest" node that could have been the original target before ShadowDOM retargetting
     *
     * @param {Event} Event An event object with clientX and clientY properties
     * @return {Element} The probable event origninator
     */
    scope.findTarget = target.findTarget.bind(target);
    /**
     * Determines if the "container" node deeply contains the "containee" node, including situations where the "containee" is contained by one or more ShadowDOM
     * roots.
     *
     * @param {Node} container
     * @param {Node} containee
     * @return {Boolean}
     */
    scope.deepContains = target.deepContains.bind(target);

    /**
     * Determines if the x/y position is inside the given node.
     *
     * Example:
     *
     *     function upHandler(event) {
     *       var innode = PolymerGestures.insideNode(event.target, event.clientX, event.clientY);
     *       if (innode) {
     *         // wait for tap?
     *       } else {
     *         // tap will never happen
     *       }
     *     }
     *
     * @param {Node} node
     * @param {Number} x Screen X position
     * @param {Number} y screen Y position
     * @return {Boolean}
     */
    scope.insideNode = target.insideNode;

})(exports);

(function() {
    function shadowSelector(v) {
        return 'html /deep/ ' + selector(v);
    }

    function selector(v) {
        return '[touch-action="' + v + '"]';
    }

    function rule(v) {
        return '{ -ms-touch-action: ' + v + '; touch-action: ' + v + ';}';
    }
    var attrib2css = [
        'none',
        'auto',
        'pan-x',
        'pan-y', {
            rule: 'pan-x pan-y',
            selectors: [
                'pan-x pan-y',
                'pan-y pan-x'
            ]
        },
        'manipulation'
    ];
    var styles = '';
    // only install stylesheet if the browser has touch action support
    var hasTouchAction = typeof document.head.style.touchAction === 'string';
    // only add shadow selectors if shadowdom is supported
    var hasShadowRoot = !window.ShadowDOMPolyfill && document.head.createShadowRoot;

    if (hasTouchAction) {
        attrib2css.forEach(function(r) {
            if (String(r) === r) {
                styles += selector(r) + rule(r) + '\n';
                if (hasShadowRoot) {
                    styles += shadowSelector(r) + rule(r) + '\n';
                }
            } else {
                styles += r.selectors.map(selector) + rule(r.rule) + '\n';
                if (hasShadowRoot) {
                    styles += r.selectors.map(shadowSelector) + rule(r.rule) + '\n';
                }
            }
        });

        var el = document.createElement('style');
        el.textContent = styles;
        document.head.appendChild(el);
    }
})();

/**
 * This is the constructor for new PointerEvents.
 *
 * New Pointer Events must be given a type, and an optional dictionary of
 * initialization properties.
 *
 * Due to certain platform requirements, events returned from the constructor
 * identify as MouseEvents.
 *
 * @constructor
 * @param {String} inType The type of the event to create.
 * @param {Object} [inDict] An optional dictionary of initial event properties.
 * @return {Event} A new PointerEvent of type `inType` and initialized with properties from `inDict`.
 */
(function(scope) {

    var MOUSE_PROPS = [
        'bubbles',
        'cancelable',
        'view',
        'detail',
        'screenX',
        'screenY',
        'clientX',
        'clientY',
        'ctrlKey',
        'altKey',
        'shiftKey',
        'metaKey',
        'button',
        'relatedTarget',
        'pageX',
        'pageY'
    ];

    var MOUSE_DEFAULTS = [
        false,
        false,
        null,
        null,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null,
        0,
        0
    ];

    var NOP_FACTORY = function() {
        return function() {};
    };

    var eventFactory = {
        // TODO(dfreedm): this is overridden by tap recognizer, needs review
        preventTap: NOP_FACTORY,
        makeBaseEvent: function(inType, inDict) {
            var e = document.createEvent('Event');
            e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);
            e.preventTap = eventFactory.preventTap(e);
            return e;
        },
        makeGestureEvent: function(inType, inDict) {
            inDict = inDict || Object.create(null);

            var e = this.makeBaseEvent(inType, inDict);
            for (var i = 0, keys = Object.keys(inDict), k; i < keys.length; i++) {
                k = keys[i];
                if (k !== 'bubbles' && k !== 'cancelable') {
                    e[k] = inDict[k];
                }
            }
            return e;
        },
        makePointerEvent: function(inType, inDict) {
            inDict = inDict || Object.create(null);

            var e = this.makeBaseEvent(inType, inDict);
            // define inherited MouseEvent properties
            for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
                p = MOUSE_PROPS[i];
                e[p] = inDict[p] || MOUSE_DEFAULTS[i];
            }
            e.buttons = inDict.buttons || 0;

            // Spec requires that pointers without pressure specified use 0.5 for down
            // state and 0 for up state.
            var pressure = 0;
            if (inDict.pressure) {
                pressure = inDict.pressure;
            } else {
                pressure = e.buttons ? 0.5 : 0;
            }

            // add x/y properties aliased to clientX/Y
            e.x = e.clientX;
            e.y = e.clientY;

            // define the properties of the PointerEvent interface
            e.pointerId = inDict.pointerId || 0;
            e.width = inDict.width || 0;
            e.height = inDict.height || 0;
            e.pressure = pressure;
            e.tiltX = inDict.tiltX || 0;
            e.tiltY = inDict.tiltY || 0;
            e.pointerType = inDict.pointerType || '';
            e.hwTimestamp = inDict.hwTimestamp || 0;
            e.isPrimary = inDict.isPrimary || false;
            e._source = inDict._source || '';
            return e;
        }
    };

    scope.eventFactory = eventFactory;
})(exports);

/**
 * This module implements an map of pointer states
 */
(function(scope) {
    var USE_MAP = window.Map && window.Map.prototype.forEach;
    var POINTERS_FN = function() {
        return this.size;
    };

    function PointerMap() {
        if (USE_MAP) {
            var m = new Map();
            m.pointers = POINTERS_FN;
            return m;
        } else {
            this.keys = [];
            this.values = [];
        }
    }

    PointerMap.prototype = {
        set: function(inId, inEvent) {
            var i = this.keys.indexOf(inId);
            if (i > -1) {
                this.values[i] = inEvent;
            } else {
                this.keys.push(inId);
                this.values.push(inEvent);
            }
        },
        has: function(inId) {
            return this.keys.indexOf(inId) > -1;
        },
        'delete': function(inId) {
            var i = this.keys.indexOf(inId);
            if (i > -1) {
                this.keys.splice(i, 1);
                this.values.splice(i, 1);
            }
        },
        get: function(inId) {
            var i = this.keys.indexOf(inId);
            return this.values[i];
        },
        clear: function() {
            this.keys.length = 0;
            this.values.length = 0;
        },
        // return value, key, map
        forEach: function(callback, thisArg) {
            this.values.forEach(function(v, i) {
                callback.call(thisArg, v, this.keys[i], this);
            }, this);
        },
        pointers: function() {
            return this.keys.length;
        }
    };

    scope.PointerMap = PointerMap;
})(exports);

(function(scope) {
    var CLONE_PROPS = [
        // MouseEvent
        'bubbles',
        'cancelable',
        'view',
        'detail',
        'screenX',
        'screenY',
        'clientX',
        'clientY',
        'ctrlKey',
        'altKey',
        'shiftKey',
        'metaKey',
        'button',
        'relatedTarget',
        // DOM Level 3
        'buttons',
        // PointerEvent
        'pointerId',
        'width',
        'height',
        'pressure',
        'tiltX',
        'tiltY',
        'pointerType',
        'hwTimestamp',
        'isPrimary',
        // event instance
        'type',
        'target',
        'currentTarget',
        'which',
        'pageX',
        'pageY',
        'timeStamp',
        // gesture addons
        'preventTap',
        'tapPrevented',
        '_source'
    ];

    var CLONE_DEFAULTS = [
        // MouseEvent
        false,
        false,
        null,
        null,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null,
        // DOM Level 3
        0,
        // PointerEvent
        0,
        0,
        0,
        0,
        0,
        0,
        '',
        0,
        false,
        // event instance
        '',
        null,
        null,
        0,
        0,
        0,
        0,
        function() {},
        false
    ];

    var HAS_SVG_INSTANCE = (typeof SVGElementInstance !== 'undefined');

    var eventFactory = scope.eventFactory;

    // set of recognizers to run for the currently handled event
    var currentGestures;

    /**
     * This module is for normalizing events. Mouse and Touch events will be
     * collected here, and fire PointerEvents that have the same semantics, no
     * matter the source.
     * Events fired:
     *   - pointerdown: a pointing is added
     *   - pointerup: a pointer is removed
     *   - pointermove: a pointer is moved
     *   - pointerover: a pointer crosses into an element
     *   - pointerout: a pointer leaves an element
     *   - pointercancel: a pointer will no longer generate events
     */
    var dispatcher = {
        IS_IOS: false,
        pointermap: new scope.PointerMap(),
        requiredGestures: new scope.PointerMap(),
        eventMap: Object.create(null),
        // Scope objects for native events.
        // This exists for ease of testing.
        eventSources: Object.create(null),
        eventSourceList: [],
        gestures: [],
        // map gesture event -> {listeners: int, index: gestures[int]}
        dependencyMap: {
            // make sure down and up are in the map to trigger "register"
            down: {
                listeners: 0,
                index: -1
            },
            up: {
                listeners: 0,
                index: -1
            }
        },
        gestureQueue: [],
        /**
         * Add a new event source that will generate pointer events.
         *
         * `inSource` must contain an array of event names named `events`, and
         * functions with the names specified in the `events` array.
         * @param {string} name A name for the event source
         * @param {Object} source A new source of platform events.
         */
        registerSource: function(name, source) {
            var s = source;
            var newEvents = s.events;
            if (newEvents) {
                newEvents.forEach(function(e) {
                    if (s[e]) {
                        this.eventMap[e] = s[e].bind(s);
                    }
                }, this);
                this.eventSources[name] = s;
                this.eventSourceList.push(s);
            }
        },
        registerGesture: function(name, source) {
            var obj = Object.create(null);
            obj.listeners = 0;
            obj.index = this.gestures.length;
            for (var i = 0, g; i < source.exposes.length; i++) {
                g = source.exposes[i].toLowerCase();
                this.dependencyMap[g] = obj;
            }
            this.gestures.push(source);
        },
        register: function(element, initial) {
            var l = this.eventSourceList.length;
            for (var i = 0, es;
                (i < l) && (es = this.eventSourceList[i]); i++) {
                // call eventsource register
                es.register.call(es, element, initial);
            }
        },
        unregister: function(element) {
            var l = this.eventSourceList.length;
            for (var i = 0, es;
                (i < l) && (es = this.eventSourceList[i]); i++) {
                // call eventsource register
                es.unregister.call(es, element);
            }
        },
        // EVENTS
        down: function(inEvent) {
            this.requiredGestures.set(inEvent.pointerId, currentGestures);
            this.fireEvent('down', inEvent);
        },
        move: function(inEvent) {
            // pipe move events into gesture queue directly
            inEvent.type = 'move';
            this.fillGestureQueue(inEvent);
        },
        up: function(inEvent) {
            this.fireEvent('up', inEvent);
            this.requiredGestures.delete(inEvent.pointerId);
        },
        cancel: function(inEvent) {
            inEvent.tapPrevented = true;
            this.fireEvent('up', inEvent);
            this.requiredGestures.delete(inEvent.pointerId);
        },
        addGestureDependency: function(node, currentGestures) {
            var gesturesWanted = node._pgEvents;
            if (gesturesWanted && currentGestures) {
                var gk = Object.keys(gesturesWanted);
                for (var i = 0, r, ri, g; i < gk.length; i++) {
                    // gesture
                    g = gk[i];
                    if (gesturesWanted[g] > 0) {
                        // lookup gesture recognizer
                        r = this.dependencyMap[g];
                        // recognizer index
                        ri = r ? r.index : -1;
                        currentGestures[ri] = true;
                    }
                }
            }
        },
        // LISTENER LOGIC
        eventHandler: function(inEvent) {
            // This is used to prevent multiple dispatch of events from
            // platform events. This can happen when two elements in different scopes
            // are set up to create pointer events, which is relevant to Shadow DOM.

            var type = inEvent.type;

            // only generate the list of desired events on "down"
            if (type === 'touchstart' || type === 'mousedown' || type === 'pointerdown' || type === 'MSPointerDown') {
                if (!inEvent._handledByPG) {
                    currentGestures = {};
                }

                // in IOS mode, there is only a listener on the document, so this is not re-entrant
                if (this.IS_IOS) {
                    var ev = inEvent;
                    if (type === 'touchstart') {
                        var ct = inEvent.changedTouches[0];
                        // set up a fake event to give to the path builder
                        ev = {
                            target: inEvent.target,
                            clientX: ct.clientX,
                            clientY: ct.clientY,
                            path: inEvent.path
                        };
                    }
                    // use event path if available, otherwise build a path from target finding
                    var nodes = inEvent.path || scope.targetFinding.path(ev);
                    for (var i = 0, n; i < nodes.length; i++) {
                        n = nodes[i];
                        this.addGestureDependency(n, currentGestures);
                    }
                } else {
                    this.addGestureDependency(inEvent.currentTarget, currentGestures);
                }
            }

            if (inEvent._handledByPG) {
                return;
            }
            var fn = this.eventMap && this.eventMap[type];
            if (fn) {
                fn(inEvent);
            }
            inEvent._handledByPG = true;
        },
        // set up event listeners
        listen: function(target, events) {
            for (var i = 0, l = events.length, e;
                (i < l) && (e = events[i]); i++) {
                this.addEvent(target, e);
            }
        },
        // remove event listeners
        unlisten: function(target, events) {
            for (var i = 0, l = events.length, e;
                (i < l) && (e = events[i]); i++) {
                this.removeEvent(target, e);
            }
        },
        addEvent: function(target, eventName) {
            target.addEventListener(eventName, this.boundHandler);
        },
        removeEvent: function(target, eventName) {
            target.removeEventListener(eventName, this.boundHandler);
        },
        // EVENT CREATION AND TRACKING
        /**
         * Creates a new Event of type `inType`, based on the information in
         * `inEvent`.
         *
         * @param {string} inType A string representing the type of event to create
         * @param {Event} inEvent A platform event with a target
         * @return {Event} A PointerEvent of type `inType`
         */
        makeEvent: function(inType, inEvent) {
            var e = eventFactory.makePointerEvent(inType, inEvent);
            e.preventDefault = inEvent.preventDefault;
            e.tapPrevented = inEvent.tapPrevented;
            e._target = e._target || inEvent.target;
            return e;
        },
        // make and dispatch an event in one call
        fireEvent: function(inType, inEvent) {
            var e = this.makeEvent(inType, inEvent);
            return this.dispatchEvent(e);
        },
        /**
         * Returns a snapshot of inEvent, with writable properties.
         *
         * @param {Event} inEvent An event that contains properties to copy.
         * @return {Object} An object containing shallow copies of `inEvent`'s
         *    properties.
         */
        cloneEvent: function(inEvent) {
            var eventCopy = Object.create(null),
                p;
            for (var i = 0; i < CLONE_PROPS.length; i++) {
                p = CLONE_PROPS[i];
                eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];
                // Work around SVGInstanceElement shadow tree
                // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
                // This is the behavior implemented by Firefox.
                if (p === 'target' || p === 'relatedTarget') {
                    if (HAS_SVG_INSTANCE && eventCopy[p] instanceof SVGElementInstance) {
                        eventCopy[p] = eventCopy[p].correspondingUseElement;
                    }
                }
            }
            // keep the semantics of preventDefault
            eventCopy.preventDefault = function() {
                inEvent.preventDefault();
            };
            return eventCopy;
        },
        /**
         * Dispatches the event to its target.
         *
         * @param {Event} inEvent The event to be dispatched.
         * @return {Boolean} True if an event handler returns true, false otherwise.
         */
        dispatchEvent: function(inEvent) {
            var t = inEvent._target;
            if (t) {
                t.dispatchEvent(inEvent);
                // clone the event for the gesture system to process
                // clone after dispatch to pick up gesture prevention code
                var clone = this.cloneEvent(inEvent);
                clone.target = t;
                this.fillGestureQueue(clone);
            }
        },
        gestureTrigger: function() {
            // process the gesture queue
            for (var i = 0, e, rg; i < this.gestureQueue.length; i++) {
                e = this.gestureQueue[i];
                rg = e._requiredGestures;
                if (rg) {
                    for (var j = 0, g, fn; j < this.gestures.length; j++) {
                        // only run recognizer if an element in the source event's path is listening for those gestures
                        if (rg[j]) {
                            g = this.gestures[j];
                            fn = g[e.type];
                            if (fn) {
                                fn.call(g, e);
                            }
                        }
                    }
                }
            }
            this.gestureQueue.length = 0;
        },
        fillGestureQueue: function(ev) {
            // only trigger the gesture queue once
            if (!this.gestureQueue.length) {
                requestAnimationFrame(this.boundGestureTrigger);
            }
            ev._requiredGestures = this.requiredGestures.get(ev.pointerId);
            this.gestureQueue.push(ev);
        }
    };
    dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);
    dispatcher.boundGestureTrigger = dispatcher.gestureTrigger.bind(dispatcher);
    scope.dispatcher = dispatcher;

    /**
     * Listen for `gesture` on `node` with the `handler` function
     *
     * If `handler` is the first listener for `gesture`, the underlying gesture recognizer is then enabled.
     *
     * @param {Element} node
     * @param {string} gesture
     * @return Boolean `gesture` is a valid gesture
     */
    scope.activateGesture = function(node, gesture) {
        var g = gesture.toLowerCase();
        var dep = dispatcher.dependencyMap[g];
        if (dep) {
            var recognizer = dispatcher.gestures[dep.index];
            if (!node._pgListeners) {
                dispatcher.register(node);
                node._pgListeners = 0;
            }
            // TODO(dfreedm): re-evaluate bookkeeping to avoid using attributes
            if (recognizer) {
                var touchAction = recognizer.defaultActions && recognizer.defaultActions[g];
                var actionNode;
                switch (node.nodeType) {
                    case Node.ELEMENT_NODE:
                        actionNode = node;
                        break;
                    case Node.DOCUMENT_FRAGMENT_NODE:
                        actionNode = node.host;
                        break;
                    default:
                        actionNode = null;
                        break;
                }
                if (touchAction && actionNode && !actionNode.hasAttribute('touch-action')) {
                    actionNode.setAttribute('touch-action', touchAction);
                }
            }
            if (!node._pgEvents) {
                node._pgEvents = {};
            }
            node._pgEvents[g] = (node._pgEvents[g] || 0) + 1;
            node._pgListeners++;
        }
        return Boolean(dep);
    };

    /**
     *
     * Listen for `gesture` from `node` with `handler` function.
     *
     * @param {Element} node
     * @param {string} gesture
     * @param {Function} handler
     * @param {Boolean} capture
     */
    scope.addEventListener = function(node, gesture, handler, capture) {
        if (handler) {
            scope.activateGesture(node, gesture);
            node.addEventListener(gesture, handler, capture);
        }
    };

    /**
     * Tears down the gesture configuration for `node`
     *
     * If `handler` is the last listener for `gesture`, the underlying gesture recognizer is disabled.
     *
     * @param {Element} node
     * @param {string} gesture
     * @return Boolean `gesture` is a valid gesture
     */
    scope.deactivateGesture = function(node, gesture) {
        var g = gesture.toLowerCase();
        var dep = dispatcher.dependencyMap[g];
        if (dep) {
            if (node._pgListeners > 0) {
                node._pgListeners--;
            }
            if (node._pgListeners === 0) {
                dispatcher.unregister(node);
            }
            if (node._pgEvents) {
                if (node._pgEvents[g] > 0) {
                    node._pgEvents[g]--;
                } else {
                    node._pgEvents[g] = 0;
                }
            }
        }
        return Boolean(dep);
    };

    /**
     * Stop listening for `gesture` from `node` with `handler` function.
     *
     * @param {Element} node
     * @param {string} gesture
     * @param {Function} handler
     * @param {Boolean} capture
     */
    scope.removeEventListener = function(node, gesture, handler, capture) {
        if (handler) {
            scope.deactivateGesture(node, gesture);
            node.removeEventListener(gesture, handler, capture);
        }
    };
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    // radius around touchend that swallows mouse events
    var DEDUP_DIST = 25;

    var WHICH_TO_BUTTONS = [0, 1, 4, 2];

    var currentButtons = 0;

    var FIREFOX_LINUX = /Linux.*Firefox\//i;

    var HAS_BUTTONS = (function() {
        // firefox on linux returns spec-incorrect values for mouseup.buttons
        // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.buttons#See_also
        // https://codereview.chromium.org/727593003/#msg16
        if (FIREFOX_LINUX.test(navigator.userAgent)) {
            return false;
        }
        try {
            return new MouseEvent('test', {
                buttons: 1
            }).buttons === 1;
        } catch (e) {
            return false;
        }
    })();

    // handler block for native mouse events
    var mouseEvents = {
        POINTER_ID: 1,
        POINTER_TYPE: 'mouse',
        events: [
            'mousedown',
            'mousemove',
            'mouseup'
        ],
        exposes: [
            'down',
            'up',
            'move'
        ],
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        lastTouches: [],
        // collide with the global mouse listener
        isEventSimulatedFromTouch: function(inEvent) {
            var lts = this.lastTouches;
            var x = inEvent.clientX,
                y = inEvent.clientY;
            for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
                // simulated mouse events will be swallowed near a primary touchend
                var dx = Math.abs(x - t.x),
                    dy = Math.abs(y - t.y);
                if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
                    return true;
                }
            }
        },
        prepareEvent: function(inEvent) {
            var e = dispatcher.cloneEvent(inEvent);
            e.pointerId = this.POINTER_ID;
            e.isPrimary = true;
            e.pointerType = this.POINTER_TYPE;
            e._source = 'mouse';
            if (!HAS_BUTTONS) {
                var type = inEvent.type;
                var bit = WHICH_TO_BUTTONS[inEvent.which] || 0;
                if (type === 'mousedown') {
                    currentButtons |= bit;
                } else if (type === 'mouseup') {
                    currentButtons &= ~bit;
                }
                e.buttons = currentButtons;
            }
            return e;
        },
        mousedown: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var p = pointermap.has(this.POINTER_ID);
                var e = this.prepareEvent(inEvent);
                e.target = scope.findTarget(inEvent);
                pointermap.set(this.POINTER_ID, e.target);
                dispatcher.down(e);
            }
        },
        mousemove: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var target = pointermap.get(this.POINTER_ID);
                if (target) {
                    var e = this.prepareEvent(inEvent);
                    e.target = target;
                    // handle case where we missed a mouseup
                    if ((HAS_BUTTONS ? e.buttons : e.which) === 0) {
                        if (!HAS_BUTTONS) {
                            currentButtons = e.buttons = 0;
                        }
                        dispatcher.cancel(e);
                        this.cleanupMouse(e.buttons);
                    } else {
                        dispatcher.move(e);
                    }
                }
            }
        },
        mouseup: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var e = this.prepareEvent(inEvent);
                e.relatedTarget = scope.findTarget(inEvent);
                e.target = pointermap.get(this.POINTER_ID);
                dispatcher.up(e);
                this.cleanupMouse(e.buttons);
            }
        },
        cleanupMouse: function(buttons) {
            if (buttons === 0) {
                pointermap.delete(this.POINTER_ID);
            }
        }
    };

    scope.mouseEvents = mouseEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var allShadows = scope.targetFinding.allShadows.bind(scope.targetFinding);
    var pointermap = dispatcher.pointermap;
    var touchMap = Array.prototype.map.call.bind(Array.prototype.map);
    // This should be long enough to ignore compat mouse events made by touch
    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DIST = 25;
    var CLICK_COUNT_TIMEOUT = 200;
    var HYSTERESIS = 20;
    var ATTRIB = 'touch-action';
    // TODO(dfreedm): disable until http://crbug.com/399765 is resolved
    // var HAS_TOUCH_ACTION = ATTRIB in document.head.style;
    var HAS_TOUCH_ACTION = false;

    // handler block for native touch events
    var touchEvents = {
        IS_IOS: false,
        events: [
            'touchstart',
            'touchmove',
            'touchend',
            'touchcancel'
        ],
        exposes: [
            'down',
            'up',
            'move'
        ],
        register: function(target, initial) {
            if (this.IS_IOS ? initial : !initial) {
                dispatcher.listen(target, this.events);
            }
        },
        unregister: function(target) {
            if (!this.IS_IOS) {
                dispatcher.unlisten(target, this.events);
            }
        },
        scrollTypes: {
            EMITTER: 'none',
            XSCROLLER: 'pan-x',
            YSCROLLER: 'pan-y',
        },
        touchActionToScrollType: function(touchAction) {
            var t = touchAction;
            var st = this.scrollTypes;
            if (t === st.EMITTER) {
                return 'none';
            } else if (t === st.XSCROLLER) {
                return 'X';
            } else if (t === st.YSCROLLER) {
                return 'Y';
            } else {
                return 'XY';
            }
        },
        POINTER_TYPE: 'touch',
        firstTouch: null,
        isPrimaryTouch: function(inTouch) {
            return this.firstTouch === inTouch.identifier;
        },
        setPrimaryTouch: function(inTouch) {
            // set primary touch if there no pointers, or the only pointer is the mouse
            if (pointermap.pointers() === 0 || (pointermap.pointers() === 1 && pointermap.has(1))) {
                this.firstTouch = inTouch.identifier;
                this.firstXY = {
                    X: inTouch.clientX,
                    Y: inTouch.clientY
                };
                this.firstTarget = inTouch.target;
                this.scrolling = null;
                this.cancelResetClickCount();
            }
        },
        removePrimaryPointer: function(inPointer) {
            if (inPointer.isPrimary) {
                this.firstTouch = null;
                this.firstXY = null;
                this.resetClickCount();
            }
        },
        clickCount: 0,
        resetId: null,
        resetClickCount: function() {
            var fn = function() {
                this.clickCount = 0;
                this.resetId = null;
            }.bind(this);
            this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
        },
        cancelResetClickCount: function() {
            if (this.resetId) {
                clearTimeout(this.resetId);
            }
        },
        typeToButtons: function(type) {
            var ret = 0;
            if (type === 'touchstart' || type === 'touchmove') {
                ret = 1;
            }
            return ret;
        },
        findTarget: function(touch, id) {
            if (this.currentTouchEvent.type === 'touchstart') {
                if (this.isPrimaryTouch(touch)) {
                    var fastPath = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        path: this.currentTouchEvent.path,
                        target: this.currentTouchEvent.target
                    };
                    return scope.findTarget(fastPath);
                } else {
                    return scope.findTarget(touch);
                }
            }
            // reuse target we found in touchstart
            return pointermap.get(id);
        },
        touchToPointer: function(inTouch) {
            var cte = this.currentTouchEvent;
            var e = dispatcher.cloneEvent(inTouch);
            // Spec specifies that pointerId 1 is reserved for Mouse.
            // Touch identifiers can start at 0.
            // Add 2 to the touch identifier for compatibility.
            var id = e.pointerId = inTouch.identifier + 2;
            e.target = this.findTarget(inTouch, id);
            e.bubbles = true;
            e.cancelable = true;
            e.detail = this.clickCount;
            e.buttons = this.typeToButtons(cte.type);
            e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
            e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
            e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
            e.isPrimary = this.isPrimaryTouch(inTouch);
            e.pointerType = this.POINTER_TYPE;
            e._source = 'touch';
            // forward touch preventDefaults
            var self = this;
            e.preventDefault = function() {
                self.scrolling = false;
                self.firstXY = null;
                cte.preventDefault();
            };
            return e;
        },
        processTouches: function(inEvent, inFunction) {
            var tl = inEvent.changedTouches;
            this.currentTouchEvent = inEvent;
            for (var i = 0, t, p; i < tl.length; i++) {
                t = tl[i];
                p = this.touchToPointer(t);
                if (inEvent.type === 'touchstart') {
                    pointermap.set(p.pointerId, p.target);
                }
                if (pointermap.has(p.pointerId)) {
                    inFunction.call(this, p);
                }
                if (inEvent.type === 'touchend' || inEvent._cancel) {
                    this.cleanUpPointer(p);
                }
            }
        },
        // For single axis scrollers, determines whether the element should emit
        // pointer events or behave as a scroller
        shouldScroll: function(inEvent) {
            if (this.firstXY) {
                var ret;
                var touchAction = scope.targetFinding.findTouchAction(inEvent);
                var scrollAxis = this.touchActionToScrollType(touchAction);
                if (scrollAxis === 'none') {
                    // this element is a touch-action: none, should never scroll
                    ret = false;
                } else if (scrollAxis === 'XY') {
                    // this element should always scroll
                    ret = true;
                } else {
                    var t = inEvent.changedTouches[0];
                    // check the intended scroll axis, and other axis
                    var a = scrollAxis;
                    var oa = scrollAxis === 'Y' ? 'X' : 'Y';
                    var da = Math.abs(t['client' + a] - this.firstXY[a]);
                    var doa = Math.abs(t['client' + oa] - this.firstXY[oa]);
                    // if delta in the scroll axis > delta other axis, scroll instead of
                    // making events
                    ret = da >= doa;
                }
                return ret;
            }
        },
        findTouch: function(inTL, inId) {
            for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
                if (t.identifier === inId) {
                    return true;
                }
            }
        },
        // In some instances, a touchstart can happen without a touchend. This
        // leaves the pointermap in a broken state.
        // Therefore, on every touchstart, we remove the touches that did not fire a
        // touchend event.
        // To keep state globally consistent, we fire a
        // pointercancel for this "abandoned" touch
        vacuumTouches: function(inEvent) {
            var tl = inEvent.touches;
            // pointermap.pointers() should be < tl.length here, as the touchstart has not
            // been processed yet.
            if (pointermap.pointers() >= tl.length) {
                var d = [];
                pointermap.forEach(function(value, key) {
                    // Never remove pointerId == 1, which is mouse.
                    // Touch identifiers are 2 smaller than their pointerId, which is the
                    // index in pointermap.
                    if (key !== 1 && !this.findTouch(tl, key - 2)) {
                        var p = value;
                        d.push(p);
                    }
                }, this);
                d.forEach(function(p) {
                    this.cancel(p);
                    pointermap.delete(p.pointerId);
                }, this);
            }
        },
        touchstart: function(inEvent) {
            this.vacuumTouches(inEvent);
            this.setPrimaryTouch(inEvent.changedTouches[0]);
            this.dedupSynthMouse(inEvent);
            if (!this.scrolling) {
                this.clickCount++;
                this.processTouches(inEvent, this.down);
            }
        },
        down: function(inPointer) {
            dispatcher.down(inPointer);
        },
        touchmove: function(inEvent) {
            if (HAS_TOUCH_ACTION) {
                // touchevent.cancelable == false is sent when the page is scrolling under native Touch Action in Chrome 36
                // https://groups.google.com/a/chromium.org/d/msg/input-dev/wHnyukcYBcA/b9kmtwM1jJQJ
                if (inEvent.cancelable) {
                    this.processTouches(inEvent, this.move);
                }
            } else {
                if (!this.scrolling) {
                    if (this.scrolling === null && this.shouldScroll(inEvent)) {
                        this.scrolling = true;
                    } else {
                        this.scrolling = false;
                        inEvent.preventDefault();
                        this.processTouches(inEvent, this.move);
                    }
                } else if (this.firstXY) {
                    var t = inEvent.changedTouches[0];
                    var dx = t.clientX - this.firstXY.X;
                    var dy = t.clientY - this.firstXY.Y;
                    var dd = Math.sqrt(dx * dx + dy * dy);
                    if (dd >= HYSTERESIS) {
                        this.touchcancel(inEvent);
                        this.scrolling = true;
                        this.firstXY = null;
                    }
                }
            }
        },
        move: function(inPointer) {
            dispatcher.move(inPointer);
        },
        touchend: function(inEvent) {
            this.dedupSynthMouse(inEvent);
            this.processTouches(inEvent, this.up);
        },
        up: function(inPointer) {
            inPointer.relatedTarget = scope.findTarget(inPointer);
            dispatcher.up(inPointer);
        },
        cancel: function(inPointer) {
            dispatcher.cancel(inPointer);
        },
        touchcancel: function(inEvent) {
            inEvent._cancel = true;
            this.processTouches(inEvent, this.cancel);
        },
        cleanUpPointer: function(inPointer) {
            pointermap['delete'](inPointer.pointerId);
            this.removePrimaryPointer(inPointer);
        },
        // prevent synth mouse events from creating pointer events
        dedupSynthMouse: function(inEvent) {
            var lts = scope.mouseEvents.lastTouches;
            var t = inEvent.changedTouches[0];
            // only the primary finger will synth mouse events
            if (this.isPrimaryTouch(t)) {
                // remember x/y of last touch
                var lt = {
                    x: t.clientX,
                    y: t.clientY
                };
                lts.push(lt);
                var fn = (function(lts, lt) {
                    var i = lts.indexOf(lt);
                    if (i > -1) {
                        lts.splice(i, 1);
                    }
                }).bind(null, lts, lt);
                setTimeout(fn, DEDUP_TIMEOUT);
            }
        }
    };

    // prevent "ghost clicks" that come from elements that were removed in a touch handler
    var STOP_PROP_FN = Event.prototype.stopImmediatePropagation || Event.prototype.stopPropagation;
    document.addEventListener('click', function(ev) {
        var x = ev.clientX,
            y = ev.clientY;
        // check if a click is within DEDUP_DIST px radius of the touchstart
        var closeTo = function(touch) {
            var dx = Math.abs(x - touch.x),
                dy = Math.abs(y - touch.y);
            return (dx <= DEDUP_DIST && dy <= DEDUP_DIST);
        };
        // if click coordinates are close to touch coordinates, assume the click came from a touch
        var wasTouched = scope.mouseEvents.lastTouches.some(closeTo);
        // if the click came from touch, and the touchstart target is not in the path of the click event,
        // then the touchstart target was probably removed, and the click should be "busted"
        var path = scope.targetFinding.path(ev);
        if (wasTouched) {
            for (var i = 0; i < path.length; i++) {
                if (path[i] === touchEvents.firstTarget) {
                    return;
                }
            }
            ev.preventDefault();
            STOP_PROP_FN.call(ev);
        }
    }, true);

    scope.touchEvents = touchEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    var HAS_BITMAP_TYPE = window.MSPointerEvent && typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number';
    var msEvents = {
        events: [
            'MSPointerDown',
            'MSPointerMove',
            'MSPointerUp',
            'MSPointerCancel',
        ],
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        POINTER_TYPES: [
            '',
            'unavailable',
            'touch',
            'pen',
            'mouse'
        ],
        prepareEvent: function(inEvent) {
            var e = inEvent;
            e = dispatcher.cloneEvent(inEvent);
            if (HAS_BITMAP_TYPE) {
                e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
            }
            e._source = 'ms';
            return e;
        },
        cleanup: function(id) {
            pointermap['delete'](id);
        },
        MSPointerDown: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.target = scope.findTarget(inEvent);
            pointermap.set(inEvent.pointerId, e.target);
            dispatcher.down(e);
        },
        MSPointerMove: function(inEvent) {
            var target = pointermap.get(inEvent.pointerId);
            if (target) {
                var e = this.prepareEvent(inEvent);
                e.target = target;
                dispatcher.move(e);
            }
        },
        MSPointerUp: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.up(e);
            this.cleanup(inEvent.pointerId);
        },
        MSPointerCancel: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.cancel(e);
            this.cleanup(inEvent.pointerId);
        }
    };

    scope.msEvents = msEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    var pointerEvents = {
        events: [
            'pointerdown',
            'pointermove',
            'pointerup',
            'pointercancel'
        ],
        prepareEvent: function(inEvent) {
            var e = dispatcher.cloneEvent(inEvent);
            e._source = 'pointer';
            return e;
        },
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        cleanup: function(id) {
            pointermap['delete'](id);
        },
        pointerdown: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.target = scope.findTarget(inEvent);
            pointermap.set(e.pointerId, e.target);
            dispatcher.down(e);
        },
        pointermove: function(inEvent) {
            var target = pointermap.get(inEvent.pointerId);
            if (target) {
                var e = this.prepareEvent(inEvent);
                e.target = target;
                dispatcher.move(e);
            }
        },
        pointerup: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.up(e);
            this.cleanup(inEvent.pointerId);
        },
        pointercancel: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.cancel(e);
            this.cleanup(inEvent.pointerId);
        }
    };

    scope.pointerEvents = pointerEvents;
})(exports);

/**
 * This module contains the handlers for native platform events.
 * From here, the dispatcher is called to create unified pointer events.
 * Included are touch events (v1), mouse events, and MSPointerEvents.
 */
(function(scope) {

    var dispatcher = scope.dispatcher;
    var nav = window.navigator;

    if (window.PointerEvent) {
        dispatcher.registerSource('pointer', scope.pointerEvents);
    } else if (nav.msPointerEnabled) {
        dispatcher.registerSource('ms', scope.msEvents);
    } else {
        dispatcher.registerSource('mouse', scope.mouseEvents);
        if (window.ontouchstart !== undefined) {
            dispatcher.registerSource('touch', scope.touchEvents);
        }
    }

    // Work around iOS bugs https://bugs.webkit.org/show_bug.cgi?id=135628 and https://bugs.webkit.org/show_bug.cgi?id=136506
    var ua = navigator.userAgent;
    var IS_IOS = ua.match(/iPad|iPhone|iPod/) && 'ontouchstart' in window;

    dispatcher.IS_IOS = IS_IOS;
    scope.touchEvents.IS_IOS = IS_IOS;

    dispatcher.register(document, true);
})(exports);

/**
 * This event denotes the beginning of a series of tracking events.
 *
 * @module PointerGestures
 * @submodule Events
 * @class trackstart
 */
/**
 * Pixels moved in the x direction since trackstart.
 * @type Number
 * @property dx
 */
/**
 * Pixes moved in the y direction since trackstart.
 * @type Number
 * @property dy
 */
/**
 * Pixels moved in the x direction since the last track.
 * @type Number
 * @property ddx
 */
/**
 * Pixles moved in the y direction since the last track.
 * @type Number
 * @property ddy
 */
/**
 * The clientX position of the track gesture.
 * @type Number
 * @property clientX
 */
/**
 * The clientY position of the track gesture.
 * @type Number
 * @property clientY
 */
/**
 * The pageX position of the track gesture.
 * @type Number
 * @property pageX
 */
/**
 * The pageY position of the track gesture.
 * @type Number
 * @property pageY
 */
/**
 * The screenX position of the track gesture.
 * @type Number
 * @property screenX
 */
/**
 * The screenY position of the track gesture.
 * @type Number
 * @property screenY
 */
/**
 * The last x axis direction of the pointer.
 * @type Number
 * @property xDirection
 */
/**
 * The last y axis direction of the pointer.
 * @type Number
 * @property yDirection
 */
/**
 * A shared object between all tracking events.
 * @type Object
 * @property trackInfo
 */
/**
 * The element currently under the pointer.
 * @type Element
 * @property relatedTarget
 */
/**
 * The type of pointer that make the track gesture.
 * @type String
 * @property pointerType
 */
/**
 *
 * This event fires for all pointer movement being tracked.
 *
 * @class track
 * @extends trackstart
 */
/**
 * This event fires when the pointer is no longer being tracked.
 *
 * @class trackend
 * @extends trackstart
 */

(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var track = {
        events: [
            'down',
            'move',
            'up',
        ],
        exposes: [
            'trackstart',
            'track',
            'trackx',
            'tracky',
            'trackend'
        ],
        defaultActions: {
            'track': 'none',
            'trackx': 'pan-y',
            'tracky': 'pan-x'
        },
        WIGGLE_THRESHOLD: 4,
        clampDir: function(inDelta) {
            return inDelta > 0 ? 1 : -1;
        },
        calcPositionDelta: function(inA, inB) {
            var x = 0,
                y = 0;
            if (inA && inB) {
                x = inB.pageX - inA.pageX;
                y = inB.pageY - inA.pageY;
            }
            return {
                x: x,
                y: y
            };
        },
        fireTrack: function(inType, inEvent, inTrackingData) {
            var t = inTrackingData;
            var d = this.calcPositionDelta(t.downEvent, inEvent);
            var dd = this.calcPositionDelta(t.lastMoveEvent, inEvent);
            if (dd.x) {
                t.xDirection = this.clampDir(dd.x);
            } else if (inType === 'trackx') {
                return;
            }
            if (dd.y) {
                t.yDirection = this.clampDir(dd.y);
            } else if (inType === 'tracky') {
                return;
            }
            var gestureProto = {
                bubbles: true,
                cancelable: true,
                trackInfo: t.trackInfo,
                relatedTarget: inEvent.relatedTarget,
                pointerType: inEvent.pointerType,
                pointerId: inEvent.pointerId,
                _source: 'track'
            };
            if (inType !== 'tracky') {
                gestureProto.x = inEvent.x;
                gestureProto.dx = d.x;
                gestureProto.ddx = dd.x;
                gestureProto.clientX = inEvent.clientX;
                gestureProto.pageX = inEvent.pageX;
                gestureProto.screenX = inEvent.screenX;
                gestureProto.xDirection = t.xDirection;
            }
            if (inType !== 'trackx') {
                gestureProto.dy = d.y;
                gestureProto.ddy = dd.y;
                gestureProto.y = inEvent.y;
                gestureProto.clientY = inEvent.clientY;
                gestureProto.pageY = inEvent.pageY;
                gestureProto.screenY = inEvent.screenY;
                gestureProto.yDirection = t.yDirection;
            }
            var e = eventFactory.makeGestureEvent(inType, gestureProto);
            t.downTarget.dispatchEvent(e);
        },
        down: function(inEvent) {
            if (inEvent.isPrimary && (inEvent.pointerType === 'mouse' ? inEvent.buttons === 1 : true)) {
                var p = {
                    downEvent: inEvent,
                    downTarget: inEvent.target,
                    trackInfo: {},
                    lastMoveEvent: null,
                    xDirection: 0,
                    yDirection: 0,
                    tracking: false
                };
                pointermap.set(inEvent.pointerId, p);
            }
        },
        move: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            if (p) {
                if (!p.tracking) {
                    var d = this.calcPositionDelta(p.downEvent, inEvent);
                    var move = d.x * d.x + d.y * d.y;
                    // start tracking only if finger moves more than WIGGLE_THRESHOLD
                    if (move > this.WIGGLE_THRESHOLD) {
                        p.tracking = true;
                        p.lastMoveEvent = p.downEvent;
                        this.fireTrack('trackstart', inEvent, p);
                    }
                }
                if (p.tracking) {
                    this.fireTrack('track', inEvent, p);
                    this.fireTrack('trackx', inEvent, p);
                    this.fireTrack('tracky', inEvent, p);
                }
                p.lastMoveEvent = inEvent;
            }
        },
        up: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            if (p) {
                if (p.tracking) {
                    this.fireTrack('trackend', inEvent, p);
                }
                pointermap.delete(inEvent.pointerId);
            }
        }
    };
    dispatcher.registerGesture('track', track);
})(exports);

/**
 * This event is fired when a pointer is held down for 200ms.
 *
 * @module PointerGestures
 * @submodule Events
 * @class hold
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * Screen X axis position of the held pointer
 * @type Number
 * @property clientX
 */
/**
 * Screen Y axis position of the held pointer
 * @type Number
 * @property clientY
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * This event is fired every 200ms while a pointer is held down.
 *
 * @class holdpulse
 * @extends hold
 */
/**
 * Milliseconds pointer has been held down.
 * @type Number
 * @property holdTime
 */
/**
 * This event is fired when a held pointer is released or moved.
 *
 * @class release
 */

(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var hold = {
        // wait at least HOLD_DELAY ms between hold and pulse events
        HOLD_DELAY: 200,
        // pointer can move WIGGLE_THRESHOLD pixels before not counting as a hold
        WIGGLE_THRESHOLD: 16,
        events: [
            'down',
            'move',
            'up',
        ],
        exposes: [
            'hold',
            'holdpulse',
            'release'
        ],
        heldPointer: null,
        holdJob: null,
        pulse: function() {
            var hold = Date.now() - this.heldPointer.timeStamp;
            var type = this.held ? 'holdpulse' : 'hold';
            this.fireHold(type, hold);
            this.held = true;
        },
        cancel: function() {
            clearInterval(this.holdJob);
            if (this.held) {
                this.fireHold('release');
            }
            this.held = false;
            this.heldPointer = null;
            this.target = null;
            this.holdJob = null;
        },
        down: function(inEvent) {
            if (inEvent.isPrimary && !this.heldPointer) {
                this.heldPointer = inEvent;
                this.target = inEvent.target;
                this.holdJob = setInterval(this.pulse.bind(this), this.HOLD_DELAY);
            }
        },
        up: function(inEvent) {
            if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
                this.cancel();
            }
        },
        move: function(inEvent) {
            if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
                var x = inEvent.clientX - this.heldPointer.clientX;
                var y = inEvent.clientY - this.heldPointer.clientY;
                if ((x * x + y * y) > this.WIGGLE_THRESHOLD) {
                    this.cancel();
                }
            }
        },
        fireHold: function(inType, inHoldTime) {
            var p = {
                bubbles: true,
                cancelable: true,
                pointerType: this.heldPointer.pointerType,
                pointerId: this.heldPointer.pointerId,
                x: this.heldPointer.clientX,
                y: this.heldPointer.clientY,
                _source: 'hold'
            };
            if (inHoldTime) {
                p.holdTime = inHoldTime;
            }
            var e = eventFactory.makeGestureEvent(inType, p);
            this.target.dispatchEvent(e);
        }
    };
    dispatcher.registerGesture('hold', hold);
})(exports);

/**
 * This event is fired when a pointer quickly goes down and up, and is used to
 * denote activation.
 *
 * Any gesture event can prevent the tap event from being created by calling
 * `event.preventTap`.
 *
 * Any pointer event can prevent the tap by setting the `tapPrevented` property
 * on itself.
 *
 * @module PointerGestures
 * @submodule Events
 * @class tap
 */
/**
 * X axis position of the tap.
 * @property x
 * @type Number
 */
/**
 * Y axis position of the tap.
 * @property y
 * @type Number
 */
/**
 * Type of the pointer that made the tap.
 * @property pointerType
 * @type String
 */
(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var tap = {
        events: [
            'down',
            'up'
        ],
        exposes: [
            'tap'
        ],
        down: function(inEvent) {
            if (inEvent.isPrimary && !inEvent.tapPrevented) {
                pointermap.set(inEvent.pointerId, {
                    target: inEvent.target,
                    buttons: inEvent.buttons,
                    x: inEvent.clientX,
                    y: inEvent.clientY
                });
            }
        },
        shouldTap: function(e, downState) {
            var tap = true;
            if (e.pointerType === 'mouse') {
                // only allow left click to tap for mouse
                tap = (e.buttons ^ 1) && (downState.buttons & 1);
            }
            return tap && !e.tapPrevented;
        },
        up: function(inEvent) {
            var start = pointermap.get(inEvent.pointerId);
            if (start && this.shouldTap(inEvent, start)) {
                // up.relatedTarget is target currently under finger
                var t = scope.targetFinding.LCA(start.target, inEvent.relatedTarget);
                if (t) {
                    var e = eventFactory.makeGestureEvent('tap', {
                        bubbles: true,
                        cancelable: true,
                        x: inEvent.clientX,
                        y: inEvent.clientY,
                        detail: inEvent.detail,
                        pointerType: inEvent.pointerType,
                        pointerId: inEvent.pointerId,
                        altKey: inEvent.altKey,
                        ctrlKey: inEvent.ctrlKey,
                        metaKey: inEvent.metaKey,
                        shiftKey: inEvent.shiftKey,
                        _source: 'tap'
                    });
                    t.dispatchEvent(e);
                }
            }
            pointermap.delete(inEvent.pointerId);
        }
    };
    // patch eventFactory to remove id from tap's pointermap for preventTap calls
    eventFactory.preventTap = function(e) {
        return function() {
            e.tapPrevented = true;
            pointermap.delete(e.pointerId);
        };
    };
    dispatcher.registerGesture('tap', tap);
})(exports);

/*
 * Basic strategy: find the farthest apart points, use as diameter of circle
 * react to size change and rotation of the chord
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class pinch
 */
/**
 * Scale of the pinch zoom gesture
 * @property scale
 * @type Number
 */
/**
 * Center X position of pointers causing pinch
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing pinch
 * @property centerY
 * @type Number
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class rotate
 */
/**
 * Angle (in degrees) of rotation. Measured from starting positions of pointers.
 * @property angle
 * @type Number
 */
/**
 * Center X position of pointers causing rotation
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing rotation
 * @property centerY
 * @type Number
 */
(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var RAD_TO_DEG = 180 / Math.PI;
    var pinch = {
        events: [
            'down',
            'up',
            'move',
            'cancel'
        ],
        exposes: [
            'pinchstart',
            'pinch',
            'pinchend',
            'rotate'
        ],
        defaultActions: {
            'pinch': 'none',
            'rotate': 'none'
        },
        reference: {},
        down: function(inEvent) {
            pointermap.set(inEvent.pointerId, inEvent);
            if (pointermap.pointers() == 2) {
                var points = this.calcChord();
                var angle = this.calcAngle(points);
                this.reference = {
                    angle: angle,
                    diameter: points.diameter,
                    target: scope.targetFinding.LCA(points.a.target, points.b.target)
                };

                this.firePinch('pinchstart', points.diameter, points);
            }
        },
        up: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            var num = pointermap.pointers();
            if (p) {
                if (num === 2) {
                    // fire 'pinchend' before deleting pointer
                    var points = this.calcChord();
                    this.firePinch('pinchend', points.diameter, points);
                }
                pointermap.delete(inEvent.pointerId);
            }
        },
        move: function(inEvent) {
            if (pointermap.has(inEvent.pointerId)) {
                pointermap.set(inEvent.pointerId, inEvent);
                if (pointermap.pointers() > 1) {
                    this.calcPinchRotate();
                }
            }
        },
        cancel: function(inEvent) {
            this.up(inEvent);
        },
        firePinch: function(type, diameter, points) {
            var zoom = diameter / this.reference.diameter;
            var e = eventFactory.makeGestureEvent(type, {
                bubbles: true,
                cancelable: true,
                scale: zoom,
                centerX: points.center.x,
                centerY: points.center.y,
                _source: 'pinch'
            });
            this.reference.target.dispatchEvent(e);
        },
        fireRotate: function(angle, points) {
            var diff = Math.round((angle - this.reference.angle) % 360);
            var e = eventFactory.makeGestureEvent('rotate', {
                bubbles: true,
                cancelable: true,
                angle: diff,
                centerX: points.center.x,
                centerY: points.center.y,
                _source: 'pinch'
            });
            this.reference.target.dispatchEvent(e);
        },
        calcPinchRotate: function() {
            var points = this.calcChord();
            var diameter = points.diameter;
            var angle = this.calcAngle(points);
            if (diameter != this.reference.diameter) {
                this.firePinch('pinch', diameter, points);
            }
            if (angle != this.reference.angle) {
                this.fireRotate(angle, points);
            }
        },
        calcChord: function() {
            var pointers = [];
            pointermap.forEach(function(p) {
                pointers.push(p);
            });
            var dist = 0;
            // start with at least two pointers
            var points = {
                a: pointers[0],
                b: pointers[1]
            };
            var x, y, d;
            for (var i = 0; i < pointers.length; i++) {
                var a = pointers[i];
                for (var j = i + 1; j < pointers.length; j++) {
                    var b = pointers[j];
                    x = Math.abs(a.clientX - b.clientX);
                    y = Math.abs(a.clientY - b.clientY);
                    d = x + y;
                    if (d > dist) {
                        dist = d;
                        points = {
                            a: a,
                            b: b
                        };
                    }
                }
            }
            x = Math.abs(points.a.clientX + points.b.clientX) / 2;
            y = Math.abs(points.a.clientY + points.b.clientY) / 2;
            points.center = {
                x: x,
                y: y
            };
            points.diameter = dist;
            return points;
        },
        calcAngle: function(points) {
            var x = points.a.clientX - points.b.clientX;
            var y = points.a.clientY - points.b.clientY;
            return (360 + Math.atan2(y, x) * RAD_TO_DEG) % 360;
        }
    };
    dispatcher.registerGesture('pinch', pinch);
})(exports);
},{}],21:[function(require,module,exports){
// list-dragon node module
// https://github.com/openfin/list-dragon

/* eslint-env node, browser */

'use strict';

var cssInjector = require('css-injector');
var format = require('templex');

var REVERT_TO_STYLESHEET_VALUE = null;  // null removes the style

var transform, timer, scrollVelocity, cssListDragon;

/* inject:css */
cssListDragon = 'div.dragon-list{position:relative;background-color:#fff}div.dragon-list>div,div.dragon-list>ul{position:absolute;left:0;right:0}div.dragon-list>div{text-align:center;background-color:#00796b;color:#fff;box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);overflow:hidden;white-space:nowrap}div.dragon-list>ul{overflow-y:auto;bottom:0;margin:0;padding:0;box-shadow:0 1px 3px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.24)}div.dragon-list>ul>li,li.dragon-pop{white-space:nowrap;list-style-type:none;border:0 solid #f4f4f4;border-bottom:1px solid #e0e0e0;cursor:move;transition:border-top-width .2s}div.dragon-list>ul>li:last-child{height:0;border-bottom:none}li.dragon-pop{position:fixed;background-color:#fff;border:1px solid #e0e0e0;left:0;top:0;overflow-x:hidden;box-shadow:rgba(0,0,0,.188235) 0 10px 20px,rgba(0,0,0,.227451) 0 6px 6px}';
/* endinject */

/**
 * @constructor ListDragon
 *
 * @desc This object services a set of item lists that allow dragging and dropping items within and between lists in a set.
 *
 * Two strategies are supported:
 *
 * 1. Supply your own HTML markup and let the API build the item models for you.
 *    To use this strategy, script your HTML and provide one of these:
 *    * an array of all the list item (`<li>`) tags
 *    * a CSS selector that points to all the list item tags
 * 2. Supply your own item models and let the API build the HTML markup for you.
 *    To use this strategy, provide an array of model lists.
 *
 * The new ListDragon object's `modelLists` property references the array of model lists the API constructed for you in strategy #1 or the array of model lists you supplied for strategy #2.
 *
 * After the user performs a successful drag-and-drop operation, the position of the model references within the `modelLists` array is rearranged. (The models themselves are the original objects as supplied in the model lists; they are not rebuilt or altered in any way. Just the references to them are moved around.)
 *
 * @param {string|Element[]|modelListType[]} selectorOrModelLists - You must supply one of the items in **bold** below:
 *
 * 1. _For strategy #1 above (API creates models from supplied elements):_ All the list item (`<li>`) DOM elements of all the lists you want the new object to manage, as either:
 *    1. **A CSS selector;** _or_
 *    2. **An array of DOM elements**
 * 2. _For strategy #2 above (API creates elements from supplied models):_ **An array of model lists,** each of which is in one of the following forms:
 *    1. An array of item models (with various option properties hanging off of it); _and/or_
 *    2. A {@link modelListType} object with those same various option properties including the required `models` property containing that same array of item models.
 *
 * In either case (2.1 or 2.2), each element of such arrays of item models may take the form of:
 * * A string primitive; _or_
 * * A {@link itemModelType} object with a various option properties including the required `label` property containing a string primitive.
 *
 * Regarding these string primitives, each is either:
 * * A string to be displayed in the list item; _or_
 * * A format string with other property values merged in, the result of which is to be displayed in the list item.
 *
 * @param {object} [options={}] - You may supply "global" template variables here, representing the "outer scope," after first searching each model and then each model list.
 * @param {undefined|null|Element|string} [cssStylesheetReferenceElement] - Determines where to insert the stylesheet. (This is the only formal option.) Passed to css-injector, the overloads are (from css-injector docs):
 * * `undefined` type (or omitted): injects stylesheet at top of `<head>...</head>` element
 * * `null` value: injects stylesheet at bottom of `<head>...</head>` element
 * * `Element` type: injects stylesheet immediately before given element, wherever it is found.
 * * `string` type: injects stylesheet immediately before given first element found that matches the given css selector.
 */
function ListDragon(selectorOrModelLists, options) {

    if (!(this instanceof ListDragon)) {
        throw error('Not called with "new" keyword.');
    }

    var self = this, modelLists, items;

    options = options || {};

    if (typeof selectorOrModelLists === 'string') {
        items = toArray(document.querySelectorAll(selectorOrModelLists));
        modelLists = createModelListsFromListElements(items);
    } else if (selectorOrModelLists[0] instanceof Element) {
        items = toArray(selectorOrModelLists);
        modelLists = createModelListsFromListElements(items);
    } else {
        // param is array of model lists
        // build new <ul> element(s) for each list and put in `.modelLists`;
        // fill `.items` array with <li> elements from these new <ul> elements
        items = [];
        modelLists = createListElementsFromModelLists(selectorOrModelLists, options);
        modelLists.forEach(function (list) {
            items = items.concat(toArray(list.element.querySelectorAll('li')));
        });
    }

    // grab wheel events and don't let 'em bubble
    modelLists.forEach(function (modelList) {
        modelList.element.addEventListener('wheel', captureEvent);
    });

    items.forEach(function (itemElement, index) {
        var item = (itemElement !== itemElement.parentElement.lastElementChild)
            ? self.addEvt(itemElement, 'mousedown', itemElement, true)
            : { element: itemElement };

        /* `item.model` not currently needed so commented out here.
         * (Originally used for rebuilding modelLists for final
         * reporting, modelLists are now spliced on every successful
         * drag-and-drop operation so they're always up to date.)

         var origin = this.itemCoordinates(itemElement);
         item.model = this.modelLists[origin.list].models[origin.item];

         */

        items[index] = item;
    });

    transform = 'transform' in items[0].element.style
        ? 'transform' // Chrome 45 and Firefox 40
        : '-webkit-transform'; // Safari 8

    // set up the new object
    this.modelLists = modelLists;
    this.items = items;
    this.bindings = {};
    this.callback = {};

    cssInjector(cssListDragon, 'list-dragon-base', options.cssStylesheetReferenceElement);

}

ListDragon.prototype = {

    addEvt: function (target, type, listener, doNotBind) {
        var binding = {
            handler: handlers[type].bind(target, this),
            element: listener || window
        };

        if (!doNotBind) {
            this.bindings[type] = binding;
        }

        binding.element.addEventListener(type, binding.handler);

        return binding;
    },

    removeEvt: function (type) {
        var binding = this.bindings[type];
        delete this.bindings[type];
        binding.element.removeEventListener(type, binding.handler);
    },

    removeAllEventListeners: function () {
        // remove drag & drop events (mousemove, mouseup, and transitionend)
        for (var type in this.bindings) {
            var binding = this.bindings[type];
            binding.element.removeEventListener(type, binding.handler);
        }
        // remove the mousedown events from all list items
        this.items.forEach(function (item) {
            if (item.handler) {
                item.element.removeEventListener('mousedown', item.handler);
            }
        });
        // wheel events on the list elements
        this.modelLists.forEach(function (modelList) {
            modelList.element.removeEventListener('wheel', captureEvent);
        });
    },

    pointInListRects: function (point) {
        return this.modelLists.find(function (modelList) {
            var rect = modelList.element.getBoundingClientRect();

            rect = {
                left:   window.scrollX + rect.left,
                top:    window.scrollY + rect.top,
                right:  window.scrollX + rect.right,
                bottom: window.scrollY + rect.bottom,
                width:  rect.width,
                height: rect.height
            };

            modelList.rect = rect;

            if (pointInRect(point, rect)) {
                modelList.rect = rect;
                return true; // found
            } else {
                return false;
            }
        });
    },

    pointInItemRects: function (point, except1, except2) {
        return this.items.find(function (item) {
            var element = item.element;
            return (
                element !== except1 &&
                element !== except2 &&
                pointInRect(point, item.rect)
            );
        });
    },

    // get positions of all list items in page coords (normalized for window and list scrolling)
    getAllItemBoundingRects: function () {
        var modelLists = this.modelLists, height;
        this.items.forEach(function (item) {
            var itemElement = item.element,
                listElement = itemElement.parentElement,
                list = modelLists.find(function (list) { return list.element === listElement; });

            if (
                // omitted: default to true
                list.isDropTarget === undefined ||

                // function: use return value
                typeof list.isDropTarget === 'function' && list.isDropTarget() ||

                // otherwise: use truthiness of given value
                list.isDropTarget
            ) {
                var rect = itemElement.getBoundingClientRect(),
                    bottom = rect.bottom;

                if (itemElement === listElement.lastElementChild) {
                    bottom = listElement.getBoundingClientRect().bottom;
                    if (bottom < rect.top) {
                        bottom = rect.top + (height || 50);
                    }
                } else {
                    height = rect.height;
                }

                rect = {
                    left:   window.scrollX + rect.left,
                    right:  window.scrollX + rect.right,
                    top:    window.scrollY + rect.top    + listElement.scrollTop,
                    bottom: window.scrollY + bottom + listElement.scrollTop
                };

                item.rect = rect;
            }
        });
    },

    reinsert: function (target) {
        var style = target.style;
        style.width = style[transform] = style.transition = REVERT_TO_STYLESHEET_VALUE;

        target.classList.remove('dragon-pop');

        this.drop.style.transitionDuration = '0s';
        this.drop.style.borderTopWidth = REVERT_TO_STYLESHEET_VALUE;
        this.drop.parentElement.insertBefore(target, this.drop);

        delete this.drop;
    },

    // return an object { item: <item index within list>, list: <list index within list of lists> }
    itemCoordinates: function (item) {
        var listElement = item.parentElement,
            coords = { item: 0 };

        while ((item = item.previousElementSibling)) {
            ++coords.item;
        }

        this.modelLists.find(function (list, index) {
            coords.list = index;
            return list.element === listElement; // stop when we find the one we belong to
        });

        return coords;
    }

};

var handlers = {
    mousedown: function (dragon, evt) {

        evt.stopPropagation();
        evt.preventDefault();  //prevents user selection of rendered nodes during drag

        if (dragon.drop) {
            return;
        }

        var rect = this.getBoundingClientRect();

        dragon.rect = rect = {
            left:   Math.round(rect.left - 1),
            top:    Math.round(rect.top - 1),
            right:  Math.round(rect.right),
            bottom: Math.round(rect.bottom),
            width:  Math.round(rect.width),
            height: Math.round(rect.height)
        };

        dragon.pin = {
            x: window.scrollX + evt.clientX,
            y: window.scrollY + evt.clientY
        };

        dragon.origin = dragon.itemCoordinates(this);

        if (dragon.callback.grabbed) {
            dragon.callback.grabbed.call(this, dragon);
        }

        dragon.getAllItemBoundingRects();

        dragon.drop = this.nextElementSibling;
        dragon.drop.style.transitionDuration = '0s';
        dragon.drop.style.borderTopWidth = rect.height + 'px';

        this.style.width = rect.width + 'px';
        this.style.transitionDuration = '0s';
        this.style[transform] = translate(
            rect.left - window.scrollX,
            rect.top  - window.scrollY
        );
        this.classList.add('dragon-pop');
        this.style.zIndex = window.getComputedStyle(dragon.modelLists[0].container.parentElement).zIndex;

        if (!dragon.container) {
            // walk back to closest shadow root OR body tag OR root tag
            var container = this;
            while (container.parentNode) {
                container = container.parentNode;
                if (
                    typeof ShadowRoot !== 'undefined' && container instanceof ShadowRoot ||
                    container.tagName === 'BODY'
                ){
                    break;
                }
            }
            dragon.container = container;
        }

        dragon.container.appendChild(this);

        rect.left   += window.scrollX;
        rect.top    += window.scrollY;
        rect.right  += window.scrollX;
        rect.bottom += window.scrollY;

        dragon.addEvt(this, 'mousemove');
        dragon.addEvt(this, 'mouseup');
    },

    mousemove: function (dragon, evt) {
        dragon.drop.style.transition = REVERT_TO_STYLESHEET_VALUE;

        var hoverList = dragon.pointInListRects({ x: evt.clientX, y: evt.clientY }) || dragon.mostRecentHoverList;

        if (hoverList) {
            var dx = evt.clientX - dragon.pin.x,
                dy = evt.clientY - dragon.pin.y;

            dragon.mostRecentHoverList = hoverList;

            var maxScrollY = hoverList.element.scrollHeight - hoverList.rect.height,
                y = evt.clientY + window.scrollY,
                magnitude;

            if (maxScrollY > 0) {
                // list is scrollable (is taller than rect)
                if (hoverList.element.scrollTop > 0 && (magnitude = y - (hoverList.rect.top + 5)) < 0) {
                    // mouse near or above top and list is not scrolled to top yet
                    resetAutoScrollTimer(magnitude, 0, hoverList.element);
                } else if (hoverList.element.scrollTop < maxScrollY && (magnitude = y - (hoverList.rect.bottom - 1 - 5)) > 0) {
                    // mouse near or below bottom and list not scrolled to bottom yet
                    resetAutoScrollTimer(magnitude, maxScrollY, hoverList.element);
                } else {
                    // mouse inside
                    resetAutoScrollTimer();
                }
            }

            var other = dragon.pointInItemRects({
                x: evt.clientX,
                y: dragon.rect.bottom + window.scrollY + dy + hoverList.element.scrollTop
            }, this, dragon.drop);

            this.style[transform] = translate(
                dragon.rect.left - window.scrollX + dx,
                dragon.rect.top - window.scrollY + dy
            );

            if (other) {
                var element = other.element;
                element.style.transition = REVERT_TO_STYLESHEET_VALUE;
                element.style.borderTopWidth = dragon.drop.style.borderTopWidth;
                dragon.drop.style.borderTopWidth = null;
                dragon.drop = element;
            }
        }
    },

    mouseup: function (dragon, evt) {
        resetAutoScrollTimer();
        dragon.removeEvt('mousemove');
        dragon.removeEvt('mouseup');

        evt.stopPropagation();

        var newRect = this.getBoundingClientRect();

        if (
            window.scrollX + newRect.left === dragon.rect.left &&
            window.scrollY + newRect.top === dragon.rect.top
        ) {
            dragon.reinsert(this);
        } else {
            var dropRect = dragon.drop.getBoundingClientRect();

            dragon.addEvt(this, 'transitionend', this);
            this.style.transitionDuration = REVERT_TO_STYLESHEET_VALUE; //reverts to 200ms
            this.style.transitionProperty = transform;
            this.style[transform] = translate(
                dropRect.left - window.scrollX,
                dropRect.top - window.scrollY
            );
        }
    },

    transitionend: function (dragon, evt) {
        if (evt.propertyName === transform) {
            dragon.removeEvt('transitionend');
            dragon.reinsert(this);

            this.style.transitionProperty = REVERT_TO_STYLESHEET_VALUE; //reverts to border-top-width

            var model = dragon.modelLists[dragon.origin.list].splice(dragon.origin.item, 1)[0];
            var destination = dragon.itemCoordinates(this);
            dragon.modelLists[destination.list].splice(destination.item, 0, model);

            if (dragon.callback.dropped) {
                dragon.callback.dropped.call(this, dragon);
            }
        }
    }
};

function resetAutoScrollTimer(magnitude, limit, element) {
    if (!magnitude) {
        clearInterval(timer);
        scrollVelocity = 0;
    } else {
        var changeDirection =
            scrollVelocity  <  0 && magnitude  >= 0 ||
            scrollVelocity === 0 && magnitude !== 0 ||
            scrollVelocity  >  0 && magnitude  <= 0;
        scrollVelocity = magnitude > 0 ? Math.min(50, magnitude) : Math.max(-50, magnitude);
        if (changeDirection) {
            clearInterval(timer);
            timer = setInterval(function (limit) {
                var scrollTop = element.scrollTop + scrollVelocity;
                if (scrollVelocity < 0 && scrollTop < limit || scrollVelocity > 0 && scrollTop > limit) {
                    element.scrollTop = limit;
                    clearInterval(timer);
                } else {
                    element.scrollTop = scrollTop;
                }
            }, 125);
        }
    }
}

function toArray(arrayLikeObject) {
    return Array.prototype.slice.call(arrayLikeObject);
}

function pointInRect(point, rect) {
    return rect.top <= point.y && point.y <= rect.bottom
        && rect.left <= point.x && point.x <= rect.right;
}

function translate(left, top) {
    return 'translate('
        + Math.floor(left + window.scrollX) + 'px,'
        + Math.floor(top + window.scrollY) + 'px)';
}

function htmlEncode(string) {
    var textNode = document.createTextNode(string);

    return document
        .createElement('a')
        .appendChild(textNode)
        .parentNode
        .innerHTML;
}

/**
 * Creates `<ul>...</ul>` elements and inserts them into an `element` property on each model.
 * @param {object} modelLists
 * @returns `modelLists`
 */
function createListElementsFromModelLists(modelLists, options) {
    var templateLabel = options.label || '{label}';

    modelLists.forEach(function (modelList, listIndex) {
        var listLabel = modelList.label || templateLabel,
            listHtmlEncode = modelList.htmlEncode !== undefined && modelList.htmlEncode || options.htmlEncode,
            container = document.createElement('div'),
            listElement = document.createElement('ul');

        if (modelList.models) {
            Object.keys(modelList).forEach(function (key) {
                if (key !== 'models') {
                    modelList.models[key] = modelList[key];
                }
            });
            modelLists[listIndex] = modelList = modelList.models;
        } else if (modelList instanceof Array) {
            modelList.models = modelList; // point to self
        } else {
            throw error('List [{1}] not an array of models (with or without additional properties) OR ' +
                'an object (with a `models` property containing an array of models).', listIndex);
        }

        modelList.forEach(function (model) {
            var modelLabel = model.label || listLabel,
                modelHtmlEncode = model.htmlEncode !== undefined && model.htmlEncode || listHtmlEncode,
                modelObject = typeof model === 'object' ? model : { label: model},
                label = format.call([modelObject, modelList, options], modelLabel),
                itemElement = document.createElement('li');

            itemElement.innerHTML = modelHtmlEncode ? htmlEncode(label) : label;

            listElement.appendChild(itemElement);
        });

        // append the final "fencepost" item -- drop target at bottom of list after all items
        var itemElement = document.createElement('li');
        itemElement.innerHTML = '&nbsp;';
        listElement.appendChild(itemElement);

        // append header to container
        if (modelList.title) {
            var header = document.createElement('div');
            header.innerHTML = listHtmlEncode ? htmlEncode(modelList.title) : modelList.title;
            container.appendChild(header);
        }

        container.appendChild(listElement);
        container.className = modelList.cssClassNames || options.cssClassNames || 'dragon-list';
        modelList.element = listElement;
        modelList.container = container;
    });

    return modelLists;
}

/**
 * Create a `.modelLists` array with these <li> elements' parent <ul> elements
 * @param {Element[]} listItemElements
 * @returns {Array}
 */
function createModelListsFromListElements(listItemElements) {
    var modelLists = [];

    listItemElements.forEach(function (itemElement) {
        var listElement = itemElement.parentElement,
            container = listElement.parentElement,
            models = [];
        if (!modelLists.find(function (list) { return list.element === listElement; })) {
            toArray(listElement.querySelectorAll('li')).forEach(function (itemElement) {
                if (itemElement !== listElement.lastElementChild) {
                    models.push(itemElement.innerHTML);
                }
            });
            models.element = listElement;
            models.container = container;
            modelLists.push(models);
        }
    });

    return modelLists;
}

function captureEvent(evt) {
    evt.stopPropagation();
}

function error() {
    return 'list-dragon: ' + format.apply(this, Array.prototype.slice.call(arguments));
}

// this interface consists solely of the prototypal object constructor
module.exports = ListDragon;

},{"css-injector":4,"templex":29}],22:[function(require,module,exports){
;(function () { // closure for web browsers

if (typeof module === 'object' && module.exports) {
  module.exports = LRUCache
} else {
  // just set the global for non-node platforms.
  this.LRUCache = LRUCache
}

function hOP (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key)
}

function naiveLength () { return 1 }

var didTypeWarning = false
function typeCheckKey(key) {
  if (!didTypeWarning && typeof key !== 'string' && typeof key !== 'number') {
    didTypeWarning = true
    console.error(new TypeError("LRU: key must be a string or number. Almost certainly a bug! " + typeof key).stack)
  }
}

function LRUCache (options) {
  if (!(this instanceof LRUCache))
    return new LRUCache(options)

  if (typeof options === 'number')
    options = { max: options }

  if (!options)
    options = {}

  this._max = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!this._max || !(typeof this._max === "number") || this._max <= 0 )
    this._max = Infinity

  this._lengthCalculator = options.length || naiveLength
  if (typeof this._lengthCalculator !== "function")
    this._lengthCalculator = naiveLength

  this._allowStale = options.stale || false
  this._maxAge = options.maxAge || null
  this._dispose = options.dispose
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, "max",
  { set : function (mL) {
      if (!mL || !(typeof mL === "number") || mL <= 0 ) mL = Infinity
      this._max = mL
      if (this._length > this._max) trim(this)
    }
  , get : function () { return this._max }
  , enumerable : true
  })

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, "lengthCalculator",
  { set : function (lC) {
      if (typeof lC !== "function") {
        this._lengthCalculator = naiveLength
        this._length = this._itemCount
        for (var key in this._cache) {
          this._cache[key].length = 1
        }
      } else {
        this._lengthCalculator = lC
        this._length = 0
        for (var key in this._cache) {
          this._cache[key].length = this._lengthCalculator(this._cache[key].value)
          this._length += this._cache[key].length
        }
      }

      if (this._length > this._max) trim(this)
    }
  , get : function () { return this._lengthCalculator }
  , enumerable : true
  })

Object.defineProperty(LRUCache.prototype, "length",
  { get : function () { return this._length }
  , enumerable : true
  })


Object.defineProperty(LRUCache.prototype, "itemCount",
  { get : function () { return this._itemCount }
  , enumerable : true
  })

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  var i = 0
  var itemCount = this._itemCount

  for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {
    i++
    var hit = this._lruList[k]
    if (isStale(this, hit)) {
      del(this, hit)
      if (!this._allowStale) hit = undefined
    }
    if (hit) {
      fn.call(thisp, hit.value, hit.key, this)
    }
  }
}

LRUCache.prototype.keys = function () {
  var keys = new Array(this._itemCount)
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    keys[i++] = hit.key
  }
  return keys
}

LRUCache.prototype.values = function () {
  var values = new Array(this._itemCount)
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    values[i++] = hit.value
  }
  return values
}

LRUCache.prototype.reset = function () {
  if (this._dispose && this._cache) {
    for (var k in this._cache) {
      this._dispose(k, this._cache[k].value)
    }
  }

  this._cache = Object.create(null) // hash of items by key
  this._lruList = Object.create(null) // list of items in order of use recency
  this._mru = 0 // most recently used
  this._lru = 0 // least recently used
  this._length = 0 // number of items in the list
  this._itemCount = 0
}

LRUCache.prototype.dump = function () {
  var arr = []
  var i = 0

  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    if (!isStale(this, hit)) {
      //Do not store staled hits
      ++i
      arr.push({
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      });
    }
  }
  //arr has the most read first
  return arr
}

LRUCache.prototype.dumpLru = function () {
  return this._lruList
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this._maxAge
  typeCheckKey(key)

  var now = maxAge ? Date.now() : 0
  var len = this._lengthCalculator(value)

  if (hOP(this._cache, key)) {
    if (len > this._max) {
      del(this, this._cache[key])
      return false
    }
    // dispose of the old one before overwriting
    if (this._dispose)
      this._dispose(key, this._cache[key].value)

    this._cache[key].now = now
    this._cache[key].maxAge = maxAge
    this._cache[key].value = value
    this._length += (len - this._cache[key].length)
    this._cache[key].length = len
    this.get(key)

    if (this._length > this._max)
      trim(this)

    return true
  }

  var hit = new Entry(key, value, this._mru++, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this._max) {
    if (this._dispose) this._dispose(key, value)
    return false
  }

  this._length += hit.length
  this._lruList[hit.lu] = this._cache[key] = hit
  this._itemCount ++

  if (this._length > this._max)
    trim(this)

  return true
}

LRUCache.prototype.has = function (key) {
  typeCheckKey(key)
  if (!hOP(this._cache, key)) return false
  var hit = this._cache[key]
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  typeCheckKey(key)
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  typeCheckKey(key)
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var hit = this._lruList[this._lru]
  del(this, hit)
  return hit || null
}

LRUCache.prototype.del = function (key) {
  typeCheckKey(key)
  del(this, this._cache[key])
}

LRUCache.prototype.load = function (arr) {
  //reset the cache
  this.reset();

  var now = Date.now()
  //A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l-- ) {
    var hit = arr[l]
    typeCheckKey(hit.k)
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      //the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      //dont add already expired items
      if (maxAge > 0) this.set(hit.k, hit.v, maxAge)
    }
  }
}

function get (self, key, doUse) {
  typeCheckKey(key)
  var hit = self._cache[key]
  if (hit) {
    if (isStale(self, hit)) {
      del(self, hit)
      if (!self._allowStale) hit = undefined
    } else {
      if (doUse) use(self, hit)
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale(self, hit) {
  if (!hit || (!hit.maxAge && !self._maxAge)) return false
  var stale = false;
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self._maxAge && (diff > self._maxAge)
  }
  return stale;
}

function use (self, hit) {
  shiftLU(self, hit)
  hit.lu = self._mru ++
  self._lruList[hit.lu] = hit
}

function trim (self) {
  while (self._lru < self._mru && self._length > self._max)
    del(self, self._lruList[self._lru])
}

function shiftLU (self, hit) {
  delete self._lruList[ hit.lu ]
  while (self._lru < self._mru && !self._lruList[self._lru]) self._lru ++
}

function del (self, hit) {
  if (hit) {
    if (self._dispose) self._dispose(hit.key, hit.value)
    self._length -= hit.length
    self._itemCount --
    delete self._cache[ hit.key ]
    shiftLU(self, hit)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, lu, length, now, maxAge) {
  this.key = key
  this.value = value
  this.lu = lu
  this.length = length
  this.now = now
  if (maxAge) this.maxAge = maxAge
}

})()

},{}],23:[function(require,module,exports){
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache (global, factory) {
  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory); // AMD
  } else {
    global.Mustache = {};
    factory(global.Mustache); // script, wsh, asp
  }
}(this, function mustacheFactory (mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill (object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction (object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr (obj) {
    return isArray(obj) ? 'array' : typeof obj;
  }

  function escapeRegExp (string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty (obj, propName) {
    return obj != null && typeof obj === 'object' && (propName in obj);
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp (re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace (string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };

  function escapeHtml (string) {
    return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap (s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate (template, tags) {
    if (!template)
      return [];

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace () {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags (tagsToCompile) {
      if (typeof tagsToCompile === 'string')
        tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push([ 'text', chr, start, start + 1 ]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n')
            stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe))
        break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe))
        throw new Error('Unclosed tag at ' + scanner.pos);

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens (tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens (tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
        case '#':
        case '^':
          collector.push(token);
          sections.push(token);
          collector = token[4] = [];
          break;
        case '/':
          section = sections.pop();
          section[5] = token[2];
          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          break;
        default:
          collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner (string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos () {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan (re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0)
      return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil (re) {
    var index = this.tail.search(re), match;

    switch (index) {
      case -1:
        match = this.tail;
        this.tail = '';
        break;
      case 0:
        match = '';
        break;
      default:
        match = this.tail.substring(0, index);
        this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context (view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup (name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, names, index, lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           **/
          while (value != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit)
          break;

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value))
      value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer () {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache () {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse (template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null)
      tokens = cache[template] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function render (template, view, partials) {
    var tokens = this.parse(template);
    var context = (view instanceof Context) ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context);
      else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined)
        buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender (template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null)
      return this.renderTokens(this.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };

  Writer.prototype.escapedValue = function escapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue (token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '2.2.1';
  mustache.tags = [ '{{', '}}' ];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function render (template, view, partials) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' +
                          'but "' + typeStr(template) + '" was given as the first ' +
                          'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html (template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

}));

},{}],24:[function(require,module,exports){
/* object-iterators.js - Mini Underscore library
 * by Jonathan Eiten
 *
 * The methods below operate on objects (but not arrays) similarly
 * to Underscore (http://underscorejs.org/#collections).
 *
 * For more information:
 * https://github.com/joneit/object-iterators
 */

'use strict';

/**
 * @constructor
 * @summary Wrap an object for one method call.
 * @Desc Note that the `new` keyword is not necessary.
 * @param {object|null|undefined} object - `null` or `undefined` is treated as an empty plain object.
 * @return {Wrapper} The wrapped object.
 */
function Wrapper(object) {
    if (object instanceof Wrapper) {
        return object;
    }
    if (!(this instanceof Wrapper)) {
        return new Wrapper(object);
    }
    this.originalValue = object;
    this.o = object || {};
}

/**
 * @name Wrapper.chain
 * @summary Wrap an object for a chain of method calls.
 * @Desc Calls the constructor `Wrapper()` and modifies the wrapper for chaining.
 * @param {object} object
 * @return {Wrapper} The wrapped object.
 */
Wrapper.chain = function (object) {
    var wrapped = Wrapper(object); // eslint-disable-line new-cap
    wrapped.chaining = true;
    return wrapped;
};

Wrapper.prototype = {
    /**
     * Unwrap an object wrapped with {@link Wrapper.chain|Wrapper.chain()}.
     * @return {object|null|undefined} The value originally wrapped by the constructor.
     * @memberOf Wrapper.prototype
     */
    value: function () {
        return this.originalValue;
    },

    /**
     * @desc Mimics Underscore's [each](http://underscorejs.org/#each) method: Iterate over the members of the wrapped object, calling `iteratee()` with each.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is undefined; an `.each` loop cannot be broken out of (use {@link Wrapper#find|.find} instead).
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {Wrapper} The wrapped object for chaining.
     * @memberOf Wrapper.prototype
     */
    each: function (iteratee, context) {
        var o = this.o;
        Object.keys(o).forEach(function (key) {
            iteratee.call(this, o[key], key, o);
        }, context || o);
        return this;
    },

    /**
     * @desc Mimics Underscore's [find](http://underscorejs.org/#find) method: Look through each member of the wrapped object, returning the first one that passes a truth test (`predicate`), or `undefined` if no value passes the test. The function returns the value of the first acceptable member, and doesn't necessarily traverse the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The found property's value, or undefined if not found.
     * @memberOf Wrapper.prototype
     */
    find: function (predicate, context) {
        var o = this.o;
        var result;
        if (o) {
            result = Object.keys(o).find(function (key) {
                return predicate.call(this, o[key], key, o);
            }, context || o);
            if (result !== undefined) {
                result = o[result];
            }
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [filter](http://underscorejs.org/#filter) method: Look through each member of the wrapped object, returning the values of all members that pass a truth test (`predicate`), or empty array if no value passes the test. The function always traverses the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} An array containing the filtered values.
     * @memberOf Wrapper.prototype
     */
    filter: function (predicate, context) {
        var o = this.o;
        var result = [];
        if (o) {
            Object.keys(o).forEach(function (key) {
                if (predicate.call(this, o[key], key, o)) {
                    result.push(o[key]);
                }
            }, context || o);
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [map](http://underscorejs.org/#map) method: Produces a new array of values by mapping each value in list through a transformation function (`iteratee`). The function always traverses the entire object.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is concatenated to the end of the new array.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} An array containing the filtered values.
     * @memberOf Wrapper.prototype
     */
    map: function (iteratee, context) {
        var o = this.o;
        var result = [];
        if (o) {
            Object.keys(o).forEach(function (key) {
                result.push(iteratee.call(this, o[key], key, o));
            }, context || o);
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [reduce](http://underscorejs.org/#reduce) method: Boil down the values of all the members of the wrapped object into a single value. `memo` is the initial state of the reduction, and each successive step of it should be returned by `iteratee()`.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with four arguments: `(memo, value, key, object)`. The return value of this function becomes the new value of `memo` for the next iteration.
     * @param {*} [memo] - If no memo is passed to the initial invocation of reduce, the iteratee is not invoked on the first element of the list. The first element is instead passed as the memo in the invocation of the iteratee on the next element in the list.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The value of `memo` "reduced" as per `iteratee`.
     * @memberOf Wrapper.prototype
     */
    reduce: function (iteratee, memo, context) {
        var o = this.o;
        if (o) {
            Object.keys(o).forEach(function (key, idx) {
                memo = (!idx && memo === undefined) ? o[key] : iteratee(memo, o[key], key, o);
            }, context || o);
        }
        return memo;
    },

    /**
     * @desc Mimics Underscore's [extend](http://underscorejs.org/#extend) method: Copy all of the properties in each of the `source` object parameter(s) over to the (wrapped) destination object (thus mutating it). It's in-order, so the properties of the last `source` object will override properties with the same name in previous arguments or in the destination object.
     * > This method copies own members as well as members inherited from prototype chain.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extend: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            if (object) {
                for (var key in object) {
                    o[key] = object[key];
                }
            }
        });
        return this.chaining ? this : o;
    },

    /**
     * @desc Mimics Underscore's [extendOwn](http://underscorejs.org/#extendOwn) method: Like {@link Wrapper#extend|extend}, but only copies its "own" properties over to the destination object.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extendOwn: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            Wrapper(object).each(function (val, key) { // eslint-disable-line new-cap
                o[key] = val;
            });
        });
        return this.chaining ? this : o;
    }
};

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
if (!Array.prototype.find) {
    Array.prototype.find = function (predicate) { // eslint-disable-line no-extend-native
        if (this === null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return value;
            }
        }
        return undefined;
    };
}

module.exports = Wrapper;

},{}],25:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var REGEXP_INDIRECTION = /^(\w+)\((\w+)\)$/;  // finds complete pattern a(b) where both a and b are regex "words"

/** @typedef {object} valueItem
 * You should supply both `name` and `alias` but you could omit one or the other and whichever you provide will be used for both.
 * > If you only give the `name` property, you might as well just give a string for {@link menuItem} rather than this object.
 * @property {string} [name=alias] - Value of `value` attribute of `<option>...</option>` element.
 * @property {string} [alias=name] - Text of `<option>...</option>` element.
 * @property {string} [type] One of the keys of `this.converters`. If not one of these (including `undefined`), field values will be tested with a string comparison.
 * @property {boolean} [hidden=false]
 */

/** @typedef {object|menuItem[]} submenuItem
 * @summary Hierarchical array of select list items.
 * @desc Data structure representing the list of `<option>...</option>` and `<optgroup>...</optgroup>` elements that make up a `<select>...</select>` element.
 *
 * > Alternate form: Instead of an object with a `menu` property containing an array, may itself be that array. Both forms have the optional `label` property.
 * @property {string} [label] - Defaults to a generated string of the form "Group n[.m]..." where each decimal position represents a level of the optgroup hierarchy.
 * @property {menuItem[]} submenu
 */

/** @typedef {string|valueItem|submenuItem} menuItem
 * May be one of three possible types that specify either an `<option>....</option>` element or an `<optgroup>....</optgroup>` element as follows:
 * * If a `string`, specifies the text of an `<option>....</option>` element with no `value` attribute. (In the absence of a `value` attribute, the `value` property of the element defaults to the text.)
 * * If shaped like a {@link valueItem} object, specifies both the text and value of an `<option....</option>` element.
 * * If shaped like a {@link submenuItem} object (or its alternate array form), specifies an `<optgroup>....</optgroup>` element.
 */

/**
 * @summary Builds a new menu prepopulated with items and groups.
 * @desc This function creates a new pop-up menu (a.k.a. "drop-down"). This is a `<select>...</select>` element, prepopulated with items (`<option>...</option>` elements) and groups (`<optgroup>...</optgroup>` elements).
 * > Bonus: This function also builds `input type=text` elements.
 * @memberOf popMenu
 *
 * @param {Element|string} el - Must be one of (case-sensitive):
 * * text box - an `HTMLInputElement` to use an existing element or `'INPUT'` to create a new one
 * * drop-down - an `HTMLSelectElement` to use an existing element or `'SELECT'` to create a new one
 * * submenu - an `HTMLOptGroupElement` to use an existing element or `'OPTGROUP'` to create a new one (meant for internal use only)
 *
 * @param {menuItem[]} [menu] - Hierarchical list of strings to add as `<option>...</option>` or `<optgroup>....</optgroup>` elements. Omitting creates a text box.
 *
 * @param {null|string} [options.prompt=''] - Adds an initial `<option>...</option>` element to the drop-down with this value in parentheses as its `text`; and empty string as its `value`. Default is empty string, which creates a blank prompt; `null` suppresses prompt altogether.
 *
 * @param {boolean} [options.sort] - Whether to alpha sort or not. If truthy, sorts each optgroup on its `label`; and each select option on its text (its `alias` if given; or its `name` if not).
 *
 * @param {string[]} [options.blacklist] - Optional list of menu item names to be ignored.
 *
 * @param {number[]} [options.breadcrumbs] - List of option group section numbers (root is section 0). (For internal use.)
 *
 * @param {boolean} [options.append=false] - When `el` is an existing `<select>` Element, giving truthy value adds the new children without first removing existing children.
 *
 * @returns {Element} Either a `<select>` or `<optgroup>` element.
 */
function build(el, menu, options) {
    options = options || {};

    var prompt = options.prompt,
        blacklist = options.blacklist,
        sort = options.sort,
        breadcrumbs = options.breadcrumbs || [],
        path = breadcrumbs ? breadcrumbs.join('.') + '.' : '',
        tagName;

    if (el instanceof Element) {
        tagName = el.tagName;
        if (!options.append) {
            el.innerHTML = ''; // remove all <option> and <optgroup> elements
        }
    } else {
        tagName = el;
        el = document.createElement(tagName);
    }

    if (menu) {
        var add, newOption;
        if (tagName === 'SELECT') {
            add = el.add;
            if (prompt) {
                newOption = new Option(prompt, '');
                newOption.innerHTML += '&hellip;';
                el.add(newOption);
            } else if (prompt !== null) {
                el.add(new Option());
            }
        } else {
            add = el.appendChild;
            el.label = prompt;
        }

        if (sort) {
            menu = menu.slice().sort(itemComparator); // sorted clone
        }

        menu.forEach(function(item, index) {
            // if item is of form a(b) and there is an function a in options, then item = options.a(b)
            if (options && typeof item === 'string') {
                var indirection = item.match(REGEXP_INDIRECTION);
                if (indirection) {
                    var a = indirection[1],
                        b = indirection[2],
                        f = options[a];
                    if (typeof f === 'function') {
                        item = f(b);
                    } else {
                        throw 'build: Expected options.' + a + ' to be a function.';
                    }
                }
            }

            var submenu = item.submenu || item;
            if (submenu instanceof Array) {

                var groupOptions = {
                    breadcrumbs: breadcrumbs.concat(index + 1),
                    prompt: item.label || 'Group ' + path + (index + 1),
                    options: sort,
                    blacklist: blacklist
                };

                var optgroup = build('OPTGROUP', submenu, groupOptions);

                if (optgroup.childElementCount) {
                    el.add(optgroup);
                }

            } else if (typeof item !== 'object') {

                if (!(blacklist && blacklist.indexOf(item) >= 0)) {
                    add.call(el, new Option(item));
                }

            } else if (!item.hidden) {

                var name = item.name || item.alias;
                if (!(blacklist && blacklist.indexOf(name) >= 0)) {
                    add.call(el, new Option(
                        item.alias || item.name,
                        name
                    ));
                }

            }
        });
    } else {
        el.type = 'text';
    }

    return el;
}

function itemComparator(a, b) {
    a = a.alias || a.name || a.label || a;
    b = b.alias || b.name || b.label || b;
    return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * @summary Recursively searches `menu` for a named `item`.
 * @memberOf popMenu
 * @param {menuItem[]} menu
 * @param {string} name
 * @returns {undefined|menuItem} The found item or `undefined` if not found.
 */
function findItem(menu, name) {
    var shallow, deep, item;

    shallow = menu.find(function(item) {
        var submenu = item.submenu || item;
        if (submenu instanceof Array) {
            return (deep = findItem(submenu, name));
        } else {
            return (item.name || item) === name;
        }
    });

    item = deep || shallow;

    return item && (item.name ? item : { name: item });
}

/**
 * @summary Recursively walks `menu` and calls `iteratee` on field.
 * @desc Iteratee is called with each item (terminal node) in the menu tree and a flat 0-based index.
 *
 * The node will always be a {@link valueItem} object; when a `string`, it is boxed for you.
 *
 * @memberOf popMenu
 * @param {menuItem[]} menu
 * @param {function} iteratee
 * @returns {number} Number of items (terminal nodes) in the menu tree.
 */
function walk(menu, iteratee) {
    var n = 0;

    menu.forEach(function(item) {
        var submenu = item.submenu || item;
        if (submenu instanceof Array) {
            n += walk(submenu, iteratee);
        } else {
            iteratee(item.name ? item : { name: item }, n);
            n += 1;
        }
    });

    return n;
}

/**
 * @summary Format item name with it's alias when available.
 * @memberOf popMenu
 * @param {string|valueItem} item
 * @returns {string} The formatted name and alias.
 */
function formatItem(item) {
    var result = item.name || item;
    if (item.alias) {
        result = '"' + item.alias + '" (' + result + ')';
    }
    return result;
}


function isGroupProxy(s) {
    return REGEXP_INDIRECTION.test(s);
}

/**
 * @namespace
 */
var popMenu = {
    build: build,
    walk: walk,
    findItem: findItem,
    formatItem: formatItem,
    isGroupProxy: isGroupProxy
};

module.exports = popMenu;

},{}],26:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

/**
 * Creates a new read-only property and attaches it to the provided context.
 * @private
 * @param {string} name - Name for new property.
 * @param {*} [value] - Value of new property.
 */
function addReadOnlyProperty(name, value) {
    Object.defineProperty(this, name, {
        value: value,
        writable: false,
        enumerable: true,
        configurable: false
    });
}

/**
 * @constructor Point
 *
 * @desc This object represents a single point in an abstract 2-dimensional matrix.
 *
 * The unit of measure is typically pixels.
 * (If used to model computer graphics, vertical coordinates are typically measured downwards
 * from the top of the window. This convention however is not inherent in this object.)
 *
 * Note: This object should be instantiated with the `new` keyword.
 *
 * @param {number} x - the new point's `x` property
 * @param {number} y - the new point's `y` property
 */
function Point(x, y) {

    /**
     * @name x
     * @type {number}
     * @summary This point's horizontal coordinate.
     * @desc Created upon instantiation by the {@link Point|constructor}.
     * @memberOf Point.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'x', Number(x) || 0);

    /**
     * @name y
     * @type {number}
     * @summary This point's vertical coordinate.
     * @desc Created upon instantiation by the {@link Point|constructor}.
     * @memberOf Point.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'y', Number(y) || 0);

}

Point.prototype = {

    /**
     * @returns {Point} A new point which is this point's position increased by coordinates of given `offset`.
     * @param {Point} offset - Horizontal and vertical values to add to this point's coordinates.
     * @memberOf Point.prototype
     */
    plus: function(offset) {
        return new Point(
            this.x + offset.x,
            this.y + offset.y
        );
    },

    /**
     * @returns {Point} A new point which is this point's position increased by given offsets.
     * @param {number} [offsetX=0] - Value to add to this point's horizontal coordinate.
     * @param {number} [offsetY=0] - Value to add to this point's horizontal coordinate.
     * @memberOf Point.prototype
     */
    plusXY: function(offsetX, offsetY) {
        return new Point(
            this.x + (offsetX || 0),
            this.y + (offsetY || 0)
        );
    },

    /**
     * @returns {Point} A new point which is this point's position decreased by coordinates of given `offset`.
     * @param {Point} offset - Horizontal and vertical values to subtract from this point's coordinates.
     * @memberOf Point.prototype
     */
    minus: function(offset) {
        return new Point(
            this.x - offset.x,
            this.y - offset.y
        );
    },

    /**
     * @returns {Point} A new `Point` positioned to least x and least y of this point and given `offset`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    min: function(point) {
        return new Point(
            Math.min(this.x, point.x),
            Math.min(this.y, point.y)
        );
    },

    /**
     * @returns {Point} A new `Point` positioned to greatest x and greatest y of this point and given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    max: function(point) {
        return new Point(
            Math.max(this.x, point.x),
            Math.max(this.y, point.y)
        );
    },

    /**
     * @returns {number} Distance between given `point` and this point using Pythagorean Theorem formula.
     * @param {Point} point - A point from which to compute the distance to this point.
     * @memberOf Point.prototype
     */
    distance: function(point) {
        var deltaX = point.x - this.x,
            deltaY = point.y - this.y;

        return Math.sqrt(
            deltaX * deltaX +
            deltaY * deltaY
        );
    },

    /**
     * _(Formerly: `equal`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are exactly equal to those of given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    equals: function(point) {
        var result = false;

        if (point) {
            result =
                this.x === point.x &&
                this.y === point.y;
        }

        return result;
    },

    /**
     * @returns {boolean} `true` iff _both_ coordinates of this point are greater than those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    greaterThan: function(point) {
        return (
            this.x > point.x &&
            this.y > point.y
        );
    },

    /**
     * @returns {boolean} `true` iff _both_ coordinates of this point are less than those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    lessThan: function(point) {
        return (
            this.x < point.x &&
            this.y < point.y
        );
    },

    /**
     * _(Formerly `greaterThanEqualTo`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are greater than or equal to those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    greaterThanOrEqualTo: function(point) {
        return (
            this.x >= point.x &&
            this.y >= point.y
        );
    },

    /**
     * _(Formerly `lessThanEqualTo`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are less than or equal to those of given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    lessThanOrEqualTo: function(point) {
        return (
            this.x <= point.x &&
            this.y <= point.y
        );
    },

    /**
     * _(Formerly `isContainedWithinRectangle`.)_
     * @param rect {Rectangle} - Rectangle to test this point against.
     * @returns {boolean} `true` iff this point is within given `rect`.
     * @memberOf Point.prototype
     */
    within: function(rect) {
        var minX = rect.origin.x,
            maxX = minX + rect.extent.x;
        var minY = rect.origin.y,
            maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        return (
            minX <= this.x && this.x < maxX &&
            minY <= this.y && this.y < maxY
        );
    }
};

Point.prototype.EQ = Point.prototype.equals;
Point.prototype.GT = Point.prototype.greaterThan;
Point.prototype.LT = Point.prototype.lessThan;
Point.prototype.GE = Point.prototype.greaterThanOrEqualTo;
Point.prototype.LE = Point.prototype.lessThanOrEqualTo;


/**
 * @constructor Rectangle
 *
 * @desc This object represents a rectangular area within an abstract 2-dimensional matrix.
 *
 * The unit of measure is typically pixels.
 * (If used to model computer graphics, vertical coordinates are typically measured downwards
 * from the top of the window. This convention however is not inherent in this object.)
 *
 * Normally, the `x` and `y` parameters to the constructor describe the upper left corner of the rect.
 * However, negative values of `width` and `height` will be added to the given `x` and `y`. That is,
 * a negative value of the `width` parameter will extend the rect to the left of the given `x` and
 * a negative value of the `height` parameter will extend the rect above the given `y`.
 * In any case, after instantiation the following are guaranteed to always be true:
 * * The `extent`, `width`, and `height` properties _always_ give positive values.
 * * The `origin`, `top`, and `left` properties _always_ reflect the upper left corner.
 * * The `corner`, `bottom`, and `right` properties _always_ reflect the lower right corner.
 *
 * Note: This object should be instantiated with the `new` keyword.
 *
 * @param {number} [x=0] - Horizontal coordinate of some corner of the rect.
 * @param {number} [y=0] - Vertical coordinate of some corner of the rect.
 * @param {number} [width=0] - Width of the new rect. May be negative (see above).
 * @param {number} [height=0] - Height of the new rect. May be negative (see above).
 */
function Rectangle(x, y, width, height) {

    x = Number(x) || 0;
    y = Number(y) || 0;
    width = Number(width) || 0;
    height = Number(height) || 0;

    if (width < 0) {
        x += width;
        width = -width;
    }

    if (height < 0) {
        y += height;
        height = -height;
    }

    /**
     * @name origin
     * @type {Point}
     * @summary Upper left corner of this rect.
     * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'origin', new Point(x, y));

    /**
     * @name extent
     * @type {Point}
     * @summary this rect's width and height.
     * @desc Unlike the other `Point` properties, `extent` is not a global coordinate pair; rather it consists of a _width_ (`x`, always positive) and a _height_ (`y`, always positive).
     *
     * This object might be more legitimately typed as something like `Area` with properties `width` and `height`; however we wanted it to be able to use it efficiently with a point's `plus` and `minus` methods (that is, without those methods having to check and branch on the type of its parameter).
     *
     * Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @see The {@link Rectangle#corner|corner} method.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'extent', new Point(width, height));

    /**
     * @name corner
     * @type {Point}
     * @summary Lower right corner of this rect.
     * @desc This is a calculated value created upon instantiation by the {@linkplain Rectangle|constructor}. It is `origin` offset by `extent`.
     *
     * **Note:** These coordinates actually point to the pixel one below and one to the right of the rect's actual lower right pixel.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'corner', new Point(x + width, y + height));

    /**
     * @name center
     * @type {Point}
     * @summary Center of this rect.
     * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'center', new Point(x + (width / 2), y + (height / 2)));

}

Rectangle.prototype = {

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Minimum vertical coordinate of this rect.
     * @memberOf Rectangle.prototype
     */
    get top() {
        return this.origin.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Minimum horizontal coordinate of this rect.
     * @memberOf Rectangle.prototype
     */
    get left() {
        return this.origin.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Maximum vertical coordinate of this rect + 1.
     * @memberOf Rectangle.prototype
     */
    get bottom() {
        return this.corner.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Maximum horizontal coordinate of this rect + 1.
     * @memberOf Rectangle.prototype
     */
    get right() {
        return this.corner.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Width of this rect (always positive).
     * @memberOf Rectangle.prototype
     */
    get width() {
        return this.extent.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Height of this rect (always positive).
     * @memberOf Rectangle.prototype
     */
    get height() {
        return this.extent.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Area of this rect.
     * @memberOf Rectangle.prototype
     */
    get area() {
        return this.width * this.height;
    },

    /**
     * @returns {Rectangle} A copy of this rect but with horizontal position reset to given `x` and no width.
     * @param {number} x - Horizontal coordinate of the new rect.
     * @memberOf Rectangle.prototype
     */
    flattenXAt: function(x) {
        return new Rectangle(x, this.origin.y, 0, this.extent.y);
    },

    /**
     * @returns {Rectangle} A copy of this rect but with vertical position reset to given `y` and no height.
     * @param {number} y - Vertical coordinate of the new rect.
     * @memberOf Rectangle.prototype
     */
    flattenYAt: function(y) {
        return new Rectangle(this.origin.x, y, this.extent.x, 0);
    },

    /**
     * @returns {boolean} `true` iff given `point` entirely contained within this rect.
     * @param {Point} pointOrRect - The point or rect to test for containment.
     * @memberOf Rectangle.prototype
     */
    contains: function(pointOrRect) {
        return pointOrRect.within(this);
    },

    /**
     * _(Formerly `isContainedWithinRectangle`.)_
     * @returns {boolean} `true` iff `this` rect is entirely contained within given `rect`.
     * @param {Rectangle} rect - Rectangle to test against this rect.
     * @memberOf Rectangle.prototype
     */
    within: function(rect) {
        return (
            rect.origin.lessThanOrEqualTo(this.origin) &&
            rect.corner.greaterThanOrEqualTo(this.corner)
        );
    },

    /**
     * _(Formerly: `insetBy`.)_
     * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
     * @param {number} padding - Amount by which to increase (+) or decrease (-) this rect
     * @see The {@link Rectangle#shrinkBy|shrinkBy} method.
     * @memberOf Rectangle.prototype
     */
    growBy: function(padding) {
        return new Rectangle(
            this.origin.x + padding,
            this.origin.y + padding,
            this.extent.x - padding - padding,
            this.extent.y - padding - padding);
    },

    /**
     * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
     * @param {number} padding - Amount by which to decrease (+) or increase (-) this rect.
     * @see The {@link Rectangle#growBy|growBy} method.
     * @memberOf Rectangle.prototype
     */
    shrinkBy: function(padding) {
        return this.growBy(-padding);
    },

    /**
     * @returns {Rectangle} Bounding rect that contains both this rect and the given `rect`.
     * @param {Rectangle} rect - The rectangle to union with this rect.
     * @memberOf Rectangle.prototype
     */
    union: function(rect) {
        var origin = this.origin.min(rect.origin),
            corner = this.corner.max(rect.corner),
            extent = corner.minus(origin);

        return new Rectangle(
            origin.x, origin.y,
            extent.x, extent.y
        );
    },

    /**
     * iterate over all points within this rect, invoking `iteratee` for each.
     * @param {function(number,number)} iteratee - Function to call for each point.
     * Bound to `context` when given; otherwise it is bound to this rect.
     * Each invocation of `iteratee` is called with two arguments:
     * the horizontal and vertical coordinates of the point.
     * @param {object} [context=this] - Context to bind to `iteratee` (when not `this`).
     * @memberOf Rectangle.prototype
     */
    forEach: function(iteratee, context) {
        context = context || this;
        for (var x = this.origin.x, x2 = this.corner.x; x < x2; x++) {
            for (var y = this.origin.y, y2 = this.corner.y; y < y2; y++) {
                iteratee.call(context, x, y);
            }
        }
    },

    /**
     * @returns {Rectangle} One of:
     * * _If this rect intersects with the given `rect`:_
     *      a new rect representing that intersection.
     * * _If it doesn't intersect and `ifNoneAction` defined:_
     *      result of calling `ifNoneAction`.
     * * _If it doesn't intersect and `ifNoneAction` undefined:_
     *      `null`.
     * @param {Rectangle} rect - The rectangle to intersect with this rect.
     * @param {function(Rectangle)} [ifNoneAction] - When no intersection, invoke and return result.
     * Bound to `context` when given; otherwise bound to this rect.
     * Invoked with `rect` as sole parameter.
     * @param {object} [context=this] - Context to bind to `ifNoneAction` (when not `this`).
     * @memberOf Rectangle.prototype
     */
    intersect: function(rect, ifNoneAction, context) {
        var result = null,
            origin = this.origin.max(rect.origin),
            corner = this.corner.min(rect.corner),
            extent = corner.minus(origin);

        if (extent.x > 0 && extent.y > 0) {
            result = new Rectangle(
                origin.x, origin.y,
                extent.x, extent.y
            );
        } else if (typeof ifNoneAction === 'function') {
            result = ifNoneAction.call(context || this, rect);
        }

        return result;
    },

    /**
     * @returns {boolean} `true` iff this rect overlaps with given `rect`.
     * @param {Rectangle} rect - The rectangle to intersect with this rect.
     * @memberOf Rectangle.prototype
     */
    intersects: function(rect) {
        return (
            rect.corner.x > this.origin.x &&
            rect.corner.y > this.origin.y &&
            rect.origin.x < this.corner.x &&
            rect.origin.y < this.corner.y
        );
    }
};

// Interface
exports.Point = Point;
exports.Rectangle = Rectangle;

},{}],27:[function(require,module,exports){
'use strict';

var // a regex search pattern that matches all the reserved chars of a regex search pattern
    reserved = /([\.\\\+\*\?\^\$\(\)\{\}\=\!\<\>\|\:\[\]])/g,

    // regex wildcard search patterns
    REGEXP_WILDCARD = '.*',
    REGEXP_WILDCHAR = '.',
    REGEXP_WILDCARD_MATCHER = '(' + REGEXP_WILDCARD + ')',

    // LIKE search patterns
    LIKE_WILDCHAR = '_',
    LIKE_WILDCARD = '%',

    // regex search patterns that match LIKE search patterns
    REGEXP_LIKE_PATTERN_MATCHER = new RegExp('(' + [
        LIKE_WILDCHAR,
        LIKE_WILDCARD,
        '\\[\\^?[^-\\]]+]', // matches a LIKE set (same syntax as a RegExp set)
        '\\[\\^?[^-\\]]\\-[^\\]]]' // matches a LIKE range (same syntax as a RegExp range)
    ].join('|') + ')', 'g');

function regExpLIKE(pattern, ignoreCase) {
    var i, parts;

    // Find all LIKE patterns
    parts = pattern.match(REGEXP_LIKE_PATTERN_MATCHER);

    if (parts) {
        // Translate found LIKE patterns to regex patterns, escaped intervening non-patterns, and interleave the two

        for (i = 0; i < parts.length; ++i) {
            // Escape left brackets (unpaired right brackets are OK)
            if (parts[i][0] === '[') {
                parts[i] = regExpLIKE.reserve(parts[i]);
            }

            // Make each found pattern matchable by enclosing in parentheses
            parts[i] = '(' + parts[i] + ')';
        }

        // Match these precise patterns again with their intervening non-patterns (i.e., text)
        parts = pattern.match(new RegExp(
            REGEXP_WILDCARD_MATCHER +
            parts.join(REGEXP_WILDCARD_MATCHER)  +
            REGEXP_WILDCARD_MATCHER
        ));

        // Discard first match of non-global search (which is the whole string)
        parts.shift();

        // For each re-found pattern part, translate % and _ to regex equivalent
        for (i = 1; i < parts.length; i += 2) {
            var part = parts[i];
            switch (part) {
                case LIKE_WILDCARD: part = REGEXP_WILDCARD; break;
                case LIKE_WILDCHAR: part = REGEXP_WILDCHAR; break;
                default:
                    var j = part[1] === '^' ? 2 : 1;
                    part = '[' + regExpLIKE.reserve(part.substr(j, part.length - (j + 1))) + ']';
            }
            parts[i] = part;
        }
    } else {
        parts = [pattern];
    }

    // For each surrounding text part, escape reserved regex chars
    for (i = 0; i < parts.length; i += 2) {
        parts[i] = regExpLIKE.reserve(parts[i]);
    }

    // Join all the interleaved parts
    parts = parts.join('');

    // Optimize or anchor the pattern at each end as needed
    if (parts.substr(0, 2) === REGEXP_WILDCARD) { parts = parts.substr(2); } else { parts = '^' + parts; }
    if (parts.substr(-2, 2) === REGEXP_WILDCARD) { parts = parts.substr(0, parts.length - 2); } else { parts += '$'; }

    // Return the new regex
    return new RegExp(parts, ignoreCase ? 'i' : undefined);
}

regExpLIKE.reserve = function (s) {
    return s.replace(reserved, '\\$1');
};

var cache, size;

/**
 * @summary Delete a pattern from the cache; or clear the whole cache.
 * @param {string} [pattern] - The LIKE pattern to remove from the cache. Fails silently if not found in the cache. If pattern omitted, clears whole cache.
 */
(regExpLIKE.clearCache = function (pattern) {
    if (!pattern) {
        cache = {};
        size = 0;
    } else if (cache[pattern]) {
        delete cache[pattern];
        size--;
    }
    return size;
})(); // init the cache

regExpLIKE.getCacheSize = function () { return size; };

/**
 * @summary Cached version of `regExpLIKE()`.
 * @desc Cached entries are subject to garbage collection if `keep` is `undefined` or `false` on insertion or `false` on most recent reference. Garbage collection will occur iff `regExpLIKE.cacheMax` is defined and it equals the number of cached patterns. The garbage collector sorts the patterns based on most recent reference; the oldest 10% of the entries are deleted. Alternatively, you can manage the cache yourself to a limited extent (see {@link regeExpLIKE.clearCache|clearCache}).
 * @param pattern - the LIKE pattern (to be) converted to a RegExp
 * @param [keep] - If given, changes the keep status for this pattern as follows:
 * * `true` permanently caches the pattern (not subject to garbage collection) until `false` is given on a subsequent call
 * * `false` allows garbage collection on the cached pattern
 * * `undefined` no change to keep status
 * @returns {RegExp}
 */
regExpLIKE.cached = function (keep, pattern, ignoreCase) {
    if (typeof keep === 'string') {
        ignoreCase = pattern;
        pattern = keep;
        keep = false;
    }
    var patternAndCase = pattern + (ignoreCase ? 'i' : 'c'),
        item = cache[patternAndCase];
    if (item) {
        item.when = new Date().getTime();
        if (keep !== undefined) {
            item.keep = keep;
        }
    } else {
        if (size === regExpLIKE.cacheMax) {
            var age = [], ages = 0, key, i;
            for (key in cache) {
                item = cache[key];
                if (!item.keep) {
                    for (i = 0; i < ages; ++i) {
                        if (item.when < age[i].item.when) {
                            break;
                        }
                    }
                    age.splice(i, 0, { key: key, item: item });
                    ages++;
                }
            }
            if (!age.length) {
                return regExpLIKE(pattern, ignoreCase); // cache is full!
            }
            i = Math.ceil(age.length / 10); // will always be at least 1
            size -= i;
            while (i--) {
                delete cache[age[i].key];
            }
        }
        item = cache[patternAndCase] = {
            regex: regExpLIKE(pattern, ignoreCase),
            keep: keep,
            when: new Date().getTime()
        };
        size++;
    }
    return item.regex;
};

module.exports = regExpLIKE;

},{}],28:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

(function (module) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See https://github.com/joneit/mnm.

    /**
     * @constructor RangeSelectionModel
     *
     * @desc This object models selection of "cells" within an abstract single-dimensional matrix.
     *
     * Disjoint selections can be built with calls to the following methods:
     * * {@link RangeSelectionModel#select|select(start, stop)} - Add a range to the matrix.
     * * {@link RangeSelectionModel#deselect|deselect(start, stop)} - Remove a range from the matrix.
     *
     * Two more methods are available:
     * * Test a cell to see if it {@link RangeSelectionModel#isSelected|isSelected(cell)}
     * * {@link RangeSelectionModel#clear|clear()} the matrix
     *
     * Internally, the selection is run-length-encoded. It is therefore a "sparse" matrix
     * with undefined bounds. A single data property called `selection` is an array that
     * contains all the "runs" (ranges) of selected cells albeit in no particular order.
     * This property should not normally need to be accessed directly.
     *
     * Note: This object should be instantiated with the `new` keyword.
     *
     * @returns {RangeSelectionModel} Self (i.e., `this` object).
     */
    function RangeSelectionModel() {
        /**
         * @name selection
         * @type {Array.Array.number}
         * @summary Unordered list of runs.
         * @desc A "run" is defined as an Array(2) where:
         * * element [0] is the beginning of the run
         * * element [1] is the end of the run (inclusive) and is always >= element [0]
         * The order of the runs within is undefined.
         * @memberOf RangeSelectionModel.prototype
         * @abstract
         */
        this.selection = [];

        //we need to be able to go back in time
        //the states field
        this.states = [];

        //clone and store my current state
        //so we can unwind changes if need be
        this.storeState = function () {
            var sels = this.selection;
            var state = [];
            var copy;
            for (var i = 0; i < sels.length; i++) {
                copy = [].concat(sels[i]);
                state.push(copy);
            }
            this.states.push(state);
        };
    }

    RangeSelectionModel.prototype = {

        /**
         * @summary Add a contiguous run of points to the selection.
         * @desc Insert a new run into `this.selection`.
         * The new run will be merged with overlapping and adjacent runs.
         *
         * The two parameters may be given in either order.
         * The start and stop elements in the resulting run will however always be ordered.
         * (However, note that the order of the runs within `this.selection` is itself always unordered.)
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        select: function (start, stop) {
            this.storeState();
            var run = makeRun(start, stop);
            var splicer = [0, 1];
            this.selection.forEach(function (each) {
                if (overlaps(each, run) || abuts(each, run)) {
                    run = merge(each, run);
                } else {
                    splicer.push(each);
                }
            });
            splicer.push(run);
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Remove a contiguous run of points from the selection.
         * @desc Truncate and/or remove run(s) from `this.selection`.
         * Removing part of existing runs will (correctly) shorten them or break them into two fragments.
         *
         * The two parameters may be given in either order.
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        deselect: function (start, stop) {
            var run = makeRun(start, stop);
            var splicer = [0, 0];
            this.selection.forEach(function (each) {
                if (overlaps(each, run)) {
                    var pieces = subtract(each, run);
                    splicer = splicer.concat(pieces);
                } else {
                    splicer.push(each);
                }
            });
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Empties `this.selection`, effectively removing all runs.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        clear: function () {
            this.states.length = 0;
            this.selection.length = 0;
            return this;
        },

        clearMostRecentSelection: function () {
            if (this.states.length === 0) {
                return;
            }
            this.selection = this.states.pop();
        },

        /**
         * @summary Determines if the given `cell` is selected.
         * @returns {boolean} `true` iff given `cell` is within any of the runs in `this.selection`.
         * @param {number} cell - The cell to test for inclusion in the selection.
         * @memberOf RangeSelectionModel.prototype
         */
        isSelected: function (cell) {
            return this.selection.some(function (each) {
                return each[0] <= cell && cell <= each[1];
            });
        },

        isEmpty: function (){
            return this.selection.length === 0;
        },

        /**
         * @summary Return the indexes that are selected.
         * @desc Return the indexes that are selected.
         * @returns {Array.Array.number}
         * @memberOf RangeSelectionModel.prototype
         */
        getSelections: function (){
            var result = [];
            this.selection.forEach(function (each) {
                for (var i = each[0]; i <= each[1]; i++) {
                    result.push(i);
                }
            });
            result.sort(function (a, b){
                return a - b;
            });
            return result;
        }

    };

    /**
     * @private
     * @summary Preps `start` and `stop` params into order array
     * @function makeRun
     * @desc Utility function called by both `select()` and `deselect()`.
     * @param {number|number[]} start - Start of run. if array, `start` and `stop` are taken from first two elements.
     * @param {number} [stop=start] - End of run (inclusive).
     */
    function makeRun(start, stop) {
        return (
            start instanceof Array
                ? makeRun.apply(this, start) // extract params from given array
                : stop === undefined
                ? [ start, start ] // single param is a run that stops where it starts
                : start <= stop
                ? [ start, stop ]
                : [ stop, start ] // reverse descending params into ascending order
        );
    }

    /**
     * @private
     * @function overlaps
     * @returns {boolean} `true` iff `run1` overlaps `run2`
     * @summary Comparison operator that determines if given runs overlap with one another.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Overlap is defined to include the case where one run completely contains the other.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function overlaps(run1, run2) {
        return (
            run1[0] <= run2[0] && run2[0] <= run1[1] || // run2's start is within run1 OR...
            run1[0] <= run2[1] && run2[1] <= run1[1] || // run2's stop is within run1 OR...
            run2[0] <  run1[0] && run1[1] <  run2[1]    // run2 completely contains run1
        );
    }

    /**
     * @private
     * @function abuts
     * @summary Comparison operator that determines if given runs are consecutive with one another.
     * @returns {boolean} `true` iff `run1` is consecutive with `run2`
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function abuts(run1, run2) {
        return (
            run1[1] === run2[0] - 1 || // run1's top immediately precedes run2's start OR...
            run2[1] === run1[0] - 1    // run2's top immediately precedes run1's start
        );
    }

    /**
     * @private
     * @function subtract
     * @summary Operator that subtracts one run from another.
     * @returns {Array.Array.number} The remaining pieces of `minuend` after removing `subtrahend`.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * This function _does not assumes_ that `overlap()` has already been called with the same runs and has returned `true`.
     *
     * Returned array contains 0, 1, or 2 runs which are the portion(s) of `minuend` that do _not_ include `subtrahend`.
     *
     * Caveat: This operator is *not* commutative.
     * @param {number[]} minuend - a run from which to "subtract" `subtrahend`
     * @param {number[]} subtrahend - a run to "subtracted" from `minuend`
     */
    function subtract(minuend, subtrahend) {
        var m0 = minuend[0];
        var m1 = minuend[1];
        var s0 = subtrahend[0];
        var s1 = subtrahend[1];
        var result = [];

        if (s0 <= m0 && s1 < m1) {
            //subtrahend extends before minuend: return remaining piece of `minuend`
            result.push([s1 + 1, m1]);
        } else if (s0 > m0 && s1 >= m1) {
            //subtrahend extends after minuend: return remaining piece of `minuend`
            result.push([m0, s0 - 1]);
        } else if (m0 < s0 && s1 < m1) {
            //completely inside: return 2 smaller pieces resulting from the hole
            result.push([m0, s0 - 1]);
            result.push([s1 + 1, m1]);
        } else if (s1 < m0 || s0 > m1) {
            // completely outside: return `minuend` untouched
            result.push(minuend);
        }

        //else subtrahend must completely overlap minuend so return no pieces

        return result;
    }


    // Local utility functions

    /**
     * @private
     * @function merge
     * @summary Operator that merges given runs.
     * @returns {number[]} A single merged run.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * The runs are assumed to be overlapping or adjacent to one another.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - a run to merge with `run2`
     * @param {number[]} run2 - a run to merge with `run1`
     */
    function merge(run1, run2) {
        var min = Math.min(Math.min.apply(Math, run1), Math.min.apply(Math, run2));
        var max = Math.max(Math.max.apply(Math, run1), Math.max.apply(Math, run2));
        return [min, max];
    }

    // Interface
    module.exports = RangeSelectionModel;
})(
    typeof module === 'object' && module || (window.RangeSelectionModel = {}),
    typeof module === 'object' && module.exports || (window.RangeSelectionModel.exports = {})
) || (
    typeof module === 'object' || (window.RangeSelectionModel = window.RangeSelectionModel.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.RangeSelectionModel`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `window` object undefined, we're in NodeJs so assume there is a `module` object with an `exports` property
 * 2. If `window` object defined, we're in browser
 * 2.a. If `module` object predefined, use it
 * 2.b. If `module` object undefined, create a `RangeSelectionModel` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will execute:
 * 1. If `window` object undefined, then we're in NodeJs so we're done
 * 2. If `window` object defined, then we're in browser
 * 2.a. If `module` object predefined, we're done; results are in `moudule.exports`
 * 2.b. If `module` object undefined, redefine`RangeSelectionModel` to be the `RangeSelectionModel.exports` object
 */

},{}],29:[function(require,module,exports){
// templex node module
// https://github.com/joneit/templex

/* eslint-env node */

/**
 * Merges values of execution context properties named in template by {prop1},
 * {prop2}, etc., or any javascript expression incorporating such prop names.
 * The context always includes the global object. In addition you can specify a single
 * context or an array of contexts to search (in the order given) before finally
 * searching the global context.
 *
 * Merge expressions consisting of simple numeric terms, such as {0}, {1}, etc., deref
 * the first context given, which is assumed to be an array. As a convenience feature,
 * if additional args are given after `template`, `arguments` is unshifted onto the context
 * array, thus making first additional arg available as {1}, second as {2}, etc., as in
 * `templex('Hello, {1}!', 'World')`. ({0} is the template so consider this to be 1-based.)
 *
 * If you prefer something other than braces, redefine `templex.regexp`.
 *
 * See tests for examples.
 *
 * @param {string} template
 * @param {...string} [args]
 */
function templex(template) {
    var contexts = this instanceof Array ? this : [this];
    if (arguments.length > 1) { contexts.unshift(arguments); }
    return template.replace(templex.regexp, templex.merger.bind(contexts));
}

templex.regexp = /\{(.*?)\}/g;

templex.with = function (i, s) {
    return 'with(this[' + i + ']){' + s + '}';
};

templex.cache = [];

templex.deref = function (key) {
    if (!(this.length in templex.cache)) {
        var code = 'return eval(expr)';

        for (var i = 0; i < this.length; ++i) {
            code = templex.with(i, code);
        }

        templex.cache[this.length] = eval('(function(expr){' + code + '})'); // eslint-disable-line no-eval
    }
    return templex.cache[this.length].call(this, key);
};

templex.merger = function (match, key) {
    // Advanced features: Context can be a list of contexts which are searched in order.
    var replacement;

    try {
        replacement = isNaN(key) ? templex.deref.call(this, key) : this[0][key];
    } catch (e) {
        replacement = '{' + key + '}';
    }

    return replacement;
};

// this interface consists solely of the templex function (and it's properties)
module.exports = templex;

},{}],30:[function(require,module,exports){
// Created by Jonathan Eiten on 1/7/16.

'use strict';

/**
 * Very fast array test.
 * For cross-frame scripting; use `crossFramesIsArray` instead.
 * @param {*} arr - The object to test.
 * @returns {boolean}
 */
unstrungify.isArray = function(arr) { return arr.constructor === Array; };

/**
 * @summary Walk a hierarchical object as JSON.stringify does but without serializing.
 *
 * @desc Usage:
 * * var myDistilledObject = unstrungify.call(myObject);
 * * var myDistilledObject = myApi.getState(); // where myApi.prototype.getState = unstrungify
 *
 * Result equivalent to `JSON.parse(JSON.stringify(this))`.
 *
 * > Do not use this function to get a JSON string; use `JSON.stringify(this)` instead.
 *
 * @this {*|object|*[]} - Object to walk; typically an object or array.
 *
 * @param {boolean} [options.nullElements==false] - Preserve undefined array elements as `null`s.
 * Use this when precise index matters (not merely the order of the elements).
 *
 * @param {boolean} [options.nullProperties==false] - Preserve undefined object properties as `null`s.
 *
 * @returns {object} - Distilled object.
 */
function unstrungify(options) {
    var clone, preserve,
        object = (typeof this.toJSON === 'function') ? this.toJSON() : this;

    if (unstrungify.isArray(object)) {
        clone = [];
        preserve = options && options.nullElements;
        object.forEach(function(obj) {
            var value = unstrungify.call(obj);
            if (value !== undefined) {
                clone.push(value);
            } else if (preserve) {
                clone.push(null); // undefined not a valid JSON value
            }
        });
    } else  if (typeof object === 'object') {
        clone = {};
        preserve = options && options.nullProperties;
        Object.keys(object).forEach(function(key) {
            var value = object[key];
            if (value !== undefined) {
                value = unstrungify.call(object[key]);
            }
            if (value !== undefined) {
                clone[key] = value;
            } else if (preserve) {
                clone[key] = null; // undefined not a valid JSON value
            }
        });
    } else {
        clone = object;
    }

    return clone;
}

/**
 * Very slow array test. Suitable for cross-frame scripting.
 *
 * Suggestion: If you need this and have jQuery loaded, use `jQuery.isArray` instead which is reasonably fast.
 *
 * @param {*} arr - The object to test.
 * @returns {boolean}
 */
unstrungify.crossFramesIsArray = function(arr) { return toString.call(arr) === arrString; }; // eslint-disable-line no-unused-vars

var toString = Object.prototype.toString, arrString = '[object Array]';

module.exports = unstrungify;

},{}],31:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var extend = require('extend-me');
var deprecated = require('./lib/deprecated');
extend.debug = true;

var FinBar = require('finbars');
var Canvas = require('fincanvas');
var Point = require('rectangular').Point;
var Rectangle = require('rectangular').Rectangle;
var _ = require('object-iterators');

var defaults = require('./defaults');
var Renderer = require('./lib/Renderer');
var SelectionModel = require('./lib/SelectionModel');
var addStylesheet = require('../css/stylesheets');
var TableDialog = require('./lib/TableDialog');
var Formatters = require('./lib/Formatters');

var themeInitialized = false,
    polymerTheme = Object.create(defaults),
    globalProperties = Object.create(polymerTheme);

/**
 * @constructor
 * @param {string|Element} div - CSS selector or Element
 * @param {string} behaviorName - name of a behavior constructor from ./behaviors
 * @param {object} [margin] - optional canvas margins
 * @param {string} [margin.top]
 * @param {string} [margin.right='-200px']
 * @param {string} [margin.bottom]
 * @param {string} [margin.left]
 */
function Hypergrid(div, behaviorFactory, margin) {
    var self = this;

    this.div = (typeof div === 'string') ? document.querySelector(div) : div;

    addStylesheet('grid');

    this.lastEdgeSelection = [0, 0];

    this.lnfProperties = Object.create(globalProperties);

    this.isWebkit = navigator.userAgent.toLowerCase().indexOf('webkit') > -1;
    this.selectionModel = new SelectionModel(this);
    this.localCellEditors = {};
    this.cellEditors = Object.create(this.localCellEditors);
    this.renderOverridesCache = {};
    this.behavior = behaviorFactory(this);

    //prevent the default context menu for appearing
    this.div.oncontextmenu = function(event) {
        event.preventDefault();
        return false;
    };

    this.clearMouseDown();
    this.dragExtent = new Point(0, 0);
    this.numRows = 0;
    this.numColumns = 0;

    //install any plugins
    this.pluginsDo(function(each) {
        if (each.installOn) {
            each.installOn(self);
        }
    });

    margin = margin || {};
    margin.top = margin.top || 0;
    margin.right = margin.right || '-200px';
    margin.bottom = margin.bottom || 0;
    margin.left = margin.left || 0;

    //initialize our various pieces
    if (!themeInitialized) {
        themeInitialized = true;
        buildPolymerTheme();
    }
    this.initRenderer();
    this.initCanvas(margin);
    this.initScrollbars();
    this.initLocalCellEditors();

    //Register a listener for the copy event so we can copy our selected region to the pastebuffer if conditions are right.
    document.body.addEventListener('copy', function(evt) {
        self.checkClipboardCopy(evt);
    });
    this.getCanvas().resize();

    this.dialog = new TableDialog(this);
    //this.computeCellsBounds();
}

Hypergrid.prototype = {
    constructor: Hypergrid.prototype.constructor,

    deprecated: deprecated,

    /**
     *
     * A null object behavior serves as a place holder.
     * @type {object}
     * @memberOf Hypergrid.prototype
     */
    behavior: null,

    /**
     * Cached resulan}
     * @memberOf Hypergrid.prototype
     */
    isWebkit: true,

    /**
     * The pixel location of an initial mousedown click, either for editing a cell or for dragging a selection.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */
    mouseDown: [],

    /**
     * The extent from the mousedown point during a drag operation.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */

    dragExtent: null,

    /**
     * A float value between 0.0 - 1.0 of the vertical scroll position.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    vScrollValue: 0,

    /**
     * A float value between 0.0 - 1.0 of the horizontal scroll position.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    hScrollValue: 0,

    /**
     * @property {window.fin.rectangular} rectangular - Namespace for Point and Rectangle "classes" (constructors).
     * @memberOf Hypergrid.prototype
     */
    rectangular: null,

    /**
     * @property {fin-hypergrid-selection-model} selectionModel - A [fin-hypergrid-selection-model](module-._selection-model.html) instance.
     * @memberOf Hypergrid.prototype
     */
    selectionModel: null,

    /**
     * @property {fin-hypergrid-cell-editor} cellEditor - The current instance of [fin-hypergrid-cell-editor](module-cell-editors_base.html).
     * @memberOf Hypergrid.prototype
     */
    cellEditor: null,

    /**
     * @property {fin-vampire-bar} sbHScroller - An instance of [fin-vampire-bar](http://datamadic.github.io/fin-vampire-bar/components/fin-vampire-bar/).
     * @memberOf Hypergrid.prototype
     */
    sbHScroller: null,

    /**
     * @property {fin-vampire-bar} sbVScroller - An instance of [fin-vampire-bar](http://datamadic.github.io/fin-vampire-bar/components/fin-vampire-bar/).
     * @memberOf Hypergrid.prototype
     */
    sbVScroller: null,

    /**
     * The previous value of sbVScrollVal.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    sbPrevVScrollValue: null,

    /**
     * The previous value of sbHScrollValue.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    sbPrevHScrollValue: null,

    /**
     * The cache of singleton cellEditors.
     * @type {object}
     * @memberOf Hypergrid.prototype
     */
    cellEditors: null,

    /**
     * is the short term memory of what column I might be dragging around
     * @type {object}
     * @memberOf Hypergrid.prototype
     */

    renderOverridesCache: {},

    /**
     * The pixel location of the current hovered cell.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */
    hoverCell: null,

    scrollingNow: false,

    lastEdgeSelection: null,

    /**
     * @memberOf Hypergrid.prototype
    clear out the LRU cache of text widths
     */
    setAttribute: function(attribute, value) {
        this.div.setAttribute(attribute, value);
    },

    /**
     * @memberOf Hypergrid.prototype
    clear out all state and data of the grid
     */
    reset: function() {
        this.lastEdgeSelection = [0, 0];
        this.lnfProperties = Object.create(globalProperties);
        this.selectionModel = new SelectionModel(this);
        this.cellEditors = Object.create(this.localCellEditors);
        this.renderOverridesCache = {};
        this.clearMouseDown();
        this.dragExtent = new Point(0, 0);

        this.numRows = 0;
        this.numColumns = 0;

        this.vScrollValue = 0;
        this.hScrollValue = 0;

        this.cellEditor = null;

        this.sbPrevVScrollValue = null;
        this.sbPrevHScrollValue = null;

        this.hoverCell = null;
        this.scrollingNow = false;
        this.lastEdgeSelection = [0, 0];

        this.behavior.reset();
        this.getRenderer().reset();
        this.getCanvas().resize();
        this.behaviorChanged();
    },

    //resetTextWidthCache: function() {
    //    textWidthCache = new LRUCache(2000);
    //},

    getProperties: function() {
        return this.getPrivateState();
    },

    _getProperties: function() {
        return this.lnfProperties;
    },

    computeCellsBounds: function() {
        var renderer = this.getRenderer();
        if (renderer) {
            renderer.computeCellsBounds();
        }
    },

    initCellEditor: function(cellEditor) {
        this.localCellEditors[cellEditor.$$CLASS_NAME.toLowerCase()] = cellEditor;
        cellEditor.grid = this;
    },

    initLocalCellEditors: function() {

        var cellEditors = [
            'Textfield',
            'Choice',
            //'Combo',
            'Color',
            'Date',
            'Slider',
            'Spinner',
            'Filter'
        ];

        var self = this;
        cellEditors.forEach(function(name) {
            self.initCellEditor(new Hypergrid.cellEditors[name]);
        });

        this.localCellEditors.int = this.localCellEditors.spinner;
        this.localCellEditors.float = this.localCellEditors.spinner;
        this.localCellEditors.date = this.localCellEditors.date;
        this.localCellEditors.string = this.localCellEditors.extfield;
    },

    toggleColumnPicker: function() {
        this.behavior.toggleColumnPicker();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The pointer is over the given cell.
     * @param {number} x - The x cell coordinate.
     * @param {number} y - The y cell coordinate.
     */
    isHovered: function(x, y) {
        var p = this.getHoverCell();
        return p && p.x === x && p.y === y;
    },

    registerFormatter: function(name, func) {
        Formatters[name] = func;
    },

    getFormatter: function(type) {
        var formatter = Formatters[type];
        if (formatter) {
            return formatter;
        }
        return Formatters.default;
    },

    formatValue: function(type, value) {
        var formatter = this.getFormatter(type);
        return formatter(value);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns boolean} The pointer is hovering over the given column.
     * @param {number} x - The horizontal cell coordinate.
     */
    isColumnHovered: function(x) {
        var p = this.getHoverCell();
        return p && p.x === x;
    },

    isRowResizeable: function() {
        return this.resolveProperty('rowResize');
    },

    isCheckboxOnlyRowSelections: function() {
        return this.resolveProperty('checkboxOnlyRowSelections');
    },

    /**
     *
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The pointer is hovering over the row `y`.
     * @param {number} y - The vertical cell coordinate.
     */
    isRowHovered: function(y) {
        var p = this.getHoverCell();
        return p && p.y === y;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Point} The cell over which the cursor is hovering.
     */
    getHoverCell: function() {
        return this.hoverCell;
    },


    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the cell under the cursor.
     * @param {Point} point
     */
    setHoverCell: function(point) {
        var me = this.hoverCell;
        var newPoint = new Point(point.x, point.y);
        if (me && me.equals(newPoint)) {
            return;
        }
        this.hoverCell = newPoint;
        this.fireSyntheticOnCellEnterEvent(newPoint);
        this.repaint();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for all hypergrids in this process.
     * @param {object} properties - A simple properties hash.
     */
    addGlobalProperties: function(properties) {
        //we check for existence to avoid race condition in initialization
        if (!globalProperties) {
            var self = this;
            setTimeout(function() {
                self.addGlobalProperties(properties);
            }, 10);
        } else {
            this._addGlobalProperties(properties);
        }

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for all hypergrids in this process.
     * @param {object} properties - A simple properties hash.
     * @private
     */
    _addGlobalProperties: function(properties) {
        _(properties).each(function(property, key) {
            globalProperties[key] = property;
        });
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Utility function to push out properties if we change them.
     * @param {object} properties - An object of various key value pairs.
     */

    refreshProperties: function() {
        // this.canvas = this.shadowRoot.querySelector('fin-canvas');
        //this.canvas = new Canvas(this.divCanvas, this.renderer); //TODO: Do we really need to be recreating it here?
        this.checkScrollbarVisibility();
        this.behavior.defaultRowHeight = null;
        if (this.isColumnAutosizing()) {
            this.behavior.autosizeAllColumns();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for this hypergrid only.
     * @param {object} moreProperties - A simple properties hash.
     */
    addProperties: function(moreProperties) {
        var properties = this.getProperties();
        addDeepProperties(properties, moreProperties);
        this.refreshProperties();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} The state object for remembering our state.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    getPrivateState: function() {
        return this.behavior.getPrivateState();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the state object to return to the given user configuration.
     * @param {object} state - A memento object.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    setState: function(state) {
        var self = this;
        this.behavior.setState(state);
        setTimeout(function() {
            self.behaviorChanged();
            self.synchronizeScrollingBoundries();
        }, 100);
    },

    getState: function() {
        return this.behavior.getState();
    },
    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} The initial mouse position on a mouse down event for cell editing or a drag operation.
     * @memberOf Hypergrid.prototype
     */
    getMouseDown: function() {
        var last = this.mouseDown.length - 1;
        if (last < 0) {
            return null;
        }
        return this.mouseDown[last];
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Remove the last item from the mouse down stack.
     */
    popMouseDown: function() {
        if (this.mouseDown.length !== 0) {
            this.mouseDown.length = this.mouseDown.length - 1;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Empty out the mouse down stack.
     */
    clearMouseDown: function() {
        this.mouseDown = [new Point(-1, -1)];
        this.dragExtent = null;
    },

    /**
     * @memberOf Hypergrid.prototype
     set the mouse point that initated a cell edit or drag operation
     *
     * @param {Point} point
     */
    setMouseDown: function(point) {
        this.mouseDown.push(point);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Point} The extent point of the current drag selection rectangle.
     */
    getDragExtent: function() {
        return this.dragExtent;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Sets the extent point of the current drag selection operation.
     * @param {Point} point
     */
    setDragExtent: function(point) {
        this.dragExtent = point;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Iterate over the plugins invoking the given function with each.
     * @todo We need a new plugin mechanism!
     * @param {function} func - The function to invoke on all the plugins.
     */
    pluginsDo: function(func) {
        //TODO: We need a new plugin mechanism!
        //var userPlugins = this.children.array();
        //var pluginsTag = this.shadowRoot.querySelector('fin-plugins');
        //
        //var plugins = userPlugins;
        //if (pluginsTag) {
        //    var systemPlugins = pluginsTag.children.array();
        //    plugins = systemPlugins.concat(plugins);
        //}
        //
        //plugins.forEach(function(plugin) {
        //    func(plugin);
        //});
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The CellProvider is accessed through Hypergrid because Hypergrid is the mediator and should have ultimate control on where it comes from. The default is to delegate through the behavior object.
     * @returns {fin-hypergrid-cell-provider}
     */
    getCellProvider: function() {
        var provider = this.behavior.getCellProvider();
        return provider;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc This function is a callback from the HypergridRenderer sub-component. It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        this.updateRenderedSizes();
        if (this.cellEditor) {
            this.cellEditor.gridRenderedNotification();
        }
        this.checkColumnAutosizing();
        this.fireSyntheticGridRenderedEvent();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The grid has just been rendered, make sure the column widths are optimal.
     */
    checkColumnAutosizing: function() {
        var behavior = this.behavior;
        behavior.autoSizeRowNumberColumn();
        if (this.isColumnAutosizing()) {
            behavior.checkColumnAutosizing(false);
        }
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Notify the GridBehavior how many rows and columns we just rendered.
     */
    updateRenderedSizes: function() {
        //add one to each of these values as we want also to include
        //the columns and rows that are partially visible
        this.behavior.setRenderedColumnCount(this.getVisibleColumns() + 1);
        this.behavior.setRenderedRowCount(this.getVisibleRows() + 1);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Conditionally copy to clipboard.
     * @desc If we have focus, copy our current selection data to the system clipboard.
     * @param {event} event - The copy system event.
     */
    checkClipboardCopy: function(event) {
        if (this.hasFocus()) {
            event.preventDefault();
            var csvData = this.getSelectionAsTSV();
            event.clipboardData.setData('text/plain', csvData);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have any selections.
     */
    hasSelections: function() {
        if (!this.getSelectionModel) {
            return; // were not fully initialized yet
        }
        return this.selectionModel.hasSelections();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {string} Tab separated value string from the selection and our data.
     */
    getSelectionAsTSV: function() {
        var sm = this.selectionModel;
        if (sm.hasSelections()) {
            var selections = this.getSelectionMatrix();
            selections = selections[selections.length - 1];
            return this.getMatrixSelectionAsTSV(selections);
        } else if (sm.hasRowSelections()) {
            return this.getMatrixSelectionAsTSV(this.getRowSelectionMatrix());
        } else if (sm.hasColumnSelections()) {
            return this.getMatrixSelectionAsTSV(this.getColumnSelectionMatrix());
        }
    },

    getMatrixSelectionAsTSV: function(selections) {
        var result = '';

        //only use the data from the last selection
        if (selections.length) {
            var width = selections.length,
                height = selections[0].length,
                area = width * height,
                last = width - 1;

            //disallow if selection is too big
            if (area > 20000) {
                alert('selection size is too big to copy to the paste buffer'); // eslint-disable-line no-alert
                return '';
            }

            for (var h = 0; h < height; h++) {
                for (var w = 0; w < width; w++) {
                    result += selections[w][h] + (w < last ? '\t' : '\n');
                }
            }
        }

        return result;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have focus.
     */
    hasFocus: function() {
        return this.getCanvas().hasFocus();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear all the selections.
     */
    clearSelections: function() {
        var dontClearRows = this.isCheckboxOnlyRowSelections();
        this.selectionModel.clear(dontClearRows);
        this.clearMouseDown();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent selection.
     */
    clearMostRecentSelection: function() {
        var dontClearRows = this.isCheckboxOnlyRowSelections();
        this.selectionModel.clearMostRecentSelection(dontClearRows);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent column selection.
     */
    clearMostRecentColumnSelection: function() {
        this.selectionModel.clearMostRecentColumnSelection();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent row selection.
     */
    clearMostRecentRowSelection: function() {
        //this.selectionModel.clearMostRecentRowSelection(); // commented off as per GRID-112
    },

    clearRowSelection: function() {
        this.selectionModel.clearRowSelection();
        this.behavior.dataModel.clearSelectedData();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Select given region.
     * @param {number} ox - origin x
     * @param {number} oy - origin y
     * @param {number} ex - extent x
     * @param {number} ex - extent y
     */
    select: function(ox, oy, ex, ey) {
        if (ox < 0 || oy < 0) {
            //we don't select negative area
            //also this means there is no origin mouse down for a selection rect
            return;
        }
        this.selectionModel.select(ox, oy, ex, ey);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} Given point is selected.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    isSelected: function(x, y) {
        return this.selectionModel.isSelected(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given column is selected anywhere in the entire table.
     * @param {number} col - The column index.
     */
    isCellSelectedInRow: function(col) {
        var selectionModel = this.selectionModel;
        var isSelected = selectionModel.isCellSelectedInRow(col);
        return isSelected;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given row is selected anywhere in the entire table.
     * @param {number} row - The row index.
     */
    isCellSelectedInColumn: function(row) {
        var selectionModel = this.selectionModel;
        var isSelected = selectionModel.isCellSelectedInColumn(row);
        return isSelected;
    },

    /** @deprecated Use `.selectionModel` property instead.
     * @memberOf Hypergrid.prototype
     * @returns {SelectionModel} The selection model.
     */
    getSelectionModel: function() {
        return this.deprecated('selectionModel', { since: '0.2' });
    },

    /** @deprecated Use `.behavior` property instead.
     * @memberOf Hypergrid.prototype
     * @returns {Behavior} The behavior (model).
     */
    getBehavior: function() {
        return this.deprecated('behavior', { since: '0.2' });
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set the Behavior (model) object for this grid control.
     * @desc This can be done dynamically.
     * @param {Behavior} behavior - The behavior (model).
     */
    setBehavior: function(behavior) {
        behavior.changed = this.behaviorChanged.bind(this);
        behavior.shapeChanged = this.behaviorShapeChanged.bind(this);
        behavior.stateChanged = this.behaviorStateChanged.bind(this);
        this.behavior = behavior;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc I've been notified that the behavior has changed.
     */
    behaviorChanged: function() {
        if (this.numColumns !== this.getColumnCount() || this.numRows !== this.getRowCount()) {
            this.numColumns = this.getColumnCount();
            this.numRows = this.getRowCount();
            this.behaviorShapeChanged();
        }
        this.computeCellsBounds();
        this.repaint();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Rectangle} My bounds.
     */
    getBounds: function() {
        var renderer = this.getRenderer();
        return renderer && renderer.getBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {string} The value of a lnf property.
     * @param {string} key - A look-and-feel key.
     */
    resolveProperty: function(key) {
        var keys = key.split('.');
        var prop = this.getProperties();
        while (keys.length) { prop = prop[keys.shift()]; }
        return prop;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorShapeChanged: function() {
        this.synchronizeScrollingBoundries();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorStateChanged: function() {
        this.getRenderer().computeCellsBounds();
        this.repaint();
    },

    repaint: function() {
        var now = this.resolveProperty('repaintImmediately');
        var canvas = this.getCanvas();
        if (canvas) {
            if (now === true) {
                canvas.paintNow();
            } else {
                canvas.repaint();
            }
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Paint immediately in this microtask.
     */
    paintNow: function() {
        var canvas = this.getCanvas();
        canvas.paintNow();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} In HiDPI mode (has an attribute as such).
     */
    useHiDPI: function() {
        return this.resolveProperty('useHiDPI') !== false;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize drawing surface.
     * @private
     */
    initCanvas: function(margin) {

        var self = this;

        var divCanvas = this.divCanvas = document.createElement('div');
        this.div.appendChild(divCanvas);
        this.canvas = new Canvas(divCanvas, this.renderer);

        var style = divCanvas.style;
        style.position = 'absolute';
        style.top = margin.top;
        style.right = margin.right;
        style.bottom = margin.bottom;
        style.left = margin.left;

        this.canvas.resizeNotification = function() {
            self.resized();
        };

        this.addEventListener('fin-canvas-mousemove', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseMove(mouseEvent);
        });

        this.addEventListener('fin-canvas-mousedown', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.keys = e.detail.keys;
            mouseEvent.primitiveEvent = e;
            self.mouseDownState = mouseEvent;
            self.delegateMouseDown(mouseEvent);
            self.fireSyntheticMouseDownEvent(mouseEvent);
            self.repaint();
        });

        // this.addEventListener('fin-canvas-click', function(e) {
        //     if (self.resolveProperty('readOnly')) {
        //         return;
        //     }
        //     //self.stopEditing();
        //     var mouse = e.detail.mouse;
        //     var mouseEvent = self.getGridCellFromMousePoint(mouse);
        //     mouseEvent.primitiveEvent = e;
        //     self.fireSyntheticClickEvent(mouseEvent);
        // });

        this.addEventListener('fin-canvas-mouseup', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.dragging = false;
            if (self.isScrollingNow()) {
                self.setScrollingNow(false);
            }
            if (self.columnDragAutoScrolling) {
                self.columnDragAutoScrolling = false;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseUp(mouseEvent);
            if (self.mouseDownState) {
                self.fireSyntheticButtonPressedEvent(self.mouseDownState);
            }
            self.mouseDownState = null;
            self.fireSyntheticMouseUpEvent(mouseEvent);
        });

        this.addEventListener('fin-canvas-dblclick', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.fireSyntheticDoubleClickEvent(mouseEvent, e);
            self.delegateDoubleClick(mouseEvent);
        });

        this.addEventListener('fin-canvas-tap', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var tapEvent = self.getGridCellFromMousePoint(mouse);
            tapEvent.primitiveEvent = e;
            tapEvent.keys = e.detail.keys;
            self.fireSyntheticClickEvent(tapEvent);
            self.delegateTap(tapEvent);
        });

        this.addEventListener('fin-canvas-drag', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.dragging = true;
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseDrag(mouseEvent);
        });

        this.addEventListener('fin-canvas-keydown', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            if (self.resolveProperty('editOnKeydown')) {
                var char = e.detail.char,
                    isVisibleChar, isDeleteChar, currentCell, editor;

                if (
                    !self.isEditing() &&
                    (
                        char === 'F2' ||
                        (isVisibleChar = char.length === 1) ||
                        (isDeleteChar = char === 'DELETE' || char === 'BACKSPACE')
                    )
                ) {
                    currentCell = self.selectionModel.getLastSelection();
                    if (currentCell) {
                        var pseudoEvent = { gridCell: currentCell.origin };
                        editor = self.onEditorActivate(pseudoEvent);
                        if (editor instanceof Hypergrid.cellEditors.Simple) {
                            if (isVisibleChar) {
                                editor.input.value = char;
                            } else if (isDeleteChar) {
                                editor.input.value = '';
                            }
                            e.detail.primitiveEvent.preventDefault();
                        }
                    }
                }
            }
            self.fireSyntheticKeydownEvent(e);
            self.delegateKeyDown(e);
        });

        this.addEventListener('fin-canvas-keyup', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.fireSyntheticKeyupEvent(e);
            self.delegateKeyUp(e);
        });

        this.addEventListener('fin-canvas-track', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            if (self.dragging) {
                return;
            }
            var primEvent = e.detail.primitiveEvent;
            if (Math.abs(primEvent.dy) > Math.abs(primEvent.dx)) {
                if (primEvent.yDirection > 0) {
                    self.scrollVBy(-2);
                } else if (primEvent.yDirection < -0) {
                    self.scrollVBy(2);
                }
            } else {
                if (primEvent.xDirection > 0) {
                    self.scrollHBy(-1);
                } else if (primEvent.xDirection < -0) {
                    self.scrollHBy(1);
                }
            }
        });

        // this.addEventListener('fin-canvas-holdpulse', function(e) {
        //     console.log('holdpulse');
        //     if (self.resolveProperty('readOnly')) {
        //         return;
        //     }
        //     var mouse = e.detail.mouse;
        //     var mouseEvent = self.getGridCellFromMousePoint(mouse);
        //     mouseEvent.primitiveEvent = e;
        //     self.delegateHoldPulse(mouseEvent);
        // });

        this.addEventListener('fin-canvas-wheelmoved', function(e) {
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateWheelMoved(mouseEvent);
        });

        this.addEventListener('fin-canvas-mouseout', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateMouseExit(mouseEvent);
        });

        this.addEventListener('fin-canvas-context-menu', function(e) {
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateContextMenu(mouseEvent);
        });

        this.div.removeAttribute('tabindex');

    },

    convertViewPointToDataPoint: function(viewPoint) {
        return this.behavior.convertViewPointToDataPoint(viewPoint);
    },

    convertDataPointToViewPoint: function(dataPoint) {
        return this.behavior.convertDataPointToViewPoint(dataPoint);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Add an event listener to me.
     * @param {string} eventName - The type of event we are interested in.
     * @param {function} callback - The event handler.
     */
    addEventListener: function(eventName, callback) {
        this.canvas.addEventListener(eventName, callback);
    },

    addFinEventListener: function(eventName, callback) {
        console.warn('.addFinEventListener() method is deprecated as of v0.2. Use .addEventListener() instead. (Will be removed in a future release.)');
        this.addEventListener(eventName, callback);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set for `scrollingNow` field.
     * @param {boolean} isItNow - The type of event we are interested in.
     */
    setScrollingNow: function(isItNow) {
        this.scrollingNow = isItNow;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The `scrollingNow` field.
     */
    isScrollingNow: function() {
        return this.scrollingNow;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The index of the column divider under the mouse coordinates.
     * @param {MouseEvent} mouseEvent - The event to interogate.
     */
    overColumnDivider: function(mouseEvent) {
        var x = mouseEvent.primitiveEvent.detail.mouse.x;
        var whichCol = this.getRenderer().overColumnDivider(x);
        return whichCol;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The index of the row divider under the mouse coordinates.
     * @param {MouseEvent} mouseEvent - The event to interogate.
     */
    overRowDivider: function(mouseEvent) {
        var y = mouseEvent.primitiveEvent.detail.mouse.y;
        var which = this.getRenderer().overRowDivider(y);
        return which;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Switch the cursor for the grid.
     * @param {string} cursorName - A well know cursor name.
     * @see [cursor names](http://www.javascripter.net/faq/stylesc.htm)
     */
    beCursor: function(cursorName) {
        if (!cursorName) {
            cursorName = 'default';
        }
        this.div.style.cursor = cursorName;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate the wheel moved event to the behavior.
     * @param {Event} event - The pertinent event.
     */
    delegateWheelMoved: function(event) {
        this.behavior.onWheelMoved(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateMouseExit: function(event) {
        this.behavior.handleMouseExit(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateContextMenu: function(event) {
       this. behavior.onContextMenu(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseMove to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseMove: function(mouseDetails) {
        this.behavior.onMouseMove(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mousedown to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDown: function(mouseDetails) {
        this.behavior.handleMouseDown(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mouseup to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseUp: function(mouseDetails) {
        this.behavior.onMouseUp(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate tap to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateTap: function(mouseDetails) {
        this.behavior.onTap(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mouseDrag to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDrag: function(mouseDetails) {
        this.behavior.onMouseDrag(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc We've been doubleclicked on. Delegate through the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateDoubleClick: function(mouseDetails) {
        this.behavior.onDoubleClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate holdpulse through the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateHoldPulse: function(mouseDetails) {
        this.behavior.onHoldPulse(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyDown: function(event) {
        this.behavior.onKeyDown(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyUp: function(event) {
        this.behavior.onKeyUp(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Shut down the current cell editor.
     */
    stopEditing: function() {
        if (this.cellEditor && this.isEditing()) {
            if (this.cellEditor.stopEditing) {
                this.cellEditor.stopEditing();
            }
            this.cellEditor = null;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Register a cell editor.
     * @desc This is typically called from within a cell-editor's `installOn` method, when it is being initialized as a plugin.
     * @param {string} alias - The name/id of the cell editor.
     * @param {fin-hypergrid-cell-editor-base} cellEditor - see [fin-hypergrid-cell-editor-base](module-cell-editors_base.html)
     */
    registerCellEditor: function(alias, cellEditor) {
        this.cellEditors[alias] = cellEditor;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Rectangle} The pixel coordinates of just the center 'main" data area.
     */
    getDataBounds: function() {
        var colDNDHackWidth = 200; //this was a hack to help with column dnd, need to factor this into a shared variable
        var b = this.canvas.bounds;

        //var x = this.getRowNumbersWidth();
        // var y = behavior.getFixedRowsHeight() + 2;

        var result = new Rectangle(0, 0, b.origin.x + b.extent.x - colDNDHackWidth, b.origin.y + b.extent.y);
        return result;
    },

    getRowNumbersWidth: function() {
        if (this.isShowRowNumbers()) {
            return this.getRenderer().getRowNumbersWidth();
        } else {
            return 0;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Canvas} Our fin-canvas instance.
     */
    getCanvas: function() {
        return this.canvas;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Open the given cell-editor at the provided model coordinates.
     * @param {string} cellEditor - The specific cell editor to use.
     * @param {Point} coordinates - The pixel locaiton of the cell to edit at.
     */
    editAt: function(cellEditor, editPoint) {

        this.cellEditor = cellEditor;

        if (editPoint.x >= 0 && editPoint.y >= 0) {
            this.setMouseDown(editPoint);
            this.setDragExtent(new Point(0, 0));
            cellEditor.beginEditAt(editPoint);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given column is fully visible.
     * @param {number} columnIndex - The column index in question.
     * @return {boolan} Visible.
     */
    isColumnVisible: function(columnIndex) {
        return this.getRenderer().isColumnVisible(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given row is fully visible.
     * @param {number} rowIndex - The row index in question.
     * @return {boolan} Visible.
     */
    isDataRowVisible: function(rowIndex) {
        return this.getRenderer().isRowVisible(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given cell is fully is visible.
     * @param {number} columnIndex - The column index in question.
     * @param {number} rowIndex - The row index in question.
     * @return {boolean} Data is visible.
     */
    isDataVisible: function(columnIndex, rowIndex) {
        return this.isDataRowVisible(rowIndex) && this.isColumnVisible(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll in the `offsetX` direction if column index `colIndex` is not visible.
     * @param {number} colIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     * @return {boolean} Column is visible.
     */
    insureModelColIsVisible: function(colIndex, offsetX) {
        var maxCols = this.getColumnCount() - 1, // -1 excludes partially visible columns
            indexToCheck = colIndex + (offsetX > 0),
            visible = !this.isColumnVisible(indexToCheck) || colIndex === maxCols;

        if (visible) {
            //the scroll position is the leftmost column
            this.scrollBy(offsetX, 0);
        }

        return visible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll in the offsetY direction if column index c is not visible.
     * @param {number} rowIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     * @return {boolean} Row is visible.
     */
    insureModelRowIsVisible: function(rowIndex, offsetY) {
        var maxRows = this.getRowCount() - 1, // -1 excludes partially visible rows
            indexToCheck = rowIndex + (offsetY > 0),
            visible = !this.isDataRowVisible(indexToCheck) || rowIndex === maxRows;

        if (visible) {
            //the scroll position is the topmost row
            this.scrollBy(0, offsetY);
        }

        return visible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll horizontal and vertically by the provided offsets.
     * @param {number} offsetX - Scroll in the x direction this much.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollBy: function(offsetX, offsetY) {
        this.scrollHBy(offsetX);
        this.scrollVBy(offsetY);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll vertically by the provided offset.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollVBy: function(offsetY) {
        var max = this.sbVScroller.range.max;
        var oldValue = this.getVScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetY));
        if (newValue !== oldValue) {
            this.setVScrollValue(newValue);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll horizontally by the provided offset.
     * @param {number} offsetX - Scroll in the x direction this much.
     */
    scrollHBy: function(offsetX) {
        var max = this.sbHScroller.range.max;
        var oldValue = this.getHScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetX));
        if (newValue !== oldValue) {
            this.setHScrollValue(newValue);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Answer which data cell is under a pixel value mouse point.
     * @param {mousePoint} mouse - The mouse point to interrogate.
     */

    getGridCellFromMousePoint: function(mouse) {
        var cell = this.getRenderer().getGridCellFromMousePoint(mouse);
        return cell;
    },

    /**
     * @returns {Rectangle} The pixel based bounds rectangle given a data cell point.
     * @param {Point} cell - The pixel location of the mouse.
     * @memberOf Hypergrid.prototype
     */
    getBoundsOfCell: function(cell) {
        var b = this.getRenderer().getBoundsOfCell(cell);

        //we need to convert this to a proper rectangle
        var newBounds = new Rectangle(b.x, b.y, b.width, b.height);
        return newBounds;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc This is called by the fin-canvas when a resize occurs.
     */
    resized: function() {
        this.synchronizeScrollingBoundries();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A click event occured.
     * @desc Determine the cell and delegate to the behavior (model).
     * @param {MouseEvent} event - The mouse event to interrogate.
     */
    cellClicked: function(event) {
        var cell = event.gridCell;

        //click occurred in background area
        if (
            cell.x <= this.getColumnCount() &&
            cell.y <= this.getRowCount()
        ) {
            var hovered = this.getHoverCell(),
                x = hovered.x,
                y = hovered.y;

            // if (x >= 0) {
            //     x = behavior.translateColumnIndex(x + this.getHScrollValue());
            // }

            if (y >= 0) {
                y += this.getVScrollValue();
            }

            this.behavior.cellClicked(new Point(x, y), event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @param {number} x - column index
     * @param {number} y - totals row index local to the totals area
     * @param value
     * @param {string[]} [areas=['top', 'bottom']] - may include `'top'` and/or `'bottom'`
     */
    setTotalsValueNotification: function(x, y, value, areas) {
        this.fireSyntheticSetTotalsValue(x, y, value, areas);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @param {number} x - column index
     * @param {number} y - totals row index local to the totals area
     * @param value
     * @param {string[]} [areas=['top', 'bottom']] - may include `'top'` and/or `'bottom'`
     */
    fireSyntheticSetTotalsValue: function(x, y, value, areas) {
        var clickEvent = new CustomEvent('fin-set-totals-value', {
            detail: {
                x: x,
                y: y,
                value: value,
                areas: areas
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyUpEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-keyup', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyDownEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-keydown', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyPressEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-keypress', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorDataChangeEvent: function(inputControl, oldValue, newValue) {
        var clickEvent = new CustomEvent('fin-editor-data-change', {
            detail: {
                input: inputControl,
                oldValue: oldValue,
                newValue: newValue
            },
            cancelable: true
        });
        return this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-row-selection-changed` event.
     */
    fireSyntheticRowSelectionChangedEvent: function() {
        var selectionEvent = new CustomEvent('fin-row-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },

    fireSyntheticColumnSelectionChangedEvent: function() {
        var selectionEvent = new CustomEvent('fin-column-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and dispatch a `fin-selection-changed` event.
     */
    selectionChanged: function() {
        var selectedRows = this.getSelectedRows();
        var selectionEvent = new CustomEvent('fin-selection-changed', {
            detail: {
                rows: selectedRows,
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },


    getRowSelection: function() {
        var c, column, self = this,
            selectedRowIndexes = this.selectionModel.getSelectedRows(),
            numCols = this.getColumnCount(),
            result = {};

        function setValue(selectedRowIndex, r) {
            column[r] = valOrFunc(self.getValue(c, selectedRowIndex));
        }

        for (c = 0; c < numCols; c++) {
            column = new Array(selectedRowIndexes.length);
            result[this.getField(c)] = column;
            selectedRowIndexes.forEach(setValue);
        }

        return result;
    },

    getRowSelectionMatrix: function() {
        var c, self = this,
            selectedRowIndexes = this.selectionModel.getSelectedRows(),
            numCols = this.getColumnCount(),
            result = new Array(numCols);

        function getValue(selectedRowIndex, r) {
            result[c][r] = valOrFunc(self.getValue(c, selectedRowIndex));
        }

        for (c = 0; c < numCols; c++) {
            result[c] = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(getValue);
        }

        return result;
    },

    getColumnSelectionMatrix: function() {
        var selectedColumnIndexes = this.getSelectedColumns();
        var numRows = this.getRowCount();
        var result = new Array(selectedColumnIndexes.length);
        var self = this;
        selectedColumnIndexes.forEach(function(selectedColumnIndex, c) {
            result[c] = new Array(numRows);
            for (var r = 0; r < numRows; r++) {
                result[c][r] = valOrFunc(self.getValue(selectedColumnIndex, r));
            }
        });
        return result;
    },

    getColumnSelection: function() {
        var selectedColumnIndexes = this.getSelectedColumns();
        var result = {};
        var rowCount = this.getRowCount();
        var self = this;
        selectedColumnIndexes.forEach(function(selectedColumnIndex) {
            var column = new Array(rowCount);
            result[self.getField(selectedColumnIndex)] = column;
            for (var r = 0; r < rowCount; r++) {
                column[r] = valOrFunc(self.getValue(selectedColumnIndex, r));
            }
        });
        return result;
    },

    getSelection: function() {
        var self = this;
        var selections = this.getSelections();
        var result = new Array(selections.length);
        selections.forEach(function(selectionRect, i) {
            result[i] = self._getSelection(selectionRect);
        });
        return result;
    },

    _getSelection: function(rect) {
        rect = normalizeRect(rect);
        var colCount = rect.extent.x + 1;
        var rowCount = rect.extent.y + 1;
        var ox = rect.origin.x;
        var oy = rect.origin.y;
        var result = {};
        var r;
        for (var c = 0; c < colCount; c++) {
            var column = new Array(rowCount);
            result[this.getField(c + ox)] = column;
            for (r = 0; r < rowCount; r++) {
                column[r] = valOrFunc(this.getValue(ox + c, oy + r));
            }
        }
        return result;
    },

    getSelectionMatrix: function() {
        var self = this;
        var selections = this.getSelections();
        var result = new Array(selections.length);
        selections.forEach(function(selectionRect, i) {
            result[i] = self._getSelectionMatrix(selectionRect);
        });
        return result;
    },

    _getSelectionMatrix: function(rect) {
        rect = normalizeRect(rect);
        var colCount = rect.extent.x + 1;
        var rowCount = rect.extent.y + 1;
        var ox = rect.origin.x;
        var oy = rect.origin.y;
        var result = [];
        for (var c = 0; c < colCount; c++) {
            var column = new Array(rowCount);
            result[c] = column;
            for (var r = 0; r < rowCount; r++) {
                column[r] = valOrFunc(this.getValue(ox + c, oy + r));
            }
        }
        return result;
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-context-menu` event
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticContextMenuEvent: function(e) {
        e.gridCell = this.convertViewPointToDataPoint(e.gridCell);
        var event = new CustomEvent('fin-context-menu', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    fireSyntheticMouseUpEvent: function(e) {
        var event = new CustomEvent('fin-mouseup', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    fireSyntheticMouseDownEvent: function(e) {
        this.stopEditing();
        var event = new CustomEvent('fin-mousedown', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    isViewableButton: function(c, r) {
        return this.getRenderer().isViewableButton(c, r);
    },

    fireSyntheticButtonPressedEvent: function(evt) {
        var dataCell = evt.dataCell;
        var gridCell = evt.gridCell;
        if (this.isViewableButton(dataCell.x, dataCell.y)) {
            var event = new CustomEvent('fin-button-pressed', {
                detail: {
                    gridCell: gridCell
                }
            });
            this.canvas.dispatchEvent(event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-keydown` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeydownEvent: function(keyEvent) {
        var clickEvent = new CustomEvent('fin-keydown', {
            detail: keyEvent.detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-keyup` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeyupEvent: function(keyEvent) {
        var clickEvent = new CustomEvent('fin-keyup', {
            detail: keyEvent.detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticFilterAppliedEvent: function(details) {
        var event = new CustomEvent('fin-filter-applied', {
            detail: details
        });
        if (this.canvas) {
            this.canvas.dispatchEvent(event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-enter` event
     * @param {Point} cell - The pixel location of the cell in which the click event occurred.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellEnterEvent: function(cell) {
        var detail = {
            gridCell: cell,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-cell-enter', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticGroupsChangedEvent: function(groups) {
        var detail = {
            groups: groups,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-groups-changed', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-exit` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellExitEvent: function(cell) {
        var detail = {
            gridCell: cell,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-cell-exit', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-click` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticClickEvent: function(mouseEvent) {
        var cell = mouseEvent.gridCell;
        var detail = {
            gridCell: cell,
            mousePoint: mouseEvent.mousePoint,
            keys: mouseEvent.keys,
            primitiveEvent: mouseEvent,
            time: Date.now(),
            grid: this
        };
        this.behavior.enhanceDoubleClickEvent(detail);
        var clickEvent = new CustomEvent('fin-click', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-double-click` event.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticDoubleClickEvent: function(mouseEvent) {
        this.stopEditing();
        var cell = mouseEvent.gridCell;
        var detail = {
            gridCell: cell,
            mousePoint: mouseEvent.mousePoint,
            time: Date.now(),
            grid: this
        };
        this.behavior.enhanceDoubleClickEvent(mouseEvent);
        var clickEvent = new CustomEvent('fin-double-click', {
            detail: detail
        });
        this.behavior.cellDoubleClicked(cell, mouseEvent);
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a rendered event.
     */
    fireSyntheticGridRenderedEvent: function() {
        var event = new CustomEvent('fin-grid-rendered', {
            detail: {
                source: this,
                time: Date.now()
            }
        });
        if (this.canvas) {
            this.canvas.dispatchEvent(event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a scroll event.
     * @param {string} type - Should be either `fin-scroll-x` or `fin-scroll-y`.
     * @param {number} oldValue - The old scroll value.
     * @param {number} newValue - The new scroll value.
     */
    fireScrollEvent: function(type, oldValue, newValue) {
        var event = new CustomEvent(type, {
            detail: {
                oldValue: oldValue,
                value: newValue,
                time: Date.now()
            }
        });
        this.canvas.dispatchEvent(event);

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the vertical scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setVScrollValue: function(y) {
        y = Math.round(y);
        var max = this.sbVScroller.range.max;
        y = Math.min(max, Math.max(0, y));
        var self = this;
        if (y !== this.vScrollValue) {
            this.behavior._setScrollPositionY(y);
            var oldY = this.vScrollValue;
            this.vScrollValue = y;
            this.scrollValueChangedNotification();
            setTimeout(function() {
                // self.sbVRangeAdapter.subjectChanged();
                self.fireScrollEvent('fin-scroll-y', oldY, y);
            });
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @return {number} The vertical scroll value.
     */
    getVScrollValue: function() {
        return this.vScrollValue;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the horizontal scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setHScrollValue: function(x) {
        x = Math.round(x);
        var max = this.sbHScroller.range.max;
        x = Math.min(max, Math.max(0, x));
        var self = this;
        if (x !== this.hScrollValue) {
            this.behavior._setScrollPositionX(x);
            var oldX = this.hScrollValue;
            this.hScrollValue = x;
            this.scrollValueChangedNotification();
            setTimeout(function() {
                //self.sbHRangeAdapter.subjectChanged();
                self.fireScrollEvent('fin-scroll-x', oldX, x);
                self.synchronizeScrollingBoundries();
            });
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns The vertical scroll value.
     */
    getHScrollValue: function() {
        return this.hScrollValue;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Request input focus.
     */
    takeFocus: function() {
        if (this.isEditing()) {
            this.stopEditing();
        } else {
            this.getCanvas().takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Request focus for our cell editor.
     */
    editorTakeFocus: function() {
        if (this.cellEditor) {
            return this.cellEditor.takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have a currently active cell editor.
     */
    isEditing: function() {
        return this.cellEditor && this.cellEditor.isEditing;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Initialize the scroll bars.
     */
    initScrollbars: function() {

        var self = this;

        var horzBar = new FinBar({
            orientation: 'horizontal',
            onchange: self.setHScrollValue.bind(self),
            cssStylesheetReferenceElement: this.div
        });

        var vertBar = new FinBar({
            orientation: 'vertical',
            onchange: self.setVScrollValue.bind(self),
            paging: {
                up: self.pageUp.bind(self),
                down: self.pageDown.bind(self)
            }
        });

        this.sbHScroller = horzBar;
        this.sbVScroller = vertBar;

        var hPrefix = this.resolveProperty('hScrollbarClassPrefix');
        var vPrefix = this.resolveProperty('vScrollbarClassPrefix');

        if (hPrefix && hPrefix !== '') {
            this.sbHScroller.classPrefix = hPrefix;
        }

        if (vPrefix && vPrefix !== '') {
            this.sbVScroller.classPrefix = vPrefix;
        }

        this.div.appendChild(horzBar.bar);
        this.div.appendChild(vertBar.bar);

        this.resizeScrollbars();

    },

    resizeScrollbars: function() {
        this.sbHScroller.shortenBy(this.sbVScroller).resize();
        //this.sbVScroller.shortenBy(this.sbHScroller);
        this.sbVScroller.resize();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll values have changed, we've been notified.
     */
    setVScrollbarValues: function(max) {
        this.sbVScroller.range = {
            min: 0,
            max: max
        };
    },

    setHScrollbarValues: function(max) {
        this.sbHScroller.range = {
            min: 0,
            max: max
        };
    },

    scrollValueChangedNotification: function() {

        if (this.hScrollValue === this.sbPrevHScrollValue && this.vScrollValue === this.sbPrevVScrollValue) {
            return;
        }

        this.sbPrevHScrollValue = this.hScrollValue;
        this.sbPrevVScrollValue = this.vScrollValue;

        if (this.cellEditor) {
            this.cellEditor.scrollValueChangedNotification();
        }

        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Get data value at given cell.
     * @desc Delegates to the behavior.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     * @param {*} value
     */
    getValue: function(x, y) {
        return this.behavior.getValue(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set a data value into the behavior (model) at the given point
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    setValue: function(x, y, value) {
        this.behavior.setValue(x, y, value);
    },

    getColumnAlignment: function(c) {
        return this.behavior.getColumnAlignment(c);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The data dimensions have changed, or our pixel boundries have changed.
     * Adjust the scrollbar properties as necessary.
     */
    synchronizeScrollingBoundries: function() {
        var numFixedColumns = this.getFixedColumnCount();
        var numFixedRows = this.getFixedRowCount();

        var numColumns = this.getColumnCount();
        var numRows = this.getRowCount();

        var bounds = this.getBounds();
        if (!bounds) {
            return;
        }
        var scrollableHeight = bounds.height - this.behavior.getFixedRowsMaxHeight() - 15; //5px padding at bottom and right side
        var scrollableWidth = (bounds.width - 200) - this.behavior.getFixedColumnsMaxWidth() - 15;

        var lastPageColumnCount = 0;
        var columnsWidth = 0;
        for (; lastPageColumnCount < numColumns; lastPageColumnCount++) {
            var eachWidth = this.getColumnWidth(numColumns - lastPageColumnCount - 1);
            columnsWidth = columnsWidth + eachWidth;
            if (columnsWidth > scrollableWidth) {
                break;
            }
        }

        var lastPageRowCount = 0;
        var rowsHeight = 0;
        for (; lastPageRowCount < numRows; lastPageRowCount++) {
            var eachHeight = this.getRowHeight(numRows - lastPageRowCount - 1);
            rowsHeight = rowsHeight + eachHeight;
            if (rowsHeight > scrollableHeight) {
                break;
            }
        }

        var hMax = Math.max(0, numColumns - numFixedColumns - lastPageColumnCount);
        this.setHScrollbarValues(hMax);

        var vMax = 1 + Math.max(0, numRows - numFixedRows - lastPageRowCount);
        this.setVScrollbarValues(vMax);

        this.setHScrollValue(Math.min(this.getHScrollValue(), hMax));
        this.setVScrollValue(Math.min(this.getVScrollValue(), vMax));

        //this.getCanvas().resize();
        this.computeCellsBounds();
        this.repaint();

        this.resizeScrollbars();

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Note that "viewable rows" includes any partially viewable rows.
     * @returns {number} The number of viewable rows.
     */
    getVisibleRows: function() {
        return this.getRenderer().getVisibleRows();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Note that "viewable columns" includes any partially viewable columns.
     * @returns {number} The number of viewable columns.
     */
    getVisibleColumns: function() {
        return this.getRenderer().getVisibleColumns();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize the renderer sub-component.
     */
    initRenderer: function() {
        this.renderer = new Renderer(this);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Renderer} sub-component
     */
    getRenderer: function() {
        return this.renderer;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     */
    getColumnWidth: function(columnIndex) {
        return this.behavior.getColumnWidth(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     * @param {number} columnWidth - The width in pixels.
     */
    setColumnWidth: function(columnIndex, columnWidth) {
        this.stopEditing();
        this.behavior.setColumnWidth(columnIndex, columnWidth);
    },

    getColumnEdge: function(c) {
        return this.behavior.getColumnEdge(c, this.getRenderer());
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The total width of all the fixed columns.
     */
    getFixedColumnsWidth: function() {
        return this.behavior.getFixedColumnsWidth();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The height of the given row
     * @param {number} rowIndex - The untranslated fixed column index.
     */
    getRowHeight: function(rowIndex) {
        return this.behavior.getRowHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the height of the given row.
     * @param {number} rowIndex - The row index.
     * @param {number} rowHeight - The width in pixels.
     */
    setRowHeight: function(rowIndex, rowHeight) {
        this.stopEditing();
        this.behavior.setRowHeight(rowIndex, rowHeight);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The total fixed rows height
     */
    getFixedRowsHeight: function() {
        return this.behavior.getFixedRowsHeight();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.behavior.getColumnCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of fixed rows.
     */
    getRowCount: function() {
        return this.behavior.getRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of unfiltered rows.
     */
    getUnfilteredRowCount: function() {
        return this.behavior.getUnfilteredRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.behavior.getFixedColumnCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.behavior.getFixedRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary The top left area has been clicked on
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    topLeftClicked: function(mouse) {
        this.behavior.topLeftClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A fixed row has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    rowHeaderClicked: function(mouse) {
        this.behavior.rowHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A fixed column has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    columnHeaderClicked: function(mouse) {
        this.behavior.columnHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc An edit event has occurred. Activate the editor at the given coordinates.
     * @param {number} event.gridCell.x - The horizontal coordinate.
     * @param {number} event.gridCell.y - The vertical coordinate.
     * @param {boolean} [event.primitiveEvent.type]
     * @returns {undefined|CellEditor} The editor object or `undefined` if no editor or editor already open.
     */
    onEditorActivate: function(event) {
        var point = event.gridCell;

        if (this.isEditable() || this.isFilterRow(point.y)) {
            var primEvent = event.primitiveEvent,
                isDblClick = primEvent && primEvent.type === 'fin-canvas-dblclick',
                editor = this.getCellEditorAt(point.x, point.y, isDblClick),
                editorPoint = editor.getEditorPoint(),
                sameCell = point.equals(editorPoint),
                editorAlreadyOpen = sameCell && editor.isEditing;

            if (editorAlreadyOpen) {
                editor = undefined;
            } else {
                if (this.isEditing()) {
                    this.stopEditing(); //other editor is open, close it first
                }
                this.editAt(editor, point);
            }
        }

        return editor;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Get the cell editor.
     * @desc Delegates to the behavior.
     * @returns The cell editor at the given coordinates.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     * @param {boolean} isDblClick - When called from `onEditorActivate`, indicates if event was a double-click.
     */
    getCellEditorAt: function(x, y, isDblClick) {
        return this.behavior._getCellEditorAt(x, y, isDblClick);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Toggle HiDPI support.
     * @desc HiDPI support is now *on* by default.
     * > There used to be a bug in Chrome that caused severe slow down on bit blit of large images, so this HiDPI needed to be optional.
     */
    toggleHiDPI: function() {
        if (this.useHiDPI()) {
            this.removeAttribute('hidpi');
        } else {
            this.setAttribute('hidpi', null);
        }
        this.canvas.resize();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} Te HiDPI ratio.
     */
    getHiDPI: function(ctx) {
        if (window.devicePixelRatio && this.useHiDPI()) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                ctx.mozBackingStorePixelRatio ||
                ctx.msBackingStorePixelRatio ||
                ctx.oBackingStorePixelRatio ||
                ctx.backingStorePixelRatio || 1;

            var ratio = devicePixelRatio / backingStoreRatio;
            return ratio;
        } else {
            return 1;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The width of the given (recently rendered) column.
     * @param {number} colIndex - The column index.
     */
    getRenderedWidth: function(colIndex) {
        return this.renderer.getRenderedWidth(colIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The height of the given (recently rendered) row.
     * @param {number} rowIndex - Tthe row index.
     */
    getRenderedHeight: function(rowIndex) {
        return this.renderer.getRenderedHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {CellEditor} The cell editor at alias "name" (a sub-component).
     * @param {string} name
     */
    resolveCellEditor: function(name) {
        return this.cellEditors[name];
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Update the cursor under the hover cell.
     */
    updateCursor: function() {
        var cursor = this.behavior.getCursorAt(-1, -1);
        var hoverCell = this.getHoverCell();
        if (
            hoverCell &&
            hoverCell.x > -1 &&
            hoverCell.y > -1
        ) {
            var x = hoverCell.x + this.getHScrollValue();
            cursor = this.behavior.getCursorAt(x, hoverCell.y + this.getVScrollValue());
        }
        this.beCursor(cursor);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Repaint the given cell.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     */
    repaintCell: function(x, y) {
        this.getRenderer().repaintCell(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The user is currently dragging a column to reorder it.
     */
    isDraggingColumn: function() {
        return !!this.renderOverridesCache.dragger;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll up one full page.
     * @returns {number}
     */
    pageUp: function() {
        var rowNum = this.getRenderer().getPageUpRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll down one full page.
     * @returns {number}
     */
    pageDown: function() {
        var rowNum = this.getRenderer().getPageDownRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Not yet implemented.
     */
    pageLeft: function() {
        console.log('page left');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Not yet implemented.
     */
    pageRight: function() {
        console.log('page right');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object[]} Objects with the values that were just rendered.
     */
    getRenderedData: function() {
        // assumes one row of headers
        var behavior = this.behavior,
            renderer = this.getRenderer(),
            colCount = this.getColumnCount(),
            rowCount = renderer.getVisibleRows(),
            headers = new Array(colCount),
            results = new Array(rowCount),
            row;

        headers.forEach(function(header, c) {
            headers[c] = behavior.getColumnId(c, 0);
        });

        results.forEach(function(result, r) {
            row = results[r] = {
                hierarchy: behavior.getFixedColumnValue(0, r)
            };
            headers.forEach(function(field, c) {
                row[field] = behavior.getValue(c, r);
            });
        });

        return results;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} An object that represents the currently selection row.
     */
    getSelectedRow: function() {
        var sels = this.selectionModel.getSelections();
        if (sels.length) {
            var behavior = this.behavior,
                colCount = this.getColumnCount(),
                topRow = sels[0].origin.y,
                row = {
                    //hierarchy: behavior.getFixedColumnValue(0, topRow)
                };

            for (var c = 0; c < colCount; c++) {
                row[behavior.getColumnId(c, 0)] = behavior.getValue(c, topRow);
            }

            return row;
        }
    },

    fireRequestCellEdit: function(cell, value) {
        var clickEvent = new CustomEvent('fin-request-cell-edit', {
            cancelable: true,
            detail: {
                value: value,
                gridCell: cell,
                time: Date.now()
            }
        });
        return this.canvas.dispatchEvent(clickEvent); //I wasn't cancelled
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a fin-before-cell-edit event.
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} value - The current value.
     */
    fireBeforeCellEdit: function(cell, oldValue, newValue, control) {
        var clickEvent = new CustomEvent('fin-before-cell-edit', {
            cancelable: true,
            detail: {
                oldValue: oldValue,
                newValue: newValue,
                gridCell: cell,
                time: Date.now(),
                input: control,
                row: this.getRow(cell.y)
            }
        });
        var proceed = this.canvas.dispatchEvent(clickEvent);
        return proceed; //I wasn't cancelled
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Renderer} sub-component
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} oldValue - The old value.
     * @param {Object} newValue - The new value.
     */
    fireAfterCellEdit: function(cell, oldValue, newValue, control) {
        var clickEvent = new CustomEvent('fin-after-cell-edit', {
            detail: {
                newValue: newValue,
                oldValue: oldValue,
                gridCell: cell,
                time: Date.now(),
                input: control,
                row: this.getRow(cell.y)
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Autosize the column at colIndex for best fit.
     * @param {number} colIndex - The column index to modify at
     */
    autosizeColumn: function(colIndex) {
        var column = this.behavior.getColumn(colIndex);
        column.checkColumnAutosizing(true);
        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Enable/disable if this component can receive the focus.
     * @param {boolean} - canReceiveFocus
     */
    setFocusable: function(canReceiveFocus) {
        this.getCanvas().setFocusable(canReceiveFocus);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of columns that were just rendered
     */
    getVisibleColumnsCount: function() {
        return this.getRenderer().getVisibleColumnsCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of rows that were just rendered
     */
    getVisibleRowsCount: function() {
        return this.getRenderer().getVisibleRowsCount();
    },

    /**
     * @memberOf Hypergrid.prototype
    update the size of the grid
     *
     * #### returns: integer
     */
    updateSize: function() {
        this.canvas.checksize();
    },


    /**
     * @memberOf Hypergrid.prototype
     * @desc Stop the global repainting flag thread.
     */
    stopPaintThread: function() {
        this.canvas.stopPaintThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Stop the global resize check flag thread.
     */
    stopResizeThread: function() {
        this.canvas.stopResizeThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Restart the global resize check flag thread.
     */
    restartResizeThread: function() {
        this.canvas.restartResizeThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Restart the global repainting check flag thread.
     */
    restartPaintThread: function() {
        this.canvas.restartPaintThread();
    },

    swapColumns: function(source, target) {
        this.behavior.swapColumns(source, target);
    },

    endDragColumnNotification: function() {
        this.behavior.endDragColumnNotification();
    },

    getFixedColumnsMaxWidth: function() {
        return this.behavior.getFixedColumnsMaxWidth();
    },

    isMouseDownInHeaderArea: function() {
        var numHeaderColumns = this.getHeaderColumnCount();
        var numHeaderRows = this.getHeaderRowCount();
        var mouseDown = this.getMouseDown();
        return mouseDown.x < numHeaderColumns || mouseDown.y < numHeaderRows;
    },

    isHeaderWrapping: function() {
        return this.resolveProperty('headerTextWrapping');
    },

    _getBoundsOfCell: function(x, y) {
        return this.getRenderer()._getBoundsOfCell(x, y);
    },

    getColumnProperties: function(columnIndex) {
        return this.behavior.getColumnProperties(columnIndex);
    },

    setColumnProperties: function(columnIndex, properties) {
        this.behavior.setColumnProperties(columnIndex, properties);
    },

    moveSingleSelect: function(x, y) {
        this.behavior.moveSingleSelect(this, x, y);
    },

    selectCell: function(x, y) {
        this.selectionModel.clear();
        this.selectionModel.select(x, y, 0, 0);
    },

    getHeaderColumnCount: function() {
        return this.behavior.getHeaderColumnCount();
    },

    toggleSort: function(x, keys) {
        this.stopEditing();
        var behavior = this.behavior;
        var self = this;
        behavior.toggleSort(x, keys);

        setTimeout(function() {
            self.synchronizeScrollingBoundries();
            //self.behaviorChanged();
            if (self.isColumnAutosizing()) {
                behavior.autosizeAllColumns();
            }
            self.repaint();
        }, 10);
    },

    toggleSelectColumn: function(x, keys) {
        keys = keys || [];
        var model = this.selectionModel;
        var alreadySelected = model.isColumnSelected(x);
        var hasCTRL = keys.indexOf('CTRL') > -1;
        var hasSHIFT = keys.indexOf('SHIFT') > -1;
        if (!hasCTRL && !hasSHIFT) {
            model.clear();
            if (!alreadySelected) {
                model.selectColumn(x);
            }
        } else {
            if (hasCTRL) {
                if (alreadySelected) {
                    model.deselectColumn(x);
                } else {
                    model.selectColumn(x);
                }
            }
            if (hasSHIFT) {
                model.clear();
                model.selectColumn(this.lastEdgeSelection[0], x);
            }
        }
        if (!alreadySelected && !hasSHIFT) {
            this.lastEdgeSelection[0] = x;
        }
        this.repaint();
        this.fireSyntheticColumnSelectionChangedEvent();
    },

    toggleSelectRow: function(y, keys) {
        //we can select the totals rows if they exist, but not rows above that
        if (y > this.getFilterRowIndex()) {
            keys = keys || [];

            var sm = this.selectionModel;
            var alreadySelected = sm.isRowSelected(y);
            var hasSHIFT = keys.indexOf('SHIFT') >= 0;

            if (alreadySelected) {
                sm.deselectRow(y);
            } else {
                this.singleSelect();
                sm.selectRow(y);
            }

            if (hasSHIFT) {
                sm.clear();
                sm.selectRow(this.lastEdgeSelection[1], y);
            }

            if (!alreadySelected && !hasSHIFT) {
                this.lastEdgeSelection[1] = y;
            }
            this.repaint();
        }
    },

    singleSelect: function() {
        var isCheckboxOnlyRowSelections = this.isCheckboxOnlyRowSelections(),
            isSingleRowSelectionMode = this.isSingleRowSelectionMode(),
            hasCTRL = this.mouseDownState.primitiveEvent.detail.primitiveEvent.ctrlKey,
            result = (
                isCheckboxOnlyRowSelections && isSingleRowSelectionMode ||
                !isCheckboxOnlyRowSelections && (!hasCTRL || isSingleRowSelectionMode)
            );

        if (result) {
            this.selectionModel.clearRowSelection();
        }

        return result;
    },

    selectViewportCell: function(x, y) {
        var headerRowCount = this.getHeaderRowCount();
        var renderer = this.getRenderer();
        var realX = renderer.getVisibleColumns()[x];
        var realY = renderer.getVisibleRows()[y];
        this.clearSelections();
        this.select(realX, realY + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(realX, realY + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToViewportCell: function(x, y) {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var headerRowCount = this.getHeaderRowCount();
            var renderer = this.getRenderer();
            var realX = renderer.getVisibleColumns()[x];
            var realY = renderer.getVisibleRows()[y] + headerRowCount;
            var selection = selections[0];
            var origin = selection.origin;
            this.setDragExtent(this.newPoint(realX - origin.x, realY - origin.y));
            this.select(origin.x, origin.y, realX - origin.x, realY - origin.y);
            this.repaint();
        }
    },

    selectFinalCellOfCurrentRow: function() {
        var x = this.getColumnCount() - 1;
        var y = this.getSelectedRows()[0];
        var headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.scrollBy(this.getColumnCount(), 0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFinalCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0];
            var origin = selection.origin;
            var extent = selection.extent;
            var columnCount = this.getColumnCount();
            this.scrollBy(columnCount, 0);

            this.clearSelections();
            this.select(origin.x, origin.y, columnCount - origin.x - 1, extent.y);

            this.repaint();
        }
    },

    selectFirstCellOfCurrentRow: function() {
        var x = 0;
        var y = this.getSelectedRows()[0];
        var headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.setHScrollValue(0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFirstCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0];
            var origin = selection.origin;
            var extent = selection.extent;
            this.clearSelections();
            this.select(origin.x, origin.y, -origin.x, extent.y);
            this.setHScrollValue(0);
            this.repaint();
        }
    },

    selectFinalCell: function() {
        this.selectCell(this.getColumnCount() - 1, this.getRowCount() - 1);
        this.scrollBy(this.getColumnCount(), this.getRowCount());
        this.repaint();
    },

    selectToFinalCell: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0];
            var origin = selection.origin;
            var columnCount = this.getColumnCount();
            var rowCount = this.getRowCount();

            this.clearSelections();
            this.select(origin.x, origin.y, columnCount - origin.x - 1, rowCount - origin.y - 1);
            this.scrollBy(columnCount, rowCount);
            this.repaint();
        }
    },

    isShowRowNumbers: function() {
        return this.resolveProperty('showRowNumbers');
    },
    isEditable: function() {
        return this.resolveProperty('editable') === true;
    },
    isShowFilterRow: function() {
        return this.resolveProperty('showFilterRow');
    },
    isShowHeaderRow: function() {
        return this.resolveProperty('showHeaderRow');
    },
    getHeaderRowCount: function() {
        return this.behavior.getHeaderRowCount();
    },
    isFilterRow: function(y) {
        return y === this.getFilterRowIndex();
    },
    getFilterRowIndex: function() {
        return !this.isShowFilterRow() ? -1 : this.isShowHeaderRow() ? 1 : 0;
    },
    setGroups: function(arrayOfColumnIndexes) {
        this.behavior.setGroups(arrayOfColumnIndexes);
    },
    hasHierarchyColumn: function() {
        return this.behavior.hasHierarchyColumn();
    },
    isHierarchyColumn: function(x) {
        return this.hasHierarchyColumn() && x === 0;
    },
    checkScrollbarVisibility: function() {
        // var hoverClassOver = this.resolveProperty('scrollbarHoverOver');
        // var hoverClassOff = this.resolveProperty('scrollbarHoverOff');

        // if (hoverClassOff === 'visible') {
        //     this.sbHScroller.classList.remove(hoverClassOver);
        //     this.sbVScroller.classList.remove(hoverClassOff);
        //     this.sbHScroller.classList.add('visible');
        //     this.sbVScroller.classList.add('visible');
        // }
    },
    isColumnOrRowSelected: function() {
        return this.selectionModel.isColumnOrRowSelected();
    },
    selectColumn: function(x1, x2) {
        this.selectionModel.selectColumn(x1, x2);
    },
    selectRow: function(y1, y2) {
        var sm = this.selectionModel;
        var selectionEdge = this.getFilterRowIndex() + 1;

        if (this.singleSelect()) {
            y1 = y2;
        } else {
            // multiple row selection
            y2 = y2 || y1;
        }
        var min = Math.min(y1, y2);
        if (min >= selectionEdge) {
            var max = Math.max(y1, y2);
            sm.selectRow(min, max);
        }
    },
    isRowNumberAutosizing: function() {
        return this.resolveProperty('rowNumberAutosizing');
    },
    isRowSelected: function(r) {
        return this.selectionModel.isRowSelected(r);
    },
    isColumnSelected: function(c) {
        return this.selectionModel.isColumnSelected(c);
    },
    lookupFeature: function(key) {
        return this.behavior.lookupFeature(key);
    },
    getRow: function(y) {
        return this.behavior.getRow(y);
    },
    getFieldName: function(index) {
        return this.behavior.getFieldName(index);
    },

    getColumnIndex: function(fieldName) {
        return this.behavior.getColumnIndex(fieldName);
    },
    isCellSelection: function() {
        return this.resolveProperty('cellSelection') === true;
    },
    isRowSelection: function() {
        return this.resolveProperty('rowSelection') === true;
    },
    isColumnSelection: function() {
        return this.resolveProperty('columnSelection') === true;
    },
    getComputedRow: function(y) {
        return this.behavior.getComputedRow(y);
    },
    isColumnAutosizing: function() {
        return this.resolveProperty('columnAutosizing') === true;
    },
    getGlobalFilter: function() {
        return this.behavior.getGlobalFilter();
    },
    setGlobalFilter: function(filterOrOptions) {
        this.behavior.setGlobalFilter(filterOrOptions);
    },
    selectRowsFromCells: function() {
        if (!this.isCheckboxOnlyRowSelections()) {
            var last,
                hasCTRL = this.mouseDownState.primitiveEvent.detail.primitiveEvent.ctrlKey;

            if (hasCTRL && !this.isSingleRowSelectionMode()) {
                this.selectionModel.selectRowsFromCells(0, hasCTRL);
            } else if ((last = this.selectionModel.getLastSelection())) {
                this.selectRow(null, last.corner.y);
            } else {
                this.clearRowSelection();
            }
        }
    },
    selectColumnsFromCells: function() {
        this.selectionModel.selectColumnsFromCells();
    },
    getSelectedRows: function() {
        return this.behavior.getSelectedRows();
    },
    getSelectedColumns: function() {
        return this.behavior.getSelectedColumns();
    },
    getSelections: function() {
        return this.behavior.getSelections();
    },
    getLastSelectionType: function() {
        return this.selectionModel.getLastSelectionType();
    },
    isCellSelected: function(x, y) {
        return this.selectionModel.isCellSelected(x, y);
    },
    isInCurrentSelectionRectangle: function(x, y) {
        return this.selectionModel.isInCurrentSelectionRectangle(x, y);
    },
    selectAllRows: function() {
        this.selectionModel.selectAllRows();
    },
    areAllRowsSelected: function() {
        return this.selectionModel.areAllRowsSelected();
    },
    toggleSelectAllRows: function() {
        if (this.areAllRowsSelected()) {
            this.selectionModel.clear();
        } else {
            this.selectAllRows();
        }
        this.repaint();
    },
    getField: function(x) {
        return this.behavior.getField(x);
    },
    isSingleRowSelectionMode: function() {
        return this.resolveProperty('singleRowSelectionMode');
    },
    newPoint: function(x, y) {
        return new Point(x, y);
    },
    newRectangle: function(x, y, width, height) {
        return new Rectangle(x, y, width, height);
    },
    getFormattedValue: function(x, y) {
        y = y + this.getHeaderRowCount();
        var formatType = this.getColumnProperties(x).format;
        var value = this.getValue(x, y);
        var formatter = this.getFormatter(formatType);
        var string = formatter(value);
        return string;
    }
};

/**
 * @summary Update deep properties with new values.
 * @desc This function is a recursive property setter which updates a deep property in a destination object with the value of a congruent property in a source object.
 *
 * > Terminology: A deep property is a "terminal node" (primitive value) nested at some depth (i.e., depth > 1) inside a complex object (an object containing nested objects). A congruent property is a property in another object with the same name and at the same level of nesting.
 *
 * This function is simple and elegant. I recommend you study the code, which nonetheless implies all of the following:
 *
 * * If the deep property is _not_ found in `destination`, it will be created.
 * * If the deep property is found in `destination` _and_ is a primitive type, it will be modified (overwritten with the value from `source`).
 * * If the deep property is found in `destination` _but_ is not a primitive type (i.e., is a nested object), it will _also_ be overwritten with the (primitive) value from `source`.
 * * If the nested object the deep property inhabits in `source` is not found in `destination`, it will be created.
 * * If the nested object the deep property inhabits in `source` is found in `destination` but is not in fact an object (i.e., it is a primitive value), it will be overwritten with a reference to that object.
 * * If the primitive value is `undefined`, the destination property is deleted.
 * * `source` may contain multiple properties to update.
 *
 * That one rule is simply this: If both the source _and_ the destination properties are objects, then recurse; else overwrite the destination property with the source property.
 *
 * > Caveat: This is _not_ equivalent to a deep extend function. While both a deep extend and this function will recurse over a complex object, they are fundamentally different: A deep extend clones the nested objects as it finds them; this function merely updates them (or creates them where they don't exist).
 *
 * @param {object} destination - An object to update with new or modified property values
 * @param {object} source - A congruent object continaly (only) the new or modified property values.
 * @returns {object} Always returns `destination`.
 */
function addDeepProperties(destination, source) {
    _(source).each(function(property, key) {
        if (typeof destination[key] === 'object' && typeof property === 'object') {
            addDeepProperties(destination[key], property);
        } else if (property === undefined) {
            delete destination[key];
        } else {
            destination[key] = property;
        }
    });
    return destination;
}

function normalizeRect(rect) {
    var o = rect.origin;
    var c = rect.corner;

    var ox = Math.min(o.x, c.x);
    var oy = Math.min(o.y, c.y);

    var cx = Math.max(o.x, c.x);
    var cy = Math.max(o.y, c.y);

    var result = new Rectangle(ox, oy, cx - ox, cy - oy);

    return result;
}

function buildPolymerTheme() {
    clearObjectProperties(polymerTheme);
    var pb = document.createElement('paper-button');

    pb.style.display = 'none';
    pb.setAttribute('disabled', true);
    document.body.appendChild(pb);
    var p = window.getComputedStyle(pb);

    var section = document.createElement('section');
    section.style.display = 'none';
    section.setAttribute('hero', true);
    document.body.appendChild(section);

    var h = window.getComputedStyle(document.querySelector('html'));
    var hb = window.getComputedStyle(document.querySelector('html, body'));
    var s = window.getComputedStyle(section);

    polymerTheme.columnHeaderBackgroundColor = p.color;
    polymerTheme.rowHeaderBackgroundColor = p.color;
    polymerTheme.topLeftBackgroundColor = p.color;
    polymerTheme.lineColor = p.backgroundColor;

    polymerTheme.backgroundColor2 = hb.backgroundColor;

    polymerTheme.color = h.color;
    polymerTheme.fontFamily = h.fontFamily;
    polymerTheme.backgroundColor = s.backgroundColor;

    pb.setAttribute('disabled', false);
    pb.setAttribute('secondary', true);
    pb.setAttribute('raised', true);
    p = window.getComputedStyle(pb);

    polymerTheme.columnHeaderColor = p.color;
    polymerTheme.rowHeaderColor = p.color;
    polymerTheme.topLeftColor = p.color;


    polymerTheme.backgroundSelectionColor = p.backgroundColor;
    polymerTheme.foregroundSelectionColor = p.color;

    pb.setAttribute('secondary', false);
    pb.setAttribute('warning', true);

    polymerTheme.columnHeaderForegroundSelectionColor = p.color;
    polymerTheme.columnHeaderBackgroundSelectionColor = p.backgroundColor;
    polymerTheme.rowHeaderForegroundSelectionColor = p.color;
    polymerTheme.fixedColumnBackgroundSelectionColor = p.backgroundColor;

    //check if there is actually a theme loaded if not, clear out all bogus values
    //from my cache
    if (polymerTheme.columnHeaderBackgroundSelectionColor === 'rgba(0, 0, 0, 0)' ||
        polymerTheme.lineColor === 'transparent') {
        clearObjectProperties(polymerTheme);
    }

    document.body.removeChild(pb);
    document.body.removeChild(section);
}

function clearObjectProperties(obj) {
    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            delete obj[prop];
        }
    }
}

function valOrFunc(vf) {
    var result = (typeof vf)[0] === 'f' ? vf() : vf;
    return result || result === 0 ? result : '';
}

module.exports = Hypergrid;

},{"../css/stylesheets":1,"./defaults":50,"./lib/Formatters":73,"./lib/Renderer":75,"./lib/SelectionModel":76,"./lib/TableDialog":77,"./lib/deprecated":78,"extend-me":5,"finbars":16,"fincanvas":17,"object-iterators":24,"rectangular":26}],32:[function(require,module,exports){
/* eslint-env browser */
'use strict';

var _ = require('object-iterators');
var Base = require('../lib/Base');

var Column = require('./Column');
var CellProvider = require('../lib/CellProvider');

var noExportProperties = [
    'columnHeader',
    'columnHeaderColumnSelection',
    'filterProperties',
    'rowHeader',
    'rowHeaderRowSelection',
    'rowNumbersProperties',
    'treeColumnProperties',
    'treeColumnPropertiesColumnSelection',
];

var isNull = {
    isNull: true
};

/**
 * @constructor
 * @abstract
 * @desc A sort of "model++." It contains all code/data that's necessary for easily implementing a virtual data source and its manipulation/analytics.
 *
 */
var Behavior = Base.extend('Behavior', {

    /**
     * @desc this is the callback for the plugin pattern of nested tags
     * @param {Hypergrid} grid
     * @memberOf Behavior.prototype
     */
    initialize: function(grid) { //formerly installOn
        this.setGrid(grid);
        this.initializeFeatureChain(grid);

        this.cellProvider = this.createCellProvider();
        this.renderedColumnCount = 30;
        this.renderedRowCount = 60;
        this.dataUpdates = {}; //for overriding with edit values;
    },

    /**
     * @desc create the feature chain - this is the [chain of responsibility](http://c2.com/cgi/wiki?ChainOfResponsibilityPattern) pattern.
     * @param {Hypergrid} grid
     * @memberOf Behavior.prototype
     */
    initializeFeatureChain: function(grid) {
        var self = this;
        this.features.forEach(function(FeatureConstructor) {
            self.setNextFeature(new FeatureConstructor);
        });

        this.featureChain.initializeOn(grid);
    },

    features: [], // in case implementing class has no features TODO: Will this ever happen?

    /**
     * memento for the user configured visual properties of the table
     * @type {object}
     * @memberOf Behavior.prototype
     */
    tableState: null,

    /**
     * @type {Hypergrid}
     * @memberOf Behavior.prototype
     */
    grid: null,

    /**
     * list of default cell editor names
     * @type {string[]}
     * @memberOf Behavior.prototype
     */
    editorTypes: [
        'choice',
        'textfield',
        'color',
        'slider',
        'spinner',
        'date'
    ],

    /**
     * controller chain of command
     * @type {object}
     * @memberOf Behavior.prototype
     */
    featureChain: null,

    dataModel: null,
    baseModel: null,

    scrollPositionX: 0,
    scrollPositionY: 0,

    featureMap: {},
    allColumns: [],
    columns: [],

    reset: function() {
        this.cellProvider = this.createCellProvider();
        this.renderedColumnCount = 30;
        this.renderedRowCount = 60;
        this.dataUpdates = {}; //for overriding with edit values;
        this.clearColumns();
        this.clearState();
        this.dataModel.reset();
        this.createColumns();
    },

    clearColumns: function() {
        this.columns = [];
        this.allColumns = [];
        this.columns[-1] = this.newColumn(-1, '');
        this.columns[-2] = this.newColumn(-2, 'Tree');
        this.allColumns[-1] = this.columns[-1];
        this.allColumns[-2] = this.columns[-2];
    },

    getColumn: function(x) {
        return this.columns[x];
    },

    getColumnId: function(x) {
        return this.getColumn(x).label;
    },

    newColumn: function(index, label) {
        var properties = this.createColumnProperties();
        this.getPrivateState().columnProperties[index] = properties;
        return new Column(this, index, label);
    },

    addColumn: function(index, label) {
        var column = this.newColumn(index, label);
        this.columns.push(column);
        this.allColumns.push(column);
        return column;
    },

    createColumns: function() {
        //concrete implementation here
    },

    createColumnProperties: function() {
        var tableState = this.getPrivateState();
        var properties = Object.create(tableState);

        properties.rowNumbersProperties = Object.create(properties, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.rowHeader = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.rowHeaderFont;
                },
                set: function(value) {
                    this.rowHeaderFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.rowHeaderColor;
                },
                set: function(value) {
                    this.rowHeaderColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundColor = value;
                }
            },
            foregroundSelectionFont: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundSelectionFont;
                },
                set: function(value) {
                    this.rowHeaderForegroundSelectionFont = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.columnHeader = Object.create(properties, {
            format: {
                value: 'default'
            },
            font: {
                configurable: true,
                get: function() {
                    return this.columnHeaderFont;
                },
                set: function(value) {
                    this.columnHeaderFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.columnHeaderColor;
                },
                set: function(value) {
                    this.columnHeaderColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundColor = value;
                }
            },
            foregroundSelectionFont: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionFont;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionFont = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.columnHeaderColumnSelection = Object.create(properties.columnHeader, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundColumnSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundColumnSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundColumnSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundColumnSelectionColor = value;
                }
            }
        });

        properties.rowHeaderRowSelection = Object.create(properties.rowHeader, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundRowSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderForegroundRowSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundRowSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundRowSelectionColor = value;
                }
            }
        });

        properties.filterProperties = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.filterFont;
                },
                set: function(value) {
                    this.filterFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.filterColor;
                },
                set: function(value) {
                    this.filterColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.filterBackgroundColor;
                },
                set: function(value) {
                    this.filterBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.filterForegroundSelectionColor;
                },
                set: function(value) {
                    this.filterForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.filterBackgroundSelectionColor;
                },
                set: function(value) {
                    this.filterBackgroundSelectionColor = value;
                }
            },
            cellBorderStyle: {
                configurable: true,
                get: function() {
                    return this.filterCellBorderStyle;
                },
                set: function(value) {
                    this.filterCellBorderStyle = value;
                }
            },
            cellBorderThickness: {
                configurable: true,
                get: function() {
                    return this.filterCellBorderThickness;
                },
                set: function(value) {
                    this.filterCellBorderThickness = value;
                }
            }
        });

        properties.treeColumnProperties = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.treeColumnFont;
                },
                set: function(value) {
                    this.treeColumnFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.treeColumnColor;
                },
                set: function(value) {
                    this.treeColumnColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnForegroundSelectionColor;
                },
                set: function(value) {
                    this.treeColumnForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundSelectionColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundSelectionColor = value;
                }
            }
        });

        properties.treeColumnPropertiesColumnSelection = Object.create(properties.treeColumnProperties, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnForegroundColumnSelectionColor;
                },
                set: function(value) {
                    this.treeColumnForegroundColumnSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundColumnSelectionColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundColumnSelectionColor = value;
                }
            }
        });

        return properties;
    },

    getColumnWidth: function(x) {
        var col = this.getColumn(x);
        if (!col) {
            return this.resolveProperty('defaultColumnWidth');
        }
        var width = col.getWidth();
        return width;
    },

    setColumnWidth: function(x, width) {
        this.getColumn(x).setWidth(width);
        this.stateChanged();
    },

    /** @deprecated Use `.dataModel` property instead.
     * @memberOf Behavior.prototype
     * @returns {Hypergrid} The hypergrid to which this behavior is attached.
     */
    getDataModel: function() {
        return this.deprecated('dataModel', { since: '0.2.1' });
    },

    getCellRenderer: function(config, x, y) {
        return this.getColumn(x).getCellRenderer(config, y);
    },

    applyAnalytics: function() {
        this.dataModel.applyAnalytics();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc utility function to empty an object of its members
     * @param {object} obj - the object to empty
     * @param {boolean} [exportProps]
     * * `undefined` (omitted) - delete *all* properties
     * * **falsy** - delete *only* the export properties
     * * **truthy** - delete all properties *except* the export properties
     */
    clearObjectProperties: function(obj, exportProps) {
        for (var key in obj) {
            if (
                obj.hasOwnProperty(key) && (
                    exportProps === undefined ||
                    !exportProps && noExportProperties.indexOf(key) >= 0 ||
                    exportProps && noExportProperties.indexOf(key) < 0
                )
            ) {
                delete obj[key];
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc getter for a [Memento](http://c2.com/cgi/wiki?MementoPattern) Object
     * @returns {object}
     */
    getPrivateState: function() {
        if (!this.tableState) {
            this.tableState = this.getDefaultState();
        }
        return this.tableState;
    },

    //this is effectively a clone, with certain things removed....
    getState: function() {
        var copy = JSON.parse(JSON.stringify(this.getPrivateState()));
        this.clearObjectProperties(copy.columnProperties, false);
        return copy;
    },
    /**
     * @memberOf Behavior.prototype
     * @desc clear all table state
     */
    clearState: function() {
        this.tableState = null;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {object} Newly created default empty tablestate.
     */
    getDefaultState: function() {
        var tableProperties = this.grid._getProperties();
        var state = Object.create(tableProperties);

        _(state).extendOwn({
            rowHeights: {},
            cellProperties: {},
            columnProperties: []
        });

        return state;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Restore this table to a previous state.
     * See the [memento pattern](http://c2.com/cgi/wiki?MementoPattern).
     * @param {Object} memento - an encapsulated representation of table state
     */
    setState: function(memento) {

        //we don't want to clobber the column properties completely
        if (!memento.columnIndexes) {
            var fields = this.getFields();
            memento.columnIndexes = [];
            for (var i = 0; i < fields.length; i++) {
                memento.columnIndexes[i] = i;
            }
        }
        var colProperties = memento.columnProperties;
        delete memento.columnProperties;
        this.tableState = null;
        var state = this.getPrivateState();
        this.createColumns();
        this.setColumnOrder(memento.columnIndexes);
        _(state).extendOwn(memento);
        this.setAllColumnProperties(colProperties);
        memento.columnProperties = colProperties;
        //memento.columnProperties = colProperties;

        // this.dataModel.setState(memento);
        // var self = this;
        // requestAnimationFrame(function() {
        //     self.applySorts();
        //     self.changed();
        //     self.stateChanged();
        // });

        //just to be close/ it's easier on the eyes
        this.setColumnWidth(-1, 24.193359375);
        this.dataModel.applyState();
    },

    setAllColumnProperties: function(properties) {
        properties = properties || [];
        for (var i = 0; i < properties.length; i++) {
            var current = this.getPrivateState().columnProperties[i];
            this.clearObjectProperties(current, false);
            _(current).extendOwn(properties[i]);
        }
    },

    setColumnOrder: function(indexes) {
        if (!indexes) {
            this.columns.length = 0;
            return;
        }
        this.columns.length = indexes.length;
        for (var i = 0; i < indexes.length; i++) {
            this.columns[i] = this.allColumns[indexes[i]];
        }
    },

    applySorts: function() {
        //if I have sorts, apply them now//
    },

    /**
     * @memberOf Behavior.prototype
     * @desc fetch the value for a property key
     * @returns {*} The value of the given property.
     * @param {string} key - a property name
     */
    resolveProperty: function(key) {
        return this.grid.resolveProperty(key);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc A specific cell was clicked; you've been notified.
     * @param {Point} cell - point of cell coordinates
     * @param {Object} event - all event information
     */
    cellClicked: function(cell, event) {
        this.dataModel.cellClicked(cell, event);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc A specific cell was le double-clicked; you've been notified.
     * @param {Point} cell - point of cell coordinates
     * @param {Object} event - all event information
     */
    cellDoubleClicked: function(cell, event) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc add nextFeature to me If I don't have a next node, otherwise pass it along
     * @param {Feature}
     */
    setNextFeature: function(nextFeature) {
        this.featureMap[nextFeature.$$CLASS_NAME] = nextFeature;
        if (this.featureChain) {
            this.featureChain.setNext(nextFeature);
        } else {
            this.featureChain = nextFeature;
        }
    },

    lookupFeature: function(key) {
        return this.featureMap[key];
    },

    /**
     * @memberOf Behavior.prototype
     * @desc getter for the cell provider
     * @return {CellProvider}
     */
    getCellProvider: function() {
        return this.cellProvider;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc setter for the hypergrid
     * @param {Hypergrid} grid
     */
    setGrid: function(grid) {
        this.grid = grid;
        this.dataModel = this.dataModel || this.getDefaultDataModel();
        this.dataModel.setGrid(grid);
        grid.setBehavior(this);
        this.clearColumns();
    },

    /** @deprecated Use `.grid` property instead.
     * @memberOf Behavior.prototype
     * @returns {Hypergrid} The hypergrid to which this behavior is attached.
     * @param {type} varname - descripton
     */
    getGrid: function() {
        return this.deprecated('grid', { since: '0.2' });
    },

    /**
     * @memberOf Behavior.prototype
     * @desc You can override this function and substitute your own cell provider.
     * @return {CellProvider}
     */
    createCellProvider: function() {
        return new CellProvider();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc First check to see if something was overridden.
     * @return {*} The value at `x,y` for the top left section of the hypergrid.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     */
    getValue: function(x, y) {
        var column = this.getColumn(x);
        return column && column.getValue(y);
    },

    getUnfilteredValue: function(x, y) {
        var column = this.getColumn(x);
        return column && column.getUnfilteredValue(y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @return The data.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     * @param {Object} value - the value to use
     */
    setValue: function(x, y, value) {
        var column = this.getColumn(x);
        return column && column.setValue(y, value);
    },

    getDataValue: function(x, y) {
        return this.dataModel.getValue(x, y);
    },

    setDataValue: function(x, y, value) {
        this.dataModel.setValue(x, y, value);
    },
    /**
     * @memberOf Behavior.prototype
     * @desc First checks to see if something was overridden.
     * @return {*} The value at x,y for the top left section of the hypergrid.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     */
    getCellProperties: function(x, y) {
        return this.getColumn(x).getCellProperties(y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     * @param {Object} value - the value to use
     */
    setCellProperties: function(x, y, value) {
        var col = this.getColumn(x);
        if (col) {
            col.setCellProperties(y, value);
        }
    },
    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of rows in the hypergrid.
     */
    getRowCount: function() {
        return this.dataModel.getRowCount();
    },

    getUnfilteredRowCount: function() {
        return this.dataModel.getUnfilteredRowCount();
    },
    /**
     * @memberOf Behavior.prototype
     * @return {number} The height in pixels of the fixed rows area  of the hypergrid.
     */
    getFixedRowsHeight: function() {
        var count = this.getFixedRowCount();
        var total = 0;
        for (var i = 0; i < count; i++) {
            total = total + this.getRowHeight(i);
        }
        //var footerHeight = this.getDefaultRowHeight();
        //total = total + (footerHeight * this.getFooterRowCount());
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The height in pixels of a specific row in the hypergrid.
     * @param {number} rowNum - row index of interest
     */
    getRowHeight: function(rowNum) {
        var rowHeights = this.getPrivateState().rowHeights;
        return rowHeights && rowHeights[rowNum] || this.getDefaultRowHeight();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The value is lazily initialized and comes from the properties mechanism for '`defaultRowHeight`', which should be ~20px.
     * @returns {number} The row height in pixels.
     */
    getDefaultRowHeight: function() {
        if (!this.defaultRowHeight) {
            this.defaultRowHeight = this.resolveProperty('defaultRowHeight');
        }
        return this.defaultRowHeight;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the pixel height of a specific row
     * @param {number} rowNum - the row index of interest
     * @param {number} height - pixel height
     */
    setRowHeight: function(rowNum, height) {
        var tableState = this.getPrivateState();
        tableState.rowHeights[rowNum] = Math.max(5, height);
        this.stateChanged();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc This will allow 'floating' fixed rows.
     * @return {number} The maximum height of the fixed rows area in the hypergrid.
     */
    getFixedRowsMaxHeight: function() {
        return this.getFixedRowsHeight();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The width of the fixed column area in the hypergrid.
     */
    getFixedColumnsWidth: function() {
        var count = this.getFixedColumnCount();
        var total = 0;
        if (this.grid.isShowRowNumbers()) {
            total = this.getColumnWidth(-1);
        }
        for (var i = 0; i < count; i++) {
            total = total + this.getColumnWidth(i);
        }
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc This exists to support "floating" columns.
     * @return {number} The total width of the fixed columns area.
     */
    getFixedColumnsMaxWidth: function() {
        return this.getFixedColumnsWidth();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the scroll position in vertical dimension and notify listeners.
     * @param {number} y - the new y value
     */
    _setScrollPositionY: function(y) {
        this.setScrollPositionY(y);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the scroll position in horizontal dimension and notify listeners.
     * @param {number} x - the new x value
     */
    _setScrollPositionX: function(x) {
        this.setScrollPositionX(x);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of columns just rendered, including partially rendered columns.
     * @param {number} count - how many columns were just rendered
     */
    setRenderedColumnCount: function(count) {
        this.renderedColumnCount = count;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of rows just rendered, including partially rendered rows.
     * @param {number} count - how many rows were just rendered
     */
    setRenderedRowCount: function(count) {
        this.renderedRowCount = count;
    },


    /**
     * @memberOf Behavior.prototype
     * @desc The fixed row area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedRowClicked: function(grid, mouse) {
        var x = this.translateColumnIndex(this.getScrollPositionX() + mouse.gridCell.x - this.getFixedColumnCount());
        var translatedPoint = this.grid.newPoint(x, mouse.gridCell.y);
        mouse.gridCell = translatedPoint;
        this.fixedRowClicked(grid, mouse);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The fixed column area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedColumnClicked: function(grid, mouse) {
        var translatedPoint = this.grid.newPoint(mouse.gridCell.x, this.getScrollPositionY() + mouse.gridCell.y - this.getFixedRowCount());
        mouse.gridCell = translatedPoint;
        this.fixedColumnClicked(grid, mouse);
    },

    moveSingleSelect: function(grid, x, y) {
        if (this.featureChain) {
            this.featureChain.moveSingleSelect(grid, x, y);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate setting the cursor up the feature chain of responsibility
     * @param {Hypergrid} grid
     */
    setCursor: function(grid) {
        grid.updateCursor();
        this.featureChain.setCursor(grid);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse move to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseMove: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseMove(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onTap: function(grid, event) {

        if (this.featureChain) {
            this.featureChain.handleTap(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onContextMenu: function(grid, event) {
        var proceed = grid.fireSyntheticContextMenuEvent(event);
        if (proceed && this.featureChain) {
            this.featureChain.handleContextMenu(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling wheel moved to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onWheelMoved: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleWheelMoved(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse drag to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseDrag: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDrag(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling key down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling key up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onDoubleClick: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleDoubleClick(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling hold pulse to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onHoldPulse: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleHoldPulse(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    toggleColumnPicker: function() {
        var dialog = this.grid.dialog;
        var self = this;
        if (dialog.isOpen()) {
            dialog.close();
        } else {
            this.buildColumnPicker(dialog.overlay);
            dialog.onClose = function() {
                self.updateFromColumnPicker(dialog.overlay);
            };
            dialog.open();
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse exit to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseExit(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is replaced by the grid on initialization and serves as the callback
     */
    changed: function() {},

    /**
     * @memberOf Behavior.prototype
     * @desc this function is replaced by the grid on initialization and serves as the callback
     */
    shapeChanged: function() {},

    /**
     * @memberOf Behavior.prototype
     * @return {boolean} Can re-order columns.
     */
    isColumnReorderable: function() {
        return true;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {Object} The properties for a specific column. These are used if no cell properties are specified.
     * @param {index} columnIndex - the column index of interest
     */
    getColumnProperties: function(columnIndex) {
        var col = this.columns[columnIndex];
        if (!col) {
            return isNull;
        }
        var properties = col.getProperties(); //TODO: returns `null` on Hypergrid.reset();
        if (!properties) {
            return isNull;
        }
        return properties;
    },

    setColumnProperties: function(columnIndex, properties) {
        var columnProperties = this.allColumns[columnIndex].getProperties();
        _(columnProperties).extendOwn(properties);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string} The field at `colIndex`.
     * @param {number} colIndex - the column index of interest
     */
    getField: function(colIndex) {
        return colIndex === -1 ? 'tree' : this.getColumn(colIndex).getField();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string} The column heading at `colIndex'.
     * @param {number} colIndex - the column index of interest
     */
    getHeader: function(colIndex) {
        return colIndex === -1 ? 'Tree' : this.getColumn(colIndex).getHeader();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this is called by the column editor post closing; rebuild the column order indexes
     * @param {Array} list - list of column objects from the column editor
     */
    setColumnDescriptors: function(lists) {
        //assumes there is one row....
        var visible = lists.visible;
        var tableState = this.getPrivateState();

        var columnCount = visible.length;
        var indexes = [];
        var i;
        for (i = 0; i < columnCount; i++) {
            indexes.push(visible[i].id);
        }
        tableState.columnIndexes = indexes;
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string[]} All the currently hidden column header labels.
     */
    getHiddenColumnDescriptors: function() {
        var tableState = this.getPrivateState();
        var indexes = tableState.columnIndexes;
        var labels = [];
        var columnCount = this.getColumnCount();
        for (var i = 0; i < columnCount; i++) {
            if (indexes.indexOf(i) === -1) {
                labels.push({
                    id: i,
                    label: this.getHeader(i),
                    field: this.getField(i)
                });
            }
        }
        return labels;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc hide columns that are specified by their indexes
     * @param {Array} arrayOfIndexes - an array of column indexes to hide
     */
    hideColumns: function(arrayOfIndexes) {
        var tableState = this.getPrivateState();
        var order = tableState.columnIndexes;
        for (var i = 0; i < arrayOfIndexes.length; i++) {
            var each = arrayOfIndexes[i];
            if (order.indexOf(each) !== -1) {
                order.splice(order.indexOf(each), 1);
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @return {integer} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.getPrivateState().fixedColumnCount || 0;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the number of fixed columns
     * @param {number} n - the integer count of how many columns to be fixed
     */
    setFixedColumnCount: function(n) {
        this.getPrivateState().fixedColumnCount = n;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {integer} The number of fixed rows.
     */
    getFixedRowCount: function() {
        if (!this.tableState) {
            return 0;
        }
        var headers = this.grid.getHeaderRowCount();
        var usersSize = this.tableState.fixedRowCount || 0;
        return headers + usersSize;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of fixed rows, which includes (top to bottom order):
     * 1. The header rows
     *    1. The header labels row (optional)
     *    2. The filter row (optional)
     *    3. The top total rows (0 or more)
     * 2. The non-scrolling rows (externally called "the fixed rows")
     *
     * @returns {number} Sum of the above or 0 if none of the above are in use.
     *
     * @param {number} n - The number of rows.
     */
    setFixedRowCount: function(n) {
        this.tableState.fixedRowCount = n;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of header rows.
     * A portion of the number returned by {@link Behavior#getFixedRowCount()|getFixedRowCount()}.
     * (The remaining _fixed rows_ are the _top totals_ rows.)
     */
    getHeaderRowCount: function() {
        var header = this.grid.isShowHeaderRow() ? 1 : 0;
        var filter = this.grid.isShowFilterRow() ? 1 : 0;
        var totals = this.getTopTotals().length;
        return header + filter + totals;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of footer rows, consisting entirely of 0 or more _bottom totals_ rows.
     */
    getFooterRowCount: function() {
        return this.getBottomTotals().length;
    },

    getTopTotals: function() {
        return this.dataModel.getTopTotals();
    },
    /**
     * @memberOf Behavior.prototype
     * @summary Set the number of header rows.
     * @param {number} n - The number of _fixed rows_ to reserve as header rows.
     * (The remaining _fixed rows_ are the _top totals_ rows.)
     */
    setHeaderRowCount: function(n) {
        this.tableState.headerRowCount = n;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of fixed rows.
     */
    getHeaderColumnCount: function() {
        return this.grid.resolveProperty('headerColumnCount');
    },

    /**
     * @memberOf Behavior.prototype
     * @param {number} The number of fixed rows.
     */
    setHeaderColumnCount: function(numberOfHeaderColumns) {
        this.tableState.headerColumnCount = numberOfHeaderColumns;
    },
    /**
     * @memberOf Behavior.prototype
     * @desc build and open the editor within the container div argument
     * @return {boolean} `false` prevents editor from opening
     * @param {HTMLDivElement} div - the containing div element
     */
    buildColumnPicker: function(div) {
        var container = document.createElement('div');

        var hidden = document.createElement('fin-hypergrid-dnd-list');
        var visible = document.createElement('fin-hypergrid-dnd-list');

        container.appendChild(hidden);
        container.appendChild(visible);

        this.beColumnStyle(hidden.style);
        hidden.title = 'hidden columns';
        hidden.list = this.getHiddenColumnDescriptors();

        this.beColumnStyle(visible.style);
        visible.style.left = '50%';
        visible.title = 'visible columns';
        visible.list = this.getColumnDescriptors();

        div.lists = {
            hidden: hidden.list,
            visible: visible.list
        };
        div.appendChild(container);
        return true;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc the editor is requesting close; deal with the edits
     * @return `true`
     * @param {HTMLDivElement} div - the containing div element
     */
    updateFromColumnPicker: function(div) {
        var lists = div.lists;
        this.setColumnDescriptors(lists);
        return true;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc a dnd column has just been dropped, we've been notified
     */
    endDragColumnNotification: function() {},

    /**
     * @memberOf Behavior.prototype
     * @desc bind column editor appropriate css values to arg style
     * @param {HTMLStyleElement} style - the style object to enhance
     */
    beColumnStyle: function(style) {
        style.top = '5%';
        style.position = 'absolute';
        style.width = '50%';
        style.height = '100%';
        style.whiteSpace = 'nowrap';
    },

    /**
     * @memberOf Behavior.prototype
     * @return {null} the cursor at a specific x,y coordinate
     * @param {number} x - the x coordinate
     * @param {number} y - the y coordinate
     */
    getCursorAt: function(x, y) {
        return null;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The total number of columns.
     */
    getColumnCount: function() {
        return this.columns.length;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string} The column alignment at column `x`: `'left'`, `'center'` , or `'right'`
     * @param {number} x - The column index of interest.
     */
    getColumnAlignment: function(x) {
        return 'center';
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Quietly set the horizontal scroll position.
     * @param {number} x - The new position in pixels.
     */
    setScrollPositionX: function(x) {
        this.scrollPositionX = x;
    },

    getScrollPositionX: function() {
        return this.scrollPositionX;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Quietly set the vertical scroll position.
     * @param {number} y - The new position in pixels.
     */
    setScrollPositionY: function(y) {
        this.scrollPositionY = y;
    },

    getScrollPositionY: function() {
        return this.scrollPositionY;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {cellEditor} The cell editor for the cell at cell coordinates `x,y`
     * @param {number} x - The horizontal cell coordinate.
     * @param {number} y - The vertical cell coordinate.
     * @param {boolean} isDblClick - When called from `onEditorActivate`, indicates if event was a double-click.
     */
    _getCellEditorAt: function(x, y, isDblClick) {
        var editor,
            isFilterRow = this.grid.isFilterRow(y);

        if (!isFilterRow) {
            editor = this.getColumn(x).getCellEditorAt(x, y);
        } else if (!isDblClick) {
            // filter row single click just gets text editor
            editor = this.grid.cellEditors.textfield;
        }

        if (!editor) {
            var column = this.getColumn(x);
            var type = isFilterRow ? column.getFilterType() : column.getType();
            editor = this.grid.resolveCellEditor(type);
        }

        return editor;
    },

    getCellEditorAt: function(x, y) {
        if (this.grid.isFilterRow(y)) {
            return this.grid.cellEditors.textfield;
        }
        return this.dataModel.getCellEditorAt(x, y);
    },

    /**
     * @memberOf Behavior.prototype
     * @param {number} x - The column index.
     * @param {string[]} keys
     */
    toggleSort: function(x, keys) {
        this.getColumn(x).toggleSort(keys);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {boolean} `true` if we should highlight on hover
     * @param {boolean} isColumnHovered - the column is hovered or not
     * @param {boolean} isRowHovered - the row is hovered or not
     */
    highlightCellOnHover: function(isColumnHovered, isRowHovered) {
        return isColumnHovered && isRowHovered;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellPropertiesPrePaintNotification: function(cellProperties) {
        var row = this.getRow(cellProperties.y);
        var columnId = this.getHeader(cellProperties.x);
        cellProperties.row = row;
        cellProperties.columnId = columnId;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a fixed row cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedRowPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a fixed column cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedColumnPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a top left cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellTopLeftPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function enhance the double click event just before it's broadcast to listeners
     * @param {Object} event - event to enhance
     */
    enhanceDoubleClickEvent: function(event) {},

    /**
     * @memberOf Behavior.prototype
     * @desc swap src and tar columns
     * @param {number} src - column index
     * @param {number} tar - column index
     */
    swapColumns: function(source, target) {
        var columns = this.columns;
        var tmp = columns[source];
        columns[source] = columns[target];
        columns[target] = tmp;
        this.changed();
    },

    getColumnEdge: function(c, renderer) {
        return this.dataModel.getColumnEdge(c, renderer);
    },

    /**
     * @memberOf Behavior.prototype
     * @param {number} x - column index
     * @param {number} y - totals row index local to the totals area
     * @param value
     * @param {string[]} [areas=['top', 'bottom']] - may include `'top'` and/or `'bottom'`
     */
    setTotalsValue: function(x, y, value, areas) {
        this.grid.setTotalsValueNotification(x, y, value, areas);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {object} The object at y index.
     * @param {number} y - the row index of interest
     */
    getRow: function(y) {
        return this.dataModel.getRow(y);
    },

    convertViewPointToDataPoint: function(viewPoint) {
        var newX = this.getColumn(viewPoint.x).index;
        var newPoint = this.grid.newPoint(newX, viewPoint.y);
        return newPoint;
    },

    setGroups: function(arrayOfColumnIndexes) {
        this.dataModel.setGroups(arrayOfColumnIndexes);
        this.createColumns();
        this.changed();
    },

    setAggregates: function(mapOfKeysToFunctions) {
        var self = this;
        this.dataModel.setAggregates(mapOfKeysToFunctions);
        this.createColumns();
        setTimeout(function() {
            self.changed();
        }, 100);
    },

    hasHierarchyColumn: function() {
        return false;
    },

    getRowContextFunction: function(selectedRows) {
        return function() {
            return null;
        };
    },

    getSelectionMatrixFunction: function(selectedRows) {
        return function() {
            return null;
        };
    },

    getFieldName: function(index) {
        return this.getFields()[index];
    },

    getColumnIndex: function(fieldName) {
        return this.getFields().indexOf(fieldName);
    },

    getComputedRow: function(y) {
        return this.dataModel.getComputedRow(y);
    },

    autosizeAllColumns: function() {
        this.checkColumnAutosizing(true);
        this.changed();
    },

    checkColumnAutosizing: function(force) {
        force = force === true;
        this.autoSizeRowNumberColumn();
        this.allColumns[-2].checkColumnAutosizing(force);
        this.allColumns.forEach(function(column) {
            column.checkColumnAutosizing(force);
        });
    },

    autoSizeRowNumberColumn: function() {
        if (this.grid.isRowNumberAutosizing()) {
            this.allColumns[-1].checkColumnAutosizing(true);
        }
    },

    getGlobalFilter: function() {
        return this.dataModel.getGlobalFilter();
    },

    setGlobalFilter: function(filterOrOptions) {
        this.dataModel.setGlobalFilter(filterOrOptions);
    },

    getSelectedRows: function() {
        return this.grid.selectionModel.getSelectedRows();
    },

    getSelectedColumns: function() {
        return this.grid.selectionModel.getSelectedColumns();
    },

    getSelections: function() {
        return this.grid.selectionModel.getSelections();
    },

    getData: function() {
        return this.dataModel.getData();
    },

    getFilteredData: function() {
        return this.dataModel.getFilteredData();
    },
});

module.exports = Behavior;

},{"../lib/Base":69,"../lib/CellProvider":70,"./Column":33,"object-iterators":24}],33:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

function Column(behavior, index, label) {
    this.behavior = behavior;
    this.dataModel = behavior.dataModel;
    this.index = index;
    this.label = label;
}

Column.prototype = {
    constructor: Column.prototype.constructor,

    getUnfilteredValue: function(y) {
        return this.dataModel.getUnfilteredValue(this.index, y);
    },

    getValue: function(y) {
        return this.dataModel.getValue(this.index, y);
    },

    setValue: function(y, value) {
        return this.dataModel.setValue(this.index, y, value);
    },

    getWidth: function() {
        var properties = this.getProperties();
        return properties && properties.width || this.behavior.resolveProperty('defaultColumnWidth');
    },

    setWidth: function(width) {
        this.getProperties().width = Math.max(5, width);
    },

    getCellRenderer: function(config, y) {
        return this.dataModel.getCellRenderer(config, this.index, y);
    },

    getCellProperties: function(y) {
        return this.behavior.getPrivateState().cellProperties[this.index + ',' + y];
    },

    setCellProperties: function(y, value) {
        this.behavior.getPrivateState().cellProperties[this.index + ',' + y] = value;
    },

    checkColumnAutosizing: function(force) {
        var properties = this.getProperties();
        var a, b, d;
        if (properties) {
            a = properties.width;
            b = properties.preferredWidth || a;
            d = properties.columnAutosized && !force;
            if (a !== b || !d) {
                properties.width = !d ? b : Math.max(a, b);
                properties.columnAutosized = !isNaN(properties.width);
            }
        }
    },

    getCellType: function(y) {
        var value = this.getValue(y);
        var type = this.typeOf(value);
        return type;
    },

    getFilterType: function() {
        // var props = this.getProperties();
        // var type = props.filterType;
        // if (!type) {
        //     type = this.getType();
        //     if (type !== 'unknown') {
        //         props.type = type;
        //     }
        // }
        // return type;
        return 'filter';
    },

    getType: function() {
        var props = this.getProperties();
        var type = props.type;
        if (!type) {
            type = this.computeColumnType();
            if (type !== 'unknown') {
                props.type = type;
            }
        }
        return type;
    },

    computeColumnType: function() {
        var headerRowCount = this.behavior.getHeaderRowCount();
        var height = this.behavior.getRowCount();
        var value = this.getValue(headerRowCount);
        var eachType = this.typeOf(value);
        if (!eachType) {
            return 'unknown';
        }
        var type = this.typeOf(value);
        var isNumber = ((typeof value) === 'number');
        for (var y = headerRowCount; y < height; y++) {
            value = this.getValue(y);
            eachType = this.typeOf(value);
            if (type !== eachType) {
                if (isNumber && (typeof value === 'number')) {
                    type = 'float';
                } else {
                    return 'mixed';
                }
            }
        }
        return type;
    },

    typeOf: function(something) {
        var typeOf = typeof something;
        switch (typeOf) {
            case 'object':
                return something.constructor.name.toLowerCase();
            case 'number':
                return parseInt(something) === something ? 'int' : 'float';
            default:
                return typeOf;
        }
    },

    getProperties: function() {
        return this.behavior.getPrivateState().columnProperties[this.index];
    },

    setProperties: function(properties) {
        var current = this.behavior.getPrivateState().columnProperties[this.index];
        this.clearObjectProperties(current, false);
        _(current).extendOwn(properties);
    },

    toggleSort: function(keys) {
        this.dataModel.toggleSort(this.index, keys);
    },

    getCellEditorAt: function(x, y) {
        return this.dataModel.getCellEditorAt(this.index, y);
    },

    getHeader: function() {
        return this.label;
    },

    getField: function() {
        return this.dataModel.getFields()[this.index];
    }
};

module.exports = Column;

},{"object-iterators":24}],34:[function(require,module,exports){
'use strict';

var ListDragon = require('list-dragon');

var Local = require('./Local');
var DataModelJSON = require('../dataModels/JSON');
var features = require('../features');
var addStylesheet = require('../../css/stylesheets');
//var aggregations = require('hyper-analytics').util.aggregations;
var aggregations = require('../local_node_modules/hyper-analytics').util.aggregations;
//var aggregations = require('../local_node_modules/finanalytics').aggregations;

/**
 * @name behaviors.JSON
 * @desc > Same parameters as {@link behaviors.Behavior#initialize|initialize}, which is called by this constructor.
 * @constructor
 */
var JSON = Local.extend('behaviors.JSON', {

    /**
     * @summary Constructor logic, called _after_{@link Behavior#initialize|Behavior.initialize()}.
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     *
     * @param grid - the hypergrid
     * @param {object[]} dataRows - array of uniform data objects
     * @memberOf behaviors.JSON.prototype
     */
    initialize: function(grid, dataRows) {
        this.setData(dataRows);
    },

    features: [
        features.CellSelection,
        features.KeyPaging,
        features.ColumnPicker,
        features.ColumnResizing,
        features.RowResizing,
        features.Filters,
        features.RowSelection,
        features.ColumnSelection,
        features.ColumnMoving,
        features.ColumnSorting,
        features.CellEditing,
        features.CellClick,
        features.OnHover
    ],

    aggregations: aggregations,

    createColumns: function() {
        var dataModel = this.dataModel;
        var columnCount = dataModel.getColumnCount();
        var headers = dataModel.getHeaders();
        var fields = dataModel.getFields();
        this.clearColumns();
        for (var i = 0; i < columnCount; i++) {
            var header = headers[i];
            var column = this.addColumn(i, header);
            var properties = column.getProperties();
            properties.field = fields[i];
            properties.header = header;
            properties.complexFilter = null;
        }
    },

    getDefaultDataModel: function() {
        return new DataModelJSON(this.grid);
    },

    applyAnalytics: function() {
        this.dataModel.applyAnalytics();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the header labels.
     * @param {string[]} headerLabels - The header labels.
     */
    setHeaders: function(headerLabels) {
        this.dataModel.setHeaders(headerLabels);
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @desc * @returns {string[]} The header labels.
     */
    getHeaders: function() {
        return this.dataModel.getHeaders();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the fields array.
     * @param {string[]} fieldNames - The field names.
     */
    setFields: function(fieldNames) {
        //were defining the columns based on field names....
        //we must rebuild the column definitions
        this.dataModel.setFields(fieldNames);
        this.createColumns();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Get the field names.
     * @returns {string[]}
     */
    getFields: function() {
        return this.dataModel.getFields();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the data field.
     * @param {object[]} objects - An array of uniform objects, each being a row in the grid.
     */
    setData: function(dataRows) {
        this.dataModel.setData(dataRows);
        this.createColumns();
        var self = this;
        if (this.grid.isColumnAutosizing()) {
            setTimeout(function() {
                self.autosizeAllColumns();
            }, 100);
            self.changed();
        } else {
            setTimeout(function() {
                self.allColumns[-1].checkColumnAutosizing(true);
                self.changed();
            });
        }
    },

    /**
     * @summary Set the top totals.
     * @memberOf behaviors.JSON.prototype
     * @param {Array<Array>} totalRows - array of rows (arrays) of totals
     */
    setTopTotals: function(totalRows) {
        this.dataModel.setTopTotals(totalRows);
    },

    /**
     * @summary Get the top totals.
     * @memberOf behaviors.JSON.prototype
     * @returns {Array<Array>}
     */
    getTopTotals: function() {
        return this.dataModel.getTopTotals();
    },

    /**
     * @summary Set the bottom totals.
     * @memberOf behaviors.JSON.prototype
     * @param {Array<Array>} totalRows - array of rows (arrays) of totals
     */
    setBottomTotals: function(totalRows) {
        this.dataModel.setBottomTotals(totalRows);
    },

    /**
     * @summary Get the bottom totals.
     * @memberOf behaviors.JSON.prototype
     * @returns {Array<Array>}
     */
    getBottomTotals: function() {
        return this.dataModel.getBottomTotals();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Build the fields and headers from the supplied column definitions.
     * ```javascript
     * myJsonBehavior.setColumns([
     *     { title: 'Stock Name', field: 'short_description' },
     *     { title: 'Status', field: 'trading_phase' },
     *     { title: 'Reference Price', field: 'reference_price' }
     * ]);
     * ```
     * @param {Array} columnDefinitions - an array of objects with fields 'title', and 'field'
     */
    setColumns: function(columnDefinitions) {
        this.dataModel.setColumns(columnDefinitions);
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Enhance the double-click event just before it's broadcast to listeners.
     * @param {Point} event
     */
    enhanceDoubleClickEvent: function(event) {
        event.row = this.getRow(event.gridCell.y);
    },

    setDataProvider: function(dataProvider) {
        this.dataModel.setDataProvider(dataProvider);
    },

    hasHierarchyColumn: function() {
        return this.dataModel.hasHierarchyColumn();
    },

    getColumnAlignment: function(x) {
        if (x === 0 && this.hasHierarchyColumn()) {
            return 'left';
        } else {
            return 'center';
        }
    },

    getRowSelectionMatrix: function(selectedRows) {
        return this.dataModel.getRowSelectionMatrix(selectedRows);
    },

    getColumnSelectionMatrix: function(selectedColumns) {
        return this.dataModel.getColumnSelectionMatrix(selectedColumns);
    },

    getSelectionMatrix: function(selections) {
        return this.dataModel.getSelectionMatrix(selections);
    },

    getRowSelection: function() {
        var selectedRows = this.getSelectedRows();
        return this.dataModel.getRowSelection(selectedRows);
    },

    getColumnSelection: function() {
        var selectedColumns = this.getSelectedColumns();
        return this.dataModel.getColumnSelection(selectedColumns);
    },

    getSelection: function() {
        var selections = this.getSelections();
        return this.dataModel.getSelection(selections);
    },

    buildColumnPicker: function(div) {
        if (!this.isColumnReorderable()) {
            return false;
        }

        var listOptions = {
            cssStylesheetReferenceElement: div
        };

        var groups = { models: this.getGroups(), title: 'Groups' },
            availableGroups = { models: this.getAvailableGroups(), title: 'Available Groups' },
            hiddenColumns = { models: this.getHiddenColumns(), title: 'Hidden Columns' },
            visibleColumns = { models: this.getVisibleColumns(), title: 'Visible Columns'},
            groupLists = new ListDragon([groups, availableGroups], listOptions),
            columnLists = new ListDragon([hiddenColumns, visibleColumns], listOptions),
            listSets = [groupLists, columnLists];

        addStylesheet('list-dragon', div);

        listSets.forEach(function(listSet) {
            listSet.modelLists.forEach(function(list) {
                div.appendChild(list.container);
            });
        });

        //attach for later retrieval
        div.lists = {
            group: groups.models,
            availableGroups: availableGroups.models,
            hidden: hiddenColumns.models,
            visible: visibleColumns.models
        };

        return true;
    },
    getGroups: function() {
        return this.dataModel.getGroups();
    },
    getAvailableGroups: function() {
        return this.dataModel.getAvailableGroups();
    },
    getHiddenColumns: function() {
        return this.dataModel.getHiddenColumns();
    },
    getVisibleColumns: function() {
        return this.dataModel.getVisibleColumns();
    },
    setColumnDescriptors: function(lists) {
        //assumes there is one row....
        var tree = this.columns[0];
        this.columns.length = 0;
        if (tree && tree.label === 'Tree') {
            this.columns.push(tree);
        }
        for (var i = 0; i < lists.visible.length; i++) {
            this.columns.push(lists.visible[i]);
        }

        var groupBys = lists.group.map(function(e) {
            return e.id;
        });
        this.dataModel.setGroups(groupBys);

        this.changed();
    },

    getSelectedRows: function() {
        var offset = -this.grid.getHeaderRowCount();
        var selections = this.grid.selectionModel.getSelectedRows();
        var result = selections.map(function(each) {
            return each + offset;
        });
        return result;
    },

    getSelectedColumns: function() {
        return this.grid.selectionModel.getSelectedColumns();
    },

    getSelections: function() {
        return this.grid.selectionModel.getSelections();
    }

});

module.exports = JSON;

},{"../../css/stylesheets":1,"../dataModels/JSON":49,"../features":68,"../local_node_modules/hyper-analytics":91,"./Local":35,"list-dragon":21}],35:[function(require,module,exports){
'use strict';

//var ListDragon = require('list-dragon');

var Behavior = require('./Behavior');
//var DataModelJSON = require('../dataModels/JSON');
//var features = require('../features');
//var addStylesheet = require('../stylesheets');
////var aggregations = require('hyper-analytics').util.aggregations;
////var aggregations = require('../local_node_modules/hyper-analytics').util.aggregations;
//var aggregations = require('../local_node_modules/finanalytics').aggregations;

/**
 * @name behaviors.Local
 * @desc > Same parameters as {@link behaviors.Behavior#initialize|initialize}, which is called by this constructor.
 * @constructor
 */
var Local = Behavior.extend('Local', {

});

module.exports = Local;

},{"./Behavior":32}],36:[function(require,module,exports){
'use strict';

var Behavior = require('./Behavior');

var noop = function() {},
    n00p = function() { return 0; };

/**
 * @constructor
 */
var Null = Behavior.extend('Null', {

    //initalize: function(grid, component) {},

    setScrollPositionY: noop,
    setScrollPositionX: noop,
    getColumnCount: n00p,
    getFixedColumnCount: n00p,
    getFixedColumnsWidth: n00p,
    getFixedColumnsMaxWidth: n00p,
    setRenderedWidth: n00p,
    getRowCount: n00p,
    getFixedRowCount: n00p,
    getFixedRowsHeight: n00p,
    getFixedRowsMaxHeight: n00p,
    setRenderedHeight: n00p,
    getCellProvider: noop,
    click: noop,
    doubleClick: noop
});

module.exports = Null;

},{"./Behavior":32}],37:[function(require,module,exports){
'use strict';

module.exports = {
    Behavior: require('./Behavior'), // abstract base class
    JSON: require('./JSON'),
    Null: require('./Null')
};
},{"./Behavior":32,"./JSON":34,"./Null":36}],38:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var mustache = require('mustache');
var Base = require('../lib/Base');

var extract = /\/\*\s*([^]+?)\s+\*\//; // finds the string inside the /* ... */; the (group) excludes the whitespace

/**
 * @constructor
 */
var CellEditor = Base.extend('CellEditor', {

    /**
     * am I currently editing (i.e., between calls to `beginEditAt` and either `stopEditing` or `cancelEditing`)
     * @type {boolean}
     * @default false
     * @memberOf CellEditor.prototype
     */
    isEditing: false,

    /**
     * the point that I am editing at right now
     * @type {Point}
     * @default null
     * @memberOf CellEditor.prototype
     */
    editorPoint: {
        x: -1,
        y: -1
    },

    /**
     * if true, check that the editor is in the right location
     * @type {boolean}
     * @default false
     * @memberOf CellEditor.prototype
     */
    checkEditorPositionFlag: false,

    /**
     * my instance of hypergrid
     * @type {Hypergrid}
     * @default null
     * @memberOf CellEditor.prototype
     */
    grid: null,

    /**
     * the value before editing
     * @type {type}
     * @default null
     * @memberOf CellEditor.prototype
     */
    initialValue: null,

    /** @deprecated Use `.grid.behavior` property instead.
     * @memberOf CellEditor.prototype
     * @returns {Behavior} The behavior (model).
     */
    getBehavior: function() {
        return this.deprecated('grid.behavior', { since: '0.2' });
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc This function is a callback from the fin-hypergrid.   It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        this.checkEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc scroll values have changed, we've been notified
     */
    scrollValueChangedNotification: function() {
        this.setCheckEditorPositionFlag();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc turn on checkEditorPositionFlag boolean field
     */
    setCheckEditorPositionFlag: function() {
        this.checkEditorPositionFlag = true;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc begin editing at location point
     * @param {Point} point - the location to start editing at
     */
    beginEditAt: function(point) {
        this.editorPoint = point;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc put value into our editor
     * @param {object} value - whatever value we want to edit
     */
    setEditorValue: function(value) {},

    /**
     * @memberOf CellEditor.prototype
     * @desc returns the point at which we are currently editing
     * @returns {Point}
     */
    getEditorPoint: function() {
        return this.editorPoint;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc set the current editor location
     * @param {Point} point - the data location of the current editor
     */
    setEditorPoint: function(point) {
        this.editorPoint = point;
        this.modelPoint = this.grid.convertViewPointToDataPoint(point);
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc display the editor
     */
    showEditor: function() {},

    /**
     * @memberOf CellEditor.prototype
     * @desc hide the editor
     */
    hideEditor: function() {},

    /**
     * @memberOf CellEditor.prototype
     * @desc stop editing
     */
    stopEditing: function() {
        if (!this.isEditing) {
            return;
        }
        var proceed = this.grid.fireSyntheticEditorDataChangeEvent(this, this.initialValue, this.getEditorValue, this);
        if (!proceed) {
            return;
        }
        this.saveEditorValue();
        this.isEditing = false;
        this.hideEditor();
    },

    cancelEditing: function() {
        if (!this.isEditing) {
            return;
        }
        this.isEditing = false;
        this.hideEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc save the new value into the behavior(model)
     */
    saveEditorValue: function() {},

    /**
     * @memberOf CellEditor.prototype
     * @desc return the current editor's value
     */
    getEditorValue: function() {},

    /**
     * @memberOf CellEditor.prototype
     * @desc request focus
     */
    takeFocus: function() {},


    /**
     * @memberOf CellEditor.prototype
     * @desc check that the editor is in the correct location, and is showing/hidden appropriately
     */
    checkEditor: function() {
    },

    /** @deprecated Use `.grid` property instead. */
    getGrid: function() {
        return this.deprecated('grid', { since: '0.2' });
    },

    template: function() {
        /*

         */
    },

    getHTML: function() {
        var template = this.template.toString().match(extract)[1];
        return mustache.render(template, this);
    },

});

module.exports = CellEditor;

},{"../lib/Base":69,"mustache":23}],39:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');
var Map = require('../lib/Mappy');

/**
 * @constructor
 */
var Choice = Simple.extend('Choice', {

    /**
     * the list of items to pick from
     * @type {Array}
     * @memberOf Choice.prototype
     */
    items: ['a', 'b', 'c'],

    template: function() {
        /*
                <select id="editor">
                    {{#items}}
                        <option value="{{.}}">{{.}}</option>
                    {{/items}}
                </select>
            */
    },

    autopopulate: function() {
        var behavior = this.grid.behavior;
        var point = this.getEditorPoint();
        var colProps = this.grid.getColumnProperties(point.x);
        if (!colProps.autopopulateEditor) {
            return;
        }
        var headerCount = this.grid.getHeaderRowCount();
        var rowCount = this.grid.getUnfilteredRowCount() - headerCount;
        var column = point.x;
        var map = new Map();
        for (var r = 0; r < rowCount; r++) {
            var each = behavior.getUnfilteredValue(column, r);
            map.set(each, each);
        }
        var values = map.values;
        values.sort();

        if (values.length > 0 && values[0].length > 0) {
            values.unshift('');
        }

        this.setItems(values);
    },

    //no events are fired while the dropdown is open
    //see http://jsfiddle.net/m4tndtu4/6/

    /**
     * @memberOf Choice.prototype
     */
    showEditor: function() {
        var self = this;
        this.input.style.display = 'inline';
        setTimeout(function() {
            self.showDropdown(self.input);
        }, 50);
    },

    preShowEditorNotification: function() {
        this.autopopulate();
        this.setEditorValue(this.initialValue);
    },

    /**
     * @memberOf Choice.prototype
     * @param items
     */
    setItems: function(items) {
        this.items = items;
        this.updateView();
    },

    /**
     * @memberOf Choice.prototype
     * @param input
     */
    initializeInput: function(input) {
        var self = this;
        Simple.prototype.initializeInput.apply(this, [input]);
        input.onchange = function() {
            self.stopEditing();
        };
    }

});

module.exports = Choice;

},{"../lib/Mappy":74,"./Simple":43}],40:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Color = Simple.extend('Color', {

    template: function() {
        /*
            <input id="editor" type="color">
        */
    }

});

module.exports = Color;

},{"./Simple":43}],41:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var Simple = require('./Simple');
var Formatters = require('../lib/Formatters');

function parseDate(input) {
  var parts = input.match(/(\d+)/g);
  // new Date(year, month [, date [, hours[, minutes[, seconds[, ms]]]]])
  return new window.Date(parts[0], parts[1] - 1, parts[2]); // months are 0-based
}

/**
 * @constructor
 */
var Date = Simple.extend('Date', {

    template: function() {
        /*
            <input id="editor" type="date">
        */
    },

    setEditorValue: function(value) {
        if (value != null && value.constructor.name === 'Date') {
            value = Formatters.date(value);
        }
        this.getInput().value = value + '';
    },

    getEditorValue: function() {
        var value = this.getInput().value;
        value = parseDate(value);
        return value;
    },

});

module.exports = Date;

},{"../lib/Formatters":73,"./Simple":43}],42:[function(require,module,exports){
/* eslint-env browser */
'use strict';

var CellEditor = require('./CellEditor');

/**
 * @constructor
 */
var Filter = CellEditor.extend('Filter', {

    initialize: function() {
        var data = document.createElement('div');
        var style = data.style;
        style.position = 'absolute';
        style.top = style.bottom = '44px';
        style.right = style.left = '1em';
        style.overflowY = 'scroll';

        var table = document.createElement('table');
        data.appendChild(table);

        style = table.style;
        style.width = style.height = '100%';

        var tr = document.createElement('tr');
        var td = document.createElement('td');
        table.appendChild(tr);
        tr.appendChild(td);


        this.title = document.createElement('div');
        this.title.innerHTML = 'Filter Editor';

        this.dialog = document.createElement('div');

        this.content = td;
        this.buttons = document.createElement('div');

        style = this.dialog.style;
        style.position = 'absolute';
        style.top = style.left = style.right = style.bottom = 0;
        style.whiteSpace = 'nowrap';

        style = this.title.style;
        style.position = 'absolute';
        style.top = style.left = style.right = 0;
        style.height = '44px';
        style.whiteSpace = 'nowrap';
        style.textAlign = 'center';
        style.padding = '11px';

        style = this.buttons.style;
        style.position = 'absolute';
        style.left = style.right = style.bottom = 0;
        style.height = '44px';
        style.whiteSpace = 'nowrap';
        style.textAlign = 'center';
        style.padding = '8px';

        this.dialog.appendChild(this.title);
        this.dialog.appendChild(data);
        this.dialog.appendChild(this.buttons);

        this.ok = document.createElement('button');
        this.ok.style.borderRadius = '8px';
        this.ok.style.width = '5.5em';

        this.cancel = document.createElement('button');
        this.cancel.style.marginLeft = '2em';
        this.cancel.style.borderRadius = '8px';
        this.cancel.style.width = '5.5em';

        this.delete = document.createElement('button');
        this.delete.style.marginLeft = '2em';
        this.delete.style.borderRadius = '8px';
        this.delete.style.width = '5.5em';

        this.reset = document.createElement('button');
        this.reset.style.marginLeft = '2em';
        this.reset.style.borderRadius = '8px';
        this.reset.style.width = '5.5em';

        this.ok.innerHTML = 'ok';
        this.cancel.innerHTML = 'cancel';
        this.delete.innerHTML = 'delete';
        this.reset.innerHTML = 'reset';

        this.buttons.appendChild(this.ok);
        this.buttons.appendChild(this.reset);
        this.buttons.appendChild(this.delete);
        this.buttons.appendChild(this.cancel);

        var self = this;
        this.ok.onclick = function() {
            self.okPressed();
        };
        this.cancel.onclick = function() {
            self.cancelPressed();
        };
        this.delete.onclick = function() {
            self.deletePressed();
        };
        this.reset.onclick = function() {
            self.resetPressed();
        };
    },

    tearDown: function() {
        this.content.innerHTML = '';
    },

    okPressed: function() {
        var dialog = this.grid.dialog;
        dialog.onOkPressed();
    },

    cancelPressed: function() {
        var dialog = this.grid.dialog;
        dialog.onCancelPressed();
    },

    deletePressed: function() {
        var dialog = this.grid.dialog;
        dialog.onDeletePressed();
    },

    resetPressed: function() {
        var dialog = this.grid.dialog;
        dialog.onResetPressed();
    },

    beginEditAt: function(editorPoint) {
        var behavior = this.grid.behavior;
        var dialog = this.grid.dialog;

        var columnIndex = editorPoint.x;
        //var title = behavior.getColumnId(columnIndex);
        //var field = behavior.getField(columnIndex);
        //var type = behavior.getColumn(columnIndex).getType();

        this.title.innerHTML = 'Manage Filters';
        var filter = behavior.getGlobalFilter();
        //var self = this;
        if (dialog.isOpen()) {
            dialog.close();
        } else {
            var self = this;

            dialog.clear();
            dialog.overlay.appendChild(this.dialog);

            filter.initializeDialog();

            dialog.onOkPressed = function() {
                if (filter.onOk && filter.onOk()) { // onOK() truthy result means abort; falsy means proceed
                    return;
                }
                self.tearDown();
                //behavior.setComplexFilter(columnIndex, {
                //    //type: filter.alias,
                //    state: filter.getState()
                //});
                dialog.close();
                behavior.applyAnalytics();
                behavior.changed();
            };

            dialog.onCancelPressed = function() {
                if (filter.onCancel && filter.onCancel()) {
                    return;
                }
                self.tearDown();
                dialog.close();
                filter = undefined;
            };

            dialog.onDeletePressed = function() {
                if (filter.onDelete && filter.onDelete()) {
                    return;
                }
                self.tearDown();
                //behavior.setComplexFilter(columnIndex, undefined);
                dialog.close();
                behavior.applyAnalytics();
                behavior.changed();
            };

            dialog.onResetPressed = function() {
                if (filter.onReset && filter.onReset()) {
                    return;
                }
                self.tearDown();
                filter.initializeDialog(dialog);
                if (filter.onShow) {
                    filter.onShow(self.content);
                }
            };

            var cellBounds = this.grid._getBoundsOfCell(columnIndex, editorPoint.y);

            //hack to accomodate bootstrap margin issues...
            var xOffset =
                this.grid.div.getBoundingClientRect().left -
                this.grid.divCanvas.getBoundingClientRect().left;
            cellBounds.x = cellBounds.x - xOffset;
            dialog.openFrom(cellBounds);

            setTimeout(function() {
                if (filter.onShow) {
                    filter.onShow(self.content);
                }
            }, dialog.getAnimationTime() + 10);
        }
    },

});

module.exports = Filter;

},{"./CellEditor":38}],43:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var CellEditor = require('./CellEditor.js');

/**
 * @constructor
 */
var Simple = CellEditor.extend('Simple', {

    /**
     * my main input control
     * @type {Element}
     * @default null
     * @memberOf CellEditor.prototype
     */
    input: null,

    /**
     * @memberOf Simple.prototype
     */
    initialize: function() {
        this.editorPoint = {
            x: 0,
            y: 0
        };
    },

    specialKeyups: {
        //0x08: 'clearStopEditing', // backspace
        0x09: 'stopEditing', // tab
        0x0d: 'stopEditing', // return/enter
        0x1b: 'cancelEditing' // escape
    },

    keyup: function(e) {
        if (e) {
            var specialKeyup = this.specialKeyups[e.keyCode];

            if (specialKeyup) {
                e.preventDefault();
                this[specialKeyup]();
                this.grid.repaint();
                this.grid.takeFocus();
            }

            this.grid.fireSyntheticEditorKeyUpEvent(this, e);
        }
    },

    /**
     * @memberOf Simple.prototype
     * @desc  the function to override for initialization
     */
    initializeInput: function(input) {
        var self = this;
        input.addEventListener('keyup', this.keyup.bind(this));
        input.addEventListener('keydown', function(e) {
            self.grid.fireSyntheticEditorKeyDownEvent(self, e);
        });
        input.addEventListener('keypress', function(e) {
            self.grid.fireSyntheticEditorKeyPressEvent(self, e);
        });
        input.onblur = function(e) {
            self.cancelEditing();
        };

        // input.addEventListener('focusout', function() {
        //     self.stopEditing();
        // });
        // input.addEventListener('blur', function() {
        //     self.stopEditing();
        // });

        input.style.position = 'absolute';
        input.style.display = 'none';
        input.style.border = 'solid 2px black';
        input.style.outline = 0;
        input.style.padding = 0;
        input.style.boxShadow = 'white 0px 0px 1px 1px';
    },

    /**
     * @memberOf Simple.prototype
     * @returns {object} the current editor's value
     */
    getEditorValue: function() {
        var value = this.getInput().value;
        return value;
    },

    /**
     * @memberOf Simple.prototype
     * @desc save the new value into the behavior(model)
     */
    setEditorValue: function(value) {
        this.getInput().value = value;
    },

    clearStopEditing: function() {
        this.setEditorValue('');
        this.stopEditing();
    },

    cancelEditing: function() {
        if (!this.isEditing) {
            return;
        }
        this.getInput().value = null;
        this.isEditing = false;
        this.hideEditor();
    },

    /**
     * @memberOf Simple.prototype
     * @desc display the editor
     */
    showEditor: function() {
        this.getInput().style.display = 'inline';
    },

    /**
     * @memberOf Simple.prototype
     * @desc hide the editor
     */
    hideEditor: function() {
        this.getInput().style.display = 'none';
    },

    /**
     * @summary Request focus for my input control.
     * @desc See GRID-95 "Scrollbar moves inward" for issue and work-around explanation.
     * @memberOf Simple.prototype
     */
    takeFocus: function() {
        var self = this;
        setTimeout(function() {
            var transformWas = self.input.style.transform;
            self.input.style.transform = 'translate(0,0)'; // work-around: move to upper left

            self.input.focus();
            self.selectAll();

            self.input.style.transform = transformWas;
        });
    },

    /**
     * @memberOf Simple.prototype
     * @desc select everything
     */
    selectAll: function() {

    },

    /**
     * @memberOf Simple.prototype
     * @desc how much should I offset my bounds from 0,0
     */
    originOffset: function() {
        return [0, 0];
    },

    /**
     * @memberOf Simple.prototype
     * @desc set the bounds of my input control
     * @param {rectangle} rectangle - the bounds to move to
     */
    setBounds: function(cellBounds) {
        var originOffset = this.originOffset();
        var translation = 'translate('
            + (cellBounds.x - 1 + originOffset[0]) + 'px,'
            + (cellBounds.y - 1 + originOffset[1]) + 'px)';

        var input = this.getInput();

        input.style.boxSizing = 'border-box';

        input.style.webkitTransform = translation;
        input.style.MozTransform = translation;
        input.style.msTransform = translation;
        input.style.OTransform = translation;

        // TODO: Obviously this was changed at some point from left,top to trnasform:translation. Wondering why this was necessary...?

        // input.style.left = cellBounds.x + originOffset[0] + 'px';
        // input.style.top = cellBounds.y + originOffset[1] + 'px';

        input.style.width = (cellBounds.width + 2) + 'px';
        input.style.height = (cellBounds.height + 2) + 'px';
        //var xOffset = this.grid.canvas.getBoundingClientRect().left;
    },

    saveEditorValue: function() {
        var point = this.getEditorPoint();
        var value = this.getEditorValue().trim();

        if (value && value === this.initialValue) {
            return; //data didn't change do nothing
        }
        if (parseFloat(this.initialValue) === this.initialValue) { // I'm a number
            value = parseFloat(value);
        }
        var continued = this.grid.fireBeforeCellEdit(point, this.initialValue, value, this);
        if (!continued) {
            return;
        }
        this.grid.behavior.setValue(point.x, point.y, value);
        this.grid.fireAfterCellEdit(point, this.initialValue, value, this);
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc move the editor to the current editor point
     */
    _moveEditor: function() {
        var editorPoint = this.getEditorPoint();
        var cellBounds = this.grid._getBoundsOfCell(editorPoint.x, editorPoint.y);

        //hack to accommodate bootstrap margin issues...
        var xOffset =
            this.grid.div.getBoundingClientRect().left -
            this.grid.divCanvas.getBoundingClientRect().left;
        cellBounds.x = cellBounds.x - xOffset;

        this.setBounds(cellBounds);
    },

    moveEditor: function() {
        this._moveEditor();
        this.takeFocus();
    },

    beginEditAt: function(point) {

        if (!this.isAdded) {
            this.isAdded = true;
            this.attachEditor();
        }

        this.setEditorPoint(point);
        var value = this.grid.behavior.getValue(point.x, point.y);
        if (value.constructor.name === 'Array') {
            value = value[1]; //it's a nested object
        }
        var proceed = this.grid.fireRequestCellEdit(point, value);
        if (!proceed) {
            //we were cancelled
            return;
        }
        this.initialValue = value;
        this.isEditing = true;
        this.setCheckEditorPositionFlag();
        this.checkEditor();
    },

    checkEditor: function() {
        if (!this.checkEditorPositionFlag) {
            return;
        } else {
            this.checkEditorPositionFlag = false;
        }
        if (!this.isEditing) {
            return;
        }
        var editorPoint = this.getEditorPoint();
        if (this.grid.isDataVisible(editorPoint.x, editorPoint.y)) {
            this.preShowEditorNotification();
            this.attachEditor();
            this.moveEditor();
            this.showEditor();
        } else {
            this.hideEditor();
        }
    },

    attachEditor: function() {
        var input = this.getInput(),
            div = this.grid.div,
            referenceNode = div.querySelectorAll('.finbar-horizontal, .finbar-vertical');

        div.insertBefore(input, referenceNode.length ? referenceNode[0] : null);
    },

    preShowEditorNotification: function() {
        this.setEditorValue(this.initialValue);
    },

    getInput: function() {
        if (!this.input) {
            this.input = this.getDefaultInput();
        }
        return this.input;
    },

    getDefaultInput: function() {
        var div = document.createElement('DIV');
        div.innerHTML = this.getHTML();
        var input = div.firstChild;
        this.initializeInput(input);
        return input;
    },

    updateView: function() {
        var oldGuy = this.getInput();
        var parent = oldGuy.parentNode;
        var newGuy = this.getDefaultInput();
        this.input = newGuy;
        parent.replaceChild(newGuy, oldGuy);
    },

    showDropdown: function(element) {
        var event;
        event = document.createEvent('MouseEvents');
        event.initMouseEvent('mousedown', true, true, window);
        element.dispatchEvent(event);
    }
});

module.exports = Simple;

},{"./CellEditor.js":38}],44:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Slider = Simple.extend('Slider', {

    template: function() {
        /*
            <input id="editor" type="range">
        */
    }

});

module.exports = Slider;

},{"./Simple":43}],45:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Spinner = Simple.extend('Spinner', {

    template: function() {
        /*
            <input id="editor" type="number">
        */
    }

});

module.exports = Spinner;

},{"./Simple":43}],46:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Textfield = Simple.extend('Textfield', {

    template: function() {
        /*
            <input id="editor">
        */
    },

    selectAll: function() {
        this.input.setSelectionRange(0, this.input.value.length);
    },

    specialKeyups: {
        0x09: 'stopEditing', // tab
        0x0d: 'stopEditing', // return/enter
        0x1b: 'cancelEditing' // escape
    },

    keyup: function(e) {
        if (e) {
            Simple.prototype.keyup.call(this, e);

            if (this.grid.isFilterRow(this.getEditorPoint().y)) {
                setTimeout(keyup.bind(this));
            }
        }
    }
});

function keyup() {
    this.saveEditorValue();
    this._moveEditor();
}

module.exports = Textfield;

},{"./Simple":43}],47:[function(require,module,exports){
'use strict';

module.exports = {
    CellEditor: require('./CellEditor'), // abstract base class
    Textfield: require('./Textfield'),
    Choice: require('./Choice'),
    //Combo: require('./Combo'),
    Color: require('./Color'),
    Date: require('./Date'),
    Simple: require('./Simple'),
    Slider: require('./Slider'),
    Spinner: require('./Spinner'),
    Filter: require('./Filter')
};

},{"./CellEditor":38,"./Choice":39,"./Color":40,"./Date":41,"./Filter":42,"./Simple":43,"./Slider":44,"./Spinner":45,"./Textfield":46}],48:[function(require,module,exports){
'use strict';

var Base = require('../lib/Base');

var A = 'A'.charCodeAt(0);

/**
 * @constructor
 */
var DataModel = Base.extend('DataModel', {

    next: null,

    grid: null,

    initialize: function(grid) {
        this.setGrid(grid);
    },

    setGrid: function(grid) {
        this.grid = grid;
    },

    /** @deprecated Use `.grid` property instead. */
    getGrid: function() {
        return this.deprecated('grid', { since: '0.2' });
    },

    /** @deprecated Use `.grid.behavior` property instead. */
    getBehavior: function() {
        return this.deprecated('grid.behavior', { since: '0.2' });
    },

    changed: function() {
        this.grid.behavior.changed();
    },

    getPrivateState: function() {
        return this.grid.getPrivateState();
    },

    applyState: function() {

    },

    alphaFor: function(i) {
        // Name the column headers in A, .., AA, AB, AC, .., AZ format
        // quotient/remainder
        //var quo = Math.floor(col/27);
        var quo = Math.floor(i / 26);
        var rem = i % 26;
        var code = '';
        if (quo > 0) {
            code += this.alpha(quo - 1);
        }
        code += this.alpha(rem);
        return code;
    },

    alpha: function(i) {
        return String.fromCharCode(A + i);
    },

    getCellEditorAt: function(x, y) {
    },

});

module.exports = DataModel;

},{"../lib/Base":69}],49:[function(require,module,exports){
'use strict';

//var analytics = require('hyper-analytics');
var analytics = require('../local_node_modules/hyper-analytics');
//var analytics = require('../local_node_modules/finanalytics');
var DataModel = require('./DataModel');
var images = require('../../images');
var CustomFilter = require('../lib/CustomFilter');

var UPWARDS_BLACK_ARROW = '\u25b2', // aka '▲'
    DOWNWARDS_BLACK_ARROW = '\u25bc'; // aka '▼'

var nullDataSource = {
    isNullObject: function() {
        return true;
    },
    getFields: function() {
        return [];
    },
    getHeaders: function() {
        return [];
    },
    getColumnCount: function() {
        return 0;
    },
    getRowCount: function() {
        return 0;
    },
    getAggregateTotals: function() {
        return [];
    },
    hasAggregates: function() {
        return false;
    },
    hasGroups: function() {
        return false;
    },
    getRow: function() {
        return null;
    }
};

/**
 * @name dataModels.JSON
 * @constructor
 */
var JSON = DataModel.extend('dataModels.JSON', {

    //null object pattern for the source object
    source: nullDataSource,

    preglobalfilter: nullDataSource,

    presorter: nullDataSource,
    analytics: nullDataSource,
    postglobalfilter: nullDataSource,
    postsorter: nullDataSource,

    topTotals: [],
    bottomTotals: [],

    initialize: function() {
        this.selectedData = [];
    },

    clearSelectedData: function() {
        this.selectedData.length = 0;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasAggregates: function() {
        return this.analytics.hasAggregates();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasGroups: function() {
        return this.analytics.hasGroups();
    },

    getDataSource: function() {
        return this.postsorter; //this.hasAggregates() ? this.analytics : this.presorter;
    },

    getGlobalFilterDataSource: function() {
        return this.postglobalfilter; //this.hasAggregates() ? this.postfilter : this.prefilter;
    },

    getSortDataSource: function() {
        return this.postsorter; //this.hasAggregates() ? this.postsorter : this.presorter;
    },

    getData: function() {
        return this.source.data;
    },

    getFilteredData: function() {
        var ds = this.getDataSource();
        var count = ds.getRowCount();
        var result = new Array(count);
        for (var y = 0; y < count; y++) {
            result[y] = ds.getRow(y);
        }
        return result;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @returns {*}
     */
    getValue: function(x, y) {
        var hasHierarchyColumn = this.hasHierarchyColumn();
        var headerRowCount = this.grid.getHeaderRowCount();
        var value;
        if (hasHierarchyColumn) {
            if (x === -2) {
                x = 0;
            }
        } else if (this.hasAggregates()) {
            x += 1;
        }
        if (y < headerRowCount) {
            value = this.getHeaderRowValue(x, y);
            return value;
        }
        // if (hasHierarchyColumn) {
        //     y += 1;
        // }
        value = this.getDataSource().getValue(x, y - headerRowCount);
        return value;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y - negative values refer to _bottom totals_ rows
     * @returns {*}
     */
    getHeaderRowValue: function(x, y) {
        var value;
        if (y === undefined) {
            value = this.getHeaders()[Math.max(x, 0)];
        } else if (y < 0) { // bottom totals rows
            var bottomTotals = this.getBottomTotals();
            value = bottomTotals[bottomTotals.length + y][x];
        } else {
            var isFilterRow = this.grid.isShowFilterRow(),
                isHeaderRow = this.grid.isShowHeaderRow(),
                topTotalsOffset = (isFilterRow ? 1 : 0) + (isHeaderRow ? 1 : 0);
            if (y >= topTotalsOffset) { // top totals rows
                value = this.getTopTotals()[y - topTotalsOffset][x];
            } else if (isHeaderRow && y === 0) {
                value = this.getHeaders()[x];
                var sortString = this.getSortImageForColumn(x);
                if (sortString) { value = sortString + value; }
            } else { // must be filter row
                var filter = this.getGlobalFilter();
                value = filter ? filter.getColumnFilterState(this.getFields()[x]) : '';
                var icon = images.filter(value.length);
                return [null, value, icon];
            }
        }
        return value;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        var hasHierarchyColumn = this.hasHierarchyColumn();
        var headerRowCount = this.grid.getHeaderRowCount();
        if (hasHierarchyColumn) {
            if (x === -2) {
                x = 0;
            }
        } else if (this.hasAggregates()) {
            x += 1;
        }
        if (y < headerRowCount) {
            this.setHeaderRowValue(x, y, value);
        } else {
            this.getDataSource().setValue(x, y - headerRowCount, value);
        }
        this.changed();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     * @returns {*}
     */
    setHeaderRowValue: function(x, y, value) {
        if (value === undefined) {
            return this._setHeader(x, y); // y is really the value
        }
        var isFilterRow = this.grid.isShowFilterRow();
        var isHeaderRow = this.grid.isShowHeaderRow();
        var isBoth = isFilterRow && isHeaderRow;
        var topTotalsOffset = (isFilterRow ? 1 : 0) + (isHeaderRow ? 1 : 0);
        if (y >= topTotalsOffset) {
            this.getTopTotals()[y - topTotalsOffset][x] = value;
        } else if (x === -1) {
            return; // can't change the row numbers
        } else if (isBoth) {
            if (y === 0) {
                return this._setHeader(x, value);
            } else {
                this.setFilter(x, value);
            }
        } else if (isFilterRow) {
            this.setFilter(x, value);
        } else {
            return this._setHeader(x, value);
        }
        return '';
    },

    setFilter: function(x, value) {
        var filter = this.getGlobalFilter(),
            columnName = this.getFields()[x];

        filter.setColumnFilterState(columnName, value);
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @returns {*}
     */
    getColumnProperties: function(colIndex) {
        //access directly because we want it ordered
        var column = this.grid.behavior.allColumns[colIndex];
        if (column) {
            return column.getProperties();
        }
        return undefined;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getColumnCount: function() {
        var showTree = this.grid.resolveProperty('showTreeColumn') === true;
        var hasAggregates = this.hasAggregates();
        var offset = (hasAggregates && !showTree) ? -1 : 0;
        return this.analytics.getColumnCount() + offset;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getRowCount: function() {
        var count = this.getDataSource().getRowCount();
        count += this.grid.getHeaderRowCount();
        return count;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getHeaders: function() {
        return this.analytics.getHeaders();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} headers
     */
    setHeaders: function(headers) {
        this.getDataSource().setHeaders(headers);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} fields
     */
    setFields: function(fields) {
        this.getDataSource().setFields(fields);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getFields: function() {
        return this.getDataSource().getFields();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {object[]} dataRows
     */
    setData: function(dataRows) {
        this.source = new analytics.JSDataSource(dataRows);
        //this.preglobalfilter = new analytics.DataSourceGlobalFilter(this.source);
        //this.presorter = new analytics.DataSourceSorterComposite(this.prefilter);

        this.analytics = new analytics.DataSourceAggregator(this.source);

        this.postglobalfilter = new analytics.DataSourceGlobalFilter(this.analytics);
        this.postsorter = new analytics.DataSourceSorterComposite(this.postglobalfilter);

        this.applyAnalytics();

    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {Array<Array>} totalRows
     */
    setTopTotals: function(totalRows) {
        this.topTotals = totalRows;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {Array<Array>}
     */
    getTopTotals: function() {
        return this.hasAggregates() ? this.getDataSource().getGrandTotals() : this.topTotals;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {Array<Array>} totalRows
     */
    setBottomTotals: function(totalRows) {
        this.bottomTotals = totalRows;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {Array<Array>}
     */
    getBottomTotals: function() {
        return this.hasAggregates() ? this.getDataSource().getGrandTotals() : this.bottomTotals;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param groups
     */
    setGroups: function(groups) {
        this.analytics.setGroupBys(groups);
        this.applyAnalytics();
        this.grid.fireSyntheticGroupsChangedEvent(this.getGroups());
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getGroups: function() {
        var headers = this.getHeaders().slice(0);
        var fields = this.getFields().slice(0);
        var groupBys = this.analytics.groupBys;
        var groups = [];
        for (var i = 0; i < groupBys.length; i++) {
            var field = headers[groupBys[i]];
            groups.push({
                id: groupBys[i],
                label: field,
                field: fields
            });
        }
        return groups;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getAvailableGroups: function() {
        var headers = this.source.getHeaders().slice(0);
        var groupBys = this.analytics.groupBys;
        var groups = [];
        for (var i = 0; i < headers.length; i++) {
            if (groupBys.indexOf(i) === -1) {
                var field = headers[i];
                groups.push({
                    id: i,
                    label: field,
                    field: field
                });
            }
        }
        return groups;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getVisibleColumns: function() {
        var items = this.grid.behavior.columns;
        items = items.filter(function(each) {
            return each.label !== 'Tree';
        });
        return items;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getHiddenColumns: function() {
        var visible = this.grid.behavior.columns;
        var all = this.grid.behavior.allColumns;
        var hidden = [];
        for (var i = 0; i < all.length; i++) {
            if (visible.indexOf(all[i]) === -1) {
                hidden.push(all[i]);
            }
        }
        hidden.sort(function(a, b) {
            return a.label < b.label;
        });
        return hidden;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param aggregations
     */
    setAggregates: function(aggregations) {
        this.quietlySetAggregates(aggregations);
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param aggregations
     */
    quietlySetAggregates: function(aggregations) {
        this.analytics.setAggregates(aggregations);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasHierarchyColumn: function() {
        var showTree = this.grid.resolveProperty('showTreeColumn') === true;
        return this.hasAggregates() && this.hasGroups() && showTree;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyAnalytics: function(dontApplyGroupBysAndAggregations) {
        selectedDataRowsBackingSelectedGridRows.call(this);

        if (!dontApplyGroupBysAndAggregations) {
            applyGroupBysAndAggregations.call(this);
        }

        applyFilters.call(this);

        applySorts.call(this);

        reselectGridRowsBackedBySelectedDataRows.call(this);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param keys
     */
    toggleSort: function(colIndex, keys) {
        this.incrementSortState(colIndex, keys);
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param {string[]} keys
     */
    incrementSortState: function(colIndex, keys) {
        colIndex++; //hack to get around 0 index
        var state = this.getPrivateState();
        var hasCTRL = keys.indexOf('CTRL') > -1;
        state.sorts = state.sorts || [];
        var already = state.sorts.indexOf(colIndex);
        if (already === -1) {
            already = state.sorts.indexOf(-1 * colIndex);
        }
        if (already > -1) {
            if (state.sorts[already] > 0) {
                state.sorts[already] = -1 * state.sorts[already];
            } else {
                state.sorts.splice(already, 1);
            }
        } else if (hasCTRL || state.sorts.length === 0) {
            state.sorts.unshift(colIndex);
        } else {
            state.sorts.length = 0;
            state.sorts.unshift(colIndex);
        }
        if (state.sorts.length > 3) {
            state.sorts.length = 3;
        }
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param index
     * @param returnAsString
     * @returns {*}
     */
    getSortImageForColumn: function(index) {
        index++;
        var up = true;
        var sorts = this.getPrivateState().sorts;
        if (!sorts) {
            return null;
        }
        var position = sorts.indexOf(index);
        if (position < 0) {
            position = sorts.indexOf(-1 * index);
            up = false;
        }
        if (position < 0) {
            return null;
        }
        var rank = sorts.length - position;
        var arrow = up ? UPWARDS_BLACK_ARROW : DOWNWARDS_BLACK_ARROW;
        return rank + arrow + ' ';
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param cell
     * @param event
     */
    cellClicked: function(cell, event) {
        if (!this.hasAggregates()) {
            return;
        }
        if (event.gridCell.x !== 0) {
            return; // this wasn't a click on the hierarchy column
        }
        var headerRowCount = this.grid.getHeaderRowCount();
        var y = event.gridCell.y - headerRowCount;
        this.getDataSource().click(y);
        this.applyAnalytics(true);
        this.changed();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    getRow: function(y) {
        var headerRowCount = this.grid.getHeaderRowCount();
        if (y < headerRowCount && !this.hasAggregates()) {
            var topTotals = this.getTopTotals();
            return topTotals[y - (headerRowCount - topTotals.length)];
        }
        return this.getDataSource().getRow(y - headerRowCount);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    buildRow: function(y) {
        var colCount = this.getColumnCount();
        var fields = [].concat(this.getFields());
        var result = {};
        if (this.hasAggregates()) {
            result.tree = this.getValue(-2, y);
            fields.shift();
        }
        for (var i = 0; i < colCount; i++) {
            result[fields[i]] = this.getValue(i, y);
        }
        return result;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    getComputedRow: function(y) {
        var rcf = this.getRowContextFunction([y]);
        var fields = this.getFields();
        var row = {};
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            row[field] = rcf(field)[0];
        }
        return row;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string} fieldName
     * @param {number} y
     * @returns {*}
     */
    getValueByField: function(fieldName, y) {
        var index = this.getFields().indexOf(fieldName);
        if (this.hasAggregates()) {
            y += 1;
        }
        return this.getDataSource().getValue(index, y);
    },

    getGlobalFilter: function() {
        return this.getGlobalFilterDataSource().get();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {FilterTree|FilterTreeOptionsObject} [filterOrOptions] - One of:
     * * `FilterTree` - an existing filter-tree
     * * `FilterTreeOptionsObject` - an options object for the creation of a new filter-tree
     * * falsy (omitted) - Turns off filtering.
     */
    setGlobalFilter: function(filterOrOptions) {
        var dataSource = this.getGlobalFilterDataSource();

        if (!filterOrOptions) {
            dataSource.clear();
        } else {
            var filter;

            if (filterOrOptions instanceof CustomFilter) {
                filter = filterOrOptions;
            } else {
                filter = new CustomFilter(filterOrOptions);

                // TODO: Remove this (just for testing):
                if (false) { // eslint-disable-line no-constant-condition
                    filter.children[1].add({
                        children: [{
                            column: 'total_number_of_pets_owned',
                            operator: '=',
                            literal: '3'
                        }],
                        type: 'columnFilter'
                    });
                }

                filter.invalid();
            }

            dataSource.set(filter);
        }

        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {object} config
     * @param {number} x
     * @param {number} y
     * @param {number} untranslatedX
     * @param {number} untranslatedY
     * @returns {object}
     */
    getCellRenderer: function(config, x, y, untranslatedX, untranslatedY) {
        var renderer;
        var provider = this.grid.getCellProvider();

        config.x = x;
        config.y = y;
        config.untranslatedX = untranslatedX;
        config.untranslatedY = untranslatedY;

        renderer = provider.getCell(config);
        renderer.config = config;

        return renderer;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyState: function() {
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    reset: function() {
        this.setData([]);
    },

    getUnfilteredValue: function(x, y) {
        return this.source.getValue(x, y);
    },

    getUnfilteredRowCount: function() {
        return this.source.getRowCount();
    },

});

// LOCAL METHODS -- to be called with `.call(this`

/**
 * Accumulate actual data row objects backing current grid row selections.
 * This call should be paired with a subsequent call to `reselectGridRowsBackedBySelectedDataRows`.
 * @private
 * @memberOf dataModels.JSON.prototype
 */
function selectedDataRowsBackingSelectedGridRows() {
    var selectedData = this.selectedData,
        hasRowSelections = this.grid.selectionModel.hasRowSelections(),
        needFilteredDataList = selectedData.length || hasRowSelections;

    if (needFilteredDataList) {
        var filteredData = this.getFilteredData();
    }

    // STEP 1: Remove any filtered data rows from the recently selected list.
    selectedData.forEach(function(dataRow, index) {
        if (filteredData.indexOf(dataRow) >= 0) {
            delete selectedData[index];
        }
    });

    // STEP 2: Accumulate the data rows backing any currently selected grid rows in `this.selectedData`.
    if (hasRowSelections) { // any current grid row selections?
        this.grid.getSelectedRows().forEach(function(selectedRowIndex) {
            var dataRow = filteredData[selectedRowIndex];
            if (selectedData.indexOf(dataRow) < 0) {
                selectedData.push(dataRow);
            }
        });
    }
}

/**
 * Re-establish grid row selections based on actual data row objects accumulated by `selectedDataRowsBackingSelectedGridRows` which should be called first.
 * @private
 * @memberOf dataModels.JSON.prototype
 */
function reselectGridRowsBackedBySelectedDataRows() {
    if (this.selectedData.length) { // any data row objects added from previous grid row selections?
        var selectionModel = this.grid.selectionModel,
            offset = this.grid.getHeaderRowCount(),
            filteredData = this.getFilteredData();

        selectionModel.clearRowSelection();

        this.selectedData.forEach(function(dataRow) {
            var index = filteredData.indexOf(dataRow);
            if (index >= 0) {
                selectionModel.selectRow(offset + index);
            }
        });
    }
}

/**
 * @private
 * @memberOf dataModels.JSON.prototype
 */
function applyGroupBysAndAggregations() {
    if (this.analytics.aggregates.length === 0) {
        this.quietlySetAggregates({});
    }
    this.analytics.apply();
}

/**
 * @private
 * @memberOf dataModels.JSON.prototype
 */
function applyFilters() {
    this.getGlobalFilterDataSource().apply();

    var details = [];

    // TODO: return something useful...
    // was previously returning, for each column in this.getVisibleColumns():
    // [ { column: column.label, format: 'complex' or column.getProperties().format }, ... ]


    this.grid.fireSyntheticFilterAppliedEvent({
        details: details
    });
}

/**
 * @private
 * @memberOf dataModels.JSON.prototype
 */
function applySorts() {
    var sortingSource = this.getSortDataSource();
    var sorts = this.getPrivateState().sorts;
    var groupOffset = this.hasAggregates() ? 1 : 0;
    if (!sorts || sorts.length === 0) {
        sortingSource.clearSorts();
    } else {
        for (var i = 0; i < sorts.length; i++) {
            var colIndex = Math.abs(sorts[i]) - 1;
            var type = sorts[i] < 0 ? -1 : 1;
            sortingSource.sortOn(colIndex - groupOffset, type);
        }
    }
    sortingSource.applySorts();
}

module.exports = JSON;

},{"../../images":3,"../lib/CustomFilter":72,"../local_node_modules/hyper-analytics":91,"./DataModel":48}],50:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var LRUCache = require('lru-cache');

var renderCellError = require('./lib/renderCellError');

/**
 * This module lists the properties that can be set on a {@link Hypergrid} along with their default values.
 * Edit this file to override the defaults.
 * @module defaults
 */

module.exports = {

    //these are for the theme


    /**
     * The font for data cells.
     * @default '13px Tahoma, Geneva, sans-serif'
     * @type {cssFont}
     * @instance
     */
    font: '13px Tahoma, Geneva, sans-serif',

    /**
     * Font color for data cells.
     * @default 'rgb(25, 25, 25)'
     * @type {string}
     * @instance
     */
    color: 'rgb(25, 25, 25)',

    /**
     * Background color for data cells.
     * @default 'rgb(241, 241, 241)'
     * @type {string}
     * @instance
     */
    backgroundColor: 'rgb(241, 241, 241)',

    /**
     * Font style for selected cell(s).
     * @default 'bold'
     * @type {string}
     * @instance
     */
    foregroundSelectionFont: 'bold 13px Tahoma, Geneva, sans-serif',

    /**
     * Font color for selected cell(s).
     * @default 'rgb(0, 0, 128)'
     * @type {string}
     * @instance
     */
    foregroundSelectionColor: 'rgb(0, 0, 128)',

    /**
     * Background color for selected cell(s).
     * @default 'rgba(147, 185, 255, 0.45)'
     * @type {string}
     * @instance
     */
    backgroundSelectionColor: 'rgba(147, 185, 255, 0.625)',


    /********** SECTION: COLUMN HEADER COLORS **********/

    // IMPORTANT CAVEAT: The code is inconsistent regarding the terminology. Is the "column header" section _the row_ of cells at the top (that act as headers for each column) or is it _the column_ of cells (that act as headers for each row)? Oh my.

    /**
     * @default '12px Tahoma, Geneva, sans-serif'
     * @type {cssFont}
     * @instance
     */
    columnHeaderFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default 'rgb(25, 25, 25)'
     * @type {cssColor}
     * @instance
     */
    columnHeaderColor: 'rgb(25, 25, 25)',

    /**
     * Font style for selected columns' headers.
     * @default 'bold'
     * @type {string}
     * @instance
     */
    columnHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',

    /**
     * @default 'rgb(223, 227, 232)'
     * @type {cssColor}
     * @instance
     */
    columnHeaderBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default 'rgb(80, 80, 80)'
     * @type {cssColor}
     * @instance
     */
    columnHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',

    /**
     * @default 'rgba(255, 220, 97, 0.45)'
     * @type {cssColor}
     * @instance
     */
    columnHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default 'rgb(25, 25, 25)'
     * @type {cssColor}
     * @instance
     */
    columnHeaderForegroundColumnSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default 'rgb(255, 180, 0)'
     * @type {cssColor}
     * @instance
     */
    columnHeaderBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',


    /********** SECTION: ROW HEADER COLORS **********/

    /**
     * @default '12px Tahoma, Geneva, sans-serif'
     * @type {cssFont}
     * @instance
     */
    rowHeaderFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default 'rgb(25, 25, 25)'
     * @type {cssColor}
     * @instance
     */
    rowHeaderColor: 'rgb(25, 25, 25)',

    /**
     * @default 'rgb(223, 227, 232)'
     * @type {cssColor}
     * @instance
     */
    rowHeaderBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default 'rgb(80, 80, 80)'
     * @type {cssColor}
     * @instance
     */
    rowHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',

    /**
     * Font style for selected rows' headers.
     * @default 'bold'
     * @type {string}
     * @instance
     */
    rowHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',

    /**
     * @default 'rgba(255, 220, 97, 0.45)'
     * @type {cssColor}
     * @instance
     */
    rowHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default 'rgb(25, 25, 25)'
     * @type {cssColor}
     * @instance
     */
    rowHeaderForegroundRowSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default 'rgb(255, 180, 0)'
     * @type {cssColor}
     * @instance
     */
    rowHeaderBackgroundRowSelectionColor: 'rgb(255, 180, 0)',


    /********** SECTION: FILTER ROW COLORS **********/

    /**
     * @default '12px Tahoma, Geneva, sans-serif'
     * @type {cssFont}
     * @instance
     */
    filterFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default 'rgb(25, 25, 25)'
     * @type {cssColor}
     * @instance
     */
    filterColor: 'rgb(25, 25, 25)',

    /**
     * @default 'white'
     * @type {cssColor}
     * @instance
     */
    filterBackgroundColor: 'white',

    /**
     * @default 'rgb(25, 25, 25)'
     * @type {cssColor}
     * @instance
     */
    filterForegroundSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default 'rgb(255, 220, 97)'
     * @type {cssColor}
     * @instance
     */
    filterBackgroundSelectionColor: 'rgb(255, 220, 97)',

    /**
     * @default 'rgba(0,0,0,0.8)'
     * @type {cssColor}
     * @instance
     */
    filterCellBorderStyle: 'rgba(0,0,0,0.8)',

    /**
     * @default 0.4
     * @type {number}
     * @instance
     */
    filterCellBorderThickness: 0.4,


    /********** SECTION: TREE COLUMN COLORS **********/
    // The "tree column" contains the hierarchical drill-down controls.

    /**
     * @default '12px Tahoma, Geneva, sans-serif'
     * @type {cssFont}
     * @instance
     */
    treeColumnFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default 'rgb(25, 25, 25)'
     * @type {cssColor}
     * @instance
     */
    treeColumnColor: 'rgb(25, 25, 25)',

    /**
     * @default 'rgb(223, 227, 232)'
     * @type {cssColor}
     * @instance
     */
    treeColumnBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default 'rgb(25, 25, 25)'
     * @type {cssColor}
     * @instance
     */
    treeColumnForegroundSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default 'rgba(255, 220, 97, 0.45)'
     * @type {cssColor}
     * @instance
     */
    treeColumnBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default 'rgb(25, 25, 25)'
     * @type {cssColor}
     * @instance
     */
    treeColumnForegroundColumnSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default 'rgb(255, 180, 0)'
     * @type {cssColor}
     * @instance
     */
    treeColumnBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',

    /**
     * @default 'rgb(201, 201, 201)'
     * @type {cssColor}
     * @instance
     */
    backgroundColor2: 'rgb(201, 201, 201)',

    /**
     * @default 0
     * @type {number}
     * @instance
     */
    voffset: 0,

    /**
     * @default 'visible'
     * @type {string}
     * @instance
     */
    scrollbarHoverOver: 'visible',

    /**
     * @default 'hidden'
     * @type {string}
     * @instance
     */
    scrollbarHoverOff: 'hidden',

    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    scrollingEnabled: true,

    /**
     * @default ''
     * @type {string}
     * @instance
     */
    vScrollbarClassPrefix: '',

    /**
     * @default ''
     * @type {string}
     * @instance
     */
    hScrollbarClassPrefix: '',

    //these used to be in the constants element

    /**
     * @default 'center'
     * @type {string}
     * @instance
     */
    fixedRowAlign: 'center',

    /**
     * @default 'center'
     * @type {string}
     * @instance
     */
    fixedColAlign: 'center',

    /**
     * @default 5
     * @type {number}
     * @instance
     */
    cellPadding: 5,

    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    gridLinesH: true,

    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    gridLinesV: true,

    /**
     * @default 'rgb(199, 199 199)'
     * @type {cssColor}
     * @instance
     */
    lineColor: 'rgb(199, 199, 199)',

    /**
     * @default 0.4
     * @type {number}
     * @instance
     */
    lineWidth: 0.4,


    /**
     * @default 15
     * @type {number}
     * @instance
     */
    defaultRowHeight: 15,

    /**
     * @default 100
     * @type {number}
     * @instance
     */
    defaultColumnWidth: 100,

    //for immediate painting, set these values to 0, true respectively

    /**
     * @default 60
     * @type {number}
     * @instance
     */
    repaintIntervalRate: 60,

    /**
     * @default `false`
     * @type {boolean}
     * @instance
     */
    repaintImmediately: false,

    //enable or disable double buffering

    /**
     * @default `false`
     * @type {boolean}
     * @instance
     */
    useBitBlit: false,


    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    useHiDPI: true,

    /**
     * @default ['alt', 'esc']
     * @type {string}
     * @instance
     */
    editorActivationKeys: ['alt', 'esc'],

    /**
     * @default `false`
     * @type {boolean}
     * @instance
     */
    readOnly: false,

    // inherited by cell renderers

    /**
     * @default getTextWidth
     * @type {function}
     * @instance
     */
    getTextWidth: getTextWidth,

    /**
     * @default getTextHeight
     * @type {function}
     * @instance
     */
    getTextHeight: getTextHeight,


    /**
     * @default 0
     * @type {number}
     * @instance
     */
    fixedColumnCount: 0,

    /**
     * @default 0
     * @type {number}
     * @instance
     */
    fixedRowCount: 0,

    /**
     * @default 0
     * @type {number}
     * @instance
     */
    headerColumnCount: 0,


    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    showRowNumbers: true,

    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    showTreeColumn: true,

    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    showHeaderRow: true,

    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    showFilterRow: true,


    /** Clicking in a cell "selects" it; it is added to the select region and repainted with "cell selection" colors.
     * @default `true`
     * @type {boolean}
     * @instance
     */
    cellSelection: true,

    /** Clicking in a row header (leftmost column) "selects" the row; the entire row is added to the select region and repainted with "row selection" colors.
     * @default `true`
     * @type {boolean}
     * @instance
     */
    columnSelection: true,

    /** Clicking in a column header (top row) "selects" the column; the entire column is added to the select region and repainted with "column selection" colors.
     * @default `true`
     * @type {boolean}
     * @instance
     */
    rowSelection: true,

    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    singleRowSelectionMode: true,

    /**
     * @default 'rgba(0, 0, 48, 0.2)'
     * @type {cssColor}
     * @instance
     */
    selectionRegionOverlayColor: 'rgba(0, 0, 48, 0.2)',

    /**
     * @default 'black'
     * @type {string}
     * @instance
     */
    selectionRegionOutlineColor: 'black',

    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    columnAutosizing: true,

    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    rowNumberAutosizing: true,

    /**
     * @default `false`
     * @type {boolean}
     * @instance
     */
    headerTextWrapping: false,

    /**
     * @default `false`
     * @type {boolean}
     * @instance
     */
    rowResize: false,

    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    editable: true,

    /**
     * @default `true`
     * @type {boolean}
     * @instance
     */
    editOnDoubleClick: true,

    /**
     * @default 325
     * @type {number}
     * @instance
     */
    doubleClickDelay: 325,

    /**
     * Grid-level property.
     * When user presses a printable character key _or_ BACKSPACE _or_ DELETE:
     * 1. Activate cell editor on current cell (i.e., origin of most recent selection).
     * 2. If cell editor is a text editor:
     *    1. Replace current value with the character the user typed; or
     *    2. Clear it on BACKSPACE, DELETE, or other invalid character (_e.g._ when user types a letter but the cell editor only accepts digits).
     *
     * > In invoked, user has the option to back out by pressing the ESCAPE key.
     *
     * @default `true`
     * @type {boolean}
     * @instance
     */
    editOnKeydown: true,

    /**
     * @default renderCellError
     * @type {function}
     */
    renderCellError: renderCellError,

    /**
     * @default `false`
     * @type {boolean}
     */
    checkboxOnlyRowSelections: false,

    /** Name of a formatters for cell text.
     * @see /src/Formatters.js
     */
    format: 'default',

    /********** HOVER COLORS **********/

    /** @typedef hoverColors
     * @property {boolean} [enable=false] - `false` means not hilite on hover
     * @property {cssColor} backgroundColor - cell, row, or colummn background color. Alpha channel will be respected and if given will be painted over the cells predetermined color.
     * @property {cssColor} [header.backgroundColor=backgroundColor] - for columns and rows, this is the background color of the column or row "handle" (header rows or columns, respectively). (Not used for cells.)
     */

    /** On mouse hover, whether to repaint the cell background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(160, 160, 40, 0.30) }'
     */
    hoverCellHighlight: {
        enabled: true,
        backgroundColor: 'rgba(160, 160, 40, 0.45)'
    },

    /** On mouse hover, whether to repaint the row background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(100, 100, 25, 0.15) }'
     */
    hoverRowHighlight: {
        enabled: true,
        backgroundColor: 'rgba(100, 100, 25, 0.30)'

    },

    /** On mouse hover, whether to repaint the column background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(60, 60, 15, 0.15) }'
     */
    hoverColumnHighlight: {
        enabled: true,
        backgroundColor: 'rgba(60, 60, 15, 0.15)'
    },


    /** Display cell font with under-score line drawn over it.
     * > Implementation of links right now is not automatic; you must attach a 'fin-click' listener to the hypergrid object, etc.
     * @type {boolean}
     * @default `false`
     */
    link: false,

    /** Display cell font with strike-through line drawn over it.
     * @type {boolean}
     * @default `false`
     */
    strikeThrough: false,

};

/** @typedef {string} cssColor
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
 */
/** @typedef {string} cssFont
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font
 */

var textWidthCache = new LRUCache(2000);

function getTextWidth(gc, string) {
    if (string === null || string === undefined) {
        return 0;
    }
    string = string + '';
    if (string.length === 0) {
        return 0;
    }
    var key = gc.font + string;
    var width = textWidthCache.get(key);
    if (!width) {
        width = gc.measureText(string).width;
        textWidthCache.set(key, width);
    }
    return width;
}

var fontData = {};

function getTextHeight(font) {
    var result = fontData[font];

    if (!result) {
        result = {};

        var text = document.createElement('span');
        text.textContent = 'Hg';
        text.style.font = font;

        var block = document.createElement('div');
        block.style.display = 'inline-block';
        block.style.width = '1px';
        block.style.height = '0px';

        var div = document.createElement('div');
        div.appendChild(text);
        div.appendChild(block);

        div.style.position = 'absolute';
        document.body.appendChild(div);

        try {

            block.style.verticalAlign = 'baseline';

            var blockRect = block.getBoundingClientRect();
            var textRect = text.getBoundingClientRect();

            result.ascent = blockRect.top - textRect.top;

            block.style.verticalAlign = 'bottom';
            result.height = blockRect.top - textRect.top;

            result.descent = result.height - result.ascent;

        } finally {
            document.body.removeChild(div);
        }
        if (result.height !== 0) {
            fontData[font] = result;
        }
    }

    return result;
}

},{"./lib/renderCellError":80,"lru-cache":22}],51:[function(require,module,exports){
/* eslint-env browser */

'use strict';

require('./lib/polyfills');

require('object-iterators'); // Installs the Array.find polyfill, as needed

var Hypergrid = require('./Hypergrid');

Hypergrid.images = require('../images');
Hypergrid.behaviors = require('./behaviors');
Hypergrid.cellEditors = require('./cellEditors');
Hypergrid.features = require('./features');

(window.fin = window.fin || {}).Hypergrid = Hypergrid;

},{"../images":3,"./Hypergrid":31,"./behaviors":37,"./cellEditors":47,"./features":68,"./lib/polyfills":79,"object-iterators":24}],52:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var CellClick = Feature.extend('CellClick', {

    /**
     * @memberOf CellClick.prototype
     * @desc Handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleTap: function(grid, event) {
        if (
            event.gridCell.y >= grid.behavior.getHeaderRowCount() &&
            event.gridCell.x >= grid.behavior.getHeaderColumnCount()
        ) {
            grid.cellClicked(event);
        } else if (this.next) {
            this.next.handleTap(grid, event);
        }
    }
});

module.exports = CellClick;

},{"./Feature.js":61}],53:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var CellEditing = Feature.extend('CellEditing', {

    /**
     * @memberOf CellEditing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function(grid, event) {
        var isDoubleClickEditorActivation = grid.resolveProperty('editOnDoubleClick');
        if (this.checkActivateEditor(grid, event, isDoubleClickEditorActivation)) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    handleTap: function(grid, event) {
        var isDoubleClickEditorActivation = grid.resolveProperty('editOnDoubleClick');
        if (this.checkActivateEditor(grid, event, !isDoubleClickEditorActivation)) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleTap(grid, event);
        }
    },

    /**
     * @memberOf CellEditing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleHoldPulse: function(grid, event) {
        var isDoubleClickEditorActivation = grid.resolveProperty('editOnDoubleClick');
        if (this.checkActivateEditor(grid, event, !isDoubleClickEditorActivation)) {
           grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleHoldPulse(grid, event);
        }
    },

    checkActivateEditor: function(grid, event, isDoubleClickEditorActivation) {
        var headerRowCount = grid.behavior.getHeaderRowCount();
        var headerColumnCount = grid.behavior.getHeaderColumnCount();
        var gridCell = event.gridCell;
        var isFilterRow = grid.isFilterRow(gridCell.y);

        return isDoubleClickEditorActivation &&
            gridCell.x >= headerColumnCount &&
            (isFilterRow || gridCell.y >= headerRowCount);
    }

});

module.exports = CellEditing;

},{"./Feature.js":61}],54:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var CellSelection = Feature.extend('CellSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @memberOf CellSelection.prototype
     */
    currentDrag: null,

    /**
     * the cell coordinates of the where the mouse pointer is during a drag operation
     * @type {Object}
     * @memberOf CellSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbAutoStart: 0,

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;
        var headerRowCount = grid.behavior.getHeaderRowCount();
        var headerColumnCount = grid.behavior.getHeaderColumnCount();
        var columnCount = grid.behavior.getColumnCount();
        var isOutside = viewCell.x >= columnCount;

        var isHeader = dy < headerRowCount || dx < headerColumnCount;

        if (!grid.isCellSelection() || isRightClick || isHeader || isOutside) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {
            var numFixedColumns = grid.getFixedColumnCount();
            var numFixedRows = grid.getFixedRowCount();

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            var keys = primEvent.detail.keys;
            this.dragging = true;
            this.extendSelection(grid, dCell, keys);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (!grid.isCellSelection() || isRightClick || !this.dragging) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();
            var numFixedRows = grid.getFixedRowCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var command = 'handle' + event.detail.char;
        if (this[command]) {
            this[command].call(this, grid, event.detail);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle a mousedrag selection.
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {

        var headerRowCount = grid.behavior.getHeaderRowCount();
        var headerColumnCount = grid.behavior.getHeaderColumnCount();
        var x = gridCell.x;
        var y = gridCell.y;
        x = Math.max(headerColumnCount, x);
        y = Math.max(headerRowCount, y);

        var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        //var scrollingNow = grid.isScrollingNow();

        var newX = x - mouseDown.x;
        var newY = y - mouseDown.y;

        if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
            return;
        }

        grid.clearMostRecentSelection();

        grid.select(mouseDown.x, mouseDown.y, newX, newY);
        grid.setDragExtent(grid.newPoint(newX, newY));

        grid.repaint();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {

        if (!grid.isScrollingNow()) {
            return;
        }

        var dragStartedInHeaderArea = grid.isMouseDownInHeaderArea();
        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (!dragStartedInHeaderArea) {
            if (this.currentDrag.x < b.origin.x) {
                xOffset = -1;
            }
            if (this.currentDrag.y < b.origin.y) {
                yOffset = -1;
            }
        }
        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }
        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        var hasCTRL = keys.indexOf('CTRL') >= 0;
        var hasSHIFT = keys.indexOf('SHIFT') >= 0;
        // var scrollTop = grid.getVScrollValue();
        // var scrollLeft = grid.getHScrollValue();

        // var numFixedColumns = 0;//grid.getFixedColumnCount();
        // var numFixedRows = 0;//grid.getFixedRowCount();

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        if (
            hasCTRL &&
            x === mousePoint.x &&
            y === mousePoint.y
        ) {
            grid.clearMostRecentSelection();
            grid.popMouseDown();
            grid.repaint();
            return;
        }

        if (!hasCTRL && !hasSHIFT) {
            grid.clearSelections();
        }

        if (hasSHIFT) {
            grid.clearMostRecentSelection();
            grid.select(mousePoint.x, mousePoint.y, x - mousePoint.x + 1, y - mousePoint.y + 1);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x + 1, y - mousePoint.y));
        } else {
            grid.select(x, y, 0, 0);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, 1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, -1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        this.moveSingleSelect(grid, 0, count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        this.moveSingleSelect(grid, 0, -count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX, offsetY) {

        var maxColumns = grid.getColumnCount() - 1;
        var maxRows = grid.getRowCount() - 1;

        var maxViewableColumns = grid.getVisibleColumns() - 1;
        var maxViewableRows = grid.getVisibleRows() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newX = extent.x + offsetX;
        var newY = extent.y + offsetY;

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));
        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentSelection();
        grid.select(origin.x, origin.y, newX, newY);

        grid.setDragExtent(grid.newPoint(newX, newY));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }
        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX, offsetY) {

        var maxColumns = grid.getColumnCount() - 1;
        var maxRows = grid.getRowCount() - 1;

        var maxViewableColumns = grid.getVisibleColumnsCount() - 1;
        var maxViewableRows = grid.getVisibleRowsCount() - 1;

        var minRows = grid.getHeaderRowCount();
        var minCols = grid.getHeaderColumnCount();

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newX = mouseCorner.x + offsetX;
        var newY = mouseCorner.y + offsetY;

        newX = Math.min(maxColumns, Math.max(minCols, newX));
        newY = Math.min(maxRows, Math.max(minRows, newY));

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelColIsVisible(newX, offsetX)) {
            this.pingAutoScroll();
        }
        if (grid.insureModelRowIsVisible(newY, offsetY)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    }

});

module.exports = CellSelection;

},{"./Feature.js":61}],55:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnAutosizing = Feature.extend('ColumnAutosizing', {

    /**
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf ColumnAutosizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        var headerRowCount = grid.getHeaderRowCount();
        //var headerColCount = grid.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (gridCell.y <= headerRowCount) {
            grid.autosizeColumn(gridCell.x);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    }

});

module.exports = ColumnAutosizing;

},{"./Feature.js":61}],56:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

// This feature is responsible for column drag and drop reordering.
// This object is a mess and desperately needs a complete rewrite.....

var Feature = require('./Feature.js');

var columnAnimationTime = 150;
var dragger;
var draggerCTX;
var floatColumn;
var floatColumnCTX;

/**
 * @constructor
 */
var ColumnMoving = Feature.extend('ColumnMoving', {

    /**
     * queue up the animations that need to play so they are done synchronously
     * @type {Array}
     * @memberOf CellMoving.prototype
     */
    floaterAnimationQueue: [],

    /**
     * am I currently auto scrolling right
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingRight: false,

    /**
     * am I currently auto scrolling left
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingLeft: false,

    /**
     * is the drag mechanism currently enabled ("armed")
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragArmed: false,

    /**
     * am I dragging right now
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragging: false,

    /**
     * the column index of the currently dragged column
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragCol: -1,

    /**
     * an offset to position the dragged item from the cursor
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragOffset: 0,

    /**
     * @memberOf CellMoving.prototype
     * @desc give me an opportunity to initialize stuff on the grid
     * @param {Hypergrid} grid
     */
    initializeOn: function(grid) {
        this.isFloatingNow = false;
        this.initializeAnimationSupport(grid);
        if (this.next) {
            this.next.initializeOn(grid);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc initialize animation support on the grid
     * @param {Hypergrid} grid
     */
    initializeAnimationSupport: function(grid) {
        if (!dragger) {
            dragger = document.createElement('canvas');
            dragger.setAttribute('width', '0px');
            dragger.setAttribute('height', '0px');

            document.body.appendChild(dragger);
            draggerCTX = dragger.getContext('2d');
        }
        if (!floatColumn) {
            floatColumn = document.createElement('canvas');
            floatColumn.setAttribute('width', '0px');
            floatColumn.setAttribute('height', '0px');

            document.body.appendChild(floatColumn);
            floatColumnCTX = floatColumn.getContext('2d');
        }

    },

    getCanDragCursorName: function() {
        return '-webkit-grab';
    },

    getDraggingCursorName: function() {
        return '-webkit-grabbing';
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {

        var gridCell = event.gridCell;
        var x;
        //var y;

        var distance = Math.abs(event.primitiveEvent.detail.dragstart.x - event.primitiveEvent.detail.mouse.x);

        if (distance < 10) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
            return;
        }

        if (this.isHeaderRow(grid, event) && this.dragArmed && !this.dragging) {
            this.dragging = true;
            this.dragCol = gridCell.x;
            this.dragOffset = event.mousePoint.x;
            this.detachChain();
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.createDragColumn(grid, x, this.dragCol);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }

        if (this.dragging) {
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.dragColumn(grid, x);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (grid.behavior.isColumnReorderable()) {
            if (this.isHeaderRow(grid, event) && event.gridCell.x !== -1) {
                this.dragArmed = true;
                this.cursor = this.getDraggingCursorName();
                grid.clearSelections();
            }
        }
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        //var col = event.gridCell.x;
        if (this.dragging) {
            this.cursor = null;
            //delay here to give other events a chance to be dropped
            var self = this;
            this.endDragColumn(grid);
            setTimeout(function() {
                self.attachChain();
            }, 200);
        }
        this.dragCol = -1;
        this.dragging = false;
        this.dragArmed = false;
        this.cursor = null;
        grid.repaint();

        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {

        if (!this.dragging && event.mousePoint.y < 5 && event.viewPoint.y === 0) {
            this.cursor = this.getCanDragCursorName();
        } else {
            this.cursor = null;
        }

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }

        if (this.isHeaderRow(grid, event) && this.dragging) {
            this.cursor = this.getDraggingCursorName(); //move';
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this is the main event handler that manages the dragging of the column
     * @param {Hypergrid} grid
     * @param {boolean} draggedToTheRight - are we moving to the right
     */
    floatColumnTo: function(grid, draggedToTheRight) {
        this.floatingNow = true;

        var renderer = grid.getRenderer();
        var colEdges = renderer.getColumnEdges();
        var scrollLeft = grid.getHScrollValue();
        var floaterIndex = grid.renderOverridesCache.floater.columnIndex;
        var draggerIndex = grid.renderOverridesCache.dragger.columnIndex;
        var hdpiratio = grid.renderOverridesCache.dragger.hdpiratio;

        var draggerStartX;
        var floaterStartX;
        var fixedColumnCount = grid.getFixedColumnCount();
        var draggerWidth = grid.getColumnWidth(draggerIndex);
        var floaterWidth = grid.getColumnWidth(floaterIndex);

        var max = grid.getVisibleColumnsCount();

        var doffset = 0;
        var foffset = 0;

        if (draggerIndex >= fixedColumnCount) {
            doffset = scrollLeft;
        }
        if (floaterIndex >= fixedColumnCount) {
            foffset = scrollLeft;
        }

        if (draggedToTheRight) {
            draggerStartX = colEdges[Math.min(max, draggerIndex - doffset)];
            floaterStartX = colEdges[Math.min(max, floaterIndex - foffset)];

            grid.renderOverridesCache.dragger.startX = (draggerStartX + floaterWidth) * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;

        } else {
            floaterStartX = colEdges[Math.min(max, floaterIndex - foffset)];
            draggerStartX = floaterStartX + draggerWidth;

            grid.renderOverridesCache.dragger.startX = floaterStartX * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;
        }
        grid.swapColumns(draggerIndex, floaterIndex);
        grid.renderOverridesCache.dragger.columnIndex = floaterIndex;
        grid.renderOverridesCache.floater.columnIndex = draggerIndex;


        this.floaterAnimationQueue.unshift(this.doColumnMoveAnimation(grid, floaterStartX, draggerStartX));

        this.doFloaterAnimation(grid);

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the column drag and drop animation
     * @param {Hypergrid} grid
     * @param {number} floaterStartX - the x start coordinate of the column underneath that floats behind the dragged column
     * @param {number} draggerStartX - the x start coordinate of the dragged column
     */
    doColumnMoveAnimation: function(grid, floaterStartX, draggerStartX) {
        var self = this;
        return function() {
            var d = floatColumn;
            d.style.display = 'inline';
            self.setCrossBrowserProperty(d, 'transform', 'translate(' + floaterStartX + 'px, ' + 0 + 'px)');

            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';
            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';

            requestAnimationFrame(function() {
                self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease');
                self.setCrossBrowserProperty(d, 'transform', 'translate(' + draggerStartX + 'px, ' + -2 + 'px)');
            });
            grid.repaint();
            //need to change this to key frames

            setTimeout(function() {
                self.setCrossBrowserProperty(d, 'transition', '');
                grid.renderOverridesCache.floater = null;
                grid.repaint();
                self.doFloaterAnimation(grid);
                requestAnimationFrame(function() {
                    d.style.display = 'none';
                    self.isFloatingNow = false;
                });
            }, columnAnimationTime + 50);
        };
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the floater animation
     * @param {Hypergrid} grid
     */
    doFloaterAnimation: function(grid) {
        if (this.floaterAnimationQueue.length === 0) {
            this.floatingNow = false;
            grid.repaint();
            return;
        }
        var animation = this.floaterAnimationQueue.pop();
        animation();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the float column at columnIndex underneath the dragged column
     * @param {Hypergrid} grid
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createFloatColumn: function(grid, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();

        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = floatColumn;
        var style = d.style;
        var location = grid.div.getBoundingClientRect();

        style.top = (location.top - 2) + 'px';
        style.left = location.left + 'px';
        style.position = 'fixed';

        var hdpiRatio = grid.getHiDPI(floatColumnCTX);

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');
        style.boxShadow = '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)';
        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';
        style.borderTop = '1px solid ' + renderer.resolveProperty('lineColor');
        style.backgroundColor = renderer.resolveProperty('backgroundColor');

        var startX = columnEdges[columnIndex - scrollLeft];
        startX = startX * hdpiRatio;

        floatColumnCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.floater = {
            columnIndex: columnIndex,
            ctx: floatColumnCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        style.zIndex = '4';
        this.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -2 + 'px)');
        style.cursor = this.getDraggingCursorName();
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting cross browser css properties
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setCrossBrowserProperty: function(element, property, value) {
        var uProperty = property[0].toUpperCase() + property.substr(1);
        this.setProp(element, 'webkit' + uProperty, value);
        this.setProp(element, 'Moz' + uProperty, value);
        this.setProp(element, 'ms' + uProperty, value);
        this.setProp(element, 'O' + uProperty, value);
        this.setProp(element, property, value);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting properties on HTMLElements
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setProp: function(element, property, value) {
        if (property in element.style) {
            element.style[property] = value;
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the dragged column at columnIndex above the floated column
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createDragColumn: function(grid, x, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();
        var hdpiRatio = grid.getHiDPI(draggerCTX);
        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = dragger;
        var location = grid.div.getBoundingClientRect();
        var style = d.style;

        style.top = location.top + 'px';
        style.left = location.left + 'px';
        style.position = 'fixed';
        style.opacity = 0.85;
        style.boxShadow = '0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22)';
        //style.zIndex = 100;
        style.borderTop = '1px solid ' + renderer.resolveProperty('lineColor');
        style.backgroundColor = grid.renderer.resolveProperty('backgroundColor');

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');

        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';

        var startX = columnEdges[columnIndex - scrollLeft];
        startX = startX * hdpiRatio;

        draggerCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.dragger = {
            columnIndex: columnIndex,
            ctx: draggerCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, -5px)');
        style.zIndex = '5';
        style.cursor = this.getDraggingCursorName();
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this function is the main dragging logic
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    dragColumn: function(grid, x) {

        //TODO: this function is overly complex, refactor this in to something more reasonable
        var self = this;
        //var renderer = grid.getRenderer();
        //var columnEdges = renderer.getColumnEdges();

        var autoScrollingNow = this.columnDragAutoScrollingRight || this.columnDragAutoScrollingLeft;

        var hdpiRatio = grid.getHiDPI(draggerCTX);

        var dragColumnIndex = grid.renderOverridesCache.dragger.columnIndex;
        var columnWidth = grid.renderOverridesCache.dragger.width;

        var minX = 0; //grid.getFixedColumnsWidth();
        var maxX = grid.renderer.getFinalVisableColumnBoundary() - columnWidth;
        x = Math.min(x, maxX + 15);
        x = Math.max(minX - 15, x);

        //am I at my lower bound
        var atMin = x < minX && dragColumnIndex !== 0;

        //am I at my upper bound
        var atMax = x > maxX;

        var d = dragger;

        this.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + 0 + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, ' + -10 + 'px)');
        requestAnimationFrame(function() {
            d.style.display = 'inline';
        });

        var overCol = grid.renderer.getColumnFromPixelX(x + (d.width / 2 / hdpiRatio));

        if (atMin) {
            overCol = 0;
        }

        if (atMax) {
            overCol = grid.getColumnCount() - 1;
        }

        var doAFloat = dragColumnIndex > overCol;
        doAFloat = doAFloat || (overCol - dragColumnIndex >= 1);

        if (doAFloat && !atMax && !autoScrollingNow) {
            var draggedToTheRight = dragColumnIndex < overCol;
            // if (draggedToTheRight) {
            //     overCol = overCol - 1;
            // }
            if (this.isFloatingNow) {
                return;
            }

            this.isFloatingNow = true;
            this.createFloatColumn(grid, overCol);
            this.floatColumnTo(grid, draggedToTheRight);
        } else {

            if (x < minX - 10) {
                this.checkAutoScrollToLeft(grid, x);
            }
            if (x > minX - 10) {
                this.columnDragAutoScrollingLeft = false;
            }
            //lets check for autoscroll to right if were up against it
            if (atMax || x > maxX + 10) {
                this.checkAutoScrollToRight(grid, x);
                return;
            }
            if (x < maxX + 10) {
                this.columnDragAutoScrollingRight = false;
            }
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the right if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToRight: function(grid, x) {
        if (this.columnDragAutoScrollingRight) {
            return;
        }
        this.columnDragAutoScrollingRight = true;
        this._checkAutoScrollToRight(grid, x);
    },

    _checkAutoScrollToRight: function(grid, x) {
        if (!this.columnDragAutoScrollingRight) {
            return;
        }
        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft > (grid.sbHScrollConfig.rangeStop - 2)) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.scrollBy(1, 0);
        var newIndex = draggedIndex + 1;
        console.log(newIndex, draggedIndex);
        grid.swapColumns(newIndex, draggedIndex);
        grid.renderOverridesCache.dragger.columnIndex = newIndex;

        setTimeout(this._checkAutoScrollToRight.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the left if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToLeft: function(grid, x) {
        if (this.columnDragAutoScrollingLeft) {
            return;
        }
        this.columnDragAutoScrollingLeft = true;
        this._checkAutoScrollToLeft(grid, x);
    },

    _checkAutoScrollToLeft: function(grid, x) {
        if (!this.columnDragAutoScrollingLeft) {
            return;
        }

        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft < 1) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.swapColumns(draggedIndex + scrollLeft, draggedIndex + scrollLeft - 1);
        grid.scrollBy(-1, 0);
        setTimeout(this._checkAutoScrollToLeft.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc a column drag has completed, update data and cleanup
     * @param {Hypergrid} grid
     */
    endDragColumn: function(grid) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        var columnIndex = grid.renderOverridesCache.dragger.columnIndex;

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();
        var self = this;
        var startX = columnEdges[columnIndex - scrollLeft];
        var d = dragger;

        self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');
        self.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -1 + 'px)');
        d.style.boxShadow = '0px 0px 0px #888888';

        setTimeout(function() {
            grid.renderOverridesCache.dragger = null;
            grid.repaint();
            requestAnimationFrame(function() {
                d.style.display = 'none';
                grid.endDragColumnNotification();
            });
        }, columnAnimationTime + 50);

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isHeaderRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y === 0;
        return isFixed;
    }

});

module.exports = ColumnMoving;

},{"./Feature.js":61}],57:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnPicker = Feature.extend('ColumnPicker', {

    /**
     * @memberOf ColumnPicker.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyUp: function(grid, event) {
        var key = event.detail.char.toLowerCase();
        var keys = grid.resolveProperty('editorActivationKeys');
        if (keys.indexOf(key) > -1) {
           grid.toggleColumnPicker();
        }
    },

});

module.exports = ColumnPicker;

},{"./Feature.js":61}],58:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnResizing = Feature.extend('ColumnResizing', {

    /**
     * the index of the column wall were currently dragging
     * @type {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    dragIndex: -2,

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragIndexStartingSize: -1,

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.x;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the grid cell x,y coordinate
     * @returns {number}
     * @param {window.fin.rectangular.Point} gridCell
     */
    getGridCellValue: function(gridCell) {
        return gridCell.y;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the grids x,y scroll value
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getScrollValue: function(grid) {
        return grid.getHScrollValue();
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the width/height of the row/column of interest
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getAreaSize: function(grid, index) {
        return grid.getColumnWidth(index);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc set the width/height of the row/column at index
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     * @param {number} value - the width/height to set to
     */
    setAreaSize: function(grid, index, value) {
        grid.setColumnWidth(index, value);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the recently rendered area's width/height
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getPreviousAbsoluteSize: function(grid, index) {
        return grid.getRenderedWidth(index);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        return grid.overColumnDivider(event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc am I over the column/row area
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedOtherArea: function(grid, event) {
        return this.isFirstFixedRow(grid, event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'col-resize';
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.dragIndex > -2) {
            //var fixedAreaCount = this.getFixedAreaCount(grid);
            //var offset = this.getFixedAreaSize(grid, fixedAreaCount + areaIndex);
            var mouse = this.getMouseValue(event);
            var scrollValue = this.getScrollValue(grid);
            if (this.dragIndex < this.getFixedAreaCount(grid)) {
                scrollValue = 0;
            }
            var previous = this.getPreviousAbsoluteSize(grid, this.dragIndex - scrollValue);
            var distance = mouse - previous;
            this.setAreaSize(grid, this.dragIndex, distance);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the width/height of a specific row/column
     * @param {Hypergrid} grid
     * @param {number} areaIndex - the row/column index of interest
     */
    getSize: function(grid, areaIndex) {
        return this.getAreaSize(grid, areaIndex);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the fixed area rows/columns count
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getOtherFixedAreaCount: function(grid) {
        return grid.getFixedRowCount();
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        var overArea = this.overAreaDivider(grid, event);
        if (isEnabled && overArea > -1 && this.isFirstFixedOtherArea(grid, event)) {
            var scrollValue = this.getScrollValue(grid);
            if (overArea < this.getFixedAreaCount(grid)) {
                scrollValue = 0;
            }
            this.dragIndex = overArea - 1 + scrollValue;
            this.dragStart = this.getMouseValue(event);
            this.dragIndexStartingSize = 0;
            this.detachChain();
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        if (isEnabled && this.dragIndex > -2) {
            this.cursor = null;
            this.dragIndex = -2;

            event.primitiveEvent.stopPropagation();
            //delay here to give other events a chance to be dropped
            var self = this;
            grid.synchronizeScrollingBoundries();
            setTimeout(function() {
                self.attachChain();
            }, 200);
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (this.dragIndex > -2) {
            return;
        }
        this.cursor = null;
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
        this.checkForAreaResizeCursorChange(grid, event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc fill this in
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    checkForAreaResizeCursorChange: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        if (isEnabled && this.overAreaDivider(grid, event) > -1 && this.isFirstFixedOtherArea(grid, event)) {
            this.cursor = this.getCursorName();
        } else {
            this.cursor = null;
        }

    },

    /**
     * @param {Hypergrid} grid
     * @returns {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    getFixedAreaCount: function(grid) {
        var count = grid.getFixedColumnCount() + (grid.isShowRowNumbers() ? 1 : 0) + (grid.hasHierarchyColumn() ? 1 : 0);
        return count;
    },

    /**
     * @param {Hypergrid} grid
     * @param event
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        var hasCursor = this.overAreaDivider(grid, event) > -1; //this.cursor !== null;
        var headerRowCount = grid.getHeaderRowCount();
        //var headerColCount = grid.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (isEnabled && hasCursor && (gridCell.y <= headerRowCount)) {
            grid.autosizeColumn(gridCell.x - 1);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @param {Hypergrid} grid
     * @returns {boolean}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    isEnabled: function(grid) {
        return true;
    }

});

module.exports = ColumnResizing;

},{"./Feature.js":61}],59:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * Extra msecs to avoid race condition with fincanvas's double click timer.
 * @type {number}
 * @defaultvalue 50
 * NOTE: 50 msecs seems to work well. 10 and even 25 proved insufficient in Chrome.
 * @private
 */
var RACE_TIME = 50;

/**
 * @constructor
 */
var ColumnSelection = Feature.extend('ColumnSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbAutoStart: 0,


    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    handleDoubleClick: function(grid, event) {
        if (this.doubleClickTimer) {
            clearTimeout(this.doubleClickTimer); // prevent mouseDown from continuing
            this.doubleClickTimer = undefined;
        }
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.doubleClickTimer) {
            return;
        }

        if ((!grid.isColumnSelection() || event.mousePoint.y < 5) && this.next) {
            this.next.handleMouseDown(grid, event);
            return;
        }

        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;

        var isHeader = grid.isShowHeaderRow() && dy === 0 && dx !== -1;

        if (isRightClick || !isHeader) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {
            // HOLD OFF WHILE WAITING FOR DOUBLE-CLICK
            this.doubleClickTimer = setTimeout(function() {
                this.doubleClickTimer = undefined;
                var numFixedColumns = grid.getFixedColumnCount();

                //if we are in the fixed area do not apply the scroll values
                //check both x and y values independently
                if (viewCell.x < numFixedColumns) {
                    dx = viewCell.x;
                }

                var dCell = grid.newPoint(dx, 0);

                var primEvent = event.primitiveEvent;
                var keys = primEvent.detail.keys;
                this.dragging = true;
                this.extendSelection(grid, dCell, keys);
            }.bind(this), grid.resolveProperty('doubleClickDelay') + RACE_TIME);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {

        if ((!grid.isColumnSelection() || this.isColumnDragging(grid)) && this.next) {
            this.next.handleMouseDrag(grid, event);
            return;
        }

        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (isRightClick || !this.dragging) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        if (grid.getLastSelectionType() !== 'column') {
            if (this.next) {
                this.next.handleKeyDown(grid, event);
            }
            return;
        }
        var command = 'handle' + event.detail.char;
        if (this[command]) {
            this[command].call(this, grid, event.detail);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {
        var x = gridCell.x;
        //            var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        var newX = x - mouseDown.x;
        //var newY = y - mouseDown.y;

        // if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
        //     return;
        // }

        grid.clearMostRecentColumnSelection();

        grid.selectColumn(mouseDown.x, x);
        grid.setDragExtent(grid.newPoint(newX, 0));

        grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {

        if (!grid.isScrollingNow()) {
            return;
        }

        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (this.currentDrag.x < b.origin.x) {
            xOffset = -1;
        }

        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        grid.stopEditing();
        //var hasCTRL = keys.indexOf('CTRL') !== -1;
        var hasSHIFT = keys.indexOf('SHIFT') !== -1;

        // var scrollTop = grid.getVScrollValue();
        // var scrollLeft = grid.getHScrollValue();

        // var numFixedColumns = 0;//grid.getFixedColumnCount();
        // var numFixedRows = 0;//grid.getFixedRowCount();

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        // if (mousePoint && x === mousePoint.x && y === mousePoint.y) {
        //     grid.clearSelections();
        //     grid.popMouseDown();
        //     grid.repaint();
        //     return;
        // }

        // if (!hasCTRL && !hasSHIFT) {
        //     grid.clearSelections();
        // }

        if (hasSHIFT) {
            grid.clearMostRecentColumnSelection();
            grid.selectColumn(x, mousePoint.x);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x, 0));
        } else {
            grid.toggleSelectColumn(x, keys);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {

        // var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        // var maxRows = grid.getRowCount() - 1;

        // var newX = mouseCorner.x;
        // var newY = grid.getHeaderRowCount() + grid.getVScrollValue();

        // newY = Math.min(maxRows, newY);

        // grid.clearSelections();
        // grid.select(newX, newY, 0, 0);
        // grid.setMouseDown(new grid.rectangular.Point(newX, newY));
        // grid.setDragExtent(new grid.rectangular.Point(0, 0));

        // grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX) {

        var maxColumns = grid.getColumnCount() - 1;

        var maxViewableColumns = grid.getVisibleColumns() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newX = extent.x + offsetX;
        //var newY = grid.getRowCount();

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));

        grid.clearMostRecentColumnSelection();
        grid.selectColumn(origin.x, origin.x + newX);

        grid.setDragExtent(grid.newPoint(newX, 0));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX) {

        var maxColumns = grid.getColumnCount() - 1;

        var maxViewableColumns = grid.getVisibleColumnsCount() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newX = mouseCorner.x + offsetX;
        //var newY = grid.getRowCount();

        newX = Math.min(maxColumns, Math.max(0, newX));

        grid.clearSelections();
        grid.selectColumn(newX);
        grid.setMouseDown(grid.newPoint(newX, 0));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelColIsVisible(newX, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    isColumnDragging: function(grid) {
        var dragger = grid.lookupFeature('ColumnMoving');
        if (!dragger) {
            return false;
        }
        var isActivated = dragger.dragging && !this.dragging;
        return isActivated;
    }

});

module.exports = ColumnSelection;

},{"./Feature.js":61}],60:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnSorting = Feature.extend('ColumnSorting', {

    /**
     * @memberOf ColumnSorting.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */

    handleDoubleClick: function(grid, event) {
        var gridCell = event.gridCell;
        if (grid.isShowHeaderRow() && gridCell.y === 0 && gridCell.x !== -1) {
            var keys = event.primitiveEvent.detail.keys;
            grid.toggleSort(gridCell.x, keys);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSorting.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        var y = event.gridCell.y;
        if (this.isFixedRow(grid, event) && y < 1) {
            this.cursor = 'pointer';
        } else {
            this.cursor = null;
        }
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    }

});

module.exports = ColumnSorting;

},{"./Feature.js":61}],61:[function(require,module,exports){
'use strict';

var Base = require('../lib/Base');

/**
 * @constructor
 * @desc instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
 */
var Feature = Base.extend('Feature', {

    /**
     * the next feature to be given a chance to handle incoming events
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    next: null,

    /**
     * a temporary holding field for my next feature when I'm in a disconnected state
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    detached: null,

    /**
     * the cursor I want to be displayed
     * @type {string}
     * @default null
     * @memberOf Feature.prototype
     */
    cursor: null,

    /**
     * the cell location where the cursor is currently
     * @type {Point}
     * @default null
     * @memberOf Feature.prototype
     */
    currentHoverCell: null,

    /**
     * @memberOf Feature.prototype
     * @desc set my next field, or if it's populated delegate to the feature in my next field
     * @param {Feature} nextFeature - this is how we build the chain of responsibility
     */
    setNext: function(nextFeature) {
        if (this.next) {
            this.next.setNext(nextFeature);
        } else {
            this.next = nextFeature;
            this.detached = nextFeature;
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc disconnect my child
     */
    detachChain: function() {
        this.next = null;
    },

    /**
     * @memberOf Feature.prototype
     * @desc reattach my child from the detached reference
     */
    attachChain: function() {
        this.next = this.detached;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle mouse move down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function(grid, event) {
        if (this.next) {
            this.next.handleMouseExit(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseEnter: function(grid, event) {
        if (this.next) {
            this.next.handleMouseEnter(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyUp: function(grid, event) {
        if (this.next) {
            this.next.handleKeyUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function(grid, event) {
        if (this.next) {
            this.next.handleWheelMoved(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function(grid, event) {
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleHoldPulse: function(grid, event) {
        if (this.next) {
            this.next.handleHoldPulse(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleTap: function(grid, event) {
        if (this.next) {
            this.next.handleTap(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleContextMenu: function(grid, event) {
        if (this.next) {
            this.next.handleContextMenu(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc toggle the column picker
     */

    moveSingleSelect: function(grid, x, y) {
        if (this.next) {
            this.next.moveSingleSelect(grid, x, y);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y < grid.getFixedRowCount();
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y < 1;
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedColumn: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.x < grid.getFixedColumnCount();
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedColumn: function(grid, event) {
        var gridCell = event.viewPoint;
        var edge = grid.isShowRowNumbers() ? 0 : 1;
        var isFixed = gridCell.x < edge;
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isTopLeft: function(grid, event) {
        var isTopLeft = this.isFixedRow(grid, event) && this.isFixedColumn(grid, event);
        return isTopLeft;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    setCursor: function(grid) {
        if (this.next) {
            this.next.setCursor(grid);
        }
        if (this.cursor) {
            grid.beCursor(this.cursor);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    initializeOn: function(grid) {
        if (this.next) {
            this.next.initializeOn(grid);
        }
    }

});

module.exports = Feature;

},{"../lib/Base":69}],62:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var Filters = Feature.extend('Filters', {

    handleDoubleClick: function(grid, event) {
        if (grid.isFilterRow(event.gridCell.y)) {
            grid.onEditorActivate(event);
        } else {
            Feature.prototype.handleDoubleClick.apply(this, arguments);
        }
    },

    handleTap: function(grid, event) {
        if (grid.isFilterRow(event.gridCell.y)) {
            grid.onEditorActivate(event);
        } else {
            Feature.prototype.handleTap.apply(this, arguments);
        }
    },

    /**
     * @memberOf CellEditing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleHoldPulse: function(grid, event) {
        var isDoubleClickEditorActivation = grid.resolveProperty('editOnDoubleClick');
        if (this.checkActivateEditor(grid, event, !isDoubleClickEditorActivation)) {
           grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleHoldPulse(grid, event);
        }
    }

});

module.exports = Filters;

},{"./Feature.js":61}],63:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

var commands = {
    PAGEDOWN: function(grid) { grid.pageDown(); },
    PAGEUP: function(grid) { grid.pageUp(); },
    PAGELEFT: function(grid) { grid.pageLeft(); },
    PAGERIGHT: function(grid) { grid.pageRight(); }
};

/**
 * @constructor
 */
var KeyPaging = Feature.extend('KeyPaging', {

    /**
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function(grid, event) {
        var detail = event.detail.char;
        var func = commands[detail];
        if (func) {
            func(grid);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

module.exports = KeyPaging;

},{"./Feature.js":61}],64:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var OnHover = Feature.extend('OnHover', {

    /**
     * @desc Hhandle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf OnHover.prototype
     */
    handleMouseMove: function(grid, event) {
        var currentHoverCell = grid.getHoverCell();
        if (!event.gridCell.equals(currentHoverCell)) {
            if (currentHoverCell) {
                this.handleMouseExit(grid, currentHoverCell);
            }
            this.handleMouseEnter(grid, event);
            grid.setHoverCell(event.gridCell);
        } else {
            if (this.next) {
                this.next.handleMouseMove(grid, event);
            }
        }
    }

});

module.exports = OnHover;

},{"./Feature.js":61}],65:[function(require,module,exports){
'use strict';

var ColumnResizing = require('./ColumnResizing');

/**
 * @constructor
 */
var RowResizing = ColumnResizing.extend('RowResizing', {

    /**
     * the index of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragArea: -1,

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragAreaStartingSize: -1,

    /**
     * @memberOf RowResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.y;
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc get the grid cell x,y coordinate
     * @returns {number}
     * @param {Point} gridCell
     */
    getGridCellValue: function(gridCell) {
        return gridCell.x;
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the grids x,y scroll value
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getScrollValue: function(grid) {
        return grid.getVScrollValue();
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the width/height of the row/column of interest
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getAreaSize: function(grid, index) {
        return grid.getRowHeight(index);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc set the width/height of the row/column at index
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     * @param {number} value - the width/height to set to
     */
    setAreaSize: function(grid, index, value) {
        grid.setRowHeight(index, value);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        return grid.overRowDivider(event);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc am I over the column/row area
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedOtherArea: function(grid, event) {
        return this.isFirstFixedColumn(grid, event);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'row-resize';
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the recently rendered area's width/height
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getPreviousAbsoluteSize: function(grid, index) {
        return grid.getRenderedHeight(index);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the fixed area rows/columns count
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getOtherFixedAreaCount: function(grid) {
        return grid.getFixedColumnCount();
    },

    /**
     *
     * @param {Hypergrid} grid
     * @returns {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    getFixedAreaCount: function(grid) {
        return grid.getFixedRowCount() + grid.getHeaderRowCount();
    },

    /**
     *
     * @param {Hypergrid} grid
     * @returns {boolean}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    isEnabled: function(grid) {
        return grid.isRowResizeable();
    }

});

module.exports = RowResizing;

},{"./ColumnResizing":58}],66:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var RowSelection = Feature.extend('RowSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {Point}
     * @default null
     * @memberOf RowSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf RowSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbAutoStart: 0,

    dragArmed: false,

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragArmed) {
            this.dragArmed = false;
            //global row selection
            if (event.gridCell.x === -1 && event.gridCell.y === 0) {
                grid.toggleSelectAllRows();
            }
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.dragging) {
            this.dragging = false;
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {

        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;


        var isHeader = grid.isShowRowNumbers() && dx < 0;

        if (!grid.isRowSelection() || isRightClick || !isHeader) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {

            var numFixedRows = grid.getFixedRowCount();

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(0, dy);

            var primEvent = event.primitiveEvent;
            var keys = primEvent.detail.keys;
            this.dragArmed = true;
            this.extendSelection(grid, dCell, keys);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (!this.dragArmed || !grid.isRowSelection() || isRightClick) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {
            this.dragging = true;
            var numFixedRows = grid.getFixedRowCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            //var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(0, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        if (grid.getLastSelectionType() !== 'row') {
            if (this.next) {
                this.next.handleKeyDown(grid, event);
            }
            return;
        }
        var command = 'handle' + event.detail.char;
        if (this[command]) {
            this[command].call(this, grid, event.detail);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {
        var y = gridCell.y;
        //            var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        var newY = y - mouseDown.y;
        //var newY = y - mouseDown.y;

        // if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
        //     return;
        // }

        grid.clearMostRecentRowSelection();

        grid.selectRow(mouseDown.y, y);
        grid.setDragExtent(grid.newPoint(0, newY));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (this.currentDrag.y < b.origin.y) {
            yOffset = -1;
        }

        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        grid.stopEditing();
        //var hasCTRL = keys.indexOf('CTRL') !== -1;
        var hasSHIFT = keys.indexOf('SHIFT') !== -1;

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        if (hasSHIFT) {
            grid.clearMostRecentRowSelection();
            grid.selectRow(y, mousePoint.y);
            grid.setDragExtent(grid.newPoint(0, y - mousePoint.y));
        } else {
            grid.toggleSelectRow(y, keys);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        var maxColumns = grid.getColumnCount() - 1;

        var newX = grid.getHeaderColumnCount() + grid.getHScrollValue();
        var newY = mouseCorner.y;

        newX = Math.min(maxColumns, newX);

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetY) {

        var maxRows = grid.getRowCount() - 1;

        var maxViewableRows = grid.getVisibleRows() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newY = extent.y + offsetY;
        //var newY = grid.getRowCount();

        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentRowSelection();
        grid.selectRow(origin.y, origin.y + newY);

        grid.setDragExtent(grid.newPoint(0, newY));

        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();

    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetY) {

        var maxRows = grid.getRowCount() - 1;

        var maxViewableRows = grid.getVisibleRowsCount() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newY = mouseCorner.y + offsetY;
        //var newY = grid.getRowCount();

        newY = Math.min(maxRows, Math.max(0, newY));

        grid.clearSelections();
        grid.selectRow(newY);
        grid.setMouseDown(grid.newPoint(0, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelRowIsVisible(newY, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();

    },

    isSingleRowSelection: function() {
        return true;
    }

});

module.exports = RowSelection;

},{"./Feature.js":61}],67:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ThumbwheelScrolling = Feature.extend('ThumbwheelScrolling', {

    /**
     * @memberOf ThumbwheelScrolling.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function(grid, e) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }

        var primEvent = e.primitiveEvent,
            deltaX = Math.sign(primEvent.wheelDeltaX || -primEvent.deltaX),
            deltaY = Math.sign(primEvent.wheelDeltaY || -primEvent.deltaY);

        if (deltaX || deltaY) {
            grid.scrollBy(
                -deltaX || 0, // 0 if NaN
                -deltaY || 0
            );
        }
    }

});


module.exports = ThumbwheelScrolling;

},{"./Feature.js":61}],68:[function(require,module,exports){
'use strict';

module.exports = {
    Feature: require('./Feature'), // abstract base class
    CellClick: require('./CellClick'),
    CellEditing: require('./CellEditing'),
    CellSelection: require('./CellSelection'),
    ColumnAutosizing: require('./ColumnAutosizing'),
    ColumnMoving: require('./ColumnMoving'),
    ColumnResizing: require('./ColumnResizing'),
    ColumnSelection: require('./ColumnSelection'),
    ColumnSorting: require('./ColumnSorting'),
    Filters: require('./Filters'),
    KeyPaging: require('./KeyPaging'),
    OnHover: require('./OnHover'),
    ColumnPicker: require('./ColumnPicker'),
    RowResizing: require('./RowResizing'),
    RowSelection: require('./RowSelection'),
    ThumbwheelScrolling: require('./ThumbwheelScrolling')
};

},{"./CellClick":52,"./CellEditing":53,"./CellSelection":54,"./ColumnAutosizing":55,"./ColumnMoving":56,"./ColumnPicker":57,"./ColumnResizing":58,"./ColumnSelection":59,"./ColumnSorting":60,"./Feature":61,"./Filters":62,"./KeyPaging":63,"./OnHover":64,"./RowResizing":65,"./RowSelection":66,"./ThumbwheelScrolling":67}],69:[function(require,module,exports){
'use strict';

var deprecated = require('./deprecated');
var Base = require('extend-me').Base;

Base.prototype.deprecated = deprecated;

module.exports = Base;

},{"./deprecated":78,"extend-me":5}],70:[function(require,module,exports){
'use strict';

var Base = require('./Base');

/** @constructor
 * @desc Instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
 *
 * See {@link CellProvider#initialize|initialize} which is called by the constructor.
 */
var CellProvider = Base.extend('CellProvider', {

    /**
     * @summary Constructor logic
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     * @memberOf CellProvider.prototype
     */
    initialize: function() {
        this.cellCache = {};
        this.initializeCells();
    },

    /**
     * @desc replace this function in on your instance of cellProvider
     * @returns cell
     * @param {object} config - an object with everything you might need for renderering a cell
     * @memberOf CellProvider.prototype
     */
    getCell: function(config) {
        var cell = this.cellCache.simpleCellRenderer;
        cell.config = config;
        return cell;
    },

    /**
     * @desc replace this function in on your instance of cellProvider
     * @returns cell
     * @param {object} config - an object with everything you might need for renderering a cell
     * @memberOf CellProvider.prototype
     */
    getColumnHeaderCell: function(config) {
        var cell = this.cellCache.simpleCellRenderer;
        cell.config = config;
        return cell;
    },

    /**
     * @desc replace this function in on your instance of cellProvider
     * @returns cell
     * @param {object} config - an object with everything you might need for renderering a cell
     * @memberOf CellProvider.prototype
     */
    getRowHeaderCell: function(config) {
        var cell = this.cellCache.simpleCellRenderer;
        cell.config = config;
        return cell;
    },

    paintButton: function(gc, config) {
        var val = config.value;
        var c = config.x;
        var r = config.y;
        var bounds = config.bounds;
        var x = bounds.x + 2;
        var y = bounds.y + 2;
        var width = bounds.width - 3;
        var height = bounds.height - 3;
        var radius = height / 2;
        var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        if (config.mouseDown) {
            arcGradient.addColorStop(0, '#B5CBED');
            arcGradient.addColorStop(1, '#4d74ea');
        } else {
            arcGradient.addColorStop(0, '#ffffff');
            arcGradient.addColorStop(1, '#aaaaaa');
        }
        gc.fillStyle = arcGradient;
        gc.strokeStyle = '#000000';
        roundRect(gc, x, y, width, height, radius, arcGradient, true);

        var ox = (width - config.getTextWidth(gc, val)) / 2;
        var oy = (height - config.getTextHeight(gc.font).descent) / 2;

        if (gc.textBaseline !== 'middle') {
            gc.textBaseline = 'middle';
        }

        gc.fillStyle = '#000000';

        config.backgroundColor = 'rgba(0,0,0,0)';
        gc.fillText(val, x + ox, y + oy);

        //identify that we are a button
        config.buttonCells[c + ',' + r] = true;
    },

    /**
     * @summary The default cell rendering function for rendering a vanilla cell.
     * @desc Great care has been taken in crafting this function as it needs to perform extremely fast. Reads on the gc object are expensive but not quite as expensive as writes to it. We do our best to avoid writes, then avoid reads. Clipping bounds are not set here as this is also an expensive operation. Instead, we truncate overflowing text and content by filling a rectangle with background color column by column instead of cell by cell.  This column by column fill happens higher up on the stack in a calling function from fin-hypergrid-renderer.  Take note we do not do cell by cell border renderering as that is expensive.  Instead we render many fewer gridlines after all cells are rendered.
     * @param {CanvasGraphicsContext} gc
     * @param {number} config.bounds.x - the x screen coordinate of my origin
     * @param {number} config.bounds.y - the y screen coordinate of my origin
     * @param {number} config.bounds.width - the width I'm allowed to draw within
     * @param {number} config.bounds.height - the height I'm allowed to draw within
     * @memberOf CellProvider.prototype
     */
    defaultCellPaint: function(gc, config) {
        var val = config.value,
            x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height,
            wrapHeaders = config.headerTextWrapping,
            leftPadding = 2, //TODO: fix this
            isHeader = config.y === 0;

        var leftIcon, rightIcon, centerIcon, ixoffset, iyoffset, font;

        // setting gc properties are expensive, let's not do it needlessly

        if (val && val.constructor === Array) {
            leftIcon = val[0];
            rightIcon = val[2];
            val = val[1];
            if (val && typeof val === 'object') {
                if (val.constructor.name === 'HTMLImageElement') { // must be an image
                    centerIcon = val;
                    val = null;
                }
            }
            if (leftIcon && leftIcon.nodeName !== 'IMG') {
                leftIcon = null;
            }
            if (rightIcon && rightIcon.nodeName !== 'IMG') {
                rightIcon = null;
            }
            if (centerIcon && centerIcon.nodeName !== 'IMG') {
                centerIcon = null;
            }
        }

        val = valOrFunc(val, config);
        val = config.formatter(val);

        font = config.isSelected ? config.foregroundSelectionFont : config.font;

        if (gc.font !== font) {
            gc.font = font;
        }
        if (gc.textAlign !== 'left') {
            gc.textAlign = 'left';
        }
        if (gc.textBaseline !== 'middle') {
            gc.textBaseline = 'middle';
        }

        // fill background only if our bgColor is populated or we are a selected cell
        var backgroundColor, hover, hoverColor, selectColor,
            colors = [];

        if (config.isCellHovered && config.hoverCellHighlight.enabled) {
            hoverColor = config.hoverCellHighlight.backgroundColor;
        } else if (config.isRowHovered && (hover = config.hoverRowHighlight).enabled) {
            hoverColor = config.isGridColumn || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
        } else if (config.isColumnHovered && (hover = config.hoverColumnHighlight).enabled) {
            hoverColor = config.isGridRow || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
        }
        if (alpha(hoverColor) < 1) {
            if (config.isSelected) {
                selectColor = valOrFunc(config.backgroundSelectionColor, config);
            }
            if (alpha(selectColor) < 1) {
                backgroundColor = valOrFunc(config.backgroundColor, config);
                if (alpha(backgroundColor) > 0) {
                    colors.push(backgroundColor);
                }
            }
            if (selectColor !== undefined) {
                colors.push(selectColor);
            }
        }
        if (hoverColor !== undefined) {
            colors.push(hoverColor);
        }
        layerColors(gc, colors, x, y, width, height);

        // draw text
        var theColor = valOrFunc(config.isSelected ? config.foregroundSelectionColor : config.color, config);
        if (gc.fillStyle !== theColor) {
            gc.fillStyle = theColor;
            gc.strokeStyle = theColor;
        }

        if (isHeader && wrapHeaders) {
            this.renderMultiLineText(gc, x, y, height, width, config, val);
        } else {
            this.renderSingleLineText(gc, x, y, height, width, config, val);
        }

        var iconWidth = 0;
        if (leftIcon) {
            iyoffset = Math.round((height - leftIcon.height) / 2);
            gc.drawImage(leftIcon, x + leftPadding, y + iyoffset);
            iconWidth = Math.max(leftIcon.width + 2);
        }
        if (rightIcon && width > 1.75 * height) {
            iyoffset = Math.round((height - rightIcon.height) / 2);
            var rightX = x + width - rightIcon.width;
            if (backgroundColor !== undefined) {
                layerColors(gc, colors, rightX, y, rightIcon.width, height);
            } else {
                gc.clearRect(rightX, y, rightIcon.width, height);
            }
            gc.drawImage(rightIcon, rightX, y + iyoffset);
            iconWidth = Math.max(rightIcon.width + 2);
        }
        if (centerIcon) {
            iyoffset = Math.round((height - centerIcon.height) / 2);
            ixoffset = Math.round((width - centerIcon.width) / 2);
            gc.drawImage(centerIcon, x + width - ixoffset - centerIcon.width, y + iyoffset);
            iconWidth = Math.max(centerIcon.width + 2);
        }
        if (config.cellBorderThickness) {
            gc.beginPath();
            gc.rect(x, y, width, height);
            gc.lineWidth = config.cellBorderThickness;
            gc.strokeStyle = config.cellBorderStyle;

            // animate the dashed line a bit here for fun

            gc.stroke();
            gc.closePath();
        }
        config.minWidth = config.minWidth + 2 * (iconWidth);
    },

    renderMultiLineText: function(gc, x, y, height, width, config, val) {
        var lines = fitText(gc, config, val, width);
        if (lines.length === 1) {
            return this.renderSingleLineText(gc, x, y, height, width, config, squeeze(val));
        }

        var colHEdgeOffset = config.cellPadding,
            halignOffset = 0,
            valignOffset = config.voffset,
            halign = config.halign,
            textHeight = config.getTextHeight(config.font).height;

        switch (halign) {
            case 'right':
                halignOffset = width - colHEdgeOffset;
                break;
            case 'center':
                halignOffset = width / 2;
                break;
            case 'left':
                halignOffset = colHEdgeOffset;
                break;
        }

        var hMin = 0, vMin = Math.ceil(textHeight / 2);

        valignOffset += Math.ceil((height - (lines.length - 1) * textHeight) / 2);

        halignOffset = Math.max(hMin, halignOffset);
        valignOffset = Math.max(vMin, valignOffset);

        gc.save(); // define a clipping region for cell
        gc.rect(x, y, width, height);
        gc.clip();

        gc.textAlign = halign;

        for (var i = 0; i < lines.length; i++) {
            gc.fillText(lines[i], x + halignOffset, y + valignOffset + (i * textHeight));
        }

        gc.restore(); // discard clipping region
    },

    renderSingleLineText: function(gc, x, y, height, width, config, val) {
        var colHEdgeOffset = config.cellPadding,
            halignOffset = 0,
            valignOffset = config.voffset,
            halign = config.halign,
            isCellHovered = config.isCellHovered,
            isLink = config.link;

        var fontMetrics = config.getTextHeight(config.font);
        var textWidth = config.getTextWidth(gc, val);

        //we must set this in order to compute the minimum width
        //for column autosizing purposes
        config.minWidth = textWidth + (2 * colHEdgeOffset);

        switch (halign) {
            case 'right':
                //textWidth = config.getTextWidth(gc, config.value);
                halignOffset = width - colHEdgeOffset - textWidth;
                break;
            case 'center':
                //textWidth = config.getTextWidth(gc, config.value);
                halignOffset = (width - textWidth) / 2;
                break;
            case 'left':
                halignOffset = colHEdgeOffset;
                break;
        }

        halignOffset = Math.max(0, halignOffset);
        valignOffset = valignOffset + Math.ceil(height / 2);

        if (val !== null) {
            gc.fillText(val, x + halignOffset, y + valignOffset);
        }

        if (isCellHovered) {
            gc.beginPath();
            if (isLink) {
                underline(config, gc, val, x + halignOffset, y + valignOffset + Math.floor(fontMetrics.height / 2), 1);
                gc.stroke();
            }
            gc.closePath();
        }
        if (config.strikeThrough === true) {
            gc.beginPath();
            strikeThrough(config, gc, val, x + halignOffset, y + valignOffset + Math.floor(fontMetrics.height / 2), 1);
            gc.stroke();
            gc.closePath();
        }
    },

    /**
     * @param {CanvasGraphicsContext} gc
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @memberOf CellProvider.prototype
     * @desc Emerson's paint function for a slider button. currently the user cannot interact with it
     */
    paintSlider: function(gc, x, y, width, height) {
        // gc.strokeStyle = 'white';
        // var val = this.config.value;
        // var radius = height / 2;
        // var offset = width * val;
        // var bgColor = this.config.isSelected ? this.config.bgSelColor : '#333333';
        // var btnGradient = gc.createLinearGradient(x, y, x, y + height);
        // btnGradient.addColorStop(0, bgColor);
        // btnGradient.addColorStop(1, '#666666');
        // var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        // arcGradient.addColorStop(0, '#aaaaaa');
        // arcGradient.addColorStop(1, '#777777');
        // gc.fillStyle = btnGradient;
        // roundRect(gc, x, y, width, height, radius, btnGradient);
        // if (val < 1.0) {
        //     gc.fillStyle = arcGradient;
        // } else {
        //     gc.fillStyle = '#eeeeee';
        // }
        // gc.beginPath();
        // gc.arc(x + Math.max(offset - radius, radius), y + radius, radius, 0, 2 * Math.PI);
        // gc.fill();
        // gc.closePath();
        // this.config.minWidth = 100;
    },

    /**
     * @desc A simple implementation of a sparkline, because it's a barchart we've changed the name ;).
     * @param {CanvasGraphicsContext} gc
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @memberOf CellProvider.prototype
     */
    paintSparkbar: function(gc, x, y, width, height) {
        gc.beginPath();
        var val = this.config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;
        var fgColor = this.config.isSelected ? this.config.fgSelColor : this.config.fgColor;
        if (this.config.bgColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.bgSelColor : this.config.bgColor;
            gc.fillRect(x, y, width, height);
        }
        gc.fillStyle = fgColor;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            gc.fillRect(x + 5, y + height - barheight, eWidth * 0.6666, barheight);
            x = x + eWidth;
        }
        gc.closePath();
        this.config.minWidth = count * 10;

    },

    /**
     * @desc A simple implementation of a sparkline.  see [Edward Tufte sparkline](http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR)
     * @param {CanvasGraphicsContext} gc
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @memberOf CellProvider.prototype
     */
    paintSparkline: function(gc, x, y, width, height) {
        gc.beginPath();
        var val = this.config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;

        var fgColor = this.config.isSelected ? this.config.fgSelColor : this.config.fgColor;
        if (this.config.bgColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.bgSelColor : this.config.bgColor;
            gc.fillRect(x, y, width, height);
        }
        gc.strokeStyle = fgColor;
        gc.fillStyle = fgColor;
        gc.beginPath();
        var prev;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            if (!prev) {
                prev = barheight;
            }
            gc.lineTo(x + 5, y + height - barheight);
            gc.arc(x + 5, y + height - barheight, 1, 0, 2 * Math.PI, false);
            x = x + eWidth;
        }
        this.config.minWidth = count * 10;
        gc.stroke();
        gc.closePath();
    },

    /**
     * @desc A simple implementation of a tree cell renderer for use mainly with the qtree.
     * @param {CanvasGraphicsContext} gc
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @memberOf CellProvider.prototype
     */
    treeCellRenderer: function(gc, x, y, width, height) {
        var val = this.config.value.data;
        var indent = this.config.value.indent;
        var icon = this.config.value.icon;

        //fill background only if our bgColor is populated or we are a selected cell
        if (this.config.bgColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.bgSelColor : this.config.bgColor;
            gc.fillRect(x, y, width, height);
        }

        if (!val || !val.length) {
            return;
        }
        var valignOffset = Math.ceil(height / 2);

        gc.fillStyle = this.config.isSelected ? this.config.fgSelColor : this.config.fgColor;
        gc.fillText(icon + val, x + indent, y + valignOffset);

        var textWidth = this.config.getTextWidth(gc, icon + val);
        var minWidth = x + indent + textWidth + 10;
        this.config.minWidth = minWidth;
    },

    /**
     * @desc An empty implementation of a cell renderer, see [the null object pattern](http://c2.com/cgi/wiki?NullObject).
     * @param {CanvasGraphicsContext} gc
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @memberOf CellProvider.prototype
     */
    emptyCellRenderer: function(gc, x, y, width, height) {},

    /**
     * @memberOf CellProvider.prototype
     * @private
     */
    initializeCells: function() {
        var self = this;
        this.cellCache.simpleCellRenderer = {
            paint: this.defaultCellPaint,
            renderSingleLineText: this.renderSingleLineText,
            renderMultiLineText: this.renderMultiLineText
        };
        this.cellCache.sliderCellRenderer = {
            paint: this.paintSlider
        };
        this.cellCache.sparkbarCellRenderer = {
            paint: this.paintSparkbar
        };
        this.cellCache.sparklineCellRenderer = {
            paint: this.paintSparkline
        };
        this.cellCache.treeCellRenderer = {
            paint: this.treeCellRenderer
        };
        this.cellCache.emptyCellRenderer = {
            paint: this.emptyCellRenderer
        };
        this.cellCache.buttonRenderer = {
            paint: this.paintButton,
            //defaultCellPaint: this.defaultCellPaint
        };
        this.cellCache.linkCellRenderer = {
            paint: function(gc, x, y, width, height) {
                self.config = this.config;
                self.defaultCellPaint(gc, x, y, width, height, true);
            }
        };
    }
});

function layerColors(gc, colors, x, y, width, height) {
    colors.forEach(function(color) {
        gc.fillStyle = color;
        gc.fillRect(x, y, width, height);
    });
}

function valOrFunc(vf, config) {
    var result = (typeof vf)[0] === 'f' ? vf(config) : vf;
    return result || result === 0 ? result : '';
}

function underline(config, gc, text, x, y, thickness) {
    var width = config.getTextWidth(gc, text);

    switch (gc.textAlign) {
        case 'center':
            x -= (width / 2);
            break;
        case 'right':
            x -= width;
            break;
    }

    //gc.beginPath();
    gc.lineWidth = thickness;
    gc.moveTo(x + 0.5, y + 0.5);
    gc.lineTo(x + width + 0.5, y + 0.5);
}

function strikeThrough(config, gc, text, x, y, thickness) {
    var fontMetrics = config.getTextHeight(config.font);
    var width = config.getTextWidth(gc, text);
    y = y - (fontMetrics.height * 0.4);

    switch (gc.textAlign) {
        case 'center':
            x -= (width / 2);
            break;
        case 'right':
            x -= width;
            break;
    }

    //gc.beginPath();
    gc.lineWidth = thickness;
    gc.moveTo(x + 0.5, y + 0.5);
    gc.lineTo(x + width + 0.5, y + 0.5);
}

function findLines(gc, config, words, width) {

    if (words.length === 1) {
        return words;
    }

    // starting with just the first word…
    var stillFits, line = [words.shift()];
    while (
        // so lone as line still fits within current column…
    (stillFits = config.getTextWidth(gc, line.join(' ')) < width)
        // …AND there are more words available…
    && words.length
        ) {
        // …add another word to end of line and retest
        line.push(words.shift());
    }

    if (
        !stillFits // if line is now too long…
        && line.length > 1 // …AND is multiple words…
    ) {
        words.unshift(line.pop()); // …back off by (i.e., remove) one word
    }

    line = [line.join(' ')];

    if (words.length) { // if there's anything left…
        line = line.concat(findLines(gc, config, words, width)); // …break it up as well
    }

    return line;
}

function fitText(gc, config, string, width) {
    return findLines(gc, config, squeeze(string).split(' '), width);
}

// trim string; then reduce all runs of multiple spaces to a single space
function squeeze(string) {
    return (string + '').trim().replace(/\s\s+/g, ' ');
}

function roundRect(gc, x, y, width, height, radius, fill, stroke) {

    if (!stroke) {
        stroke = true;
    }
    if (!radius) {
        radius = 5;
    }
    gc.beginPath();
    gc.moveTo(x + radius, y);
    gc.lineTo(x + width - radius, y);
    gc.quadraticCurveTo(x + width, y, x + width, y + radius);
    gc.lineTo(x + width, y + height - radius);
    gc.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    gc.lineTo(x + radius, y + height);
    gc.quadraticCurveTo(x, y + height, x, y + height - radius);
    gc.lineTo(x, y + radius);
    gc.quadraticCurveTo(x, y, x + radius, y);
    gc.closePath();
    if (stroke) {
        gc.stroke();
    }
    if (fill) {
        gc.fill();
    }
    gc.closePath();
}

function alpha(cssColorSpec) {
    if (cssColorSpec === undefined) {
        // undefined so not visible; treat as transparent
        return 0;
    }

    var matches = cssColorSpec.match(alpha.regex);

    if (matches === null) {
        // an opaque color (a color spec with no alpha channel)
        return 1;
    }

    var A = matches[4];

    if (A === undefined) {
        // cssColorSpec must have been 'transparent'
        return 0;
    }

    return Number(A);
}

alpha.regex = /^(transparent|((RGB|HSL)A\(.*,\s*([\d\.]+)\)))$/i;

module.exports = CellProvider;

},{"./Base":69}],71:[function(require,module,exports){
'use strict';

var REGEXP_BOOLS = /\b(AND|OR|NOR)\b/gi,
    REGEXP_CELL_FILTER = /^\s*(<=|>=|<>|[<≤≠≥>=]|(NOT )?(IN|CONTAINS|BEGINS|ENDS|LIKE) )?(.*?)\s*$/i,
    EXP = '(.*?)', BR = '\\b',
    PREFIX = '^' + EXP + BR,
    INFIX = BR + EXP + BR,
    POSTFIX = BR + EXP + '$',
    opMap = {
        '>=': '≥',
        '<=': '≤',
        '<>': '≠'
    };

var optionsPrototype = {
    autoLookupByName: true,
    autoLookupByAlias: true,
    caseSensitiveColumnNames: false
};

/**
 * @module CQL
 *
 * @summary Column Query Language
 *
 * @author Jonathan Eiten <jonathan@openfin.com>
 *
 * @desc This grammar came from the legacy system in use at Barclays where they enter syntax into _column filter cells._ As in Hypergrid, each column's filter cell is directly below the column header, above the data rows.
 *
 * The original grammar was simply:
 *
 * > _expression_ ::= [ _op-symbol_ ] _operand_
 * > _op-synmbol_ ::= `=` | `<>` | `<` | `>` | `<=` | `>=`
 * > _operand_ ::= _column-name_ | _random-text_
 *
 * We expanded this grammar as follows:
 *
 * > _expression_ ::= _simple-expression_ { _logic-op_ _simple-expression_ }
 * > _simple-expression_ ::= [ _operator_ ] _operand_
 * > _operator_ ::= _op-symbol_ | _op-phrase_
 * > _op-symbol_ ::= `=` | `<>` | `<` | `>` | `<=` | `>=`
 * > _op-phrase_ ::= [ `NOT` _white-space_ ] _op-word_ _white-space_
 * > _op-word_ ::= `STARTS` | `ENDS` | `CONTAINS` | `LIKE` | `IN`
 * > _operand_ ::= _column-name_ | _column alias_ | _random-text_
 * > _logic-op_ ::=  _white-space_ ( `AND` | `OR` | `NOR` ) _white-space_
 *
 * Notes:
 * 1. The default _op-symbol_ is "equals" when no operator is given.
 * 2. Order of operations in undefined.
 * 3. In particular, there is no precedence for logical operators and to resolve any ambiguity as to which binds more tightly, all such operators in an expression _must be the same._ If you need to group two expressions more tightly, put them in a subexpression.
 * 4. Words are shown in the grammar above in upper case. However, they may be any mixture of upper and lower case.
 * 5. _white-space_ is optional if following or preceding a non-alpha character, specifically,_ an _op-symbol_).
 *
 * The original grammar was deterministic (unambiguous), consisting entirely of a single operand (after the optional operator, that is). The one exception is when that operand is an exact (case-insensitive) match for the name (or alias) of a column, it would indirect to that named column's value. Thus, there is no way to use a column name as a literal.
 *
 * The extended grammar is definitely non-deterministic because, in addition to the above, the words `and`, `or`, and `nor` also cannot be part of a literal. In a future release, we plan to allow optional paired quotation marks or parentheses to solve this problem:
 *
 * > _quoted-operand_ ::= ( `'` | `"` | `(` ) _operand_ ( `'` | `"` | `)` )
 *
 * @param {FilterTree} schema - Column schema for column name recognition.
 * @param {function} [options.propResolver]
 */
function ColumnQueryLanguage(schema, options) {
    this.schema = schema;
    this.options = Object.create(optionsPrototype);

    if (options) { this.setOptions(function(key) { return options[key]; }); }
}

ColumnQueryLanguage.prototype = {

    constructor: ColumnQueryLanguage.prototype.constructor,

    /** Override default properties with properties defined by supplied property resolver.
     * @param {function} propResolver
     */
    setOptions: function(propResolver) {
        for (var key in optionsPrototype) {
            if (optionsPrototype.hasOwnProperty(key)) {
                var prop = propResolver(key);
                if (prop !== undefined) {
                    this.options[key] = prop;
                } else {
                    delete this.options[key]; // reveals prototype (default) value
                }
            }
        }
    },

    /**
     * @summary Extract the boolean operators from an expression chain.
     * @desc Returns list of homogeneous operators transformed to lower case.
     *
     * Throws an error if all the boolean operators in the chain are not identical.
     * @param {string} cql
     * @returns {string[]}
     */
    captureBooleans: function(cql) {
        var booleans = cql.match(REGEXP_BOOLS);

        if (booleans) {
            var heterogeneousOperator = booleans.find(function(op, i) {
                booleans[i] = op.toLowerCase();
                return booleans[i] !== booleans[0];
            });

            if (heterogeneousOperator) {
                throw new Error([
                    'Expected homogeneous boolean operators.',
                    'You cannot mix <code>AND</code>, <code>OR</code>, and <code>NOR</code> operators here.',
                    '(Everything after your <code style="color:red">' + heterogeneousOperator.toUpperCase() + '</code> was ignored.)',
                    '<i>Tip: You can create more complex filters by using Manage Filters.</i>'
                ].join('<br>'));
            }
        }

        return booleans;
    },

    /**
     * Break an expression chain into a list of expressions.
     * @param {string} cql
     * @returns {string[]}
     */
    captureExpressions: function(cql, booleans) {
        var expressions, re;

        if (booleans) {
            re = new RegExp(PREFIX + booleans.join(INFIX) + POSTFIX, 'i');
            expressions = cql.match(re);
            expressions.shift(); // discard [0] (input)
        } else {
            expressions = [cql];
        }

        return expressions;
    },

    /**
     * @summary Make a list of children out of a list of expressions.
     * @desc Uses only _complete_ expressions (a value OR an operator + a value).
     *
     * Ignores _incomplete_ expressions (empty string OR an operator - a value).
     *
     * @param {string} columnName
     * @param {string[]} expressions
     *
     * @returns {expressionState[]} where `expressionState` is one of:
     * * `{column: string, operator: string, literal: string}`
     * * `{column: string, operator: string, column2: string, editor: 'Columns'}`
     */
    makeChildren: function(columnName, expressions) {
        var self = this,
            children = [],
            orphanedOps = [];

        expressions.forEach(function(expression) {
            if (expression) {
                var parts = expression.match(REGEXP_CELL_FILTER),
                    op = parts[1] && parts[1].trim().toUpperCase() || '=',
                    literal = parts[parts.length - 1];

                if (!literal) {
                    orphanedOps.push(op);
                } else {
                    var compareLiteral = self.comparable(literal);
                    var fieldName = self.schema.find(function(column) {
                        return (
                            compareLiteral === (self.autoLookupByName && self.comparable(column.name || column)) ||
                            compareLiteral === (self.autoLookupByAlias && self.comparable(column.alias))
                        );
                    });

                    var child = {
                        column: columnName,
                        operator: opMap[op] || op
                    };

                    if (fieldName) {
                        child.column2 = fieldName.name || fieldName;
                        child.editor = 'Columns';
                    } else {
                        child.literal = literal;
                    }

                    children.push(child);
                }
            }
        });

        if (children.length > 0 && orphanedOps.length > 0 || orphanedOps.length > 1) {
            var RED = ' <code style="color:red">';
            if (orphanedOps.length === 1) {
                orphanedOps = [
                    'Expected a value following' + RED + orphanedOps +
                    '</code> to compare against the column.',
                    'The incomplete expression was ignored.'
                ];
            } else {
                orphanedOps = [
                    'Expected values following' + RED + orphanedOps.join('</code> and' + RED) + '</code> to compare against the column.',
                    'The incomplete expressions were ignored.'
                ];
            }
            this.orphanedOpMsg = orphanedOps.join('<br>');
        } else {
            this.orphanedOpMsg = undefined;
        }

        return children;
    },

    comparable: function(name) {
        if (!this.caseSensitiveColumnNames && typeof name === 'string') {
            name = name.toLowerCase();
        }

        return name;
    },

    /**
     * @summary Make a "locked" subexpression definition object from an expression chain.
     * @desc _Locked_ means it is locked to a single field.
     *
     * When there is only a single expression in the chain, the `operator` is omitted (defaults to `'op-and'`).
     * @param {string} columnName
     * @param {string} cql - A CQL expression (one or more simple expressions all separated by the same logical operator).
     * @returns {undefined|{operator: string, children: string[], schema: string[]}}
     * `undefined` when there are no complete expressions
     *
     * @memberOf module:CQL
     */
    parse: function(columnName, cql) {
        // reduce all runs of white space to a single space; then trim
        cql = cql.replace(/\s\s+/g, ' ').trim();

        var booleans = this.captureBooleans(cql),
            expressions = this.captureExpressions(cql, booleans),
            children = this.makeChildren(columnName, expressions),
            operator = booleans && booleans[0],
            state;

        if (children.length) {
            state = {
                type: 'columnFilter',
                children: children
            };

            if (operator) {
                state.operator = 'op-' + operator;
            }
        }

        this.cql = cql;
        this.state = state;

        return state;
    }
};

module.exports = ColumnQueryLanguage;

},{}],72:[function(require,module,exports){
'use strict';

var FilterTree = require('filter-tree');
//var FilterTree = require('../../../../filter-tree/src/js/FilterTree');
var popMenu = require('pop-menu');

var ColumnQueryLanguage = require('./ColumnQueryLanguage');

/*
function ColumnQueryLanguage() {}

ColumnQueryLanguage.prototype.parse = function(columnName, state) {
    state =  {
        type: 'columnFilter',
        children: [ {
            column: columnName,
            operator: '>',
            literal: '2'
        }, {
            column: columnName,
            operator: '<',
            literal: '8'
        } ]
    };
    return state;
};

ColumnQueryLanguage.prototype.setOptions = function() {};
*/

/** @typedef {function} fieldsProviderFunc
 * @returns {menuOption[]} see jsdoc typedef in pop-menu.js
 */

var QUIET_VALIDATION = {
    alert: false,
    focus: false
};

/** @constructor
 *
 * @desc This extension of FilterTree forces a specific tree structure.
 * See {@link makeNewRoot} for a description.
 *
 * @param {FilterTreeOptionsObject} options - You must provide column schema, either for the whole filter tree through `options.schema` or `options.state.schema` or for the specific nodes that need to render column list drop-downs.
 *
 * > NOTE: If `options.state` is undefined, it is defined here as a new {@link makeNewRoot|empty state scaffold) to hold new table filter and column filter expressions to be added through UI.
 */
var CustomFilter = FilterTree.extend('CustomFilter', {

    preInitialize: function(options) {
        if (options) {

            // Set up the default "Hyperfilter" profile (see function comments)
            options.state = options.state || this.makeNewRoot();

            // Upon creation of a 'columnFilter' node, force the schema to the one column
            if ((options.type || options.state && options.state.type) === 'columnFilter') {
                this.schema = [
                    popMenu.findItem(options.parent.root.schema, options.state.children[0].column)
                ];
            }
        }
    },

    initialize: function(options) {
        this.cache = {};

        if (!options.parent) {
            this.extractSubtrees();
        }
    },

    /**
     * Create convenience vars to reference the 2 root "Hyperfilter" nodes
     */
    extractSubtrees: function() {
        var rootNodes = this.root.children;
        this.tableFilter = rootNodes[0];
        this.columnFilters = rootNodes[1];
    },

    /**
     * @summary Make a new empty Hypergrid filter tree state object.
     * @desc This function makes a new default state object as used by Hypergrid, a root with exactly two persisted child nodes:
     *
     * * children[0] represents the _table filter,_ a series of any number of filter expressions and/or subexpressions
     * * children[1] represents the _column filters,_ a series of subexpressions, one per active column filter
     *
     * The `operator` properties for all subexpressions default to `'op-and'`, which means:
     * * AND all table filter expressions and subexpressions together (may be changed from UI)
     * * AND all column Filters subexpressions together (cannot be changed from UI)
     * * AND table filters and column filters together (cannot be changed from UI)
     *
     * @returns a new instance of a Hyperfilter root
     * @memberOf Hyperfilter.prototype
     */
    makeNewRoot: function() {

        this.tableFilter = {
            persist: true,
            children: [
                // table filter expressions and subexpressions go here
            ]
        };

        this.columnFilters = {
            persist: true,
            type: 'columnFilters',
            children: [
                // subexpressions with type 'columnFilter' go here, one for each active column filter
            ]
        };

        var filter = {
            children: [
                this.tableFilter,
                this.columnFilters
            ]
        };

        return filter;
    },

    getColumnFilter: function(columnName) {
        return this.columnFilters.children.find(function(columnFilter) {
            return columnFilter.children.length && columnFilter.children[0].column === columnName;
        });
    },

    /**
     *
     * @param columnName
     * @param {boolean} [options.syntax='CQL'] See detectState in FilterNode.js.
     */
    getColumnFilterState: function(columnName, options) {
        var result = this.cache[columnName];

        if (result === undefined) {
            var subexpression = this.getColumnFilter(columnName);

            if (subexpression) {
                var syntax = options && options.syntax || 'CQL';
                result = subexpression.getState({ syntax: syntax });
            } else {
                result = '';
            }

            this.cache[columnName] = result;
        }

        return result;
    },

    /**
     *
     * @param columnName
     * @param state
     * @param {boolean} [options.syntax='CQL'] See detectState in FilterNode.js.
     */
    setColumnFilterState: function(columnName, state, options) {
        var syntax = options && options.syntax,
            isCql = syntax === undefined || syntax === 'CQL',
            subexpression = this.getColumnFilter(columnName);

        if (isCql) {
            if (!this.CQL) {
                // set up a new CQL instance for this column prior to first use
                this.CQL = new ColumnQueryLanguage(this.root.schema);

                // bind it to this column's properties
                this.CQL.setOptions(resolveProperty.bind(this, columnName));
            }

            // convert some CQL state syntax into a filter tree state object
            var message;
            try {
                state = this.CQL.parse(columnName, state);
                this.cache[columnName] = this.CQL.cql;
                message = this.CQL.orphanedOpMsg;
            } catch (e) {
                message = e.message;
            }
            if (message) {
                console.warn(message);
            }
        }

        if (state) {
            if (subexpression) {
                // replace subexpression representing this column
                subexpression.setState(state);
            } else {
                // add a subexpression representing this column
                subexpression = this.columnFilters.add(state);
            }

            subexpression.invalid(QUIET_VALIDATION);
        } else /* !state */ {
            // remove subexpression representing this column
            subexpression.remove();
        }
    },

    // All remaining methods are co-routines called from grid.dialog
    // See cellEditors/Filter.js

    initializeDialog: function() {

    },

    onShow: function(container) {
        container.appendChild(this.el);
    },

    onOk: function() {
        return this.invalid();
    },

    onReset: function() {

    },

    onDelete: function() {

    },

    onCancel: function() {

    },

    create: function() {
        return this.test.bind(this);
    }
});

function resolveProperty(columnName, propertyName) {
    //todo: finish this
    //return column.resolveProperty('filterCql' + key[0].toUpperCase() + key.substr(1));
}

module.exports = CustomFilter;

},{"./ColumnQueryLanguage":71,"filter-tree":6,"pop-menu":25}],73:[function(require,module,exports){
'use strict';

function nn(number) {
    return (number < 10 ? '-0' : '-') + number;
}

module.exports = {
    date: function(value) {
        return value instanceof Date
            ? value.getFullYear() + nn(value.getMonth() + 1) + nn(value.getDate())
            : value + '';
    },
    default: function(value) {
        return value + '';
    }
};

},{}],74:[function(require,module,exports){
'use strict';

module.exports = (function() {

    var oidPrefix = '.~.#%_'; //this should be something we never will see at the begining of a string
    var counter = 0;

    var hash = function(key) {
        var typeOf = typeof key;
        switch (typeOf) {
            case 'number':
                return oidPrefix + typeOf + '_' + key;
            case 'string':
                return oidPrefix + typeOf + '_' + key;
            case 'boolean':
                return oidPrefix + typeOf + '_' + key;
            case 'symbol':
                return oidPrefix + typeOf + '_' + key;
            case 'undefined':
                return oidPrefix + 'undefined';
            case 'object':
            case 'function':
                /*eslint-disable */
                if (!key.___finhash) {
                    key.___finhash = oidPrefix + counter++;
                }
                return key.___finhash;
                /*eslint-enable */
        }
    };

    // Object.is polyfill, courtesy of @WebReflection
    var is = Object.is ||
        function(a, b) {
            return a === b ? a !== 0 || 1 / a == 1 / b : a != a && b != b; // eslint-disable-line
        };

    // More reliable indexOf, courtesy of @WebReflection
    var betterIndexOf = function(arr, value) {
        if (value != value || value === 0) { // eslint-disable-line
            for (var i = arr.length; i-- && !is(arr[i], value);) { // eslint-disable-line
            }
        } else {
            i = [].indexOf.call(arr, value);
        }
        return i;
    };

    function Mappy() {
        this.keys = [];
        this.data = {};
        this.values = [];
    }

    Mappy.prototype.set = function(key, value) {
        var hashCode = hash(key);
        if (this.data[hashCode] === undefined) {
            this.keys.push(key);
            this.values.push(value);
        }
        this.data[hashCode] = value;
    };

    Mappy.prototype.get = function(key) {
        var hashCode = hash(key);
        return this.data[hashCode];
    };

    Mappy.prototype.getIfAbsent = function(key, ifAbsentFunc) {
        var value = this.get(key);
        if (value === undefined) {
            value = ifAbsentFunc(key, this);
        }
        return value;
    };

    Mappy.prototype.size = function() {
        return this.keys.length;
    };

    Mappy.prototype.clear = function() {
        this.keys.length = 0;
        this.data = {};
    };

    Mappy.prototype.delete = function(key) {
        var hashCode = hash(key);
        if (this.data[hashCode] === undefined) {
            return;
        }
        var index = betterIndexOf(this.keys, key);
        this.keys.splice(index, 1);
        this.values.splice(index, 1);
        delete this.data[hashCode];
    };

    Mappy.prototype.forEach = function(func) {
        var keys = this.keys;
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = this.get(key);
            func(value, key, this);
        }
    };

    Mappy.prototype.map = function(func) {
        var keys = this.keys;
        var newMap = new Mappy();
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = this.get(key);
            var transformed = func(value, key, this);
            newMap.set(key, transformed);
        }
        return newMap;
    };

    Mappy.prototype.copy = function() {
        var keys = this.keys;
        var newMap = new Mappy();
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = this.get(key);
            newMap.set(key, value);
        }
        return newMap;
    };

    return Mappy;

})();

},{}],75:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var _ = require('object-iterators');
var Base = require('./Base');

var images = require('../../images');

/** @typedef {object} CanvasRenderingContext2D
 * @see [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 */

/**
 * @constructor
 * @desc fin-hypergrid-renderer is the canvas enabled top level sub component that handles the renderering of the Grid.
 *
 * It relies on two other external subprojects
 *
 * 1. fin-canvas: a wrapper to provide a simpler interface to the HTML5 canvas component
 * 2. rectangular: a small npm module providing Point and Rectangle objects
 *
 * The fin-hypergrid-renderer is in a unique position to provide critical functionality to the fin-hypergrid in a hightly performant manner.
 * Because it MUST iterate over all the visible cells it can store various bits of information that can be encapsulated as a service for consumption by the fin-hypergrid component.
 *
 * Instances of this object have basically four main functions.
 *
 * 1. render fixed row headers
 * 2. render fixed col headers
 * 3. render main data cells
 * 4. render grid lines
 *
 * Same parameters as {@link Renderer#initialize|initialize}, which is called by this constructor.
 *
 */
var Renderer = Base.extend('Renderer', {

    //the shared single item "pooled" cell object for drawing each cell
    cell: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    },

    scrollHeight: 0,

    viewHeight: 0,

    reset: function() {
        this.bounds = {
            width: 0,
            height: 0
        };
        this.columnEdges = [];
        this.columnEdgesIndexMap = [];
        this.renderedColumnMinWidths = [];
        this.rowEdges = [];
        this.rowEdgesIndexMap = [];
        this.visibleColumns = [];
        this.visibleRows = [];
        this.insertionBounds = [];
    },

    /**
     * @summary Constructor logic
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     * @memberOf Renderer.prototype
     */
    initialize: function(grid) {
        this.grid = grid;
        this.reset();
    },

    //this function computes the grid coordinates used for extremely fast iteration over
    //painting the grid cells. this function is very fast, for thousand rows X 100 columns
    //on a modest machine taking usually 0ms and no more that 3 ms.
    computeCellsBounds: function() {

        //var startTime = Date.now();

        var scrollTop = this.getScrollTop(),
            scrollLeft = this.getScrollLeft(),

            numColumns = this.getColumnCount(),
            numFixedColumns = this.getFixedColumnCount(),

            numRows = this.getRowCount(),
            numFixedRows = this.getFixedRowCount(),

            bounds = this.getBounds(),
            grid = this.grid,
            numberOfBottomTotalsRows = grid.behavior.dataModel.getBottomTotals().length,
            viewWidth = bounds.width || grid.canvas.width, // if 0, we must be in bootstrap
            viewHeight = bounds.height - numberOfBottomTotalsRows * grid.behavior.getDefaultRowHeight(),

            insertionBoundsCursor = 0,
            previousInsertionBoundsCursorValue = 0,

            start = 0,
            x = 0, y = 0,
            c, r,
            vx, vy,
            width, height,
            firstVX, lastVX,
            firstVY, lastVY;

        this.getColumnEdges().length = 0;
        this.rowEdges.length = 0;

        this.columnEdges[0] = 0;
        this.rowEdges[0] = 0;
        this.scrollHeight = 0;

        this.visibleColumns.length = 0;
        this.visibleRows.length = 0;
        this.columnEdgesIndexMap = [];
        this.rowEdgesIndexMap = [];

        this.insertionBounds = [];

        if (this.grid.isShowRowNumbers()) {
            start--;
            this.columnEdges[-1] = -1;
        }

        for (c = start; c < numColumns; c++) {
            vx = c;
            if (c >= numFixedColumns) {
                vx = vx + scrollLeft;
                if (firstVX === undefined) {
                    firstVX = vx;
                }
                lastVX = vx;
            }
            if (x > viewWidth || numColumns <= vx) {
                break;
            }
            width = grid.getColumnWidth(vx);
            x = x + width;
            this.columnEdges[c + 1] = Math.round(x);
            this.visibleColumns[c] = vx;
            this.columnEdgesIndexMap[vx] = c;

            insertionBoundsCursor = insertionBoundsCursor + Math.round(width / 2) + previousInsertionBoundsCursorValue;
            this.insertionBounds.push(insertionBoundsCursor);
            previousInsertionBoundsCursorValue = Math.round(width / 2);
        }

        for (r = 0; r < numRows; r++) {
            vy = r;
            if (r >= numFixedRows) {
                vy = vy + scrollTop;
                if (firstVY === undefined) {
                    firstVY = vy;
                }
                lastVY = vy;
            }
            if (y > viewHeight || numRows <= vy) {
                break;
            }
            height = grid.getRowHeight(vy);
            y = y + height;
            this.rowEdges[r + 1] = Math.round(y);
            this.visibleRows[r] = vy;
            this.rowEdgesIndexMap[vy] = r;
        }
        this.viewHeight = viewHeight;
        this.dataWindow = this.grid.newRectangle(firstVX, firstVY, lastVX - firstVX, lastVY - firstVY);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {Object} a property value at a key, delegates to the grid
     */
    resolveProperty: function(key) {
        return this.grid.resolveProperty(key);
    },

    /** @deprecated Use `.grid` property instead.
     * @memberOf Renderer.prototype
     * @returns {Hypergrid} grid
     */
    getGrid: function() {
        return this.deprecated('grid', { since: '0.2' });
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Notify the fin-hypergrid everytime we've repainted.
     * @desc This is the entry point from fin-canvas.
     * @param {CanvasRenderingContext2D} gc
     */
    paint: function(gc) {
        if (this.grid) {
            this.renderGrid(gc);
            this.grid.gridRenderedNotification();
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Answer how many rows we rendered
     */
    getVisibleRowsCount: function() {
        return this.visibleRows.length - 1;
    },

    getVisibleScrollHeight: function() {
        return this.viewHeight - this.grid.getFixedRowsHeight();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number[]} Rows we just rendered.
     */
    getVisibleRows: function() {
        return this.visibleRows;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Numer of columns we just rendered.
     */
    getVisibleColumnsCount: function() {
        return this.visibleColumns.length - 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Columns we just rendered.
     */
    getVisibleColumns: function() {
        return this.visibleColumns;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The column index whne the mouseEvent coordinates are over a column divider.
     */
    overColumnDivider: function(x) {
        x = Math.round(x);
        var edges = this.getColumnEdges();
        var whichCol = edges.indexOf(x - 1);
        if (whichCol < 0) {
            whichCol = edges.indexOf(x);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x - 2);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x + 1);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x - 3);
        }

        return whichCol;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row index when the mouseEvent coordinates are over a row divider.
     */
    overRowDivider: function(y) {
        y = Math.round(y);
        var which = this.rowEdges.indexOf(y + 1);
        if (which < 0) {
            which = this.rowEdges.indexOf(y);
        }
        if (which < 0) {
            which = this.rowEdges.indexOf(y - 1);
        }
        return which;
    },

    /**
     * @memberOf Renderer.prototype
     * @param {Point} cell
     * @returns {Rectangle} Bounding rect of the given `cell`.
     */
    getBoundsOfCell: function(cell) {
        return this._getBoundsOfCell(cell.x, cell.y);
    },

    /**
     * @memberOf Renderer.prototype
     * @param {number} c - The horizontal coordinate.
     * @param {number} r - The vertical coordinate.
     * @returns {Rectangle} Bounding rect of cell with the given coordinates.
     */
    _getBoundsOfCell: function(c, r) {
        var xOutside = false,
            yOutside = false,
            cell = this.cell;

        var y, x = this.columnEdgesIndexMap[c];
        if (x === undefined) {
            x = this.columnEdgesIndexMap[c - 1];
            xOutside = true;
        }

        var oy, ox = this.columnEdges[x],
            cy, cx = this.columnEdges[x + 1],
            ey, ex = cx - ox;

        cell.x = xOutside ? cx : ox;
        cell.width = xOutside ? 0 : ex;

        if (r < 0) { // bottom totals rows
            var behavior = this.grid.behavior,
                bounds = this.getBounds();

            ey = behavior.getDefaultRowHeight();
            oy = bounds.height + r * ey;
            cy = oy + ey;
        } else {
            y = this.rowEdgesIndexMap[r];
            if (y === undefined) {
                y = this.rowEdgesIndexMap[r - 1];
                yOutside = true;
            }

            oy = this.rowEdges[y];
            cy = this.rowEdges[y + 1];
            ey = cy - oy;
        }

        cell.y = yOutside ? cy : oy;
        cell.height = yOutside ? 0 : ey;

        return cell;
    },

    /**
     * @memberOf Renderer.prototype
     * @desc answer the column index under the coordinate at pixelX
     * @param {number} pixelX - The horizontal coordinate.
     * @returns {number} The column index under the coordinate at pixelX.
     */
    getColumnFromPixelX: function(pixelX) {
        var width = 0,
            fixedColumnCount = this.getFixedColumnCount(),
            scrollLeft = this.grid.getHScrollValue(),
            edges = this.getColumnEdges();

        for (var c = 1; c < edges.length - 1; c++) {
            width = edges[c] - (edges[c] - edges[c - 1]) / 2;
            if (pixelX < width) {
                if (c > fixedColumnCount) {
                    c = c + scrollLeft;
                }
                return c - 1;
            }
        }
        if (c > fixedColumnCount) {
            c = c + scrollLeft;
        }
        return c - 1;
    },


    /**
     * @memberOf Renderer.prototype
     * @desc Answer specific data cell coordinates given mouse coordinates in pixels.
     * @param {Point} point
     * @returns {Point} Cell coordinates
     */
    getGridCellFromMousePoint: function(point) {

        var behavior = this.grid.behavior;
        var width = 0;
        var height = 0;
        var x, y, c, r;
        var previous = 0;
        var columnEdges = this.getColumnEdges();
        var fixedColumnCount = this.getFixedColumnCount(); // + gridSize;
        var fixedRowCount = this.getFixedRowCount();

        // var fixedColumnCount = this.getFixedColumnCount();
        // var fixedRowCount = this.getFixedRowCount();
        var scrollX = this.getScrollLeft();
        var scrollY = this.getScrollTop();

        for (c = 0; c < columnEdges.length; c++) {
            width = columnEdges[c];
            if (point.x < width) {
                x = Math.max(0, point.x - previous - 2);
                break;
            }
            previous = width;
        }
        c--;
        previous = 0;
        for (r = 0; r < this.rowEdges.length; r++) {
            height = this.rowEdges[r];
            if (point.y < height) {
                y = Math.max(0, point.y - previous - 2);
                break;
            }
            previous = height;
        }
        r--;
        if (point.x < 0) {
            c = -1;
        }
        if (point.y < 0) {
            r = -1;
        }

        var viewPoint = this.grid.newPoint(c, r);

        //compensate if we are scrolled
        if (c >= fixedColumnCount) {
            c = c + scrollX;
        }
        if (r >= fixedRowCount) {
            r = r + scrollY;
        }

        var translatedIndex = -1;

        var column = behavior.getColumn(c);
        if (column) {
            translatedIndex = column.index;
        }

        return {
            gridCell: this.grid.newPoint(c, r),
            mousePoint: this.grid.newPoint(x, y),
            viewPoint: viewPoint,
            dataCell: this.grid.newPoint(translatedIndex, r),
        };
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a column is visible.
     * @param {number} colIndex - the column index*
     * @returns {boolean} The given column is fully visible.
     */
    isColumnVisible: function(colIndex) {
        var isVisible = this.visibleColumns.indexOf(colIndex) !== -1;
        return isVisible;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The width x coordinate of the last rendered column
     */
    getFinalVisableColumnBoundary: function() {
        var isMaxX = this.isLastColumnVisible();
        var chop = isMaxX ? 2 : 1;
        var colWall = this.getColumnEdges()[this.getColumnEdges().length - chop];
        var result = Math.min(colWall, this.getBounds().width - 200);
        return result;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines visibility of a row.
     * @param {number} rowIndex - the row index
     * @returns {boolean} The given row is fully visible.
     */
    isRowVisible: function(rowIndex) {
        var isVisible = this.visibleRows.indexOf(rowIndex) !== -1;
        return isVisible;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a cell is selected.
     * @param {number} x - the x cell coordinate
     * @param {number} y - the y cell coordinate*
     * @returns {boolean} The given cell is fully visible.
     */
    isSelected: function(x, y) {
        return this.grid.isSelected(x, y);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc This is the main forking of the renderering task.
     * @param {CanvasRenderingContext2D} gc
     */
    renderGrid: function(gc) {
        gc.beginPath();

        this.paintCells(gc);
        this.paintGridlines(gc);
        this.renderOverrides(gc);
        this.renderFocusCell(gc);
        gc.closePath();
    },

    focusLineStep: [
        [5, 5],
        [0, 1, 5, 4],
        [0, 2, 5, 3],
        [0, 3, 5, 2],
        [0, 4, 5, 1],
        [0, 5, 5, 0],
        [1, 5, 4, 0],
        [2, 5, 3, 0],
        [3, 5, 2, 0],
        [4, 5, 1, 0]
    ],

    renderFocusCell: function(gc) {
        gc.beginPath();
        this._renderFocusCell(gc);
        gc.closePath();
    },

    _renderFocusCell: function(gc) {

        var selections = this.grid.selectionModel.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var selection = selections[selections.length - 1];
        var mouseDown = selection.origin;
        if (mouseDown.x === -1) {
            //no selected area, lets exit
            return;
        }

        var visibleColumns = this.getVisibleColumns();
        var visibleRows = this.getVisibleRows();
        var lastVisibleColumn = visibleColumns[visibleColumns.length - 1];
        var lastVisibleRow = visibleRows[visibleRows.length - 1];

        var extent = selection.extent;

        var dpOX = Math.min(mouseDown.x, mouseDown.x + extent.x);
        var dpOY = Math.min(mouseDown.y, mouseDown.y + extent.y);

        //lets check if our selection rectangle is scrolled outside of the visible area
        if (dpOX > lastVisibleColumn) {
            return; //the top of our rectangle is below visible
        }
        if (dpOY > lastVisibleRow) {
            return; //the left of our rectangle is to the right of being visible
        }

        var dpEX = Math.max(mouseDown.x, mouseDown.x + extent.x) + 1;
        dpEX = Math.min(dpEX, 1 + lastVisibleColumn);

        var dpEY = Math.max(mouseDown.y, mouseDown.y + extent.y) + 1;
        dpEY = Math.min(dpEY, 1 + lastVisibleRow);

        var o = this._getBoundsOfCell(dpOX, dpOY);
        var ox = Math.round((o.x === undefined) ? this.grid.getFixedColumnsWidth() : o.x);
        var oy = Math.round((o.y === undefined) ? this.grid.getFixedRowsHeight() : o.y);
        // var ow = o.width;
        // var oh = o.height;
        var e = this._getBoundsOfCell(dpEX, dpEY);
        var ex = Math.round((e.x === undefined) ? this.grid.getFixedColumnsWidth() : e.x);
        var ey = Math.round((e.y === undefined) ? this.grid.getFixedRowsHeight() : e.y);
        // var ew = e.width;
        // var eh = e.height;
        var x = Math.min(ox, ex);
        var y = Math.min(oy, ey);
        var width = 1 + ex - ox;
        var height = 1 + ey - oy;
        if (x === ex) {
            width = ox - ex;
        }
        if (y === ey) {
            height = oy - ey;
        }
        if (width * height < 1) {
            //if we are only a skinny line, don't render anything
            return;
        }

        gc.rect(x, y, width, height);
        gc.fillStyle = this.resolveProperty('selectionRegionOverlayColor');
        gc.fill();
        gc.lineWidth = 1;
        gc.strokeStyle = this.resolveProperty('selectionRegionOutlineColor');

        // animate the dashed line a bit here for fun

        gc.stroke();

        //gc.rect(x, y, width, height);

        //gc.strokeStyle = 'white';

        // animate the dashed line a bit here for fun
        //gc.setLineDash(this.focusLineStep[Math.floor(10 * (Date.now() / 300 % 1)) % this.focusLineStep.length]);

        //gc.stroke();
    },

    /**
     * @memberOf Renderer.prototype
     * @desc iterate the renderering overrides and manifest each
     * @param {CanvasRenderingContext2D} gc
     */
    renderOverrides: function(gc) {
        var cache = this.grid.renderOverridesCache;
        for (var key in cache) {
            if (cache.hasOwnProperty(key)) {
                var override = cache[key];
                if (override) {
                    this.renderOverride(gc, override);
                }
            }
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @desc copy each overrides specified area to it's target and blank out the source area
     * @param {CanvasRenderingContext2D} gc
     * @param {OverrideObject} override - an object with details contain an area and a target context
     */
    renderOverride: function(gc, override) {
        //lets blank out the drag row
        var hdpiRatio = override.hdpiratio;
        //var edges = this.getColumnEdges();
        var startX = override.startX; //hdpiRatio * edges[override.columnIndex];
        var width = override.width + 1;
        var height = override.height;
        var targetCTX = override.ctx;
        var imgData = gc.getImageData(startX, 0, Math.round(width * hdpiRatio), Math.round(height * hdpiRatio));
        targetCTX.putImageData(imgData, 0, 0);
        gc.fillStyle = this.resolveProperty('backgroundColor2');
        gc.fillRect(Math.round(startX / hdpiRatio), 0, width, height);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current vertical scroll value.
     */
    getScrollTop: function() {
        return this.grid.getVScrollValue();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current horizontal scroll value.
     */
    getScrollLeft: function() {
        return this.grid.getHScrollValue();
    },

    /** @deprecated Use `.grid.behavior` property instead.
     * @memberOf Renderer.prototype
     * @returns {Behavior} The behavior (model).
     */
    getBehavior: function() {
        return this.deprecated('grid.behavior', { since: '0.2' });
    },

    getColumnEdges: function() {
        return this.columnEdges;
    },

    getRowEdges: function() {
        return this.rowEdges;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} The last col was rendered (is visible)
     */
    isLastColumnVisible: function() {
        var lastColumnIndex = this.getColumnCount() - 1;
        return this.visibleColumns.indexOf(lastColumnIndex) !== -1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered column width at index
     */
    getRenderedWidth: function(index) {
        return this.getColumnEdges()[index];
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered row height at index
     */
    getRenderedHeight: function(index) {
        return this.rowEdges[index];
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {fin-canvas} my [fin-canvas](https://github.com/stevewirts/fin-canvas)
     */
    getCanvas: function() {
        return this.grid.getCanvas();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} User is currently dragging a column for reordering.
     */
    isDraggingColumn: function() {
        return this.grid.isDraggingColumn();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page up.
     */
    getPageUpRow: function() {
        var grid = this.grid,
            scrollHeight = this.getVisibleScrollHeight(),
            headerRows = this.grid.getFixedRowCount(),
            top = this.dataWindow.origin.y - headerRows,
            scanHeight = 0;
        while (scanHeight < scrollHeight && top > -1) {
            scanHeight = scanHeight + grid.getRowHeight(top);
            top--;
        }
        return top + 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page down.
     */
    getPageDownRow: function() {
        var headerRows = this.grid.getFixedRowCount();
        var rowNum = this.dataWindow.corner.y - headerRows - 1;
        return rowNum;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.grid.getColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of rows.
     */
    getRowCount: function() {
        return this.grid.getRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.grid.getFixedColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.grid.getFixedRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of header rows.
     */
    getHeaderRowCount: function() {
        return this.grid.getHeaderRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of header columns.
     */
    getHeaderColumnCount: function() {
        return this.grid.getHeaderColumnCount();
    },

    /** @summary Smart render the grid.
     * @desc Paint all the cells of a grid, including all "fixed" columns and rows.
     * We snapshot the context to insure against its pollution.
     * `try...catch` surrounds each cell paint in case a cell editor throws an error.
     * The error message is error-logged to console AND displayed in cell.
     * @memberOf Renderer.prototype
     * @param {CanvasRenderingContext2D} gc
     */
    paintCells: function(gc) {
        var renderCellError,
            message,
            x, y,
            c, r,

            columnEdges = this.getColumnEdges(),
            rowEdges = this.rowEdges,

            visibleCols = this.getVisibleColumns(),
            visibleRows = this.getVisibleRows(),

            behavior = this.grid.behavior,

            clipX = 0,
            clipY = 0,
            clipWidth,
            clipHeight = this.getBounds().height,

            loopStart = this.grid.isShowRowNumbers() ? -1 : 0,
            loopLength = visibleCols.length; // regardless of loopStart, due to definition of .length

        this.buttonCells = {};

        if (loopLength) { // this if prevents painting just the fixed columns when there are no visible columns

            // For each column...
            for (x = loopStart; x < loopLength; x++, clipX += clipWidth) {

                c = visibleCols[x];
                this.renderedColumnMinWidths[c] = 0;
                renderCellError = behavior.getColumnProperties(c).renderCellError;

                gc.save();

                // Clip to visible portion of column to prevent overflow to right. Previously we clipped to entire visible grid and dealt with overflow by overpainting with next column. However, this strategy fails when transparent background (no background color).
                // TODO: if extra clip() calls per column affect performance (not the clipping itself which was happening anyway, but the clip calls which set up the clipping), use previous strategy when there is a background color
                clipWidth = columnEdges[x - loopStart] - clipX;
                gc.beginPath();
                gc.rect(clipX, clipY, clipWidth, clipHeight);
                gc.clip();

                // For each row (of each column)...
                for (y = 0; y < visibleRows.length; y++) {

                    r = visibleRows[y];

                    try {

                        this._paintCell(gc, c, r);

                        //if (r === 9 && c === 2) { throw Error('She sells sea shells by the sea shore.'); }

                    } catch (e) {

                        message = e && (e.message || e) || 'Unknown error.';

                        console.error(message);

                        if (renderCellError) {
                            var rawGc = gc.gc || gc, // Don't log these canvas calls
                                errY = rowEdges[y],
                                errHeight = rowEdges[y + 1] - errY;

                            rawGc.save(); // define clipping region
                            rawGc.beginPath();
                            rawGc.rect(clipX, errY, clipWidth, errHeight);
                            rawGc.clip();

                            renderCellError(rawGc, message, clipX, errY, clipWidth, errHeight);

                            rawGc.restore(); // discard clipping region
                        }

                    }
                }

                // Bottom totals rows...
                for (y = -behavior.dataModel.getBottomTotals().length; y; y++) {
                    this._paintCell(gc, c, y);
                }

                gc.restore(); // Remove column's clip region (and anything else renderCellError() might have set)
            }
        }

        setNumberColumnWidth(gc, behavior, this.grid.getRowCount());
    },

    /**
     * @memberOf Renderer.prototype
     * @desc We opted to not paint borders for each cell as that was extremely expensive. Instead we draw gridlines here. Also we record the widths and heights for later.
     * @param {CanvasRenderingContext2D} gc
     */
    paintGridlines: function(gc) {
        var x, y, c, r = 0;

        var colWidths = this.getColumnEdges();
        var rowHeights = this.rowEdges;

        var viewWidth = colWidths[colWidths.length - 1];
        var viewHeight = this.getBounds().height; //rowHeights[rowHeights.length - 1];

        var drawThemH = this.resolveProperty('gridLinesH');
        var drawThemV = this.resolveProperty('gridLinesV');
        var lineColor = this.resolveProperty('lineColor');

        gc.beginPath();

        if (drawThemV) {
            for (c = 0; c < colWidths.length + 1; c++) {
                x = colWidths[c] + 0.5;
                gc.moveTo(x, 0);
                gc.lineTo(x, viewHeight);
            }
        }

        if (drawThemH) {
            for (r = 0; r < rowHeights.length - 1; r++) {
                y = rowHeights[r] + 0.5;
                gc.moveTo(0, y);
                gc.lineTo(viewWidth, y);
            }

            // Bottom totals rows...
            var behavior = this.grid.behavior,
                rowHeight = behavior.getDefaultRowHeight();
            for (r = -behavior.dataModel.getBottomTotals().length, y = this.getBounds().height; r; r++) {
                y -= rowHeight;
                gc.moveTo(0, y);
                gc.lineTo(viewWidth, y);
            }
        }

        gc.closePath();

        gc.strokeStyle = lineColor;
        gc.lineWidth = this.resolveProperty('lineWidth');
        gc.stroke();
    },

    /**
     * @memberOf Renderer.prototype
     * @param {CanvasRenderingContext2D} gc
     * @param x
     * @param y
     */
    paintCell: function(gc, x, y) {
        gc.moveTo(0, 0);

        var c = this.getVisibleColumns()[x],
            r = this.getVisibleRows()[y];

        if (c) { //something is being viewed at at the moment (otherwise returns undefined)
            this._paintCell(gc, c, r);
        }
    },

    _paintCell: function(gc, c, r) {

        var grid = this.grid,
            behavior = grid.behavior,
            baseProperties = behavior.getColumnProperties(c);

        if (baseProperties.isNull) {
            return;
        }

        var columnProperties = baseProperties,

            headerRowCount = behavior.getHeaderRowCount(),
            isGridRow = r >= headerRowCount,
            isFooterRow = r < 0,
            isHeaderRow = !isGridRow && !isFooterRow,
            isFilterRow = grid.isFilterRow(r),

            headerColumnCount = behavior.getHeaderColumnCount(),
            isGridColumn = c >= headerColumnCount,
            isShowRowNumbers = grid.isShowRowNumbers(),
            isHierarchyColumn = grid.isHierarchyColumn(c),

            isRowSelected = grid.isRowSelected(r),
            isColumnSelected = grid.isColumnSelected(c),
            isCellSelected = grid.isCellSelected(c, r),
            isCellSelectedInColumn = grid.isCellSelectedInColumn(c),
            isCellSelectedInRow = grid.isCellSelectedInRow(r),
            areAllRowsSelected = grid.areAllRowsSelected(),
            cellProperties;

        if ((isShowRowNumbers && c === -1) || isHierarchyColumn) {
            if (isRowSelected) {
                cellProperties = Object.create(baseProperties.rowHeaderRowSelection);
                cellProperties.isSelected = true;
            } else {
                cellProperties = Object.create(baseProperties.rowHeader);
                cellProperties.isSelected = isCellSelectedInRow;
            }
            cellProperties.isUserDataArea = false;
        } else if (isHeaderRow || isFooterRow) {
            if (isFilterRow) {
                cellProperties = Object.create(baseProperties.filterProperties);
                cellProperties.isSelected = false;
            } else if (isColumnSelected) {
                cellProperties = Object.create(baseProperties.columnHeaderColumnSelection);
                cellProperties.isSelected = true;
            } else {
                cellProperties = Object.create(baseProperties.columnHeader);
                cellProperties.isSelected = isCellSelectedInColumn;
            }
            cellProperties.isUserDataArea = false;
        } else if (isHierarchyColumn) {
            cellProperties = Object.create(baseProperties.rowHeader);
            cellProperties.isSelected = isCellSelectedInRow;
        } else {
            cellProperties = Object.create(baseProperties);
            cellProperties.isSelected = isCellSelected || isRowSelected || isColumnSelected;
            cellProperties.isUserDataArea = true;
        }

        var rowNum = r - headerRowCount + 1;

        if (c === -1) {
            if (r === 0) { // header label row gets "master" checkbox
                cellProperties.value = [images.checkbox(areAllRowsSelected), '', null];
            } else if (isFilterRow) { // no checkbox but show filter icon
                cellProperties.value = [images.filter(false), '', null];
            } else if (isHeaderRow || isFooterRow) { // no checkbox on "totals" rows
                cellProperties.value = '';
            } else {
                cellProperties.value = [images.checkbox(isRowSelected), rowNum, null];
            }
            cellProperties.halign = 'right';
        } else {
            cellProperties.value = grid.getValue(c, r);
            cellProperties.halign = grid.getColumnAlignment(c);
        }

        cellProperties.isGridColumn = isGridColumn;
        cellProperties.isGridRow = isGridRow;
        cellProperties.isColumnHovered = grid.isColumnHovered(c) && isGridColumn;
        cellProperties.isRowHovered = grid.isRowHovered(r) && isGridRow;
        cellProperties.isCellHovered = grid.isHovered(c, r) && isGridColumn && isGridRow;
        cellProperties.bounds = this._getBoundsOfCell(c, r);
        cellProperties.isCellSelected = isCellSelected;
        cellProperties.isRowSelected = isRowSelected;
        cellProperties.isColumnSelected = isColumnSelected;
        cellProperties.isInCurrentSelectionRectangle = grid.isInCurrentSelectionRectangle(c, r);

        if (grid.mouseDownState) {
            var point = grid.mouseDownState.gridCell;
            cellProperties.mouseDown = point.x === c && point.y === r;
        }

        cellProperties.x = c;
        cellProperties.y = r;

        behavior.cellPropertiesPrePaintNotification(cellProperties);

        var cell = behavior.getCellRenderer(cellProperties, c, r);
        var overrides = behavior.getCellProperties(c, r);

        //declarative cell properties
        _(cellProperties).extendOwn(overrides);

        //allow the renderer to identify itself if it's a button
        cellProperties.buttonCells = this.buttonCells;
        var formatType = cellProperties.isUserDataArea ? cellProperties.format : 'default';
        cellProperties.formatter = grid.getFormatter(formatType);
        cell.paint(gc, cellProperties);

        this.renderedColumnMinWidths[c] = Math.max(cellProperties.minWidth || 0, this.renderedColumnMinWidths[c]);
        columnProperties.preferredWidth = this.renderedColumnMinWidths[c];
    },

    isViewableButton: function(c, r) {
        var key = c + ',' + r;
        return this.buttonCells[key] === true;
    },

    getRowNumbersWidth: function() {
        var colEdges = this.getColumnEdges();
        if (colEdges.length === 0) {
            return 0;
        }
        return colEdges[0];
    },

    startAnimator: function() {
        var self = this;
        requestAnimationFrame(function animate() {
            self.animate();
            requestAnimationFrame(animate);
        });
    },

    animate: function() {
        var ctx = this.getCanvas().canvasCTX;
        ctx.beginPath();
        ctx.save();
        this.renderFocusCell(ctx);
        ctx.restore();
        ctx.closePath();
    },

    getBounds: function() {
        return this.bounds;
    },

    setBounds: function(bounds) {
        return (this.bounds = bounds);
    }

});

function setNumberColumnWidth(gc, behavior, maxRow) {
    var columnProperties = behavior.getColumnProperties(-1),
        cellProperties = columnProperties.rowHeader,
        icon = images.checked;

    gc.font = cellProperties.font;

    columnProperties.preferredWidth = icon.width + 7 + cellProperties.getTextWidth(gc, maxRow + 1);
}

module.exports = Renderer;

},{"../../images":3,"./Base":69,"object-iterators":24}],76:[function(require,module,exports){
'use strict';

var RangeSelectionModel = require('sparse-boolean-array');

/**
 *
 * @constructor
 * @desc We represent selections as a list of rectangles because large areas can be represented and tested against quickly with a minimal amount of memory usage. Also we need to maintain the selection rectangles flattened counter parts so we can test for single dimension contains. This is how we know to highlight the fixed regions on the edges of the grid.
 */

function SelectionModel(grid) {

    this.grid = grid;

    /**
     * @name selections
     * @type {Rectangle[]}
     * @summary The selection rectangles.
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.selections = [];

    /**
     * @name flattenedX
     * @type {Rectangle[]}
     * @summary The selection rectangles flattened in the horizontal direction (no width).
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.flattenedX = [];

    /**
     * @name flattenedY
     * @type {Rectangle[]}
     * @summary The selection rectangles flattened in the vertical direction (no height).
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.flattenedY = [];

    /**
     * @name rowSelectionModel
     * @type {RangeSelectionModel}
     * @summary The selection rectangles.
     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.rowSelectionModel = new RangeSelectionModel();

    /**
     * @name columnSelectionModel
     * @type {RangeSelectionModel}
     * @summary The selection rectangles.
     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.columnSelectionModel = new RangeSelectionModel();

    this.setLastSelectionType('');
}

SelectionModel.prototype = {

    constructor: SelectionModel.prototype.constructor,

    /**
     * @type {boolean}
     * @memberOf SelectionModel.prototype
     */
    allRowsSelected: false,

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelection: function() {
        var sels = this.selections;
        var sel = sels[sels.length - 1];
        return sel;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelectionType: function() {
        return this.lastSelectionType;
    },

    /**
     * @param type
     * @memberOf SelectionModel.prototype
     */
    setLastSelectionType: function(type) {
        this.lastSelectionType = type;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @description Select the region described by the given coordinates.
     *
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     */
    select: function(ox, oy, ex, ey) {
        var newSelection = this.grid.newRectangle(ox, oy, ex, ey);
        this.selections.push(newSelection);
        this.flattenedX.push(newSelection.flattenXAt(0));
        this.flattenedY.push(newSelection.flattenYAt(0));
        this.setLastSelectionType('cell');
        this.grid.selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     */
    toggleSelect: function(ox, oy, ex, ey) {

        var selected, index;

        selected = this.selections.find(function(selection, idx) {
            index = idx;
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });

        if (selected) {
            this.selections.splice(index, 1);
            this.flattenedX.splice(index, 1);
            this.flattenedY.splice(index, 1);
            this.grid.selectionChanged();
        } else {
            this.select(ox, oy, ex, ey);
        }
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc Remove the last selection that was created.
     */
    clearMostRecentSelection: function(dontClearRowSelections) {
        dontClearRowSelections = dontClearRowSelections === true;
        if (!dontClearRowSelections) {
            this.setAllRowsSelected(false);
        }
        if (this.selections.length) { --this.selections.length; }
        if (this.flattenedX.length) { --this.flattenedX.length; }
        if (this.flattenedY.length) { --this.flattenedY.length; }
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentColumnSelection: function() {
        this.columnSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentRowSelection: function() {
        this.rowSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearRowSelection: function() {
        this.rowSelectionModel.clear();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelections: function() {
        return this.selections;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean} There are active selection(s).
     */
    hasSelections: function() {
        return this.selections.length !== 0;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasRowSelections: function() {
        return !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasColumnSelections: function() {
        return !this.columnSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @return {boolean} Selection covers a specific column.
     * @param {number} y
     */
    isCellSelectedInRow: function(y) {
        return this._isCellSelected(this.flattenedX, 0, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns Selection covers a specific row.
     * @param {number} x
     */
    isCellSelectedInColumn: function(x) {
        return this._isCellSelected(this.flattenedY, x, 0);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @summary Selection query function.
     * @returns {boolean} The given cell is selected (part of an active selection).
     * @param {Rectangle[]} selections - Selection rectangles to search through.
     * @param {number} x
     * @param {number} y
     */
    isSelected: function(x, y) {
        return (
            this.isColumnSelected(x) ||
            this.isRowSelected(y) ||
            this._isCellSelected(this.selections, x, y)
        );
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isCellSelected: function(x, y) {
        return this._isCellSelected(this.selections, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param selections
     * @param x
     * @param y
     * @returns {boolean}
     * @private
     */
    _isCellSelected: function(selections, x, y) {
        var self = this;
        return !!selections.find(function(selection) {
            return self.rectangleContains(selection, x, y);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc empty out all our state
     *
     */
    clear: function(dontClearRowSelections) {
        dontClearRowSelections = dontClearRowSelections === true;
        this.selections.length = 0;
        this.flattenedX.length = 0;
        this.flattenedY.length = 0;
        this.columnSelectionModel.clear();
        if (!dontClearRowSelections) {
            this.setAllRowsSelected(false);
            this.rowSelectionModel.clear();
        }
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     * @returns {boolean}
     */
    isRectangleSelected: function(ox, oy, ex, ey) {
        return !!this.selections.find(function(selection) {
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @returns {*}
     */
    isColumnSelected: function(x) {
        return this.columnSelectionModel.isSelected(x);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y
     * @returns {boolean|*}
     */
    isRowSelected: function(y) {
        return this.allRowsSelected || this.rowSelectionModel.isSelected(y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    selectColumn: function(x1, x2) {
        this.columnSelectionModel.select(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    selectAllRows: function() {
        this.clear();
        this.setAllRowsSelected(true);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */

    setAllRowsSelected: function(isIt) {
        this.allRowsSelected = isIt;
    },

    areAllRowsSelected: function() {
        return this.allRowsSelected;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    selectRow: function(y1, y2) {
        this.rowSelectionModel.select(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    deselectColumn: function(x1, x2) {
        this.columnSelectionModel.deselect(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    deselectRow: function(y1, y2) {
        this.rowSelectionModel.deselect(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelectedRows: function() {
        if (this.areAllRowsSelected()) {
            var headerRows = this.grid.getHeaderRowCount();
            var rowCount = this.grid.getRowCount() - headerRows;
            var result = new Array(rowCount);
            for (var i = 0; i < rowCount; i++) {
                result[i] = i + headerRows;
            }
            return result;
        }
        return this.rowSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*|Array.Array.number}
     */
    getSelectedColumns: function() {
        return this.columnSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
     isColumnOrRowSelected: function() {
        return !this.columnSelectionModel.isEmpty() || !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {Array}
     */
    getFlattenedYs: function() {
        var result = [];
        var set = {};
        this.selections.forEach(function(selection) {
            var top = selection.origin.y;
            var size = selection.extent.y + 1;
            for (var r = 0; r < size; r++) {
                var ti = r + top;
                if (!set[ti]) {
                    result.push(ti);
                    set[ti] = true;
                }
            }
        });
        result.sort(function(x, y) {
            return x - y;
        });
        return result;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectRowsFromCells: function(offset, dontClearRowSelections) {
        offset = offset || 0;
        dontClearRowSelections = dontClearRowSelections === true;

        var sm = this.rowSelectionModel;

        if (!dontClearRowSelections) {
            this.setAllRowsSelected(false);
            sm.clear();
        }

        this.selections.forEach(function(selection) {
            var top = selection.origin.y,
                extent = selection.extent.y;
            top += offset;
            sm.select(top, top + extent);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectColumnsFromCells: function(offset) {
        offset = offset || 0;

        var sm = this.columnSelectionModel;
        sm.clear();

        this.selections.forEach(function(selection) {
            var left = selection.origin.x,
                extent = selection.extent.x;
            left += offset;
            sm.select(left, left + extent);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isInCurrentSelectionRectangle: function(x, y) {
        var last = this.selections[this.selections.length - 1];
        return last && this.rectangleContains(last, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param rect
     * @param x
     * @param y
     * @returns {boolean}
     */
    rectangleContains: function(rect, x, y) { //TODO: explore why this works and contains on rectanglular does not
        var minX = rect.origin.x;
        var minY = rect.origin.y;
        var maxX = minX + rect.extent.x;
        var maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        var result =
            x >= minX &&
            y >= minY &&
            x <= maxX &&
            y <= maxY;

        return result;
    }
};

module.exports = SelectionModel;

},{"sparse-boolean-array":28}],77:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var Base = require('./Base');


var ANIMATION_TIME = 500,
    TRANSITION = ANIMATION_TIME + 'ms ease-in';

/** @constructor
 * @desc Instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
 *
 * See {@link TableDialog#initialize|initialize} which is called by the constructor.
 */
var TableDialog = Base.extend('TableDialog', {

    initialize: function(grid) {
        this.grid = grid;
        this.initializeOverlaySurface();
        this.openNow = false;
    },

    /**
     * @memberOf Overlay.prototype
     * @desc returns true if the overlay is open
     * @returns {boolean}
     * @param {Hypergrid} grid
     */
    isOpen: function() {
        return this.openNow;
    },

    open: function() {
        if (this.isOpen()) {
            return;
        }

        this.openNow = true;
        var self = this;
        this.overlay.style.backgroundColor = this.grid.resolveProperty('backgroundColor');

        this.overlay.style.top = this.overlay.style.bottom = this.overlay.style.right = this.overlay.style.left = 0;

        self.overlay.style.webkitTransition = '';

        this.overlay.style.margin = '15px 35px 35px 15px';
        this.overlay.style.opacity = 0;
        this.overlay.style.zIndex = 100;

        this.closeTransition = function() {
            this.overlay.style.opacity = 0;
        };

        if (!this._closer) {
            this._closer = function(e) {
                var key = self.getCharFor(e.keyCode).toLowerCase();
                var keys = self.grid.resolveProperty('editorActivationKeys');
                if (keys.indexOf(key) > -1 || e.keyCode === 27) {
                    e.preventDefault();
                    self.close();
                }
            };
        }
        requestAnimationFrame(function() {
            self.overlay.style.webkitTransition = 'opacity ' + ANIMATION_TIME + 'ms ease-in';
            requestAnimationFrame(function() {
                document.addEventListener('keydown', self._closer, false);
                self.overlay.style.opacity = 0.95;
            });
        });

        setTimeout(function() {
            self.overlay.focus();
        }, 100);
    },
    /**
     * @memberOf Overlay.prototype
     * @desc open the overlay
     * #### returns: type
     * @param {Hypergrid} grid
     */
    openFrom: function(rect) {
        if (this.isOpen()) {
            return;
        }
        this.openNow = true;
        var self = this;
        var style = this.overlay.style;
        style.backgroundColor = this.grid.resolveProperty('backgroundColor');

        var bounds = this.grid.div.getBoundingClientRect(),
            margins = rect.y + 'px ' +
                (bounds.width - (rect.x + rect.width)) + 'px ' +
                (bounds.height - (rect.y + rect.height)) + 'px ' +
                rect.x + 'px';

        style.webkitTransition = '';

        style.top = style.right = style.bottom = style.left = 0;

        style.margin = margins;
        style.zIndex = 100;
        style.opacity = 1;

        this.closeTransition = function() {
            style.margin = margins;
        };

        if (!this._closer) {
            this._closer = function(e) {
                var key = self.getCharFor(e.keyCode).toLowerCase();
                var keys = self.grid.resolveProperty('editorActivationKeys');
                if (keys.indexOf(key) > -1 || e.keyCode === 27) {
                    e.preventDefault();
                    self.close();
                }
            };
        }

        //grid.setFocusable(false);
        requestAnimationFrame(function() {
            document.addEventListener('keydown', self._closer, false);
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    style.webkitTransition = 'margin-top ' + TRANSITION + ', margin-right ' + TRANSITION + ', margin-bottom ' + TRANSITION + ', margin-left ' + TRANSITION;
                    style.margin = '15px 35px 35px 15px';
                });
            });
        });
        setTimeout(function() {
            self.overlay.focus();
        }, 100);
    },

    /**
     * @memberOf Overlay.prototype
     * @desc close the overlay
     * @param {Hypergrid} grid
     */
    close: function() {
        //grid.setFocusable(true);
        this.openNow = false;
        document.removeEventListener('keydown', this._closer, false);

        var self = this;

        requestAnimationFrame(function() {
            self.closeTransition();
        });

        setTimeout(function() {
            self.clear();
            self.overlay.style.zIndex = -1000;
            if (self.onClose) {
                self.onClose();
                self.onClose = undefined;
            }
            self.grid.takeFocus();
        }, ANIMATION_TIME);
    },

    /**
     * @memberOf Overlay.prototype
     * @desc initialize the overlay surface into the grid
     * #### returns: type
     * @param {Hypergrid} grid
     */
    initializeOverlaySurface: function() {
        this.overlay = document.createElement('div');
        this.overlay.setAttribute('tabindex', 0);
        this.overlay.addEventListener('wheel', function(evt) { evt.stopPropagation(); });

        var style = this.overlay.style;
        style.outline = 'none';
        style.boxShadow = '0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22)';
        style.position = 'absolute';

        style.margin = 0;
        style.overflow = 'hidden';

        //style.display = 'none';

        //style.webkitTransition = 'margin-top ' + TRANSITION + ', margin-right ' + TRANSITION + ', margin-bottom ' + TRANSITION + ', margin-left ' + TRANSITION;

        style.opacity = 0;
        style.zIndex = 10;
        this.grid.div.appendChild(this.overlay);
        //document.body.appendChild(this.overlay);
    },

    /**
     * @memberOf Overlay.prototype
     * @desc get a human readable description of the key pressed from it's integer representation
     * @returns {string}
     * @param {Hypergrid} grid
     * @param {number} integer - the integer we want the char for
     */
    getCharFor: function(integer) {
        var charMap = this.grid.getCanvas().getCharMap();
        return charMap[integer][0];
    },

    clear: function() {
        this.overlay.innerHTML = '';
    },

    querySelector: function(selector) {
        var elements = this.overlay.querySelector(selector);
        return elements;
    },

    getAnimationTime: function() {
        return ANIMATION_TIME;
    }
});

module.exports = TableDialog;

},{"./Base":69}],78:[function(require,module,exports){
'use strict';

// console.warn polyfill as needed
// used for deprecation warnings
if (!console.warn) {
    console.warn = function() {
        console.log.apply(console, ['WARNING:'].concat(Array.prototype.slice.call(arguments)));
    };
}

var deprecated = function(dotProps, options) {
    var chain = dotProps.split('.'),
        method = chain[chain.length - 1],
        asOfVersion = options && options.asOfVersion,
        result = this,
        warning;

    method = 'get' + method[0].toUpperCase() + method.substr(1);

    warning = '.' + method + '() method is deprecated';

    if (asOfVersion) {
        warning += ' as of v' + options.asOfVersion;
    }

    warning += '. Use .' + dotProps;

    if (dotProps[dotProps.length - 1] !== ')') {
        warning += ' property';
    }

    warning += ' instead. (Will be removed in a future release.)';

    console.warn(warning);

    chain.forEach(function(link) {
        result = result[link];
    });

    return result;
};

module.exports = deprecated;

},{}],79:[function(require,module,exports){
'use strict';

Math.sign = Math.sign || function(x) {
    x = +x; // convert to a number
    if (x === 0 || isNaN(x)) {
        return x;
    }
    return x > 0 ? 1 : -1;
};

},{}],80:[function(require,module,exports){
'use strict';

var images = require('../../images');

/**
 * @summary Writes error message into cell.
 *
 * @desc This funciton is guaranteed to be called as follows:
 *
 * ```javascript
 * gc.save();
 * gc.beginPath();
 * gc.rect(x, y, width, height);
 * gc.clip();
 * renderCellError(gc, message, x, y, width, height);
 * gc.restore();
 * ```
 *
 * Before doing anything else, this function should clear the cell by setting `gc.fillStyle` and calling `gc.fill()`.
 *
 * @param {CanvasRenderingContext2D} gc
 * @param {string} message
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 */
function renderCellError(gc, message, x, y, width, height) {

    // clear the cell
    // (this makes use of the rect path defined by the caller)
    gc.fillStyle = '#FFD500';
    gc.fill();

    // render cell border
    gc.strokeStyle = gc.createPattern(images.caution, 'repeat');
    gc.lineWidth = 5;
    gc.beginPath();
    gc.moveTo(x, y); // caution: do not use rect() here because Chrome does not clip its stroke properly
    gc.lineTo(x + width, y);
    gc.lineTo(x + width, y + height);
    gc.lineTo(x, y + height);
    gc.lineTo(x, y);
    gc.stroke();

    // adjust clip region to prevent text from rendering over right border should it overflow
    gc.beginPath();
    gc.rect(x, y, width - 2, height);
    gc.clip();

    // render message text
    gc.fillStyle = '#A00';
    gc.textAlign = 'start';
    gc.textBaseline = 'middle';
    gc.font = 'bold 6pt "arial narrow", verdana, geneva';
    gc.fillText(message, x + 4, y + height / 2 + 0.5);

}

module.exports = renderCellError;

},{"../../images":3}],81:[function(require,module,exports){
'use strict';

var Base = require('../../lib/Base');

/**
 * See {@link DataBaseNode#initialize|initialize()} method for parameters.
 * @constructor
 */
var DataNodeBase = Base.extend('DataNodeBase', {

    isNullObject: false,

    INDENT: '   ', // 3 spaces

    /**
     * @memberOf DataNodeBase.prototype
     * @param {string} key
     */
    initialize: function(key) {
        /**
         * @memberOf DataNodeBase.prototype
         * @type {string}
         */

        this.label = key;

        /**
         * @memberOf DataNodeBase.prototype
         * @type {string[]}
         * @default false
         */
        this.data = ['']; // TODO: Why is this first element needed?

        /**
         * @memberOf DataNodeBase.prototype
         * @type {number[]}
         * @default ['']
         */
        this.index = []; // TODO: formerly rowIndex

        /**
         * @memberOf DataNodeBase.prototype
         * @type {boolean}
         * @default false
         */
        this.hasChildren = false; // TODO: Where/how is this used?

        /**
         * @memberOf DataNodeBase.prototype
         * @type {number}
         * @default 0
         */
        this.depth = 0;

        /**
         * @memberOf DataNodeBase.prototype
         * @type {number}
         * @default 1
         */
        this.height = 1;

        /**
         * @memberOf DataNodeBase.prototype
         * @type {boolean}
         * @default false
         */
        this.expanded = false;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param x
     * @returns {*}
     */
    getValue: function(x) {
        return this.data[x];
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {string}
     */
    computeDepthString: function() {
        return Array(this.depth + 1).join(this.INDENT) + '  ' + this.label;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {number}
     */
    computeHeight: function() {
        return 1;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {Array}
     */
    getIndex: function() { // TODO: formerly getAllRowIndexes
        return this.index;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param aggregator
     */
    computeAggregates: function(aggregator) {
        var index = this.getIndex();

        if (index.length) {
            var groupsOffset = Number(aggregator.hasGroups());

            // redimension the data
            var data = this.data;
            data.length = groupsOffset + aggregator.aggregates.length;

            var sorter = aggregator.sorterInstance;
            sorter.index = index;

            aggregator.aggregates.forEach(function(aggregate, i) {
                data[groupsOffset + i] = aggregate(sorter);
            });
        }
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param aggregator
     */
    buildView: function(aggregator) {
        aggregator.addView(this);
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     */
    toggleExpansionState: function() { /* aggregator */
        //do nothing by default
    }

});

//DataNodeBase.prototype.applyAggregates = DataNodeBase.prototype.computeAggregates;

module.exports = DataNodeBase;

},{"../../lib/Base":69}],82:[function(require,module,exports){
'use strict';

var Map = require('./util/Mappy');
var DataNodeBase = require('./DataNodeBase');

var expandedMap = {
    true: '\u25bc', // BLACK DOWN-POINTING TRIANGLE aka '▼'
    false: '\u25b6' // BLACK RIGHT-POINTING TRIANGLE aka '▶'
};

/**
 * > See {@link DataNodeGroup#initialize|initialize()} method for constructor parameters.
 * @constructor
 * @extends DataNodeBase
 */
var DataNodeGroup = DataNodeBase.extend('DataNodeGroup', {

    extendable: true,

    /**
     * @memberOf DataNodeGroup.prototype
     * @param key
     */
    initialize: function(key) {
        this.children = new Map();
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.children = this.children.values;
        this.children.forEach(function(child) {
            child.toArray(depth + 1);
        });
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {string}
     */
    computeDepthString: function() {
        return Array(this.depth + 1).join(this.INDENT) +
            expandedMap[this.expanded] + ' ' +
            this.label;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {*}
     */
    getIndex: function() {
        if (this.index.length === 0) {
            this.index = this.computeIndex();
        }
        return this.index;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {Array}
     */
    computeIndex: function() { // TODO: formerly computeAllRowIndexes
        var result = [];
        result.append = append;
        this.children.forEach(function(child) {
            result.append(child.getIndex());
        });
        return result;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param aggregator
     */
    toggleExpansionState: function(aggregator) { /* aggregator */
        this.expanded = !this.expanded;
        this.data[0] = this.computeDepthString();
        if (this.expanded) {
            this.computeAggregates(aggregator);
        }
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param aggregator
     */
    computeAggregates: function(aggregator) {
        DataNodeBase.prototype.computeAggregates.call(this, aggregator); // call base class's version
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.computeAggregates(aggregator);
            });
        }
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param aggregator
     */
    buildView: function(aggregator) {
        aggregator.view.push(this);
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.buildView(aggregator);
            });
        }
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {number}
     */
    computeHeight: function() {
        var height = 1;

        if (this.expanded) {
            this.children.forEach(function(child) {
                height = height + child.computeHeight();
            });
        }

        return (this.height = height);
    }

});

/**
 * @private
 * @summary Array mixin to append another array to end of `this` one.
 * @desc Appends in place, unlike `this.concat()` which creates a new array.
 * Uses less memory than concat, important when `appendix` is huge.
 * > CAUTION: Mutates `this` array!
 * @param {Array} appendix
 * @returns {Array} Reference to `this` (for convenience)
 */
function append(appendix) {
    this.splice.bind(this, this.length, 0).apply(this, appendix);
    return this;
}

module.exports = DataNodeGroup;

},{"./DataNodeBase":81,"./util/Mappy":92}],83:[function(require,module,exports){
'use strict';

var DataNodeBase = require('./DataNodeBase');

/**
 * @constructor
 * @extends DataNodeBase
 */
var DataNodeLeaf = DataNodeBase.extend('DataNodeLeaf', {

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {numer[]}
     */
    getIndex: function() {
        return this.index;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param aggregator
     */
    buildView: function(aggregator) {
        aggregator.addView(this);
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {number}
     */
    computeHeight: function() {
        return 1;
    }

});

module.exports = DataNodeLeaf;

},{"./DataNodeBase":81}],84:[function(require,module,exports){
'use strict';

var DataNodeGroup = require('./DataNodeGroup');

/**
 * See {@link DataNodeGroup#initialize|initialize()} method for parameters.
 * @constructor
 * @extends DataNodeGroup
 */
var DataNodeTree = DataNodeGroup.extend('DataNodeTree', {

    /**
     * @memberOf DataNodeGroup.prototype
     * @param {string} key
     */
    initialize: function(key) {
        this.height = 0;
        this.expanded = true;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     */
    toArray: function() {
        this.children = this.children.values;
        this.children.forEach(function(child) {
            child.toArray(0);
        });
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param aggregator
     */
    buildView: function(aggregator) {
        this.children.forEach(function(child) {
            child.buildView(aggregator);
        });
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {number}
     */
    computeHeight: function() {
        var height = 1;

        this.children.forEach(function(child) {
            height = height + child.computeHeight();
        });

        return (this.height = height);
    }

});

module.exports = DataNodeTree;

},{"./DataNodeGroup":82}],85:[function(require,module,exports){
'use strict';

var headerify = require('./util/headerify');

/**
 * @constructor
 * @param {object[]} data
 * @param {string[]} fields
 */
function DataSource(data, fields) {
    /**
     * @type {string[]}
     */
    this.fields = fields || computeFieldNames(data[0]);

    /**
     * @type {object[]}
     */
    this.data = data;
}

DataSource.prototype = {
    constructor: DataSource.prototype.constructor, // preserve constructor

    isNullObject: false,

    /**
     * @memberOf DataSource.prototype
     * @param y
     * @returns {object[]}
     */
    getRow: function(y) {
        return this.data[y];
    },

    /**
     * @memberOf DataSource.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        var row = this.getRow(y);
        if (!row) {
            return null;
        }
        return row[this.fields[x]];
    },

    /**
     * @memberOf DataSource.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        this.getRow(y)[this.fields[x]] = value;
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {number}
     */
    getRowCount: function() {
        return this.data.length;
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {number}
     */
    getColumnCount: function() {
        return this.getFields().length;
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {number[]}
     */
    getFields: function() {
        return this.fields;
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {string[]}
     */
    getHeaders: function() {
        return (
            this.headers = this.headers || this.getDefaultHeaders().map(function(each) {
                return headerify(each);
            })
        );
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {string[]}
     */
    getDefaultHeaders: function() {
        return this.getFields();
    },

    /**
     * @memberOf DataSource.prototype
     * @param {string[]} fields
     */
    setFields: function(fields) {
        this.fields = fields;
    },

    /**
     * @memberOf DataSource.prototype
     * @param {string[]} headers
     */
    setHeaders: function(headers) {
        if (!(headers instanceof Array)) {
            error('setHeaders', 'param #1 `headers` not array');
        }
        this.headers = headers;
    },

    /**
     * @memberOf DataSource.prototype
     */
    getGrandTotals: function() {
        //nothing here
    },

    /**
     * @memberOf DataSource.prototype
     * @param arrayOfUniformObjects
     */
    setData: function(arrayOfUniformObjects) {
        this.data = arrayOfUniformObjects;
    }
};

function error(methodName, message) {
    throw new Error('DataSource.' + methodName + ': ' + message);
}

/**
 * @private
 * @param {object} object
 * @returns {string[]}
 */
function computeFieldNames(object) {
    return Object.getOwnPropertyNames(object || []).filter(function(e) {
        return e.substr(0, 2) !== '__';
    });
}

module.exports = DataSource;

},{"./util/headerify":94}],86:[function(require,module,exports){
'use strict';

var DataSourceSorter = require('./DataSourceSorter');
var DataNodeTree = require('./DataNodeTree');
var DataNodeGroup = require('./DataNodeGroup');
var DataNodeLeaf = require('./DataNodeLeaf');
var headerify = require('./util/headerify');

/**
 * @constructor
 * @param {DataSource} dataSource
 */
function DataSourceAggregator(dataSource) {

    /**
     * @memberOf DataSourceAggregator.prototype
     * @type {DataSource}
     */
    this.dataSource = dataSource;

    /**
     * @memberOf DataSourceAggregator.prototype
     * @type {DataNodeTree}
     */
    this.tree = new DataNodeTree('Totals');

    /**
     * @memberOf DataSourceAggregator.prototype
     * @type {number[]}
     * @default []
     */
    this.index = [];

    /**
     * @memberOf DataSourceAggregator.prototype
     * @type {Array}
     * @default []
     */
    this.aggregates = [];

    /**
     * @memberOf DataSourceAggregator.prototype
     * @type {string[]}
     * @default []
     */
    this.headers = [];

    /**
     * @memberOf DataSourceAggregator.prototype
     * @type {Array}
     * @default []
     */
    this.groupBys = [];

    /**
     * @memberOf DataSourceAggregator.prototype
     * @type {Array}
     * @default []
     */
    this.view = [];

    /**
     * @memberOf DataSourceAggregator.prototype
     * @type {object}
     * @default {}
     */
    this.sorterInstance = {};

    /**
     * @memberOf DataSourceAggregator.prototype
     * @type {boolean}
     * @default true
     */
    this.presortGroups = true;

    /**
     * @memberOf DataSourceAggregator.prototype
     * @type {object}
     * @default {}
     */
    this.lastAggregate = {};

    this.setAggregates({});
}

DataSourceAggregator.prototype = {
    constructor: DataSourceAggregator.prototype.constructor, // preserve constructor

    isNullObject: false,

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param aggregations
     */
    setAggregates: function(aggregations) {
        this.lastAggregate = aggregations;
        this.clearAggregations();
        this.headers.length = 0;

        if (this.hasGroups()) {
            this.headers.push('Tree');
        }

        for (var key in aggregations) {
            this.addAggregate(key, aggregations[key]);
        }
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param label
     * @param func
     */
    addAggregate: function(label, func) {
        this.headers.push(headerify(label));
        this.aggregates.push(func);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param columnIndexArray
     */
    setGroupBys: function(columnIndexArray) {
        var groupBys = this.groupBys;
        groupBys.length = 0;
        columnIndexArray.forEach(function(columnIndex) {
            groupBys.push(columnIndex);
        });
        this.setAggregates(this.lastAggregate);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param index
     */
    addGroupBy: function(index) {
        this.groupBys.push(index);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {boolean}
     */
    hasGroups: function() {
        return !!this.groupBys.length;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {boolean}
     */
    hasAggregates: function() {
        return !!this.aggregates.length;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    apply: function() {
        this.buildGroupTree();
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    clearGroups: function() {
        this.groupBys.length = 0;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    clearAggregations: function() {
        this.aggregates.length = 0;
        this.headers.length = 0;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    buildGroupTree: function() {
        var groupBys = this.groupBys,
            leafDepth = groupBys.length - 1,
            source = this.dataSource,
            rowCount = source.getRowCount(),
            tree = this.tree = new DataNodeTree('Totals');

        // first sort data
        if (this.presortGroups) {
            groupBys.reverse().forEach(function(groupBy) {
                source = new DataSourceSorter(source);
                source.sortOn(groupBy);
            });
        }

        for (var r = 0; r < rowCount; r++) {
            var path = tree;

            groupBys.forEach(function(g, c) { // eslint-disable-line no-loop-func
                var key = source.getValue(g, r),
                    factoryDataNode = (c === leafDepth) ? factoryDataNodeLeaf : factoryDataNodeGroup;
                path = path.children.getIfUndefined(key, factoryDataNode);
            });

            path.index.push(r);
        }

        this.sorterInstance = new DataSourceSorter(source);
        tree.toArray();
        tree.computeAggregates(this);
        this.buildView();
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param dataNode
     */
    addView: function(dataNode) {
        this.view.push(dataNode);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    buildView: function() {
        this.view.length = 0;
        this.tree.computeHeight();
        this.tree.buildView(this);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {*|boolean}
     */
    viewMakesSense: function() {
        return this.hasAggregates();
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getValue(x, y);
        }

        var row = this.view[y];

        return row ? row.getValue(x) : null; // TODO: what kind of object is row... ? should it be unfiltred?
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param x
     * @param y
     * @param value
     * @returns {*}
     */
    setValue: function(x, y, value) {
        if (!this.viewMakesSense()) {
            return this.dataSource.setValue(x, y, value);
        }
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {*}
     */
    getColumnCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getColumnCount();
        }
        return this.getHeaders().length;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {*}
     */
    getRowCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRowCount();
        }
        return this.view.length; //header column
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param y
     */
    click: function(y) {
        var group = this.view[y];
        group.toggleExpansionState(this);
        this.buildView();
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {*}
     */
    getHeaders: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getHeaders();
        }
        return this.headers; // TODO: Views override dataSource headers with their own headers?
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param headers
     */
    setHeaders: function(headers) {
        this.dataSource.setHeaders(headers);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {*|number[]}
     */
    getFields: function() {
        return this.dataSource.getFields();
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param fields
     * @returns {*}
     */
    setFields: function(fields) {
        return this.dataSource.setFields(fields);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {object[]}
     */
    getGrandTotals: function() {
        var view = this.tree;
        return [view.data];
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param y
     * @returns {*}
     */
    getRow: function(y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRow(y);
        }

        var rollups = this.view[y];

        return rollups ? rollups : this.tree;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param arrayOfUniformObjects
     */
    setData: function(arrayOfUniformObjects) {
        this.dataSource.setData(arrayOfUniformObjects);
        this.apply();
    }
};

function factoryDataNodeLeaf(key) {
    return new DataNodeLeaf(key);
}

function factoryDataNodeGroup(key) {
    return new DataNodeGroup(key);
}

module.exports = DataSourceAggregator;

},{"./DataNodeGroup":82,"./DataNodeLeaf":83,"./DataNodeTree":84,"./DataSourceSorter":89,"./util/headerify":94}],87:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

/**
 * @typedef {function} filterFunction
 * @param cellValue
 * @param {object} rowObject - Reference to `this.dataSource.data[r]`.
 * @param {number} r - Row number (index within `this.dataSource.data`).
 */

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceGlobalFilter = DataSourceIndexed.extend('DataSourceGlobalFilter', {

    /**
     *
     * @memberOf DataSourceGlobalFilter.prototype
     * @param filter
     */
    set: function(filter) {
        /**
         * @type {filterFunction}
         * @memberOf DataSourceGlobalFilter.prototype
         */
        this.filter = filter;
    },

    get: function(filter) {
        return this.filter;
    },

    /**
     *
     * @memberOf DataSourceGlobalFilter.prototype
     */
    clear: function() {
        delete this.filter;
        this.clearIndex();
    },

    /**
     *
     * @memberOf DataSourceGlobalFilter.prototype
     */
    apply: function() {
        if (!this.filter) {
            this.clearIndex();
        } else {
            this.buildIndex(function applyFilter(r, rowObject) {
                return this.filter.test(rowObject);
            });
        }
    },

    /**
     *
     * @memberOf DataSourceGlobalFilter.prototype
     * @returns {number}
     */
    getRowCount: function() {
        return this.filter ? this.index.length : this.dataSource.getRowCount();
    }
});

module.exports = DataSourceGlobalFilter;

},{"./DataSourceIndexed":88}],88:[function(require,module,exports){
'use strict';

var Base = require('../../lib/Base');

/**
 * @constructor
 */
var DataSourceIndexed = Base.extend('DataSourceIndexed', {

    /**
     *
     */
    isNullObject: false,

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param dataSource
     */
    initialize: function(dataSource) {
        this.dataSource = dataSource;
        this.index = [];
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param y
     * @returns {*}
     */
    transposeY: function(y) {
        return this.index.length ? this.index[y] : y;
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param y
     * @returns {object}
     */
    getRow: function(y) {
        return this.dataSource.getRow(this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param x
     * @param y
     * @returns {*|Mixed}
     */
    getValue: function(x, y) {
        return this.dataSource.getValue(x, this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param {number} x
     * @param {number} y
     * @param {*} value
     */
    setValue: function(x, y, value) {
        this.dataSource.setValue(x, this.transposeY(y), value);
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @returns {Number|*}
     */
    getRowCount: function() {
        return this.index.length || this.dataSource.getRowCount();
    },

    /**
     *
     * @returns {*}
     */
    getColumnCount: function() {
        return this.dataSource.getColumnCount();
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @returns {*}
     */
    getFields: function() {
        return this.dataSource.getFields();
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param fields
     * @returns {*}
     */
    setFields: function(fields) {
        return this.dataSource.setFields(fields);
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param {string[]} headers
     * @returns {string[]}
     */
    setHeaders: function(headers) {
        return this.dataSource.setHeaders(headers);
    },

    /**
     *
     * @returns {string[]}
     */
    getHeaders: function() {
        return this.dataSource.getHeaders();
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @returns {*}
     */
    getGrandTotals: function() {
        return this.dataSource.getGrandTotals();
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param {object[]} arrayOfUniformObjects
     * @returns {object[]}
     */
    setData: function(arrayOfUniformObjects) {
        return this.dataSource.setData(arrayOfUniformObjects);
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     */
    clearIndex: function() {
        this.index.length = 0;
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param {filterPredicate} predicate
     * @returns {number[]}
     */
    buildIndex: function(predicate) {
        var rowCount = this.dataSource.getRowCount(),
            index = this.index;

        this.clearIndex();

        for (var r = 0; r < rowCount; r++) {
            if (!predicate || predicate.call(this, r, this.dataSource.getRow(r))) {
                index.push(r);
            }
        }

        return index;
    }

});

/** @typedef {function} filterPredicate
 * @summary Applies filter to given row.
 * @param {nubmer} r - Row index of row data within rows array `this.dataSource.data[]`.
 * @param {object} rowObject - Row data; element of `this.dataSource.data[]`.
 * @returns {boolean} Row qualifies (passes through filter).
 */

module.exports = DataSourceIndexed;

},{"../../lib/Base":69}],89:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var stableSort = require('./util/stableSort');

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceSorter = DataSourceIndexed.extend('DataSourceSorter', {

    /**
     * @memberOf DataSourceSorter.prototype
     */
    initialize: function() {
        /**
         * @memberOf DataSourceSorter.prototype
         * @type {boolean}
         */
        this.descendingSort = false; // TODO: this does not seem to be in use
    },

    /**
     * @memberOf DataSourceSorter.prototype
     * @param {number} colIdx
     * @param {number} [direction=1]
     */
    sortOn: function(colIdx, direction) {
        switch (direction) {
            case 0:
                this.clearIndex();
                break;

            case undefined:
            case 1:
            case -1:
                var self = this; // for use in getValue
                stableSort.sort(this.buildIndex(), getValue, direction);
                break;
        }

        function getValue(rowIdx) {
            return valOrFuncCall(self.dataSource.getValue(colIdx, rowIdx));
        }
    }
});

/**
 * @private
 * @param {*|function} valOrFunc
 * @returns {*}
 */
function valOrFuncCall(valOrFunc) {
    return typeof valOrFunc === 'function' ? valOrFunc() : valOrFunc;
}

module.exports = DataSourceSorter;

},{"./DataSourceIndexed":88,"./util/stableSort":95}],90:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var DataSourceSorter = require('./DataSourceSorter');

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceSorterComposite = DataSourceIndexed.extend('DataSourceSorterComposite', {

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    initialize: function() {
        /**
         * Caveats:
         *
         * 1. Columns should be uniquely represented (i.e., no repeats with same columnIndex)
         * 2. Columns should be added low- to high-order (i.e., most grouped columns come last)
         *
         * @type {number[]}
         * @memberOf DataSourceSorterComposite.prototype
         */
        this.sorts = [];

        /**
         * @type {DataSource}
         * @memberOf DataSourceSorterComposite.prototype
         */
        this.last = this.dataSource;
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param {number} y
     * @returns {Object}
     */
    getRow: function(y) {
        return this.last.getRow(y);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param columnIndex
     * @param direction
     */
    sortOn: function(columnIndex, direction) {
        this.sorts.push([columnIndex, direction]);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    applySorts: function() {
        var each = this.dataSource;

        this.sorts.forEach(function(sort) {
            each = new DataSourceSorter(each);
            each.sortOn.apply(each, sort);
        });

        this.last = each;
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    clearSorts: function() {
        this.sorts.length = 0;
        this.last = this.dataSource;
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param {number} x
     * @param {number} y
     * @returns {*}
     */
    getValue: function(x, y) {
        return this.last.getValue(x, y);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param {number} x
     * @param {number} y
     * @param {*} value
     */
    setValue: function(x, y, value) {
        this.last.setValue(x, y, value);
    }
});

module.exports = DataSourceSorterComposite;

},{"./DataSourceIndexed":88,"./DataSourceSorter":89}],91:[function(require,module,exports){
'use strict';

module.exports = {
    JSDataSource: require('./DataSource'),
    DataSourceSorter: require('./DataSourceSorter'),
    DataSourceSorterComposite: require('./DataSourceSorterComposite'),
    DataSourceGlobalFilter: require('./DataSourceGlobalFilter'),
    DataSourceAggregator: require('./DataSourceAggregator'),
    util: {
        aggregations: require('./util/aggregations')
    }
};

},{"./DataSource":85,"./DataSourceAggregator":86,"./DataSourceGlobalFilter":87,"./DataSourceSorter":89,"./DataSourceSorterComposite":90,"./util/aggregations":93}],92:[function(require,module,exports){
'use strict';

/**
 * @constructor
 */
function Mappy() {
    this.keys = [];
    this.data = {};
    this.values = [];
}

Mappy.prototype = {

    constructor: Mappy.prototype.constructor, // preserve constructor

    /**
     * @memberOf Mappy.prototype
     * @param key
     * @param value
     */
    set: function(key, value) {
        var hashCode = hash(key);
        if (!(hashCode in this.data)) {
            this.keys.push(key);
            this.values.push(value);
        }
        this.data[hashCode] = value;
    },

    /**
     * @memberOf Mappy.prototype
     * @param key
     * @returns {*}
     */
    get: function(key) {
        var hashCode = hash(key);
        return this.data[hashCode];
    },

    /**
     *
     * @memberOf Mappy.prototype
     * @param key
     * @param {function} ifUndefinedFunc - Value getter when value is otherwise undefined.
     * @returns {*}
     */
    getIfUndefined: function(key, ifUndefinedFunc) {
        var value = this.get(key);
        if (value === undefined) {
            value = ifUndefinedFunc(key);
            this.set(key, value);
        }
        return value;
    },

    size: function() {
        return this.keys.length;
    },

    /**
     * @memberOf Mappy.prototype
     */
    clear: function() {
        this.keys.length = 0;
        this.values.length = 0;
        this.data = {};
    },

    /**
     * @memberOf Mappy.prototype
     * @param key
     */
    delete: function(key) {
        var hashCode = hash(key);
        if (this.data[hashCode] !== undefined) {
            var index = betterIndexOf(this.keys, key);
            this.keys.splice(index, 1);
            this.values.splice(index, 1);
            delete this.data[hashCode];
        }
    },

    /**
     * @memberOf Mappy.prototype
     * @param {function} iteratee
     */
    forEach: function(iteratee) {
        if (typeof iteratee === 'function') {
            var keys = this.keys,
                self = this;
            keys.forEach(function(key) {
                var value = self.get(key);
                iteratee(value, key, self);
            });
        }
    },

    /**
     * @memberOf Mappy.prototype
     * @param {function} iteratee
     * @returns {Mappy}
     */
    map: function(iteratee) {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;

        if (!(typeof iteratee === 'function')) {
            iteratee = reflection;
        }

        keys.forEach(function(key) {
            var value = self.get(key),
                transformed = iteratee(value, key, self);
            newMap.set(key, transformed);
        });
        return newMap;
    },

    /**
     * @memberOf Mappy.prototype
     * @returns {Mappy}
     */
    copy: function() {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;
        keys.forEach(function(key) {
            var value = self.get(key);
            newMap.set(key, value);
        });
        return newMap;
    }

};

var OID_PREFIX = '.~.#%_'; //this should be something we never will see at the beginning of a string
var counter = 0;

function hash(key) {
    var typeOf = typeof key;

    switch (typeOf) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'symbol':
            return OID_PREFIX + typeOf + '_' + key;

        case 'undefined':
            return 'UNDEFINED';

        case 'object':
            if (key === null) {
                return 'NULL';
            }
            // fall through when not null:
        case 'function':
            return (key.___finhash = key.___finhash || OID_PREFIX + counter++); // eslint-disable-line no-underscore-dangle
    }
}

// Object.is polyfill, courtesy of @WebReflection
var is = Object.is || function(a, b) {
    return a === b ? a !== 0 || 1 / a == 1 / b : a != a && b != b; // eslint-disable-line eqeqeq
};

function reflection(val) {
    return val;
}

// More reliable indexOf, courtesy of @WebReflection
function betterIndexOf(arr, value) {
    if (value != value || value === 0) { // eslint-disable-line eqeqeq
        var i = arr.length;
        while (i-- && !is(arr[i], value)) {
            // eslint-disable-line no-empty
        }
    } else {
        i = [].indexOf.call(arr, value);
    }
    return i;
}

module.exports = Mappy;

},{}],93:[function(require,module,exports){
'use strict';

/**
 * @module aggregations
 */

/**
 * @typedef {function} aggregationFunction
 * @summary A bound function.
 * @desc An aggregation function bound to the `columnIndex` value supplied to one of the above factory functions.
 * @param {object} group
 * @returns {*} Aggregated value.
 */

module.exports = {
    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    count: function(columnIndex) {
        return count;
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    sum: function(columnIndex) {
        return sum.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    min: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.min, Infinity);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    max: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.max, -Infinity);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    avg: function(columnIndex) {
        return avg.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    first: function(columnIndex) {
        return first.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    last: function(columnIndex) {
        return last.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    stddev: function(columnIndex) {
        return stddev.bind(this, columnIndex);
    }
};

function count(group) {
    return group.getRowCount();
}

function sum(columnIndex, group) {
    var r = group.getRowCount(),
        n = 0;

    while (r--) {
        n += group.getValue(columnIndex, r);
    }

    return n;
}

function minmax(columnIndex, method, n, group) {
    var r = group.getRowCount();

    while (r--) {
        n = method(n, group.getValue(columnIndex, r));
    }

    return n;
}

function avg(columnIndex, group) {
    return sum(columnIndex, group) / group.getRowCount();
}

function first(columnIndex, group) {
    return group.getValue(columnIndex, 0);
}

function last(columnIndex, group) {
    return group.getValue(columnIndex, group.getRowCount() - 1);
}

function stddev(columnIndex, group) {
    var rows = group.getRowCount(),
        mean = avg(columnIndex, group);

    for (var dev, r = rows, variance = 0; r--; variance += dev * dev) {
        dev = group.getValue(columnIndex, r) - mean;
    }

    return Math.sqrt(variance / rows);
}

},{}],94:[function(require,module,exports){
'use strict';

function headerify(string) {
    return (/[a-z]/.test(string) ? string : string.toLowerCase())
        .replace(/[\s\-_]*([^\s\-_])([^\s\-_]+)/g, replacer)
        .replace(/[A-Z]/g, ' $&')
        .trim();
}

function replacer(a, b, c) {
    return b.toUpperCase() + c;
}

module.exports = headerify;
},{}],95:[function(require,module,exports){
'use strict';

/**
 * Note that {@link module:stableSort#sort|sort()} is the only exposed method.
 * @module stableSort
 */

/**
 * @private
 * @instance
 * @param {function} comparator
 * @param {boolean} descending
 * @param {Array} arr1
 * @param {Array} arr2
 * @returns {function}
 */
function stabilize(comparator, descending, arr1, arr2) { // eslint-disable-line no-shadow
    var x = arr1[0];
    var y = arr2[0];

    if (x === y) {
        x = descending ? arr2[1] : arr1[1];
        y = descending ? arr1[1] : arr2[1];
    } else {
        if (y === null) {
            return -1;
        }
        if (x === null) {
            return 1;
        }
    }

    return comparator(x, y);
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function ascendingNumbers(x, y) {
    return x - y;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function descendingNumbers(x, y) {
    return y - x;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function ascendingAllOthers(x, y) {
    return x < y ? -1 : 1;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function descendingAllOthers(x, y) {
    return y < x ? -1 : 1;
}

/**
 * @private
 * @instance
 * @param typeOfData
 * @returns {function(this:ascending)}
 */
function ascending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? ascendingNumbers : ascendingAllOthers, false);
}

/**
 * @private
 * @instance
 * @param typeOfData
 * @returns {function(this:descending)}
 */
function descending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? descendingNumbers : descendingAllOthers, true);
}

/**
 * @instance
 * @param {number} index
 * @param {function} getValue
 * @param {number} [direction=1]
 */
function sort(index, getValue, direction) {

    var compare, i;

    // apply defaults
    if (direction === undefined) {
        direction = 1;
    }

    if (index.length) { // something to do
        switch (direction) {
            case 0:
                return; // bail: nothing to sort

            case undefined: // eslint-disable-line no-fallthrough
                direction = 1;
            case 1:
                compare = ascending(typeof getValue(0));
                break;

            case -1:
                compare = descending(typeof getValue(0));
                break;
        }

        // set up the sort.....
        var tmp = new Array(index.length);

        // add the index for "stability"
        for (i = 0; i < index.length; i++) {
            tmp[i] = [getValue(i), i];
        }

        // do the actual sort
        tmp.sort(compare);

        // copy the sorted values into our index vector
        for (i = 0; i < index.length; i++) {
            index[i] = tmp[i][1];
        }
    }

}

exports.sort = sort;

},{}]},{},[51])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL2Nzcy9zdHlsZXNoZWV0cy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9pbWFnZXMvaW1hZ2VzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL2ltYWdlcy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvY3NzLWluamVjdG9yL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9leHRlbmQtbWUvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbHRlci10cmVlL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maWx0ZXItdHJlZS9qcy9GaWx0ZXJMZWFmLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maWx0ZXItdHJlZS9qcy9GaWx0ZXJOb2RlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maWx0ZXItdHJlZS9qcy9GaWx0ZXJUcmVlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maWx0ZXItdHJlZS9qcy9jb25kaXRpb25hbHMuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbHRlci10cmVlL2pzL2NvcHktaW5wdXQuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbHRlci10cmVlL2pzL2Nzcy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvanMvc3FsLXdoZXJlLXBhcnNlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maWx0ZXItdHJlZS9qcy90ZW1wbGF0ZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvanMvdHJlZS1vcGVyYXRvcnMuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbmJhcnMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbmNhbnZhcy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmluY2FudmFzL2pzL0dyYXBoaWNzQ29udGV4dC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmluY2FudmFzL2pzL2djLWNvbnNvbGUtbG9nZ2VyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5jYW52YXMvanMvcG9seW1lcmdlc3R1cmVzLmRldi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvbGlzdC1kcmFnb24vaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9saWIvbHJ1LWNhY2hlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9tdXN0YWNoZS9tdXN0YWNoZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvb2JqZWN0LWl0ZXJhdG9ycy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvcG9wLW1lbnUvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL3JlY3Rhbmd1bGFyL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9yZWdleHAtbGlrZS9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvc3BhcnNlLWJvb2xlYW4tYXJyYXkvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL3RlbXBsZXgvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL3Vuc3RydW5naWZ5L2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9IeXBlcmdyaWQuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9CZWhhdmlvci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL0NvbHVtbi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL0pTT04uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9Mb2NhbC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL051bGwuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvQ2VsbEVkaXRvci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvQ2hvaWNlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9Db2xvci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvRGF0ZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvRmlsdGVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9TaW1wbGUuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL1NsaWRlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvU3Bpbm5lci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvVGV4dGZpZWxkLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvZGF0YU1vZGVscy9EYXRhTW9kZWwuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2RhdGFNb2RlbHMvSlNPTi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvZGVmYXVsdHMuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2Zha2VfOWY5NWJlZjcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NlbGxDbGljay5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ2VsbEVkaXRpbmcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NlbGxTZWxlY3Rpb24uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtbkF1dG9zaXppbmcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtbk1vdmluZy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ29sdW1uUGlja2VyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Db2x1bW5SZXNpemluZy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ29sdW1uU2VsZWN0aW9uLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Db2x1bW5Tb3J0aW5nLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9GZWF0dXJlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9GaWx0ZXJzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9LZXlQYWdpbmcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL09uSG92ZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL1Jvd1Jlc2l6aW5nLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Sb3dTZWxlY3Rpb24uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL1RodW1id2hlZWxTY3JvbGxpbmcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9saWIvQmFzZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvbGliL0NlbGxQcm92aWRlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvbGliL0NvbHVtblF1ZXJ5TGFuZ3VhZ2UuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9DdXN0b21GaWx0ZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9Gb3JtYXR0ZXJzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9saWIvTWFwcHkuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9SZW5kZXJlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvbGliL1NlbGVjdGlvbk1vZGVsLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9saWIvVGFibGVEaWFsb2cuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9kZXByZWNhdGVkLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9saWIvcG9seWZpbGxzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9saWIvcmVuZGVyQ2VsbEVycm9yLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9sb2NhbF9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL0RhdGFOb2RlQmFzZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvbG9jYWxfbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9EYXRhTm9kZUdyb3VwLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9sb2NhbF9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL0RhdGFOb2RlTGVhZi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvbG9jYWxfbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9EYXRhTm9kZVRyZWUuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2xvY2FsX25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvRGF0YVNvdXJjZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvbG9jYWxfbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9EYXRhU291cmNlQWdncmVnYXRvci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvbG9jYWxfbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9EYXRhU291cmNlR2xvYmFsRmlsdGVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9sb2NhbF9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL0RhdGFTb3VyY2VJbmRleGVkLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9sb2NhbF9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL0RhdGFTb3VyY2VTb3J0ZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvaHlwZXJncmlkL2Zpbi1oeXBlcmdyaWQvc3JjL2xvY2FsX25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvbG9jYWxfbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy9oeXBlcmdyaWQvZmluLWh5cGVyZ3JpZC9zcmMvbG9jYWxfbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy91dGlsL01hcHB5LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9sb2NhbF9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3V0aWwvYWdncmVnYXRpb25zLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9sb2NhbF9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3V0aWwvaGVhZGVyaWZ5LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL2h5cGVyZ3JpZC9maW4taHlwZXJncmlkL3NyYy9sb2NhbF9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3V0aWwvc3RhYmxlU29ydC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4ckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2tCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcm5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzd6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9wQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1bENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3NzSW5qZWN0b3IgPSByZXF1aXJlKCdjc3MtaW5qZWN0b3InKTtcblxudmFyIHN0eWxlc2hlZXRzID0ge1xuICAgIGdyaWQ6IFtcbiAgICAgICAgJ2RpdiNncmlkLWNvbnRhaW5lciB7JyxcbiAgICAgICAgJyAgICBwb3NpdGlvbjogcmVsYXRpdmU7JyxcbiAgICAgICAgJyAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7JyxcbiAgICAgICAgJyAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOycsXG4gICAgICAgICcgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTsnLFxuICAgICAgICAnICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTsnLFxuICAgICAgICAnICAgIC1vLXVzZXItc2VsZWN0OiBub25lOycsXG4gICAgICAgICcgICAgdXNlci1zZWxlY3Q6IG5vbmU7JyxcbiAgICAgICAgJyAgICBvdmVyZmxvdzogaGlkZGVuOyB9JyxcbiAgICAgICAgJ3Zpc2libGUgeyBvcGFjaXR5OiAwLjc1OyB9JyxcbiAgICAgICAgJ2hpZGRlbiB7IG9wYWNpdHk6IDAuMDsgfScsXG4gICAgICAgICdlZGl0b3IgeycsXG4gICAgICAgICcgICAgcG9zaXRpb246IGFic29sdXRlOycsXG4gICAgICAgICcgICAgZGlzcGxheTogbm9uZTsnLFxuICAgICAgICAnICAgIGJvcmRlcjogc29saWQgMnB4IGJsYWNrOycsXG4gICAgICAgICcgICAgb3V0bGluZTogMDsnLFxuICAgICAgICAnICAgIHBhZGRpbmc6IDA7JyxcbiAgICAgICAgJyAgICB6LWluZGV4OiAxMDAwOyB9J1xuICAgIF0sXG4gICAgJ2xpc3QtZHJhZ29uJzogW1xuICAgICAgICAnZGl2LmRyYWdvbi1saXN0LCBsaS5kcmFnb24tcG9wIHsnLFxuICAgICAgICAnICAgIGZvbnQtZmFtaWx5OiBSb2JvdG8sIHNhbnMtc2VyaWY7JyxcbiAgICAgICAgJyAgICB0ZXh0LXRyYW5zZm9ybTogY2FwaXRhbGl6ZTsgfScsXG4gICAgICAgICdkaXYuZHJhZ29uLWxpc3QgeycsXG4gICAgICAgICcgICAgcG9zaXRpb246IGFic29sdXRlOycsXG4gICAgICAgICcgICAgdG9wOiA0JTsnLFxuICAgICAgICAnICAgIGxlZnQ6IDQlOycsXG4gICAgICAgICcgICAgaGVpZ2h0OiA5MiU7JyxcbiAgICAgICAgJyAgICB3aWR0aDogMjAlOyB9JyxcbiAgICAgICAgJ2Rpdi5kcmFnb24tbGlzdDpudGgtY2hpbGQoMikgeyBsZWZ0OiAyOCU7IH0nLFxuICAgICAgICAnZGl2LmRyYWdvbi1saXN0Om50aC1jaGlsZCgzKSB7IGxlZnQ6IDUyJTsgfScsXG4gICAgICAgICdkaXYuZHJhZ29uLWxpc3Q6bnRoLWNoaWxkKDQpIHsgbGVmdDogNzYlOyB9JyxcbiAgICAgICAgJ2Rpdi5kcmFnb24tbGlzdCA+IGRpdiwgZGl2LmRyYWdvbi1saXN0ID4gdWwgPiBsaSwgbGkuZHJhZ29uLXBvcCB7IGxpbmUtaGVpZ2h0OiA0NnB4OyB9JyxcbiAgICAgICAgJ2Rpdi5kcmFnb24tbGlzdCA+IHVsIHsgdG9wOiA0NnB4OyB9JyxcbiAgICAgICAgJ2Rpdi5kcmFnb24tbGlzdCA+IHVsID4gbGk6bm90KDpsYXN0LWNoaWxkKTo6YmVmb3JlLCBsaS5kcmFnb24tcG9wOjpiZWZvcmUgeycsXG4gICAgICAgICcgICAgY29udGVudDogXFwnXFxcXDJiMjRcXCc7JywgLy8gQkxBQ0sgTEFSR0UgQ0lSQ0xFXG4gICAgICAgICcgICAgY29sb3I6ICNiNmI2YjY7JyxcbiAgICAgICAgJyAgICBmb250LXNpemU6IDMwcHg7JyxcbiAgICAgICAgJyAgICBtYXJnaW46IDhweCAxNHB4IDhweCA4cHg7IH0nLFxuICAgICAgICAnbGkuZHJhZ29uLXBvcCB7IG9wYWNpdHk6Ljg7IH0nXG4gICAgXVxufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzaGVldChrZXksIHJlZmVyZW5jZUVsZW1lbnQpIHtcbiAgICBjc3NJbmplY3RvcihzdHlsZXNoZWV0c1trZXldLCBrZXksIHJlZmVyZW5jZUVsZW1lbnQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZFN0eWxlc2hlZXQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgLy8gVGhpcyBmaWxlIGdlbmVyYXRlZCBieSBndWxwLWltYWdpbmUtNjQgYXQgNTozNjozNyBQTSBvbiAzLzgvMjAxNlxuXHRcImNhbGVuZGFyXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFvQUFBQUtDQVlBQUFDTk1zKzlBQUFBYzBsRVFWUjRuSVhRd1FrQ01SU0U0VTlaTE1DVDlYamFxMkFmTmhmWVU1b1FMTUFPdG9ONDhFV2VpNWlCSVJQZS95WVEzcXJoZjFsRkc3aUtjRWFKeFNmdWtVdk1XZ2RIYXZ0MHVXSHRnMlF3eFhuQW5KWjJ1T0x5Vlp0eWJ6emhnV05tZm9GbDAvWUI4N05ielIxY2pQOXhlUUhTREM2bWNMMXhGUUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cdH0sXG5cdFwiY2hlY2tlZFwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBMEFBQUFQQ0FZQUFBQS9JMFYzQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd2dBQURzSUJGU2hLZ0FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFZSkpSRUZVT0UrTmtzdExnbEVReGYwZmFoRzBpRnJVeG0yRWxGRFlMb2hDcUNEYUNBa1dQYXhJUmJGRkVKRWFHRUtMRENvTUVUUkZVQU1MeWFJSEJVRzZzU0tJTXRLRnFFaExUODE4WlVnbURoenUzRFBuOXowdVYxUnJtVXdteUdReXFOVnFmRnZWaXdCeHU1UkZQWnVMU3lHTUtoei9xbEVzUlYxOUs4eG02eSt3N2JwQlBGbkFmZXJqajNiZFFYNkRwSGNBVXdhdkFIVU4yUkdJWnhCSlpISDJtQy9UVWV5ZHd3VFp2QmVnTEVOTmd3N3NYNldoMUZzd05tUEVtalBDRHlHUlJ3Q3RXOUUzdE1nZEF0UXc3R1pqWWNOWCtnemEyd0ozWlhzU1pVdVEwdldDT1Y4U0hmSkovdWx1aGJIVWoxdjhQS05Nc3pJb1FOUk1IQ1NoRDZXaDh6eWhyYk9Qd3o4dytTVEtsQ0NKN29STlV6UUg2M2tCczV0aEJnaGVQWHhsajJhVW9TeERQY3VYUE5pTEFjNUVFWjZISWtibVYyRFlpWEJQSHMwbzA3OStLMERUVmovczExbUUwMEEwTCtnNFZjRHAxMHFLWk1Benl0QmhNYVRSYVBtWWc4ODVEbGNTelNpajBlb0VpSW91b1VxbHFxcWFMMnJsRW9rK0FkNHZsZnpQb1ZEc0FBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcImRvd24tcmVjdGFuZ2xlXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFrQUFBQUVDQVlBQUFCY0R4WE9BQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQWFkRVZZZEZOdlpuUjNZWEpsQUZCaGFXNTBMazVGVkNCMk15NDFMakV4Ui9OQ053QUFBQnBKUkVGVUdGZGpnSUwvZURBS0lLZ0FCZ2dxZ0FFMEJRd01BUFRsRC9GcGkwSmZBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJmaWx0ZXItb2ZmXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQU1DQVlBQUFCU2dJemFBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQVlkRVZZZEZOdlpuUjNZWEpsQUhCaGFXNTBMbTVsZENBMExqQXVOV1dGTW1VQUFBQ2hTVVJCVkNoVHpaSEJDb1VnRkVUOVRxRWlza2d5V291dFF2UkxSSXIrY1I3WFFBamlKVy8xQmdabU1VZXZYc1k1eHk5T29ERUdNY1lpVXplQjY3cWliVnV3UWpWTkE2MzExVitXQmVNNHZzTERNRUFwZGUvMWZZOXBtdEk0NTNuZUhFS0FsQkpkMXowZlh0YzE2UGJqT0RLMDd6dm1lVVpWVmQ4bm9vYzc1ekpJT1gzR202aTBiVnNHS2Y4eEtJUkl1eUpUTGdKSjNudlF6c2pXMmdlSXNRL3ByOWhNVnJTbmNBQUFBQUJKUlU1RXJrSmdnZz09XCJcblx0fSxcblx0XCJmaWx0ZXItb25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBTUNBWUFBQUJTZ0l6YUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWWRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU5XV0ZNbVVBQUFDb1NVUkJWQ2hUWTNCcWZQMmZIQXpXbURiajdmOHAyOTRSaFZPQmFzRWEwMmUrL2UvVkJtUVFDVHhhWC85UG52WUdvajV5d3B2L1FkMkVOZnQzdnY0ZjFnZlZCQVArblcvK2gvYStBVHRuMXE3M0tIanl0dmRnZzMwNzBEVEJnSHZMNi84ZzIyZnNRR2lhRG1TSEEyMXhheWJnSXBESGl4YThoV3NzbkE4TkRFSUFwQ2gzTGtJamlEMklOWUpDTDJYNlczQjhnZGhFYVFRQlVPQ0E0Z3lFOCtlOXhhS0pnUUVBLzc0Qk5FM2NFbGtBQUFBQVNVVk9SSzVDWUlJPVwiXG5cdH0sXG5cdFwidW5jaGVja2VkXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUEwQUFBQVBDQVlBQUFBL0kwVjNBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQVJCSlJFRlVPRSs5a3J0dWcxQVFSUGxkU2lvN0ZRMXRaSW1Pa29LT0JvbUdUMEVVUkM1aW5vNTR5VHc5MFd5d1FoVGtJa1ZXR29GMnp1eGRybEQrdDB6VGhLWnBUMFZteGI4Q1FSQ2c2enIwZmI4cmVyN3Zmd2NQeHhkY3J4K1lwZ256UEdOWmxoOWlieHhIbEdVSnNoTFNkVjBhdDl0TnBnN0RJQnJYNStPa1BNOUJWa0tHWVNCSkV0UjFqYlpyQmRpcWJWdFVWWVUwVFVGV1FxK25FK0k0eHZ2bEltR2FXN0ZIand4WkNWbVdoYmZ6R1ZtV29TZ0tXWFVyOXVpUklTc2h4M0ZrRWxkb211YlhhdXpSSTBOV1FwN255VVIrTkcvcmZyL2pVWHhuang1dm1LeUViTnVXb3g5WHZpZDZaTWhLNkhBNHduVmRoR0dJS0lwMlJZOE1XUW14K0p1b3F2cFVaRmI4TDZVb255WUwzdU90ckZIK0FBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcInVwLWRvd24tc3BpblwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFQQ0FZQUFBRFVGUDUwQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd1FBQURzRUJ1SkZyN1FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFHSkpSRUZVT0UrbGt3RUtBQ0VJQkgyWmIvUG5Ic29HZWFWSkRVakdPZ1JScEtwa2lJait5NE1NRTNlRFI3a2FLT1ZOc0p5TU5qSUh6R3k5WW5XNko3cUljcnJpUWltZUNxT1JOQUJkMGZwUlRrdDh1VlVqN0VzeEM2dnMvcTNlL1E2aUQyYnduQnlqUFhITkFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcInVwLWRvd25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBUENBWUFBQURVRlA1MEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dRQUFEc0VCdUpGcjdRQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBR0ZKUkVGVU9FK2xra0VLUUNFSVJEMlpKM1BoM2lONFdEOUdmbHBZaGowWVlvd3BHZ0ptYmlrZDNnak1ERm9rd2J1VDFpQWl1ckc1bm9tZ3FvNVFhUG85RVJRUkk2SmY3c2ZHanVkeTJqZTIzK2kwV2wyb1E4NVRPZGxmckpRT2F6RjhicitycVRYUUtuMEFBQUFBU1VWT1JLNUNZSUk9XCJcblx0fSxcbn07XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxudmFyIGltYWdlcyA9IHJlcXVpcmUoJy4vaW1hZ2VzJyk7IC8vIHRoaXMgaXMgdGhlIGZpbGUgZ2VuZXJhdGVkIGJ5IGd1bHBmaWxlLmpzIChhbmQgaWdub3JlZCBieSBnaXQpXG5cbl8oaW1hZ2VzKS5lYWNoKGZ1bmN0aW9uKGltYWdlLCBrZXkpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgIGVsZW1lbnQuc3JjID0gJ2RhdGE6JyArIGltYWdlLnR5cGUgKyAnO2Jhc2U2NCwnICsgaW1hZ2UuZGF0YTtcbiAgICBpbWFnZXNba2V5XSA9IGVsZW1lbnQ7XG59KTtcblxuaW1hZ2VzLmNoZWNrYm94ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gaW1hZ2VzW3N0YXRlID8gJ2NoZWNrZWQnIDogJ3VuY2hlY2tlZCddO1xufTtcblxuaW1hZ2VzLmZpbHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIGltYWdlc1tzdGF0ZSA/ICdmaWx0ZXItb24nIDogJ2ZpbHRlci1vZmYnXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW1hZ2VzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqIEBuYW1lc3BhY2UgY3NzSW5qZWN0b3IgKi9cblxuLyoqXG4gKiBAc3VtbWFyeSBJbnNlcnQgYmFzZSBzdHlsZXNoZWV0IGludG8gRE9NXG4gKlxuICogQGRlc2MgQ3JlYXRlcyBhIG5ldyBgPHN0eWxlPi4uLjwvc3R5bGU+YCBlbGVtZW50IGZyb20gdGhlIG5hbWVkIHRleHQgc3RyaW5nKHMpIGFuZCBpbnNlcnRzIGl0IGJ1dCBvbmx5IGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QgaW4gdGhlIHNwZWNpZmllZCBjb250YWluZXIgYXMgcGVyIGByZWZlcmVuY2VFbGVtZW50YC5cbiAqXG4gKiA+IENhdmVhdDogSWYgc3R5bGVzaGVldCBpcyBmb3IgdXNlIGluIGEgc2hhZG93IERPTSwgeW91IG11c3Qgc3BlY2lmeSBhIGxvY2FsIGByZWZlcmVuY2VFbGVtZW50YC5cbiAqXG4gKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgbmV3bHkgY3JlYXRlZCBgPHN0eWxlPi4uLjwvc3R5bGU+YCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBjc3NSdWxlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtJRF1cbiAqIEBwYXJhbSB7dW5kZWZpbmVkfG51bGx8RWxlbWVudHxzdHJpbmd9IFtyZWZlcmVuY2VFbGVtZW50XSAtIENvbnRhaW5lciBmb3IgaW5zZXJ0aW9uLiBPdmVybG9hZHM6XG4gKiAqIGB1bmRlZmluZWRgIHR5cGUgKG9yIG9taXR0ZWQpOiBpbmplY3RzIHN0eWxlc2hlZXQgYXQgdG9wIG9mIGA8aGVhZD4uLi48L2hlYWQ+YCBlbGVtZW50XG4gKiAqIGBudWxsYCB2YWx1ZTogaW5qZWN0cyBzdHlsZXNoZWV0IGF0IGJvdHRvbSBvZiBgPGhlYWQ+Li4uPC9oZWFkPmAgZWxlbWVudFxuICogKiBgRWxlbWVudGAgdHlwZTogaW5qZWN0cyBzdHlsZXNoZWV0IGltbWVkaWF0ZWx5IGJlZm9yZSBnaXZlbiBlbGVtZW50LCB3aGVyZXZlciBpdCBpcyBmb3VuZC5cbiAqICogYHN0cmluZ2AgdHlwZTogaW5qZWN0cyBzdHlsZXNoZWV0IGltbWVkaWF0ZWx5IGJlZm9yZSBnaXZlbiBmaXJzdCBlbGVtZW50IGZvdW5kIHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gY3NzIHNlbGVjdG9yLlxuICpcbiAqIEBtZW1iZXJPZiBjc3NJbmplY3RvclxuICovXG5mdW5jdGlvbiBjc3NJbmplY3Rvcihjc3NSdWxlcywgSUQsIHJlZmVyZW5jZUVsZW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIHJlZmVyZW5jZUVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJlZmVyZW5jZUVsZW1lbnQpO1xuICAgICAgICBpZiAoIXJlZmVyZW5jZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRocm93ICdDYW5ub3QgZmluZCByZWZlcmVuY2UgZWxlbWVudCBmb3IgQ1NTIGluamVjdGlvbi4nO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZlcmVuY2VFbGVtZW50ICYmICEocmVmZXJlbmNlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgIHRocm93ICdHaXZlbiB2YWx1ZSBub3QgYSByZWZlcmVuY2UgZWxlbWVudC4nO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXIgPSByZWZlcmVuY2VFbGVtZW50ICYmIHJlZmVyZW5jZUVsZW1lbnQucGFyZW50Tm9kZSB8fCBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cbiAgICBpZiAoSUQpIHtcbiAgICAgICAgSUQgPSBjc3NJbmplY3Rvci5pZFByZWZpeCArIElEO1xuXG4gICAgICAgIGlmIChjb250YWluZXIucXVlcnlTZWxlY3RvcignIycgKyBJRCkpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gc3R5bGVzaGVldCBhbHJlYWR5IGluIERPTVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcbiAgICBpZiAoSUQpIHtcbiAgICAgICAgc3R5bGUuaWQgPSBJRDtcbiAgICB9XG4gICAgaWYgKGNzc1J1bGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY3NzUnVsZXMgPSBjc3NSdWxlcy5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgY3NzUnVsZXMgPSAnXFxuJyArIGNzc1J1bGVzICsgJ1xcbic7XG4gICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzUnVsZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzUnVsZXMpKTtcbiAgICB9XG5cbiAgICBpZiAocmVmZXJlbmNlRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHN0eWxlLCByZWZlcmVuY2VFbGVtZW50KTtcblxuICAgIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBPcHRpb25hbCBwcmVmaXggZm9yIGA8c3R5bGU+YCB0YWcgSURzLlxuICogQGRlc2MgRGVmYXVsdHMgdG8gYCdpbmplY3RlZC1zdHlsZXNoZWV0LSdgLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBtZW1iZXJPZiBjc3NJbmplY3RvclxuICovXG5jc3NJbmplY3Rvci5pZFByZWZpeCA9ICdpbmplY3RlZC1zdHlsZXNoZWV0LSc7XG5cbi8vIEludGVyZmFjZVxubW9kdWxlLmV4cG9ydHMgPSBjc3NJbmplY3RvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEBuYW1lc3BhY2UgZXh0ZW5kLW1lICoqL1xuXG4vKiogQHN1bW1hcnkgRXh0ZW5kcyBhbiBleGlzdGluZyBjb25zdHJ1Y3RvciBpbnRvIGEgbmV3IGNvbnN0cnVjdG9yLlxuICpcbiAqIEByZXR1cm5zIHtDaGlsZENvbnN0cnVjdG9yfSBBIG5ldyBjb25zdHJ1Y3RvciwgZXh0ZW5kZWQgZnJvbSB0aGUgZ2l2ZW4gY29udGV4dCwgcG9zc2libHkgd2l0aCBzb21lIHByb3RvdHlwZSBhZGRpdGlvbnMuXG4gKlxuICogQGRlc2MgRXh0ZW5kcyBcIm9iamVjdHNcIiAoY29uc3RydWN0b3JzKSwgd2l0aCBvcHRpb25hbCBhZGRpdGlvbmFsIGNvZGUsIG9wdGlvbmFsIHByb3RvdHlwZSBhZGRpdGlvbnMsIGFuZCBvcHRpb25hbCBwcm90b3R5cGUgbWVtYmVyIGFsaWFzZXMuXG4gKlxuICogPiBDQVZFQVQ6IE5vdCB0byBiZSBjb25mdXNlZCB3aXRoIFVuZGVyc2NvcmUtc3R5bGUgLmV4dGVuZCgpIHdoaWNoIGlzIHNvbWV0aGluZyBlbHNlIGVudGlyZWx5LiBJJ3ZlIHVzZWQgdGhlIG5hbWUgXCJleHRlbmRcIiBoZXJlIGJlY2F1c2Ugb3RoZXIgcGFja2FnZXMgKGxpa2UgQmFja2JvbmUuanMpIHVzZSBpdCB0aGlzIHdheS4gWW91IGFyZSBmcmVlIHRvIGNhbGwgaXQgd2hhdGV2ZXIgeW91IHdhbnQgd2hlbiB5b3UgXCJyZXF1aXJlXCIgaXQsIHN1Y2ggYXMgYHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2V4dGVuZCcpYC5cbiAqXG4gKiBQcm92aWRlIGEgY29uc3RydWN0b3IgYXMgdGhlIGNvbnRleHQgYW5kIGFueSBwcm90b3R5cGUgYWRkaXRpb25zIHlvdSByZXF1aXJlIGluIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IHdpc2ggdG8gYmUgYWJsZSB0byBleHRlbmQgYEJhc2VDb25zdHJ1Y3RvcmAgdG8gYSBuZXcgY29uc3RydWN0b3Igd2l0aCBwcm90b3R5cGUgb3ZlcnJpZGVzIGFuZC9vciBhZGRpdGlvbnMsIGJhc2ljIHVzYWdlIGlzOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBCYXNlID0gcmVxdWlyZSgnZXh0ZW5kLW1lJykuQmFzZTtcbiAqIHZhciBCYXNlQ29uc3RydWN0b3IgPSBCYXNlLmV4dGVuZChiYXNlUHJvdG90eXBlKTsgLy8gbWl4ZXMgaW4gLmV4dGVuZFxuICogdmFyIENoaWxkQ29uc3RydWN0b3IgPSBCYXNlQ29uc3RydWN0b3IuZXh0ZW5kKGNoaWxkUHJvdG90eXBlT3ZlcnJpZGVzQW5kQWRkaXRpb25zKTtcbiAqIHZhciBHcmFuZGNoaWxkQ29uc3RydWN0b3IgPSBDaGlsZENvbnN0cnVjdG9yLmV4dGVuZChncmFuZGNoaWxkUHJvdG90eXBlT3ZlcnJpZGVzQW5kQWRkaXRpb25zKTtcbiAqIGBgYFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gKGBleHRlbmQoKWApIGlzIGFkZGVkIHRvIHRoZSBuZXcgZXh0ZW5kZWQgb2JqZWN0IGNvbnN0cnVjdG9yIGFzIGEgcHJvcGVydHkgYC5leHRlbmRgLCBlc3NlbnRpYWxseSBtYWtpbmcgdGhlIG9iamVjdCBjb25zdHJ1Y3RvciBpdHNlbGYgZWFzaWx5IFwiZXh0ZW5kYWJsZS5cIiAoTm90ZTogVGhpcyBpcyBhIHByb3BlcnR5IG9mIGVhY2ggY29uc3RydWN0b3IgYW5kIG5vdCBhIG1ldGhvZCBvZiBpdHMgcHJvdG90eXBlISlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4dGVuZGVkQ2xhc3NOYW1lXSAtIFRoaXMgaXMgc2ltcGx5IGFkZGVkIHRvIHRoZSBwcm90b3R5cGUgYXMgJCRDTEFTU19OQU1FLiBVc2VmdWwgZm9yIGRlYnVnZ2luZyBiZWNhdXNlIGFsbCBkZXJpdmVkIGNvbnN0cnVjdG9ycyBhcHBlYXIgdG8gaGF2ZSB0aGUgc2FtZSBuYW1lIChcIkNvbnN0cnVjdG9yXCIpIGluIHRoZSBkZWJ1Z2dlci4gVGhpcyBwcm9wZXJ0eSBpcyBpZ25vcmVkIHVubGVzcyBgZXh0ZW5kLmRlYnVnYCBpcyBleHBsaWNpdGx5IHNldCB0byBhIHRydXRoeSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge2V4dGVuZGVkUHJvdG90eXBlQWRkaXRpb25zT2JqZWN0fSBbcHJvdG90eXBlQWRkaXRpb25zXSAtIE9iamVjdCB3aXRoIG1lbWJlcnMgdG8gY29weSB0byBuZXcgY29uc3RydWN0b3IncyBwcm90b3R5cGUuIE1vc3QgbWVtYmVycyB3aWxsIGJlIGNvcGllZCB0byB0aGUgcHJvdG90eXBlLiBTb21lIG1lbWJlcnMsIGhvd2V2ZXIsIGhhdmUgc3BlY2lhbCBtZWFuaW5ncyBhcyBleHBsYWluZWQgaW4gdGhlIHtAbGluayBleHRlbmRlZFByb3RvdHlwZUFkZGl0aW9uc09iamVjdHx0eXBlIGRlZmluaXRpb259IChhbmQgbWF5IG9yIG1heSBub3QgYmUgY29waWVkIHRvIHRoZSBwcm90b3R5cGUpLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlYnVnXSAtIFNlZSBwYXJhbWV0ZXIgYGV4dGVuZGVkQ2xhc3NOYW1lYCBfKGFib3ZlKV8uXG4gKlxuICogQHByb3BlcnR5IHtvYmplY3R9IEJhc2UgLSBBIGNvbnZlbmllbnQgYmFzZSBjbGFzcyBmcm9tIHdoaWNoIGFsbCBvdGhlciBjbGFzc2VzIGNhbiBiZSBleHRlbmRlZC5cbiAqXG4gKiBAbWVtYmVyT2YgZXh0ZW5kLW1lXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChleHRlbmRlZENsYXNzTmFtZSwgcHJvdG90eXBlQWRkaXRpb25zKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHByb3RvdHlwZUFkZGl0aW9ucyA9IHt9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHByb3RvdHlwZUFkZGl0aW9ucyA9IGV4dGVuZGVkQ2xhc3NOYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGVBZGRpdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1NpbmdsZSBwYXJhbWV0ZXIgb3ZlcmxvYWQgbXVzdCBiZSBvYmplY3QuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dGVuZGVkQ2xhc3NOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5kZWRDbGFzc05hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm90b3R5cGVBZGRpdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1R3byBwYXJhbWV0ZXIgb3ZlcmxvYWQgbXVzdCBiZSBzdHJpbmcsIG9iamVjdC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnVG9vIG1hbnkgcGFyYW1ldGVycyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIGlmIChwcm90b3R5cGVBZGRpdGlvbnMucHJlSW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgcHJvdG90eXBlQWRkaXRpb25zLnByZUluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxpemVQcm90b3R5cGVDaGFpbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIGlmIChwcm90b3R5cGVBZGRpdGlvbnMucG9zdEluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIHByb3RvdHlwZUFkZGl0aW9ucy5wb3N0SW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQ29uc3RydWN0b3IuZXh0ZW5kID0gZXh0ZW5kO1xuXG4gICAgdmFyIHByb3RvdHlwZSA9IENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuICAgIHByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuXG4gICAgaWYgKGV4dGVuZGVkQ2xhc3NOYW1lICYmIGV4dGVuZC5kZWJ1Zykge1xuICAgICAgICBwcm90b3R5cGUuJCRDTEFTU19OQU1FID0gZXh0ZW5kZWRDbGFzc05hbWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3RvdHlwZUFkZGl0aW9ucykge1xuICAgICAgICBpZiAocHJvdG90eXBlQWRkaXRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3RvdHlwZUFkZGl0aW9uc1trZXldO1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbml0aWFsaXplT3duJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBjYWxsZWQgYWJvdmU7IG5vdCBuZWVkZWQgaW4gcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWFzZXMnOlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhbGlhcyBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGFsaWFzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VBbGlhcyh2YWx1ZVthbGlhc10sIGFsaWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZVswXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlQWxpYXModmFsdWUsIGtleS5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuXG4gICAgZnVuY3Rpb24gbWFrZUFsaWFzKHZhbHVlLCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zaGFkb3dcbiAgICAgICAgcHJvdG90eXBlW2tleV0gPSBwcm90b3R5cGVBZGRpdGlvbnNbdmFsdWVdO1xuICAgIH1cbn1cblxuZXh0ZW5kLkJhc2UgPSBmdW5jdGlvbiAoKSB7fTtcbmV4dGVuZC5CYXNlLmV4dGVuZCA9IGV4dGVuZDtcblxuLyoqIEB0eXBlZGVmIHtmdW5jdGlvbn0gZXh0ZW5kZWRDb25zdHJ1Y3RvclxuICogQHByb3BlcnR5IHByb3RvdHlwZS5zdXBlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBwcm90b3R5cGUgdGhpcyBjb25zdHJ1Y3RvciB3YXMgZXh0ZW5kZWQgZnJvbS5cbiAqIEBwcm9wZXJ0eSBbZXh0ZW5kXSAtIElmIGBwcm90b3R5cGVBZGRpdGlvbnMuZXh0ZW5kYWJsZWAgd2FzIHRydXRoeSwgdGhpcyB3aWxsIGJlIGEgcmVmZXJlbmNlIHRvIHtAbGluayBleHRlbmQuZXh0ZW5kfGV4dGVuZH0uXG4gKi9cblxuLyoqIEB0eXBlZGVmIHtvYmplY3R9IGV4dGVuZGVkUHJvdG90eXBlQWRkaXRpb25zT2JqZWN0XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbaW5pdGlhbGl6ZV0gLSBBZGRpdGlvbmFsIGNvbnN0cnVjdG9yIGNvZGUgZm9yIG5ldyBvYmplY3QuIFRoaXMgbWV0aG9kIGlzIGFkZGVkIHRvIHRoZSBuZXcgY29uc3RydWN0b3IncyBwcm90b3R5cGUuIEdldHMgcGFzc2VkIG5ldyBvYmplY3QgYXMgY29udGV4dCArIHNhbWUgYXJncyBhcyBjb25zdHJ1Y3RvciBpdHNlbGYuIENhbGxlZCBvbiBpbnN0YW50aWF0aW9uIGFmdGVyIHNpbWlsYXIgZnVuY3Rpb24gaW4gYWxsIGFuY2VzdG9ycyBjYWxsZWQgd2l0aCBzYW1lIHNpZ25hdHVyZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtpbml0aWFsaXplT3duXSAtIEFkZGl0aW9uYWwgY29uc3RydWN0b3IgY29kZSBmb3IgbmV3IG9iamVjdC4gVGhpcyBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG5ldyBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZS4gR2V0cyBwYXNzZWQgbmV3IG9iamVjdCBhcyBjb250ZXh0ICsgc2FtZSBhcmdzIGFzIGNvbnN0cnVjdG9yIGl0c2VsZi4gQ2FsbGVkIG9uIGluc3RhbnRpYXRpb24gYWZ0ZXIgKGFsbCkgdGhlIGBpbml0aWFsaXplYCBmdW5jdGlvbihzKS5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbYWxpYXNlc10gLSBIYXNoIG9mIGFsaWFzZXMgZm9yIHByb3RvdHlwZSBtZW1iZXJzIGluIGZvcm0gYHsga2V5OiAnbWVtYmVyJywgLi4uIH1gIHdoZXJlIGBrZXlgIGlzIHRoZSBuYW1lIG9mIGFuIGFsaWVhcyBhbmQgYCdtZW1iZXInYCBpcyB0aGUgbmFtZSBvZiBhbiBleGlzdGluZyBtZW1iZXIgaW4gdGhlIHByb3RvdHlwZS4gRWFjaCBzdWNoIGtleSBpcyBhZGRlZCB0byB0aGUgcHJvdG90eXBlIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBuYW1lZCBtZW1iZXIuIChUaGUgYGFsaWFzZXNgIG9iamVjdCBpdHNlbGYgaXMgKm5vdCogYWRkZWQgdG8gcHJvdG90eXBlLikgQWx0ZXJuYXRpdmVseTpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2V5c10gLSBBcmJpdHJhcnkgcHJvcGVydHkgbmFtZXMgZGVmaW5lZCBoZXJlIHdpdGggc3RyaW5nIHZhbHVlcyBzdGFydGluZyB3aXRoIGEgYCNgIGNoYXJhY3RlciB3aWxsIGFsaWFzIHRoZSBhY3R1YWwgcHJvcGVydGllcyBuYW1lZCBpbiB0aGUgc3RyaW5ncyAoZm9sbG93aW5nIHRoZSBgI2ApLiBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvIHByb3ZpZGluZyBhbiBgYWxpYXNlc2AgaGFzaCwgcGVyaGFwcyBzaW1wbGVyICh0aG91Z2ggc3VidGxlcikuIChVc2UgYXJiaXRyYXJ5IGlkZW50aWZpZXJzIGhlcmU7IGRvbid0IHVzZSB0aGUgbmFtZSBga2V5c2AhKVxuICogQHByb3BlcnR5IHsqfSBbYXJiaXRyYXJ5UHJvcGVydGllc10gLSBBbnkgYWRkaXRpb25hbCBhcmJpdHJhcnkgcHJvcGVydGllcyBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhZGRlZCB0byB0aGUgbmV3IGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLiAoVXNlIGFyYml0cmFyeSBpZGVudGlmaWVycyBoZXJlOyBkb24ndCB1c2UgdGhlIG5hbWUgYGFyaWJpdHJhcnlQcm9wZXJ0aWVzYCEpXG4gKi9cblxuLyoqIEBzdW1tYXJ5IENhbGwgYWxsIGBpbml0aWFsaXplYCBtZXRob2RzIGZvdW5kIGluIHByb3RvdHlwZSBjaGFpbi5cbiAqIEBkZXNjIFRoaXMgcmVjdXJzaXZlIHJvdXRpbmUgaXMgY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAqIDEuIFdhbGtzIGJhY2sgdGhlIHByb3RvdHlwZSBjaGFpbiB0byBgT2JqZWN0YCdzIHByb3RvdHlwZVxuICogMi4gV2Fsa3MgZm9yd2FyZCB0byBuZXcgb2JqZWN0LCBjYWxsaW5nIGFueSBgaW5pdGlhbGl6ZWAgbWV0aG9kcyBpdCBmaW5kcyBhbG9uZyB0aGUgd2F5IHdpdGggdGhlIHNhbWUgY29udGV4dCBhbmQgYXJndW1lbnRzIHdpdGggd2hpY2ggdGhlIGNvbnN0cnVjdG9yIHdhcyBjYWxsZWQuXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlck9mIGV4dGVuZC1tZVxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvdG90eXBlQ2hhaW4oKSB7XG4gICAgdmFyIHRlcm0gPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJlY3VyKHRlcm0pO1xuXG4gICAgZnVuY3Rpb24gcmVjdXIob2JqKSB7XG4gICAgICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgICAgICBpZiAocHJvdG8uY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICAgICAgICAgICAgcmVjdXIocHJvdG8pO1xuICAgICAgICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCdpbml0aWFsaXplJykpIHtcbiAgICAgICAgICAgICAgICBwcm90by5pbml0aWFsaXplLmFwcGx5KHRlcm0sIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG52YXIgcG9wTWVudSA9IHJlcXVpcmUoJ3BvcC1tZW51Jyk7XG5cbnZhciBGaWx0ZXJOb2RlID0gcmVxdWlyZSgnLi9qcy9GaWx0ZXJOb2RlJyk7XG52YXIgRmlsdGVyVHJlZSA9IHJlcXVpcmUoJy4vanMvRmlsdGVyVHJlZScpO1xuXG52YXIgY29uZGl0aW9uYWxzID0gcmVxdWlyZSgnLi9qcy9jb25kaXRpb25hbHMnKTtcbnZhciBjb3B5ID0gcmVxdWlyZSgnLi9qcy9jb3B5LWlucHV0Jyk7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL2pzL3RlbXBsYXRlJyk7XG5cbi8vIGV4cG9zZSBzb21lIG9iamVjdHMgZm9yIHBsdWctaW4gYWNjZXNzXG5cbkZpbHRlclRyZWUuY29uZGl0aW9uYWxzID0gY29uZGl0aW9uYWxzO1xuRmlsdGVyVHJlZS5GaWx0ZXJUcmVlRXJyb3IgPSBGaWx0ZXJOb2RlLkZpbHRlclRyZWVFcnJvcjtcblxuLy8gRk9MTE9XSU5HIFBST1BFUlRJRVMgQVJFICoqKiBURU1QT1JBUlkgKioqLFxuLy8gRk9SIFRIRSBERU1PIFRPIEFDQ0VTUyBUSEVTRSBOT0RFIE1PRFVMRVMuXG5cbkZpbHRlclRyZWUuXyA9IF87XG5GaWx0ZXJUcmVlLnBvcE1lbnUgPSBwb3BNZW51O1xuRmlsdGVyVHJlZS5jb3B5ID0gY29weTtcbkZpbHRlclRyZWUudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlclRyZWU7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBvcE1lbnUgPSByZXF1aXJlKCdwb3AtbWVudScpO1xuXG52YXIgRmlsdGVyTm9kZSA9IHJlcXVpcmUoJy4vRmlsdGVyTm9kZScpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xudmFyIGNvbmRpdGlvbmFscyA9IHJlcXVpcmUoJy4vY29uZGl0aW9uYWxzJyk7XG5cblxuLyoqIEB0eXBlZGVmIHtvYmplY3R9IGNvbnZlcnRlclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gdG8gLSBSZXR1cm5zIGlucHV0IHZhbHVlIGNvbnZlcnRlZCB0byB0eXBlLiBGYWlscyBzaWxlbnRseS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG5vdCAtIFRlc3RzIGlucHV0IHZhbHVlIGFnYWluc3QgdHlwZSwgcmV0dXJuaW5nIGBmYWxzZSBpZiB0eXBlIG9yIGB0cnVlYCBpZiBub3QgdHlwZS5cbiAqL1xuLyoqIEB0eXBlIHtjb252ZXJ0ZXJ9ICovXG52YXIgbnVtYmVyQ29udmVydGVyID0geyB0bzogTnVtYmVyLCBub3Q6IGlzTmFOIH07XG5cbi8qKiBAdHlwZSB7Y29udmVydGVyfSAqL1xudmFyIGRhdGVDb252ZXJ0ZXIgPSB7IHRvOiBmdW5jdGlvbihzKSB7IHJldHVybiBuZXcgRGF0ZShzKTsgfSwgbm90OiBpc05hTiB9O1xuXG4vKiogQGNvbnN0cnVjdG9yXG4gKiBAc3VtbWFyeSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgdGVybWluYWwgbm9kZSBpbiBhIGZpbHRlciB0cmVlLlxuICogQGRlc2MgU3BlY2lmaWNhbGx5LCB0aGUgdGVybWluYWwgbm9kZSBpbiBhIGZpbHRlciB0cmVlIHJlcHJlc2VudHMgYSBzaW1wbGUgZHlhZGljIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24uXG4gKiBpbiB0aGUgZm9ybSBfZmllbGQtcHJvcGVydHkgb3BlcmF0b3ItcHJvcGVydHkgYXJndW1lbnQtcHJvcGVydHlfIHdoZXJlOlxuICpcbiAqICogX2ZpZWxkLXByb3BlcnR5XyBpcyB0aGUgbmFtZSBvZiBhIGNvbHVtbiwgc2VsZWN0ZWQgZnJvbSBhIGRyb3AtZG93bjtcbiAqICogX29wZXJhdG9yLXByb3BlcnR5XyBpcyBhbiBvcGVyYXRvciBmcm9tIGFuIGV4dGVuc2libGUgbGlzdCBvZiBvcGVyYXRvcnMsIGFsc28gc2VsZWN0ZWQgZnJvbSBhIGRyb3AtZG93bjsgYW5kXG4gKiAqIF9hcmd1bWVudC1wcm9wZXJ0eV8gaXMgYSBjb25zdGFudCB0eXBlZCBpbnRvIGEgdGV4dCBib3guXG4gKlxuICogVGhlIGRlZmF1bHQgb3BlcmF0b3IgbGlzdCBpcyBkZWZpbmVkIGluIGNvbmRpdGlvbmFscy5qcyBhbmQgaW5jbHVkZXMgZXF1YWxpdHkgKD0pLCBpbmVxdWFsaXR5ICg8LCDiiaQsIOKJoCwg4omlLCA+KSwgYW5kIHZhcmlvdXMgcGF0dGVybiBvcGVyYXRvcnMgKHN1Y2ggYXMgTElLRSwgTk9UIExJS0UsIGV0Yy4pXG4gKi9cbnZhciBGaWx0ZXJMZWFmID0gRmlsdGVyTm9kZS5leHRlbmQoJ0ZpbHRlckxlYWYnLCB7XG5cbiAgICBuYW1lOiAnY29sdW1uID0gdmFsdWUnLFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdba2V5XS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHZpZXcgaW4gYHRoaXMudmlld2AuXG4gICAgICogQGRlc2MgVGhpcyBuZXcgXCJ2aWV3XCIgaXMgYSBncm91cCBvZiBIVE1MIGBFbGVtZW50YCBjb250cm9scyB0aGF0IGNvbXBsZXRlbHkgZGVzY3JpYmUgdGhlIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24gdGhpcyBvYmplY3QgcmVwcmVzZW50cy4gVGhpcyBtZXRob2QgY3JlYXRlcyB0aGUgZm9sbG93aW5nIG9iamVjdCBwcm9wZXJ0aWVzOlxuICAgICAqXG4gICAgICogKiBgdGhpcy5lbGAgLSBhIGA8c3Bhbj4uLi48L3NwYW4+YCBlbGVtZW50IHRvIGNvbnRhaW4gdGhlIGNvbnRyb2xzIGFzIGNoaWxkIG5vZGVzXG4gICAgICogKiBgdGhpcy52aWV3YCAtIGEgaGFzaCBjb250YWluaW5nIGRpcmVjdCByZWZlcmVuY2VzIHRvIHRoZSBjb250cm9scy5cbiAgICAgKlxuICAgICAqIFRoZSB2aWV3IGZvciB0aGlzIGJhc2UgYEZpbHRlckxlYWZgIG9iamVjdCBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIGNvbnRyb2xzOlxuICAgICAqXG4gICAgICogKiBgdGhpcy52aWV3LmNvbHVtbmAgLSBBIGRyb3AtZG93biB3aXRoIG9wdGlvbnMgZnJvbSBgdGhpcy5zY2hlbWFgLiBWYWx1ZSBpcyB0aGUgbmFtZSBvZiB0aGUgY29sdW1uIGJlaW5nIHRlc3RlZCAoaS5lLiwgdGhlIGNvbHVtbiB0byB3aGljaCB0aGlzIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24gYXBwbGllcykuXG4gICAgICogKiBgdGhpcy52aWV3Lm9wZXJhdG9yYCAtIEEgZHJvcC1kb3duIHdpdGggb3B0aW9ucyBmcm9tIHtAbGluayBjb2x1bW5PcE1lbnV9LCB7QGxpbmsgdHlwZU9wTWVudX0sIG9yIHtAbGluayB0cmVlT3BNZW51fS4gVmFsdWUgaXMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb3BlcmF0b3IuXG4gICAgICogKiBgdGhpcy52aWV3LmxpdGVyYWxgIC0gQSB0ZXh0IGJveC5cbiAgICAgKlxuICAgICAqICA+IFByb3RvdHlwZXMgZXh0ZW5kZWQgZnJvbSBgRmlsdGVyTGVhZmAgbWF5IGhhdmUgZGlmZmVyZW50IGNvbnRyb2xzIGFzIG5lZWRlZC4gVGhlIG9ubHkgcmVxdWlyZWQgY29udHJvbCBpcyBgY29sdW1uYCwgd2hpY2ggYWxsIHN1Y2ggXCJlZGl0b3JzXCIgbXVzdCBzdXBwb3J0LlxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJMZWFmLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZVZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG4gICAgICAgIGVsLmNsYXNzTmFtZSA9ICdmaWx0ZXItdHJlZS1lZGl0b3IgZmlsdGVyLXRyZWUtZGVmYXVsdCc7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY29sdW1uKSB7XG4gICAgICAgICAgICAvLyBTdGF0ZSBpbmNsdWRlcyBjb2x1bW46XG4gICAgICAgICAgICAvLyBPcGVyYXRvciBtZW51IGlzIGJ1aWx0IGxhdGVyIGluIGxvYWRTdGF0ZTsgd2UgZG9uJ3QgbmVlZCB0byBidWlsZCBpdCBub3cuIFRoZSBjYWxsIHRvXG4gICAgICAgICAgICAvLyBnZXRPcE1lbnUgYmVsb3cgd2l0aCB1bmRlZmluZWQgY29sdW1uTmFtZSByZXR1cm5zIFtdIHJlc3VsdGluZyBpbiBhbiBlbXB0eSBkcm9wLWRvd24uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIHN0YXRlIGRvZXMgTk9UIGluY2x1ZGUgY29sdW1uLCBpdCdzIGJlY2F1c2UgZWl0aGVyOlxuICAgICAgICAgICAgLy8gYS4gY29sdW1uIGlzIHVua25vd24gYW5kIG5vIG9wIG1lbnUgd2lsbCBiZSBlbXB0eSB1bnRpbCB1c2VyIGNob29zZXMgYSBjb2x1bW47IG9yXG4gICAgICAgICAgICAvLyBiLiBjb2x1bW4gaXMgaGFyZC1jb2RlZCB3aGVuIHRoZXJlJ3Mgb25seSBvbmUgcG9zc2libGUgY29sdW1uIGFzIGluZmVyYWJsZSBmcm9tIHNjaGVtYTpcbiAgICAgICAgICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYSAmJiB0aGlzLnNjaGVtYS5sZW5ndGggPT09IDEgJiYgdGhpcy5zY2hlbWFbMF0sXG4gICAgICAgICAgICAgICAgY29sdW1uTmFtZSA9IHNjaGVtYSAmJiAoc2NoZW1hLm5hbWUgfHwgc2NoZW1hKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmlldyA9IHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5tYWtlRWxlbWVudCh0aGlzLnNjaGVtYSwgJ2NvbHVtbicsIHRoaXMuc29ydENvbHVtbk1lbnUpLFxuICAgICAgICAgICAgb3BlcmF0b3I6IHRoaXMubWFrZUVsZW1lbnQoZ2V0T3BNZW51LmNhbGwodGhpcywgY29sdW1uTmFtZSksICdvcGVyYXRvcicpLFxuICAgICAgICAgICAgbGl0ZXJhbDogdGhpcy5tYWtlRWxlbWVudCgpXG4gICAgICAgIH07XG5cbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSk7XG4gICAgfSxcblxuICAgIGxvYWRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUsIGVsLCBpLCBiLCBzZWxlY3RlZCwgbm90ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzW2tleV0gPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBlbCA9IHRoaXMudmlld1trZXldO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGVsLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9XFwnJyArIGVsLm5hbWUgKyAnXFwnXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbFtpXS5jaGVja2VkID0gdmFsdWUuaW5kZXhPZihlbFtpXS52YWx1ZSkgPj0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZWwub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBiID0gZmFsc2U7IGkgPCBlbC5sZW5ndGg7IGkrKywgYiA9IGIgfHwgc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB2YWx1ZS5pbmRleE9mKGVsW2ldLnZhbHVlKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbFtpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaWx0ZXJOb2RlLnNldFdhcm5pbmdDbGFzcyhlbCwgYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEZpbHRlck5vZGUuc2V0V2FybmluZ0NsYXNzKGVsKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZXMucHVzaCh7IGtleToga2V5LCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VPcE1lbnUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsZSA9IG5vdGVzLmxlbmd0aCA+IDEsXG4gICAgICAgICAgICAgICAgICAgIGZvb3Rub3RlcyA9IHRlbXBsYXRlKG11bHRpcGxlID8gJ25vdGVzJyA6ICdub3RlJyksXG4gICAgICAgICAgICAgICAgICAgIGlubmVyID0gZm9vdG5vdGVzLnF1ZXJ5U2VsZWN0b3IoJy5mb290bm90ZScpO1xuICAgICAgICAgICAgICAgIG5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9vdG5vdGUgPSBtdWx0aXBsZSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJykgOiBpbm5lcjtcbiAgICAgICAgICAgICAgICAgICAgbm90ZSA9IHRlbXBsYXRlKCdvcHRpb25NaXNzaW5nJywgbm90ZS5rZXksIG5vdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm90ZS5sZW5ndGgpIHsgZm9vdG5vdGUuYXBwZW5kQ2hpbGQobm90ZVswXSk7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7IGlubmVyLmFwcGVuZENoaWxkKGZvb3Rub3RlKTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ub3Rlc0VsID0gZm9vdG5vdGVzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Y29udmVydGVyfSBudW1iZXJcbiAgICAgKiBAcHJvcGVydHkge2NvbnZlcnRlcn0gZGF0ZVxuICAgICAqL1xuICAgIGNvbnZlcnRlcnM6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJDb252ZXJ0ZXIsXG4gICAgICAgIGludDogbnVtYmVyQ29udmVydGVyLCAvLyBwc2V1ZG8tdHlwZTogcmVhbGx5IGp1c3QgYSBOdW1iZXJcbiAgICAgICAgZmxvYXQ6IG51bWJlckNvbnZlcnRlciwgLy8gcHNldWRvLXR5cGU6IHJlYWxseSBqdXN0IGEgTnVtYmVyXG4gICAgICAgIGRhdGU6IGRhdGVDb252ZXJ0ZXJcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhyb3dzIGVycm9yIGlmIGludmFsaWQgZXhwcmVzc2lvbi5cbiAgICAgKiBDYXVnaHQgYnkge0BsaW5rIEZpbHRlclRyZWUjaW52YWxpZHxGaWx0ZXJUcmVlLnByb3RvdHlwZS5pbnZhbGlkKCl9LlxuICAgICAqXG4gICAgICogQWxzbyBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIGNvbXBpbGF0aW9uIGFjdGlvbnM6XG4gICAgICogKiBDb3BpZXMgYWxsIGB0aGlzLnZpZXdgJyB2YWx1ZXMgZnJvbSB0aGUgRE9NIHRvIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0aWVzIG9mIGB0aGlzYC5cbiAgICAgKiAqIFByZS1zZXRzIGB0aGlzLm9wYCBhbmQgYHRoaXMuY29udmVydGVyYCBmb3IgdXNlIGluIGB0ZXN0YCdzIHRyZWUgd2Fsay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZm9jdXM9dHJ1ZV0gLSBNb3ZlIGZvY3VzIHRvIG9mZmVuZGluZyBjb250cm9sLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9IGlmIHZhbGlkXG4gICAgICogQG1lbWJlck9mIEZpbHRlckxlYWYucHJvdG90eXBlXG4gICAgICovXG4gICAgaW52YWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZWxlbWVudE5hbWUsIGZpZWxkO1xuXG4gICAgICAgIGZvciAoZWxlbWVudE5hbWUgaW4gdGhpcy52aWV3KSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLnZpZXdbZWxlbWVudE5hbWVdLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gY29udHJvbFZhbHVlKGVsKS50cmltKCk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSBvcHRpb25zICYmIG9wdGlvbnMuZm9jdXM7XG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzID09PSB1bmRlZmluZWQgfHwgZm9jdXMpIHsgY2xpY2tJbihlbCk7IH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlsdGVyTm9kZS5GaWx0ZXJUcmVlRXJyb3IoJ0JsYW5rICcgKyBlbGVtZW50TmFtZSArICcgY29udHJvbC5cXG5Db21wbGV0ZSB0aGUgZmlsdGVyIG9yIGRlbGV0ZSBpdC4nLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ29weSBlYWNoIGNvbnRyb2xzJ3MgdmFsdWUgYXMgYSBuZXcgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgICAgICAgIHRoaXNbZWxlbWVudE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wID0gY29uZGl0aW9uYWxzLm9wZXJhdG9yc1t0aGlzLm9wZXJhdG9yXTtcblxuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IHRoaXMuY29udmVydGVyc1sgLy8gdW5kZWZpbmVkIGlmIG5vbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgdGhpcy50eXBlIHx8IC8vIHRoZSBleHByZXNzaW9uJ3MgdHlwZSwgaWYgYW55XG4gICAgICAgICAgICB0aGlzLm9wLnR5cGUgfHwgLy8gdGhlIGV4cHJlc3Npb24ncyBvcGVyYXRvciB0eXBlLCBpZiBhbnlcbiAgICAgICAgICAgIChmaWVsZCA9IHBvcE1lbnUuZmluZEl0ZW0odGhpcy5zY2hlbWEsIHRoaXNbdGhpcy52aWV3LmNvbHVtbl0pKSAmJiBmaWVsZC50eXBlIC8vIHRoZSBleHByZXNzaW9uJ3MgY29sdW1uIHR5cGUsIGlmIGFueVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBwOiBmdW5jdGlvbihkYXRhUm93KSB7IHJldHVybiBkYXRhUm93W3RoaXMuY29sdW1uXTsgfSxcbiAgICBxOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubGl0ZXJhbDsgfSxcblxuICAgIHRlc3Q6IGZ1bmN0aW9uKGRhdGFSb3cpIHtcbiAgICAgICAgdmFyIHAsIHEsIC8vIHVudHlwZWQgdmVyc2lvbnMgb2YgYXJnc1xuICAgICAgICAgICAgUCwgUSwgLy8gdHlwZWQgdmVyc2lvbnMgb2YgcCBhbmQgcVxuICAgICAgICAgICAgY29udmVydDtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8ocCA9IHZhbE9yRnVuYyh0aGlzLnAoZGF0YVJvdykpKSA9PT0gdW5kZWZpbmVkIHx8IC8vIFRPRE86IHJpZ2h0IG5vdyBhc3N1bWluZyBhbGwgdmFsdWVzIGFyZSBuYXRpdmVseSBzdHJpbmdzXG4gICAgICAgICAgICAvLyhxID0gdmFsT3JGdW5jKHRoaXMucShkYXRhUm93KSkpID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgIChwID0gdGhpcy5wKGRhdGFSb3cpKSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAocSA9IHRoaXMucShkYXRhUm93KSkgPT09IHVuZGVmaW5lZFxuICAgICAgICApXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IChcbiAgICAgICAgICAgICAgICAoY29udmVydCA9IHRoaXMuY29udmVydGVyKSAmJlxuICAgICAgICAgICAgICAgICFjb252ZXJ0Lm5vdChQID0gY29udmVydC50byhwKSkgJiZcbiAgICAgICAgICAgICAgICAhY29udmVydC5ub3QoUSA9IGNvbnZlcnQudG8ocSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgPyB0aGlzLm9wLnRlc3QoUCwgUSlcbiAgICAgICAgICAgICAgICA6IHRoaXMub3AudGVzdChwICsgJycsIHEgKyAnJyk7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IpIHtcbiAgICAgICAgICAgIHN0YXRlLmVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgIHN0YXRlW2tleV0gPSB0aGlzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hICE9PSB0aGlzLnBhcmVudC5zY2hlbWEpIHtcbiAgICAgICAgICAgIHN0YXRlLnNjaGVtYSA9IHRoaXMuc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc3ludGF4IC0gU2VlIHtAbGluayBGaWx0ZXJUcmVlI2dldFN0YXRlfHN1YnRyZWUgdmVyc2lvbn0gZm9yIG1vcmUgaW5mby5cbiAgICAgKiA+IEZvciBgJ29iamVjdCdgIGFuZCBgJ0pTT04nYCBub3RlIHRoYXQgdGhlIHN1YnRyZWUncyB2ZXJzaW9uIG9mIGBnZXRTdGF0ZWAgd2lsbCBub3QgY2FsbCB0aGlzIGxlYWYgdmVyaXNvbiBvZiBgZ2V0U3RhdGVgIGJlY2F1c2UgdGhlIGZvcm1lciB1c2VzIGB1bnN0cnVuZ2lmeSgpYCBhbmQgYEpTT04uc3RyaW5naWZ5KClgLCByZXNwZWN0aXZlbHksIGJvdGggb2Ygd2hpY2ggcmVjdXJzZSBvbiB0aGVpciBvd24uXG4gICAgICogQG1lbWJlck9mIEZpbHRlckxlYWYucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uIGdldFN0YXRlKG9wdGlvbnMsIHN1Ym9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgc3ludGF4ID0gb3B0aW9ucyAmJiBvcHRpb25zLnN5bnRheCB8fCAnb2JqZWN0JztcblxuICAgICAgICBzd2l0Y2ggKHN5bnRheCkge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzogLy8gc2VlIG5vdGUgYWJvdmVcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnRvSlNPTigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSlNPTic6IC8vIHNlZSBub3RlIGFib3ZlXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkodGhpcywgbnVsbCwgc3Vib3B0aW9ucyAmJiBzdWJvcHRpb25zLnNwYWNlKSB8fCAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1NRTCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5nZXRTeW50YXgoY29uZGl0aW9uYWxzLnNxbE9wZXJhdG9ycyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDUUwnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZ2V0U3ludGF4KGNvbmRpdGlvbmFscy5maWx0ZXJDZWxsT3BlcmF0b3JzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0WzBdID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaWx0ZXJOb2RlLkZpbHRlclRyZWVFcnJvcignVW5rbm93biBzeW50YXggb3B0aW9uIFwiJyArIHN5bnRheFswXSArICdcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0U3ludGF4OiBmdW5jdGlvbihvcGVyYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yc1t0aGlzLm9wZXJhdG9yXS5tYWtlLmNhbGwob3BlcmF0b3JzLCB0aGlzLmNvbHVtbiwgdGhpcy5saXRlcmFsKTtcbiAgICB9LFxuXG5cbiAgICAvKiogQHN1bW1hcnkgSFRNTCBmb3JtIGNvbnRyb2xzIGZhY3RvcnkuXG4gICAgICogQGRlc2MgQ3JlYXRlcyBhbmQgYXBwZW5kcyBhIHRleHQgYm94IG9yIGEgZHJvcC1kb3duLlxuICAgICAqID4gRGVmaW5lZCBvbiB0aGUgRmlsdGVyVHJlZSBwcm90b3R5cGUgZm9yIGFjY2VzcyBieSBkZXJpdmVkIHR5cGVzIChhbHRlcm5hdGUgZmlsdGVyIGVkaXRvcnMpLlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge21lbnVJdGVtW119IFttZW51XSAtIE92ZXJsb2FkczpcbiAgICAgKiAqIElmIG9taXR0ZWQsIHdpbGwgY3JlYXRlIGFuIGA8aW5wdXQvPmAgKHRleHQgYm94KSBlbGVtZW50LlxuICAgICAqICogSWYgY29udGFpbnMgb25seSBhIHNpbmdsZSBvcHRpb24sIHdpbGwgY3JlYXRlIGEgYDxzcGFuPi4uLjwvc3Bhbj5gIGVsZW1lbnQgY29udGFpbmluZyB0aGUgc3RyaW5nIGFuZCBhIGA8aW5wdXQgdHlwZT1oaWRkZW4+YCBjb250YWluaW5nIHRoZSB2YWx1ZS5cbiAgICAgKiAqIE90aGVyd2lzZSwgY3JlYXRlcyBhIGA8c2VsZWN0Pi4uLjwvc2VsZWN0PmAgZWxlbWVudCB3aXRoIHRoZXNlIG1lbnUgaXRlbXMuXG4gICAgICogQHBhcmFtIHtudWxsfHN0cmluZ30gW3Byb21wdD0nJ10gLSBBZGRzIGFuIGluaXRpYWwgYDxvcHRpb24+Li4uPC9vcHRpb24+YCBlbGVtZW50IHRvIHRoZSBkcm9wLWRvd24gd2l0aCB0aGlzIHZhbHVlLCBwYXJlbnRoZXNpemVkLCBhcyBpdHMgYHRleHRgOyBhbmQgZW1wdHkgc3RyaW5nIGFzIGl0cyBgdmFsdWVgLiBPbWl0dGluZyBjcmVhdGVzIGEgYmxhbmsgcHJvbXB0OyBgbnVsbGAgc3VwcHJlc3Nlcy5cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTGVhZi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtYWtlRWxlbWVudDogZnVuY3Rpb24obWVudSwgcHJvbXB0LCBzb3J0KSB7XG4gICAgICAgIHZhciBlbCwgcmVzdWx0LCBvcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9uID0gbWVudSxcbiAgICAgICAgICAgIHRhZ05hbWUgPSBtZW51ID8gJ1NFTEVDVCcgOiAnSU5QVVQnO1xuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiB0aGVyZSB3b3VsZCBiZSBvbmx5IGEgc2luZ2xlIGl0ZW0gaW4gdGhlIGRyb3Bkb3duXG4gICAgICAgIHdoaWxlIChvcHRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5sZW5ndGggPT09IDEgJiYgIXBvcE1lbnUuaXNHcm91cFByb3h5KG9wdGlvblswXSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25bMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICAgIC8vIGhhcmQgdGV4dCB3aGVuIHNpbmdsZSBpdGVtXG4gICAgICAgICAgICBlbCA9IHRlbXBsYXRlKFxuICAgICAgICAgICAgICAgICdsb2NrZWRDb2x1bW4nLFxuICAgICAgICAgICAgICAgIG9wdGlvbi5hbGlhcyB8fCBvcHRpb24ubmFtZSB8fCBvcHRpb24sXG4gICAgICAgICAgICAgICAgb3B0aW9uLm5hbWUgfHwgb3B0aW9uLmFsaWFzIHx8IG9wdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0LFxuICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnQsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IGZ1bmN0aW9uKGdyb3VwTmFtZSkgeyByZXR1cm4gY29uZGl0aW9uYWxzLmdyb3Vwc1tncm91cE5hbWVdOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWwgPSBwb3BNZW51LmJ1aWxkKHRhZ05hbWUsIG1lbnUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGVsLnR5cGUgPT09ICd0ZXh0JyAmJiB0aGlzLmV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZSB8fCBjbGVhblVwQW5kTW92ZU9uLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UpO1xuICAgICAgICAgICAgRmlsdGVyTm9kZS5zZXRXYXJuaW5nQ2xhc3MoZWwpO1xuICAgICAgICAgICAgcmVzdWx0ID0gZWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGVsKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0pO1xuXG4vL2Z1bmN0aW9uIHZhbE9yRnVuYyh2Zikge1xuLy92YXIgcmVzdWx0ID0gKHR5cGVvZiB2ZilbMF0gPT09ICdmJyA/IHZmKCkgOiB2Zjtcbi8vICAgIHJldHVybiByZXN1bHQgfHwgcmVzdWx0ID09PSAwID8gcmVzdWx0IDogJyc7XG4vL31cblxuLyoqIGBjaGFuZ2VgIGV2ZW50IGhhbmRsZXIgZm9yIGFsbCBmb3JtIGNvbnRyb2xzLlxuICogUmVidWlsZHMgdGhlIG9wZXJhdG9yIGRyb3AtZG93biBhcyBuZWVkZWQuXG4gKiBSZW1vdmVzIGVycm9yIENTUyBjbGFzcyBmcm9tIGNvbnRyb2wuXG4gKiBBZGRzIHdhcm5pbmcgQ1NTIGNsYXNzIGZyb20gY29udHJvbCBpZiBibGFuazsgcmVtb3ZlcyBpZiBub3QgYmxhbmsuXG4gKiBBZGRzIHdhcm5pbmcgQ1NTIGNsYXNzIGZyb20gY29udHJvbCBpZiBibGFuazsgcmVtb3ZlcyBpZiBub3QgYmxhbmsuXG4gKiBNb3ZlcyBmb2N1cyB0byBuZXh0IG5vbi1ibGFuayBzaWJsaW5nIGNvbnRyb2wuXG4gKiBAdGhpcyBCb3VuZCB0byB0aGlzIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXBBbmRNb3ZlT24oZXZ0KSB7XG4gICAgdmFyIGVsID0gZXZ0LnRhcmdldDtcblxuICAgIC8vIHJlbW92ZSBgZXJyb3JgIENTUyBjbGFzcywgd2hpY2ggbWF5IGhhdmUgYmVlbiBhZGRlZCBieSBgRmlsdGVyTGVhZi5wcm90b3R5cGUuaW52YWxpZGBcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmaWx0ZXItdHJlZS1lcnJvcicpO1xuXG4gICAgLy8gc2V0IG9yIHJlbW92ZSAnd2FybmluZycgQ1NTIGNsYXNzLCBhcyBwZXIgZWwudmFsdWVcbiAgICBGaWx0ZXJOb2RlLnNldFdhcm5pbmdDbGFzcyhlbCk7XG5cbiAgICBpZiAoZWwgPT09IHRoaXMudmlldy5jb2x1bW4pIHtcbiAgICAgICAgLy8gcmVidWlsZCBvcGVyYXRvciBsaXN0IGFjY29yZGluZyB0byBzZWxlY3RlZCBjb2x1bW4gbmFtZSBvciB0eXBlLCByZXN0b3Jpbmcgc2VsZWN0ZWQgaXRlbVxuICAgICAgICBtYWtlT3BNZW51LmNhbGwodGhpcywgZWwudmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChlbC52YWx1ZSkge1xuICAgICAgICAvLyBmaW5kIG5leHQgc2libGluZyBjb250cm9sLCBpZiBhbnlcbiAgICAgICAgaWYgKCFlbC5tdWx0aXBsZSkge1xuICAgICAgICAgICAgd2hpbGUgKChlbCA9IGVsLm5leHRFbGVtZW50U2libGluZykgJiYgKCEoJ25hbWUnIGluIGVsKSB8fCBlbC52YWx1ZS50cmltKCkgIT09ICcnKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFuZCBjbGljayBpbiBpdCAob3BlbnMgc2VsZWN0IGxpc3QpXG4gICAgICAgIGlmIChlbCAmJiBlbC52YWx1ZS50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICBlbC52YWx1ZSA9ICcnOyAvLyByaWQgb2YgYW55IHdoaXRlIHNwYWNlXG4gICAgICAgICAgICBGaWx0ZXJOb2RlLmNsaWNrSW4oZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyKGV2dCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRPcE1lbnUoY29sdW1uTmFtZSkge1xuICAgIHZhciBjb2x1bW4gPSBwb3BNZW51LmZpbmRJdGVtKHRoaXMuc2NoZW1hLCBjb2x1bW5OYW1lKTtcbiAgICByZXR1cm4gKFxuICAgICAgICAhY29sdW1uICYmIFtdXG4gICAgICAgICAgICB8fFxuICAgICAgICBjb2x1bW4ub3BNZW51XG4gICAgICAgICAgICB8fFxuICAgICAgICB0aGlzLnR5cGVPcE1lbnUgJiYgdGhpcy50eXBlT3BNZW51W2NvbHVtbi50eXBlXVxuICAgICAgICAgICAgfHxcbiAgICAgICAgdGhpcy50cmVlT3BNZW51XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbWFrZU9wTWVudShjb2x1bW5OYW1lKSB7XG4gICAgdmFyIG9wTWVudSA9IGdldE9wTWVudS5jYWxsKHRoaXMsIGNvbHVtbk5hbWUpO1xuXG4gICAgaWYgKG9wTWVudSAhPT0gdGhpcy5vbGRPcE1lbnUpIHtcbiAgICAgICAgdmFyIG5ld09wRHJvcCA9IHRoaXMubWFrZUVsZW1lbnQob3BNZW51LCAnb3BlcmF0b3InKTtcblxuICAgICAgICBuZXdPcERyb3AudmFsdWUgPSB0aGlzLnZpZXcub3BlcmF0b3IudmFsdWU7XG4gICAgICAgIHRoaXMuZWwucmVwbGFjZUNoaWxkKG5ld09wRHJvcCwgdGhpcy52aWV3Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy52aWV3Lm9wZXJhdG9yID0gbmV3T3BEcm9wO1xuXG4gICAgICAgIEZpbHRlck5vZGUuc2V0V2FybmluZ0NsYXNzKG5ld09wRHJvcCk7XG5cbiAgICAgICAgdGhpcy5vcE1lbnUgPSBvcE1lbnU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbGlja0luKGVsKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnZmlsdGVyLXRyZWUtZXJyb3InKTtcbiAgICAgICAgRmlsdGVyTm9kZS5jbGlja0luKGVsKTtcbiAgICB9LCAwKTtcbn1cblxuZnVuY3Rpb24gY29udHJvbFZhbHVlKGVsKSB7XG4gICAgdmFyIHZhbHVlLCBpO1xuXG4gICAgc3dpdGNoIChlbC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPVxcJycgKyBlbC5uYW1lICsgJ1xcJ106ZW5hYmxlZDpjaGVja2VkJyk7XG4gICAgICAgICAgICBmb3IgKHZhbHVlID0gW10sIGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGVsW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6XG4gICAgICAgICAgICBlbCA9IGVsLm9wdGlvbnM7XG4gICAgICAgICAgICBmb3IgKHZhbHVlID0gW10sIGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsLmRpc2FibGVkICYmIGVsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goZWxbaV0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YWx1ZSA9IGVsLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJMZWFmO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLW1lJyksIEJhc2UgPSBleHRlbmQuQmFzZTsgZXh0ZW5kLmRlYnVnID0gdHJ1ZTtcblxudmFyIGNzc0luamVjdG9yID0gcmVxdWlyZSgnLi9jc3MnKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcbnZhciBjb25kaXRpb25hbHMgPSByZXF1aXJlKCcuL2NvbmRpdGlvbmFscycpO1xudmFyIHNxbFdoZXJlUGFyc2UgPSByZXF1aXJlKCcuL3NxbC13aGVyZS1wYXJzZScpO1xuXG5cbnZhciBDSElMRFJFTl9UQUcgPSAnT0wnLFxuICAgIENISUxEX1RBRyA9ICdMSSc7XG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBGaWx0ZXJUcmVlT3B0aW9uc09iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtzY2hlbWFdIC0gQSBkZWZhdWx0IGxpc3Qgb2YgY29sdW1uIG5hbWVzIGZvciBmaWVsZCBkcm9wLWRvd25zIG9mIGFsbCBkZXNjZW5kYW50IHRlcm1pbmFsIG5vZGVzLiBPdmVycmlkZXMgYG9wdGlvbnMuc3RhdGUuc2NoZW1hYCAoc2VlKS4gTWF5IGJlIGRlZmluZWQgZm9yIGFueSBub2RlIGFuZCBwZXJ0YWlucyB0byBhbGwgZGVzY2VuZGFudHMgb2YgdGhhdCBub2RlIChpbmNsdWRpbmcgdGVybWluYWwgbm9kZXMpLiBJZiBvbWl0dGVkIChhbmQgbm8gYG93blNjaGVtYWApLCB3aWxsIHVzZSB0aGUgbmVhcmVzdCBhbmNlc3RvciBgc2NoZW1hYCBkZWZpbml0aW9uLiBIb3dldmVyLCBkZXNjZW5kYW50cyB3aXRoIHRoZWlyIG93biBkZWZpbml0aW9uIG9mIGB0eXBlc2Agd2lsbCBvdmVycmlkZSBhbnkgYW5jZXN0b3IgZGVmaW5pdGlvbi5cbiAqXG4gKiA+IFR5cGljYWxseSBvbmx5IHVzZWQgYnkgdGhlIGNhbGxlciBmb3IgdGhlIHRvcC1sZXZlbCAocm9vdCkgdHJlZS5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbb3duU2NoZW1hXSAtIEEgZGVmYXVsdCBsaXN0IG9mIGNvbHVtbiBuYW1lcyBmb3IgZmllbGQgZHJvcC1kb3ducyBvZiBpbW1lZGlhdGUgZGVzY2VuZGFudCB0ZXJtaW5hbCBub2RlcyBfb25seV8uIE92ZXJyaWRlcyBgb3B0aW9ucy5zdGF0ZS5vd25TY2hlbWFgIChzZWUpLlxuICpcbiAqIEFsdGhvdWdoIGJvdGggYG9wdGlvbnMuc2NoZW1hYCBhbmQgYG9wdGlvbnMub3duU2NoZW1hYCBhcmUgbm90YXRlZCBhcyBvcHRpb25hbCBoZXJlaW4sIGJ5IHRoZSB0aW1lIGEgdGVybWluYWwgbm9kZSB0cmllcyB0byByZW5kZXIgYSBzY2hlbWEgZHJvcC1kb3duLCBhIGBzY2hlbWFgIGxpc3QgX211c3RfIGJlIGRlZmluZWQgdGhyb3VnaCAoaW4gb3JkZXIgb2YgcHJpb3JpdHkpOlxuICpcbiAqICogVGVybWluYWwgbm9kZSdzIG93biBgb3B0aW9ucy5zY2hlbWFgIChvciBgb3B0aW9ucy5zdGF0ZS5zY2hlbWFgKSBkZWZpbml0aW9uLlxuICogKiBUZXJtaW5hbCBub2RlJ3MgcGFyZW50IG5vZGUncyBgb3B0aW9uLm93blNjaGVtYWAgKG9yIGBvcHRpb24uc3RhdGUubm9kZXNGaWVsZHNgKSBkZWZpbml0aW9uLlxuICogKiBBbnkgb2YgdGVybWluYWwgbm9kZSdzIGFuY2VzdG9yJ3MgYG9wdGlvbnMuc2NoZW1hYCAob3IgYG9wdGlvbnMuc3RhdGUuc2NoZW1hYCkgZGVmaW5pdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdHxzdHJpbmd9IFtzdGF0ZV0gLSBBIGRhdGEgc3RydWN0dXJlIHRoYXQgZGVzY3JpYmVzIGEgdHJlZSwgc3VidHJlZSwgb3IgbGVhZiAodGVybWluYWwgbm9kZSk6XG4gKlxuICogKiBNYXkgZGVzY3JpYmUgYSB0ZXJtaW5hbCBub2RlIHdpdGggcHJvcGVydGllczpcbiAqICAgKiBgc2NoZW1hYCAtIE92ZXJyaWRkZW4gb24gaW5zdGFudGlhdGlvbiBieSBgb3B0aW9ucy5zY2hlbWFgLiBJZiBib3RoIHVuc3BlY2lmaWVkLCB1c2VzIHBhcmVudCdzIGRlZmluaXRpb24uXG4gKiAgICogYGVkaXRvcmAgLSBBIHN0cmluZyBpZGVudGlmeWluZyB0aGUgdHlwZSBvZiBjb25kaXRpb25hbC4gTXVzdCBiZSBpbiB0aGUgcGFyZW50IG5vZGUncyB7QGxpbmsgRmlsdGVyVHJlZSNlZGl0b3JzfGVkaXRvcnN9IGhhc2guIElmIG9taXR0ZWQsIGRlZmF1bHRzIHRvIGAnRGVmYXVsdCdgLlxuICogICAqIG1pc2MuIC0gT3RoZXIgcHJvcGVydGllcyBwZWN1bGlhciB0byB0aGlzIGZpbHRlciB0eXBlIChidXQgdHlwaWNhbGx5IGluY2x1ZGluZyBhdCBsZWFzdCBhIGBmaWVsZGAgcHJvcGVydHkpLlxuICogKiBNYXkgZGVzY3JpYmUgYSBub24tdGVybWluYWwgbm9kZSB3aXRoIHByb3BlcnRpZXM6XG4gKiAgICogYHNjaGVtYWAgLSBPdmVycmlkZGVuIG9uIGluc3RhbnRpYXRpb24gYnkgYG9wdGlvbnMuc2NoZW1hYC4gSWYgYm90aCB1bnNwZWNpZmllZCwgdXNlcyBwYXJlbnQncyBkZWZpbml0aW9uLlxuICogICAqIGBvcGVyYXRvcmAgLSBPbmUgb2Yge0BsaW5rIHRyZWVPcGVyYXRvcnN9LlxuICogICAqIGBjaGlsZHJlbmAgLSAgQXJyYXkgY29udGFpbmluZyBhZGRpdGlvbmFsIHRlcm1pbmFsIGFuZCBub24tdGVybWluYWwgbm9kZXMuXG4gKlxuICogSWYgdGhpcyBgb3B0aW9ucy5zdGF0ZWAgb2JqZWN0IGlzIG9taXR0ZWQgYWx0b2dldGhlciwgbG9hZHMgYW4gZW1wdHkgZmlsdGVyLCB3aGljaCBpcyBhIGBGaWx0ZXJUcmVlYCBub2RlIGNvbnNpc3RpbmcgdGhlIGRlZmF1bHQgYG9wZXJhdG9yYCB2YWx1ZSAoYCdvcC1hbmQnYCkuXG4gKlxuICogVGhlIGNvbnN0cnVjdG9yIGF1dG8tZGV0ZWN0cyBgc3RhdGVgJ3MgdHlwZTpcbiAqICAqIEpTT04gc3RyaW5nIHRvIGJlIHBhcnNlZCBieSBgSlNPTi5wYXJzZSgpYCBpbnRvIGEgcGxhaW4gb2JqZWN0XG4gKiAgKiBTUUwgV0hFUkUgY2xhdXNlIHN0cmluZyB0byBiZSBwYXJzZWQgaW50byBhIHBsYWluIG9iamVjdFxuICogICogQ1NTIHNlbGVjdG9yIG9mIGFuIEVsZW1lbnQgd2hvc2UgYHZhbHVlYCBjb250YWlucyBvbmUgb2YgdGhlIGFib3ZlXG4gKiAgKiBwbGFpbiBvYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZWRpdG9yPSdEZWZhdWx0J10gLSBUeXBlIG9mIHNpbXBsZSBleHByZXNzaW9uOyBhIGtleSBpbiB0aGUgRmlsdGVyVHJlZS5wcm90b3R5cGUuZWRpdG9ycyBoYXNoIHdoaWNoIG1hcHMgdG8gYSBzaW1wbGUgZXhwcmVzc2lvbiBjb25zdHJ1Y3Rvciwgd2hpY2ggd2lsbCBiZSBgRmlsdGVyTGVhZmAgb3IgYSBjb25zdHJ1Y3RvciBleHRlbmRlZCBmcm9tIGBGaWx0ZXJMZWFmYC5cbiAqXG4gKiBAcHJvcGVydHkge0ZpbHRlclRyZWV9IFtwYXJlbnRdIC0gVXNlZCBpbnRlcm5hbGx5IHRvIGluc2VydCBlbGVtZW50IHdoZW4gY3JlYXRpbmcgbmVzdGVkIHN1YnRyZWVzLiBPcHRpb25hbCBmb3IgdGhlIHRvcCBsZXZlbCB0cmVlIG9ubHkuIChOb3RlIHRoYXQgeW91IGFyZSByZXNwb25zaWJsZSBmb3IgaW5zZXJ0aW5nIHRoZSB0b3AtbGV2ZWwgYC5lbGAgaW50byB0aGUgRE9NLilcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW2Nzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50XSAtIHBhc3NlZCB0byBjc3NJbnNlcnRcbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBzdW1tYXJ5IEEgbm9kZSBpbiBhIGZpbHRlciB0cmVlLlxuICpcbiAqIEBkZXNjcmlwdGlvbiBBIGZpbHRlciB0cmVlIHJlcHJlc2VudHMgYSBfY29tcGxleCBjb25kaXRpb25hbCBleHByZXNzaW9uXyBhbmQgY29uc2lzdHMgb2YgYSBzaW5nbGUgaW5zdGFuY2Ugb2YgYSB7QGxpbmsgRmlsdGVyVHJlZX0gYXMgdGhlIF9yb290XyBvZiBhbiBfbl8tYXJ5IHRyZWUuXG4gKlxuICogSW4gZ2VuZXJhbCwgZWFjaCBpbnN0YW5jZSBvZiBhIGBGaWx0ZXJOb2RlYCBtYXkgYmU6XG4gKiAqIGEge0BsaW5rIEZpbHRlclRyZWV9LCBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbm9uLXRlcm1pbmFsIG5vZGUgaW4gYSBmaWx0ZXIgdHJlZTtcbiAqICogYSB7QGxpbmsgRmlsdGVyTGVhZn0sIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSB0ZXJtaW5hbCBub2RlIGluIGEgZmlsdGVyIHRyZWU7IG9yXG4gKiAqIGFueSBvdGhlciBvYmplY3QgZXh0ZW5kZWQgZnJvbSBlaXRoZXIgb2YgdGhlIGFib3ZlLlxuICpcbiAqIFRoZSBgRmlsdGVyVHJlZWAgb2JqZWN0IGhhcyBwb2x5bW9ycGhpYyBtZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiB0aGUgZW50aXJlIHRyZWUgdXNpbmcgcmVjdXJzaW9uLiBXaGVuIHRoZSByZWN1cnNpb24gcmVhY2hlcyBhIHRlcm1pbmFsIG5vZGUsIGl0IGNhbGxzIHRoZSBtZXRob2RzIG9uIHRoZSBgRmlsdGVyTGVhZmAgb2JqZWN0IGluc3RlYWQuIENhbGxpbmcgYHRlc3QoKWAgb24gdGhlIHJvb3QgdHJlZSB0aGVyZWZvcmUgcmV0dXJucyBhIGJvb2xlYW4gdGhhdCBkZXRlcm1pbmVzIGlmIHRoZSByb3cgcGFzc2VzIHRocm91Z2ggdGhlIGVudGlyZSBmaWx0ZXIgZXhwcmVzc2lvbiAoYHRydWVgKSBvciBpcyBibG9ja2VkIGJ5IGl0IChgZmFsc2VgKS5cbiAqXG4gKiBUaGUgYEZpbHRlckxlYWZgIG9iamVjdCBpcyB0aGUgZGVmYXVsdCB0eXBlIG9mIHNpbXBsZSBleHByZXNzaW9uLCB3aGljaCBpc1xuICpcbiAqIFRoZSBwcm9ncmFtbWVyIG1heSBkZWZpbmUgYSBuZXcgdHlwZSBvZiBzaW1wbGUgZXhwcmVzc2lvbiBieSBleHRlbmRpbmcgZnJvbSBgRmlsdGVyTGVhZmAuIEFuIGV4YW1wbGUgaXMgdGhlIGBGaWx0ZXJGaWVsZGAgb2JqZWN0LiBTdWNoIGFuIGltcGxlbWVudGF0aW9uIG11c3QgaW5jbHVkZSBtZXRob2RzOlxuICpcbiAqICogU2F2ZSBhbmQgc3Vic2VxdWVudGx5IHJlbG9hZCB0aGUgc3RhdGUgb2YgdGhlIGNvbmRpdGlvbmFsIGFzIGVudGVyZWQgYnkgdGhlIHVzZXIgKGBnZXRTdGF0ZSgpYCBhbmQgYHNldFN0YXRlKClgLCByZXNwZWN0aXZlbHkpLlxuICogKiBDcmVhdGUgdGhlIERPTSBvYmplY3RzIHRoYXQgcmVwcmVzZW50IHRoZSBVSSBmaWx0ZXIgZWRpdG9yIGFuZCByZW5kZXIgdGhlbSB0byB0aGUgVUkgKGBjcmVhdGVWaWV3KClgIGFuZCBgcmVuZGVyKClgLCByZXNwZWN0aXZlbHkpLlxuICogKiBGaWx0ZXIgYSB0YWJsZSBieSBpbXBsZW1lbnRpbmcgb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZzpcbiAqICAgKiBBcHBseSB0aGUgY29uZGl0aW9uYWwgbG9naWMgdG8gYXZhaWxhYmxlIHRhYmxlIHJvdyBkYXRhIChgdGVzdCgpYCkuXG4gKiAgICogQXBwbHkgdGhlIGNvbmRpdGlvbmFsIGxvZ2ljIHRvIGEgcmVtb3RlIGRhdGEtc3RvcmUgYnkgZ2VuZXJhdGluZyBhICoqU1FMKiogb3IgKipRKiogX1dIRVJFXyBjbGF1c2UgKGB0b1NRTCgpYCBhbmQgYHRvUSgpYCwgcmVzcGVjdGl2ZWx5KS5cbiAqXG4gKiBAcHJvcGVydHkge0ZpbHRlck5vZGV9IFtwYXJlbnRdIC0gVW5kZWZpbmVkIG1lYW5zIHRoaXMgaXMgdGhlIHJvb3Qgbm9kZS5cbiAqXG4gKiBAcHJvcGVydHkge0ZpbHRlck5vZGV9IHJvb3QgLSBDb252ZW5pZW5jZSByZWZlcmVuY2UgdG8gdGhlIHJvb3Qgbm9kZS5cbiAqXG4gKiBAcHJvcGVydHkge21lbnVJdGVtW119IHNjaGVtYSAtIENvbHVtbiBzY2hlbWEgdXNlZCBieSBkZXNjZW5kYW50IGxlYWYgbm9kZXMgKGluY2x1ZGluZyB0aGlzIG5vZGUgaWYgaXQgaXMgYSBsZWFmIG5vZGUpIHRvIHJlbmRlciBhIGNvbHVtbiBjaG9pY2UgZHJvcC1kb3duLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZWRpdG9yXSAtIE5hbWUgb2YgZmlsdGVyIGVkaXRvciB1c2VkIGJ5IGRlc2NlbmRhbnQgbGVhZiBub2RlcyAoaW5jbHVkaW5nIHRoaXMgbm9kZSBpZiBpdCBpcyBhIGxlYWYgbm9kZSkuXG4gKlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2V2ZW50SGFuZGxlcl0gLSBFdmVudCBoYW5kbGVyIGZvciBVSSBldmVudHMuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0ZW1wbGF0ZV0gLSBJZGVudGlmaWVzIGVpdGhlcjpcbiAqIDEuIFRoZSB0eXBlIG9mIGEge0BsaW5rIEZpbHRlclRyZWV9IG5vZGUsIHVzZWQgYW1vbmcgb3RoZXIgdGhpbmdzIHRvIHNlbGVjdCBhIHJlbmRlcmluZyB0ZW1wbGF0ZTpcbiAqICAgICogYHVuZGVmaW5lZGAgKG9yIG9taXR0ZWQpIC0gQSBnZW5lcmljIGZpbHRlciB0cmVlIG5vZGUsXG4gKiAgICAqIGAnY29sdW1uRmlsdGVycydgIC0gQSBzcGVjaWFsIHtAbGluayBGaWx0ZXJUcmVlfSBjb250YWluaW5nIF9jb2x1bW4gZmlsdGVyXyBzdWJleHByZXNzaW9uc1xuICogICAgKiBgJ2NvbHVtbkZpbHRlcidgIC0gIEEgc3BlY2lhbCB7QGxpbmsgRmlsdGVyVHJlZX0gY29udGFpbmluZyBob21vZ2VuZW91cyBfY29sdW1uIGZpbHRlcl8gZXhwcmVzc2lvbnMgKGFsbCByZWZlcmVuY2luZyB0aGUgc2FtZSBjb2x1bW4gb24gdGhlIGxlZnQgc2lkZSBvZiB0aGVpciBkeWFkaWMgZXhwcmVzc2lvbnMpLlxuICogMi4gVGhlIGRhdGEgdHlwZSBvZiBhIHtAbGluayBGaWx0ZXJMZWFmfSAodGVybWluYWwpIG5vZGUuXG4gKlxuICogQHByb3BlcnR5IHttZW51SXRlbVtdfSBbdHJlZU9wTWVudT1jb25kaXRpb25hbHMuZGVmYXVsdE9wTWVudV0gLSAgRGVmYXVsdCBvcGVyYXRvciBtZW51IGZvciBhbGwgZGVzY2VuZGFudCBsZWFmIG5vZGVzLlxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbdHlwZU9wTWVudV0gLSBBIGhhc2ggb2YgdHlwZSBuYW1lcy4gRWFjaCBtZW1iZXIgdGh1cyBkZWZpbmVkIGNvbnRhaW5zIGEgc3BlY2lmaWMgb3BlcmF0b3IgbWVudSBmb3IgYWxsIGRlc2NlbmRhbnQgbGVhZiBub2RlcyB0aGF0OlxuICogMS4gZG8gbm90IGhhdmUgdGhlaXIgb3duIG9wZXJhdG9yIG1lbnUgKGBvcE1lbnVgIHByb3BlcnR5KSBvZiB0aGVpciBvd247IGFuZFxuICogMi4gd2hvc2UgY29sdW1ucyByZXNvbHZlIHRvIHRoYXQgdHlwZS5cbiAqXG4gKiBUaGUgdHlwZSBpcyBkZXRlcm1pbmVkIGJ5IChpbiBwcmlvcml0eSBvcmRlcik6XG4gKiAxLiB0aGUgYHR5cGVgIHByb3BlcnR5IG9mIHRoZSB7QGxpbmsgRmlsdGVyTGVhZn07IG9yXG4gKiAyLiB0aGUgYHR5cGVgIHByb3BlcnR5IG9mIHRoZSBlbGVtZW50IGluIHRoZSBuZWFyZXN0IG5vZGUgKGluY2x1ZGluZyB0aGUgbGVhZiBub2RlIGl0c2VsZikgdGhhdCBoYXMgYSBkZWZpbmVkIGBvd25TY2hlbWFgIG9yIGBzY2hlbWFgIGFycmF5IHByb3BlcnR5IHdpdGggYW4gZWxlbWVudCBoYXZpbmcgYSBtYXRjaGluZyBjb2x1bW4gbmFtZS5cbiAqXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBET00gZWxlbWVudCBjcmVhdGVkIGJ5IHRoZSBgcmVuZGVyYCBtZXRob2QgdG8gcmVwcmVzZW50IHRoaXMgbm9kZS4gQ29udGFpbnMgdGhlIGBlbGBzIGZvciBhbGwgY2hpbGQgbm9kZXMgKHdoaWNoIGFyZSB0aGVtc2VsdmVzIHBvaW50ZWQgdG8gYnkgdGhvc2Ugbm9kZXMpLiBUaGlzIGlzIGFsd2F5cyBnZW5lcmF0ZWQgYnV0IGlzIG9ubHkgaW4gdGhlIHBhZ2UgRE9NIGlmIHlvdSBwdXQgaXQgdGhlcmUuXG4gKi9cblxudmFyIEZpbHRlck5vZGUgPSBCYXNlLmV4dGVuZCh7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXRlID0gb3B0aW9ucyAmJiBvcHRpb25zLnN0YXRlICYmIHBhcnNlU3RhdGVTdHJpbmcob3B0aW9ucy5zdGF0ZSksXG4gICAgICAgICAgICBwYXJlbnQgPSBvcHRpb25zICYmIG9wdGlvbnMucGFyZW50O1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMucm9vdCA9IHBhcmVudCAmJiBwYXJlbnQucm9vdCB8fCB0aGlzO1xuXG4gICAgICAgIHRoaXMucm9vdC5zdHlsZXNoZWV0ID0gdGhpcy5yb290LnN0eWxlc2hlZXQgfHxcbiAgICAgICAgICAgIGNzc0luamVjdG9yKG9wdGlvbnMgJiYgb3B0aW9ucy5jc3NTdHlsZXNoZWV0UmVmZXJlbmNlRWxlbWVudCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGVhY2ggc3RhbmRhcmQgb3B0aW9uIGZyb20gYG9wdGlvbnNgIG9yIGBzdGF0ZWAgb3IgYHBhcmVudGAgKHdoZXJldmVyIGl0J3MgZGVmaW5lZCBmaXJzdCwgaWYgYW55d2hlcmUpXG4gICAgICAgIF8oRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hKS5lYWNoKGZ1bmN0aW9uKG9wdGlvblNjaGVtYSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhb3B0aW9uU2NoZW1hLmlnbm9yZSkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBvcHRpb25zICYmIG9wdGlvbnNba2V5XSB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSAmJiBzdGF0ZVtrZXldIHx8XG4gICAgICAgICAgICAgICAgICAgICFvcHRpb25TY2hlbWEub3duICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCAmJiBwYXJlbnRba2V5XSB8fCAvLyByZWZlcmVuY2UgcGFyZW50IHZhbHVlIG5vdyBzbyB3ZSBkb24ndCBoYXZlIHRvIHNlYXJjaCB1cCB0aGUgdHJlZSBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2NoZW1hLmRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZltrZXldID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY29weSBhbGwgcmVtYWluaW5nIG9wdGlvbnMgZGlyZWN0bHkgdG8gdGhlIG5ldyBpbnN0YW5jZSwgb3ZlcnJpZGluZyBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWUgaW4gdGhlIHByb3RvdHlwZVxuICAgICAgICBfKG9wdGlvbnMpLmVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaWYgKCFGaWx0ZXJOb2RlLm9wdGlvbnNTY2hlbWFba2V5XSkge1xuICAgICAgICAgICAgICAgIHNlbGZba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlLCBvcHRpb25zKTsgLy8gZm9yd2FyZCBgb3B0aW9ucy5iZWdgIGFuZCBgb3B0aW9ucy5lbmRgIGZvciB1c2UgYnkgYHNxbFdoZXJlUGFyc2UoKWBcbiAgICB9LFxuXG4gICAgLyoqIEluc2VydCBlYWNoIHN1YnRyZWUgaW50byBpdHMgcGFyZW50IG5vZGUgYWxvbmcgd2l0aCBhIFwiZGVsZXRlXCIgYnV0dG9uLlxuICAgICAqID4gVGhlIHJvb3QgdHJlZSBpcyBoYXMgbm8gcGFyZW50IGFuZCBpcyBpbnNlcnRlZCBpbnRvIHRoZSBET00gYnkgdGhlIGluc3RhbnRpYXRpbmcgY29kZSAod2l0aG91dCBhIGRlbGV0ZSBidXR0b24pLlxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdmFyIG5ld0xpc3RJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChDSElMRF9UQUcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5ub3Rlc0VsKSB7XG4gICAgICAgICAgICAgICAgbmV3TGlzdEl0ZW0uYXBwZW5kQ2hpbGQodGhpcy5ub3Rlc0VsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEodGhpcy5zdGF0ZSAmJiB0aGlzLnN0YXRlLmxvY2tlZCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSB0ZW1wbGF0ZSgncmVtb3ZlQnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnJlbW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBuZXdMaXN0SXRlbS5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld0xpc3RJdGVtLmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5lbC5xdWVyeVNlbGVjdG9yKENISUxEUkVOX1RBRykuYXBwZW5kQ2hpbGQobmV3TGlzdEl0ZW0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldFN0YXRlOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb2xkRWwgPSB0aGlzLmVsO1xuICAgICAgICB0aGlzLnN0YXRlID0gcGFyc2VTdGF0ZVN0cmluZyhzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY3JlYXRlVmlldygpO1xuICAgICAgICB0aGlzLmxvYWRTdGF0ZSgpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICBpZiAob2xkRWwpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbCA9IHRoaXMuZWw7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBvbGRFbCA9IG9sZEVsLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbmV3RWwgPSBuZXdFbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2xkRWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3RWwsIG9sZEVsKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogUmVtb3ZlIGJvdGg6XG4gICAgICogKiBgdGhpc2AgZmlsdGVyIG5vZGUgZnJvbSBpdCdzIGBwYXJlbnRgJ3MgYGNoaWxkcmVuYCBjb2xsZWN0aW9uOyBhbmRcbiAgICAgKiAqIGB0aGlzYCBmaWx0ZXIgbm9kZSdzIGBlbGAncyBjb250YWluZXIgKGFsd2F5cyBhIGA8bGk+YCBlbGVtZW50KSBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudC5cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXIoeyB0eXBlOiAnZGVsZXRlJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnBlcnNpc3QgfHwgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZSgpOyAvLyBhbHdheXMgdGhlIGNvbnRhaW5pbmcgPGxpPiB0YWdcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShub2RlLmNoaWxkcmVuLmluZGV4T2YodGhpcyksIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkZpbHRlck5vZGUub3B0aW9uc1NjaGVtYSA9IHtcblxuICAgIGNzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50OiB7IGlnbm9yZTogdHJ1ZSB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IERlZmF1bHQgY29sdW1uIHNjaGVtYSBmb3IgY29sdW1uIGRyb3AtZG93bnMgb2YgZGlyZWN0IGRlc2NlbmRhbnQgbGVhZiBub2RlcyBvbmx5LlxuICAgICAqIEBkZXNjID4gVGhpcyBkb2NzIGVudHJ5IGRlc2NyaWJlcyBhIHByb3BlcnR5IGluIHRoZSBGaWx0ZXJOb2RlIHByb3RvdHlwZS4gSXQgZG9lcyBub3QgZGVzY3JpYmUgdGhlIG9wdGlvbnNTY2hlbWEgcHJvcGVydHkgKGRlc3BpdGUgaXQncyBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGNvZGUpLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTm9kZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBvd25TY2hlbWE6IHsgb3duOiB0cnVlIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgRGVmYXVsdCBjb2x1bW4gc2NoZW1hIGZvciBjb2x1bW4gZHJvcC1kb3ducyBvZiBhbGwgZGVzY2VuZGFudCBsZWFmIG5vZGVzLlxuICAgICAqIEBkZXNjID4gVGhpcyBkb2NzIGVudHJ5IGRlc2NyaWJlcyBhIHByb3BlcnR5IGluIHRoZSBGaWx0ZXJOb2RlIHByb3RvdHlwZS4gSXQgZG9lcyBub3QgZGVzY3JpYmUgdGhlIG9wdGlvbnNTY2hlbWEgcHJvcGVydHkgKGRlc3BpdGUgaXQncyBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGNvZGUpLlxuICAgICAqIEB0eXBlIHttZW51SXRlbVtdfVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJOb2RlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNjaGVtYToge30sXG5cbiAgICAvKiogQHN1bW1hcnkgVHlwZSBvZiBmaWx0ZXIgZWRpdG9yLlxuICAgICAqIEBkZXNjID4gVGhpcyBkb2NzIGVudHJ5IGRlc2NyaWJlcyBhIHByb3BlcnR5IGluIHRoZSBGaWx0ZXJOb2RlIHByb3RvdHlwZS4gSXQgZG9lcyBub3QgZGVzY3JpYmUgdGhlIG9wdGlvbnNTY2hlbWEgcHJvcGVydHkgKGRlc3BpdGUgaXQncyBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGNvZGUpLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIEZpbHRlck5vZGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZWRpdG9yOiB7fSxcblxuICAgIC8qKiBAc3VtbWFyeSBFdmVudCBoYW5kbGVyIGZvciBVSSBldmVudHMuXG4gICAgICogQGRlc2MgPiBUaGlzIGRvY3MgZW50cnkgZGVzY3JpYmVzIGEgcHJvcGVydHkgaW4gdGhlIEZpbHRlck5vZGUgcHJvdG90eXBlLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgb3B0aW9uc1NjaGVtYSBwcm9wZXJ0eSAoZGVzcGl0ZSBpdCdzIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgY29kZSkuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTm9kZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBldmVudEhhbmRsZXI6IHt9LFxuXG4gICAgdHlwZTogeyBvd246IHRydWUgfSxcblxuICAgIHBlcnNpc3Q6IHsgb3duOiB0cnVlIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgT3ZlcnJpZGUgb3BlcmF0b3IgbGlzdCBhdCBhbnkgbm9kZS5cbiAgICAgKiBAZGVzYyA+IFRoaXMgZG9jcyBlbnRyeSBkZXNjcmliZXMgYSBwcm9wZXJ0eSBpbiB0aGUgRmlsdGVyTm9kZSBwcm90b3R5cGUuIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBvcHRpb25zU2NoZW1hIHByb3BlcnR5IChkZXNwaXRlIGl0J3MgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBjb2RlKS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICogQG1lbWJlck9mIEZpbHRlck5vZGUucHJvdG90eXBlXG4gICAgICovXG4gICAgdHJlZU9wTWVudTogeyBkZWZhdWx0OiBjb25kaXRpb25hbHMuZGVmYXVsdE9wTWVudSB9LFxuXG4gICAgdHlwZU9wTWVudToge30sXG5cbiAgICBzb3J0Q29sdW1uTWVudToge31cbn07XG5cbkZpbHRlck5vZGUuc2V0V2FybmluZ0NsYXNzID0gZnVuY3Rpb24oZWwsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHZhbHVlID0gZWwudmFsdWU7XG4gICAgfVxuICAgIGVsLmNsYXNzTGlzdFt2YWx1ZSA/ICdyZW1vdmUnIDogJ2FkZCddKCdmaWx0ZXItdHJlZS13YXJuaW5nJyk7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuZnVuY3Rpb24gRmlsdGVyVHJlZUVycm9yKG1lc3NhZ2UsIG5vZGUpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG59XG5GaWx0ZXJUcmVlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuRmlsdGVyVHJlZUVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0ZpbHRlclRyZWVFcnJvcic7XG5GaWx0ZXJOb2RlLkZpbHRlclRyZWVFcnJvciA9IEZpbHRlclRyZWVFcnJvcjtcblxuRmlsdGVyTm9kZS5jbGlja0luID0gZnVuY3Rpb24oZWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgICAgaWYgKGVsLnRhZ05hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBlbC5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KCdtb3VzZWRvd24nKSk7IH0sIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciByZVNlbGVjdG9yID0gL15bI1xcLl0/XFx3KyhcXHMqWyBcXC5cXC18KisjOn5eJD5dK1xccypcXHcrLiopPyQvO1xudmFyIHJlSlNPTiA9IC9eXFxzKltcXFtcXHtdLztcblxuLyoqXG4gKlxuICogQHBhcmFtIHt1bmRlZmluZWR8c3RyaW5nfG9iamVjdH0gc3RhdGUgLSBNYXkgYmUgb25lIG9mOlxuICogKiBGaWx0ZXItdHJlZSBzdGF0ZSBvYmplY3Q6XG4gKiAgIFJldHVybiBhcyBpcy5cbiAqICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGZpbHRlci10cmVlIHN0YXRlIG9iamVjdCAoSlNPTiBvciBTUUwsIGF1dG8tZGV0ZWN0ZWQpOlxuICogICBQYXJzZSB0aGUgc3RyaW5nIGFuZCByZXR1cm4gYW4gYWN0dWFsIGZpbHRlci10cmVlIHN0YXRlIG9iamVjdC5cbiAqICogU3RyaW5nIENTUyBzZWxlY3RvciAoYXV0by1kZXRlY3RlZCkgb2YgYSBIVE1MIGZvcm0gY29udHJvbCB3aXRoIGEgYHZhbHVlYCBjb250YWluaW5nIHRoZSBhYm92ZTpcbiAqICAgUGFyc2UgYHZhbHVlYCBhbmQgcmV0dXJuIGFuIGFjdHVhbCBmaWx0ZXItdHJlZSBzdGF0ZSBvYmplY3QuXG4gKiAqIGB1bmRlZmluZWRgIChvciBhbnkgb3RoZXIgZmFsc3kgdmFsdWUpOlxuICogICBSZXR1cm4gYXMgaXMuIChVbmRlZmluZWQgc3RhdGUgcmVwcmVzZW50cyBhbiBuZXcgZW1wdHkgRmlsdGVyTm9kZSBvYmplY3QuKVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5zeW50YXhdIC0gTWF5IGJlIGAnSlNPTidgIG9yIGAnU1FMJ2AgdG8gb3ZlcnJpZGUgYXV0by1kZXRlY3Rpb25cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBmaWx0ZXItdHJlZSBzdGF0ZSBvYmplY3Q7IG9yIHRocm93cyBlcnJvciBpZiB1bmtub3duIG9yIGludmFsaWQgc3ludGF4XG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RhdGVTdHJpbmcoc3RhdGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChyZVNlbGVjdG9yLnRlc3Qoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHN0YXRlKS52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN5bnRheCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zeW50YXggfHxcbiAgICAgICAgICAgICAgICByZUpTT04udGVzdChzdGF0ZSkgJiYgJ0pTT04nO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHN5bnRheCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0pTT04nOlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBKU09OLnBhcnNlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaWx0ZXJUcmVlRXJyb3IoJ0pTT04gcGFyc2VyOiAnICsgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NRTCc6XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHNxbFdoZXJlUGFyc2Uoc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpbHRlclRyZWVFcnJvcignU1FMIFdIRVJFIGNsYXVzZSBwYXJzZXI6ICcgKyBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpbHRlclRyZWVFcnJvcignVW5leHBlY3RlZCBpbnB1dCBzdGF0ZS4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJOb2RlO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8vIFRoaXMgaXMgdGhlIG1haW4gZmlsZSwgdXNhYmxlIGFzIGlzLCBzdWNoIGFzIGJ5IC90ZXN0L2luZGV4LmpzLlxuXG4vLyBGb3IgbnBtOiByZXF1aXJlIHRoaXMgZmlsZVxuLy8gRm9yIENETjogZ3VscGZpbGUuanMgYnJvd3NlcmlmaWVzIHRoaXMgZmlsZSB3aXRoIHNvdXJjZW1hcCB0byAvYnVpbGQvZmlsdGVyLXRyZWUuanMgYW5kIHVnbGlmaWVkIHdpdGhvdXQgc291cmNlbWFwIHRvIC9idWlsZC9maWx0ZXItdHJlZS5taW4uanMuIFRoZSBDRE4gaXMgaHR0cHM6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwb3BNZW51ID0gcmVxdWlyZSgncG9wLW1lbnUnKTtcbnZhciB1bnN0cnVuZ2lmeSA9IHJlcXVpcmUoJ3Vuc3RydW5naWZ5Jyk7XG5cbnZhciBGaWx0ZXJOb2RlID0gcmVxdWlyZSgnLi9GaWx0ZXJOb2RlJyk7XG52YXIgVGVybWluYWxOb2RlID0gcmVxdWlyZSgnLi9GaWx0ZXJMZWFmJyk7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG52YXIgb3BlcmF0b3JzID0gcmVxdWlyZSgnLi90cmVlLW9wZXJhdG9ycycpO1xudmFyIGNvbmRpdGlvbmFscyA9IHJlcXVpcmUoJy4vY29uZGl0aW9uYWxzJyk7XG5cblxudmFyIG9yZGluYWwgPSAwO1xuXG4vKiogQGNvbnN0cnVjdG9yXG4gKiBAc3VtbWFyeSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbm9uLXRlcm1pbmFsIG5vZGUgaW4gYSBmaWx0ZXIgdHJlZS5cbiAqIEBkZXNjIEEgbm9kZSByZXByZXNlbnRpbmcgYSBzdWJleHByZXNzaW9uIGluIHRoZSBmaWx0ZXIgZXhwcmVzc2lvbi4gTWF5IGJlIHRob3VnaHQgb2YgYXMgYSBwYXJlbnRoZXNpemVkIHN1YmV4cHJlc3Npb24gaW4gYWxnZWJyYWljIGV4cHJlc3Npb24gc3ludGF4LiBJdCdzIGNoaWxkcmVuIG1heSBiZSBlaXRoZXIge0BsaW5rIEZpbHRlckxlYWZ9KiAodGVybWluYWwpIG5vZGVzIG9yIG90aGVyIChuZXN0ZWQpIGBGaWx0ZXJUcmVlYCogc3ViZXhwcmVzc2lvbnMuIFRoZSBzYW1lIGBvcGVyYXRvcmAgdG8gYmUgYXBwbGllZCB0byBhbGwgaXRzIGBjaGlsZHJlbmAuXG4gKlxuICogXFwqIE9yIG90aGVyIFwiY2xhc3NcIiBvYmplY3RzIGV4dGVuZGVkIHRoZXJlZnJvbS5cbiAqXG4gKiBIYXMgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIHtAbGluayBGaWx0ZXJOb2RlfSAoc2VlKSwgcGx1cyB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgcHJvcGVydGllczpcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29wZXJhdG9yPSdvcC1hbmQnXSAtIE9uZSBvZjpcbiAqICogYCdvcC1hbmQnYFxuICogKiBgJ29wLW9yJ2BcbiAqICogYCdvcC1ub3InYFxuICpcbiAqIEBwcm9wZXJ0eSB7RmlsdGVyTm9kZVtdfSBjaGlsZHJlbiAtIEEgbGlzdCBvZiBkZXNjZW5kYW50cyBvZiB0aGlzIG5vZGUuIE1heSBiZSBhbnkgbnVtYmVyIGluY2x1ZGluZyAwIChub25lOyBlbXB0eSkuXG4gKlxuICogQHByb3BlcnR5IHtmaWVsZEl0ZW1bXX0gW293blNjaGVtYV0gLSBDb2x1bW4gbWVudSB0byBiZSB1c2VkIG9ubHkgYnkgbGVhZiBub2RlcyB0aGF0IGFyZSBjaGlsZHJlbiAoZGlyZWN0IGRlc2NlbmRhbnRzKSBvZiB0aGlzIG5vZGUuXG4gKlxuICogTm90ZXM6XG4gKiAxLiBBIGBGaWx0ZXJUcmVlYCBtYXkgY29uc2lzdCBvZiBhIHNpbmdsZSBsZWFmLCBpbiB3aGljaCBjYXNlIHRoZSBgb3BlcmF0b3JgIGlzIG5vdCB1c2VkIGFuZCBtYXkgYmUgbGVmdCB1bmRlZmluZWQuIEhvd2V2ZXIsIGlmIGEgc2Vjb25kIGNoaWxkIGlzIGFkZGVkIGFuZCB0aGUgb3BlcmF0b3IgaXMgc3RpbGwgdW5kZWZpbmVkLCBpdCB3aWxsIGJlIHNldCB0byB0aGUgZGVmYXVsdCAoYCdvcC1hbmQnYCkuXG4gKiAyLiBUaGUgb3JkZXIgb2YgdGhlIGNoaWxkcmVuIGlzIHVuZGVmaW5lZCBhcyBhbGwgb3BlcmF0b3JzIGFyZSBjb21tdXRhdGl2ZS4gRm9yIHRoZSAnYG9wLW9yYCcgb3BlcmF0b3IsIGV2YWx1YXRpb24gY2Vhc2VzIG9uIHRoZSBmaXJzdCBwb3NpdGl2ZSByZXN1bHQgYW5kIGZvciBlZmZpY2llbmN5LCBhbGwgc2ltcGxlIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIGJlZm9yZSBhbnkgY29tcGxleCBzdWJleHByZXNzaW9ucy5cbiAqIDMuIEEgbmVzdGVkIGBGaWx0ZXJUcmVlYCBpcyBkaXN0aW5ndWlzaGVkIGZyb20gYSBgRmlsdGVyYCBieSB0aGUgcHJlc2VuY2Ugb2YgYSBgY2hpbGRyZW5gIG1lbWJlci5cbiAqIDQuIE5lc3RpbmcgYSBgRmlsdGVyVHJlZWAgY29udGFpbmluZyBhIHNpbmdsZSBjaGlsZCBpcyB2YWxpZCAoYWxiZWl0IHBvaW50bGVzcykuXG4gKi9cbnZhciBGaWx0ZXJUcmVlID0gRmlsdGVyTm9kZS5leHRlbmQoJ0ZpbHRlclRyZWUnLCB7XG5cbiAgICAvKipcbiAgICAgKiBIYXNoIG9mIGNvbnN0cnVjdG9ycyBmb3Igb2JqZWN0cyB0aGF0IGV4dGVuZCBmcm9tIHtAbGluayBGaWx0ZXJMZWFmfSwgd2hpY2ggaXMgdGhlIGBEZWZhdWx0YCBtZW1iZXIgaGVyZS5cbiAgICAgKlxuICAgICAqIEFkZCBhZGRpdGlvbmFsIGVkaXRvcnMgdG8gdGhpcyBvYmplY3QgKGluIHRoZSBwcm90b3R5cGUpIHByaW9yIHRvIGluc3RhbnRpYXRpbmcgYSBsZWFmIG5vZGUgdGhhdCByZWZlcnMgdG8gaXQuXG4gICAgICpcbiAgICAgKiBBbHRlcm5hdGl2ZWx5LCB5b3UgY291bGQgYWxzbyBvdmVycmlkZSB0aGUgZW50aXJlIG9iamVjdCBpbiB5b3VyIGluc3RhbmNlIGJ1dCBpZiB5b3UgZG8gc28sIGJlIHN1cmUgdG8gaW5jbHVkZSB0aGUgZGVmYXVsdCBlZGl0b3IsIGZvciBleGFtcGxlOiBgeyBEZWZhdWx0OiBGaWx0ZXJUcmVlLnByb3RvdHlwZS5lZGl0b3JzLkRlZmF1bHQsIC4uLiB9YC4gKE9uZSB3YXkgb2Ygb3ZlcnJpZGluZyB3b3VsZCBiZSB0byBpbmNsdWRlIHN1Y2ggYW4gb2JqZWN0IGluIGFuIGBlZGl0b3JzYCBtZW1iZXIgb2YgdGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3Igb24gaW5zdGFudGlhdGlvbi4gVGhpcyB3b3JrcyBiZWNhdXNlIGFsbCBtaXNjZWxsYW5lb3VzIG1lbWJlcnMgYXJlIHNpbXBseSBjb3BpZWQgdG8gdGhlIG5ldyBpbnN0YW5jZS4gTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggdGhlIHN0YW5kYXJkIG9wdGlvbiBgZWRpdG9yYCB3aGljaCBpcyBhIHN0cmluZyBjb250YWluaW5nIGEga2V5IGZyb20gdGhpcyBoYXNoIGFuZCB0ZWxscyB0aGUgbGVhZiBub2RlIHdoYXQgdHlwZSB0byB1c2UuKVxuICAgICAqL1xuICAgIGVkaXRvcnM6IHtcbiAgICAgICAgRGVmYXVsdDogVGVybWluYWxOb2RlXG4gICAgfSxcblxuICAgIGFkZEVkaXRvcjogZnVuY3Rpb24oa2V5LCBvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JzW2tleV0gPSBUZXJtaW5hbE5vZGUuZXh0ZW5kKG92ZXJyaWRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5lZGl0b3JzW2tleV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY3JlYXRlVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWwgPSB0ZW1wbGF0ZShcbiAgICAgICAgICAgIHRoaXMudHlwZSB8fCAnc3VidHJlZScsXG4gICAgICAgICAgICArK29yZGluYWwsXG4gICAgICAgICAgICBwb3BNZW51LmZvcm1hdEl0ZW0odGhpcy5zY2hlbWFbMF0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBleHByZXNzaW9uIGVkaXRvcnMgdG8gdGhlIFwiYWRkIG5ld1wiIGRyb3AtZG93blxuICAgICAgICB2YXIgYWRkTmV3Q3RybCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignOnNjb3BlPnNlbGVjdCcpO1xuICAgICAgICBpZiAoYWRkTmV3Q3RybCkge1xuICAgICAgICAgICAgdmFyIHN1Ym1lbnUsIG9wdGdyb3VwLFxuICAgICAgICAgICAgICAgIGVkaXRvcnMgPSB0aGlzLmVkaXRvcnM7XG5cbiAgICAgICAgICAgIGlmIChhZGROZXdDdHJsLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmVkaXRvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBlZGl0b3IgaXMgdGhlIG9ubHkgb3B0aW9uIGJlc2lkZXMgdGhlIG51bGwgcHJvbXB0IG9wdGlvblxuICAgICAgICAgICAgICAgIC8vIHNvIG1ha2UgaXQgdGggZW9ubHkgaXRlbSBpIHRoZSBkcm9wLWRvd25cbiAgICAgICAgICAgICAgICBzdWJtZW51ID0gYWRkTmV3Q3RybDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgYXJlIGFscmVhZHkgb3B0aW9ucyBhbmQvb3IgbXVsdGlwbGUgZWRpdG9yc1xuICAgICAgICAgICAgICAgIHN1Ym1lbnUgPSBvcHRncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGdyb3VwJyk7XG4gICAgICAgICAgICAgICAgb3B0Z3JvdXAubGFiZWwgPSAnQ29uZGl0aW9uYWwgRXhwcmVzc2lvbnMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoZWRpdG9ycykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVkaXRvcnNba2V5XS5wcm90b3R5cGUubmFtZSB8fCBrZXk7XG4gICAgICAgICAgICAgICAgc3VibWVudS5hcHBlbmRDaGlsZChuZXcgT3B0aW9uKG5hbWUsIGtleSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICBhZGROZXdDdHJsLmFkZChvcHRncm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uY2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uVHJlZU9wQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIGxvYWRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgdGhpcy5vcGVyYXRvciA9ICdvcC1hbmQnO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIGBzdGF0ZS5jaGlsZHJlbmAgKHJlcXVpcmVkKVxuICAgICAgICAgICAgaWYgKCEoc3RhdGUuY2hpbGRyZW4gaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlsdGVyTm9kZS5GaWx0ZXJUcmVlRXJyb3IoJ0V4cGVjdGVkIGBjaGlsZHJlbmAgcHJvcGVydHkgdG8gYmUgYW4gYXJyYXkuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIGBzdGF0ZS5vcGVyYXRvcmAgKGlmIGdpdmVuKVxuICAgICAgICAgICAgaWYgKHN0YXRlLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRvcnNbc3RhdGUub3BlcmF0b3JdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaWx0ZXJOb2RlLkZpbHRlclRyZWVFcnJvcignRXhwZWN0ZWQgYG9wZXJhdG9yYCBwcm9wZXJ0eSB0byBiZSBvbmUgb2Y6ICcgKyBPYmplY3Qua2V5cyhvcGVyYXRvcnMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gc3RhdGUub3BlcmF0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLmNoaWxkcmVuLmZvckVhY2godGhpcy5hZGQuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJhZGlvQnV0dG9uID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCc6c2NvcGUgPiBsYWJlbCA+IGlucHV0W3ZhbHVlPScgKyB0aGlzLm9wZXJhdG9yICsgJ10nKSxcbiAgICAgICAgICAgIGFkZEZpbHRlckxpbmsgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5maWx0ZXItdHJlZS1hZGQtY29uZGl0aW9uYWwnKTtcblxuICAgICAgICBpZiAocmFkaW9CdXR0b24pIHtcbiAgICAgICAgICAgIHJhZGlvQnV0dG9uLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgb25UcmVlT3BDbGljay5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHJhZGlvQnV0dG9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gbXVsdGlwbGUgZmlsdGVyIGVkaXRvcnMgYXZhaWxhYmxlLCBzaW11bGF0ZSBjbGljayBvbiB0aGUgbmV3IFwiYWRkIGNvbmRpdGlvbmFsXCIgbGlua1xuICAgICAgICBpZiAoYWRkRmlsdGVyTGluayAmJiAhdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgT2JqZWN0LmtleXModGhpcy5lZGl0b3JzKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzWydmaWx0ZXItdHJlZS1hZGQtY29uZGl0aW9uYWwnXSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBhZGRGaWx0ZXJMaW5rXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByb2NlZWQgd2l0aCByZW5kZXJcbiAgICAgICAgRmlsdGVyTm9kZS5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBub2RlIGFzIHBlciBgc3RhdGVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXtzdGF0ZTp7fX1dIC0gTWF5IGJlIG9uZSBvZjpcbiAgICAgKlxuICAgICAqICogYW4gYG9wdGlvbnNgIG9iamVjdCBjb250YWluaW5nIGEgYHN0YXRlYCBwcm9wZXJ0eVxuICAgICAqICogYSBgc3RhdGVgIG9iamVjdCAoaW4gd2hpY2ggY2FzZSB0aGVyZSBpcyBubyBgb3B0aW9uc2Agb2JqZWN0KVxuICAgICAqXG4gICAgICogSW4gYW55IGNhc2UsIHJlc3VsdGluZyBgc3RhdGVgIG9iamVjdCBtYXkgYmUgZWl0aGVyLi4uXG4gICAgICogKiBBIG5ldyBzdWJ0cmVlIChoYXMgYSBgY2hpbGRyZW5gIHByb3BlcnR5KTpcbiAgICAgKiAgIEFkZCBhIG5ldyBgRmlsdGVyVHJlZWAgbm9kZS5cbiAgICAgKiAqIEEgbmV3IGxlYWYgKG5vIGBjaGlsZHJlbmAgcHJvcGVydHkpOiBhZGQgYSBuZXcgYEZpbHRlckxlYWZgIG5vZGU6XG4gICAgICogICAqIElmIHRoZXJlIGlzIGFuIGBlZGl0b3JgIHByb3BlcnR5OlxuICAgICAqICAgICBBZGQgbGVhZiB1c2luZyBgdGhpcy5lZGl0b3JzW3N0YXRlLmVkaXRvcl1gLlxuICAgICAqICAgKiBPdGhlcndpc2UgKGluY2x1ZGluZyB0aGUgY2FzZSB3aGVyZSBgc3RhdGVgIGlzIHVuZGVmaW5lZCk6XG4gICAgICogICAgIEFkZCBsZWFmIHVzaW5nIGB0aGlzLmVkaXRvcnMuRGVmYXVsdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvY3VzPWZhbHNlXSBDYWxsIGludmFsaWQoKSBhZnRlciBpbnNlcnRpbmcgdG8gZm9jdXMgb24gZmlyc3QgYmxhbmsgY29udHJvbCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJOb2RlfSBUaGUgbmV3IG5vZGUuXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciwgbmV3Tm9kZTtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RhdGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IHN0YXRlOiBvcHRpb25zIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zdGF0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgQ29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQ29uc3RydWN0b3IgPSB0aGlzLmVkaXRvcnNbb3B0aW9ucy5zdGF0ZS5lZGl0b3IgfHwgJ0RlZmF1bHQnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMucGFyZW50ID0gdGhpcztcbiAgICAgICAgbmV3Tm9kZSA9IG5ldyBDb25zdHJ1Y3RvcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmZvY3VzKSB7XG4gICAgICAgICAgICAvLyBmb2N1cyBvbiBibGFuayBjb250cm9sIGEgYmVhdCBhZnRlciBhZGRpbmcgaXRcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IG5ld05vZGUuaW52YWxpZCh7IGFsZXJ0OiBmYWxzZSB9KTsgfSwgNzUwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvYmplY3QucmV0aHJvdz1mYWxzZV0gLSBUaHJvdyAoZG8gbm90IGNhdGNoKSBgRmlsdGVyVHJlZUVycm9yYHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb2JqZWN0LmFsZXJ0PXRydWVdIC0gQW5ub3VuY2UgZXJyb3IgdmlhIHdpbmRvdy5hbGVydCgpIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb2JqZWN0LmZvY3VzPXRydWVdIC0gUGxhY2UgdGhlIGZvY3VzIG9uIHRoZSBvZmZlbmRpbmcgY29udHJvbCBhbmQgZ2l2ZSBpdCBlcnJvciBjb2xvci5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEZpbHRlclRyZWVFcnJvcn0gYHVuZGVmaW5lZGAgaWYgdmFsaWQ7IG9yIHRoZSBjYXVnaHQgYEZpbHRlclRyZWVFcnJvcmAgaWYgZXJyb3IuXG4gICAgICovXG4gICAgaW52YWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgYWxlcnQgPSBvcHRpb25zLmFsZXJ0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5hbGVydCxcbiAgICAgICAgICAgIHJldGhyb3cgPSBvcHRpb25zLnJldGhyb3csXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGludmFsaWQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBlcnI7XG5cbiAgICAgICAgICAgIC8vIFRocm93IHdoZW4gcmVxdWVzdGVkIE9SIHdoZW4gdW5leHBlY3RlZCAobm90IGEgZmlsdGVyIHRyZWUgZXJyb3IpXG4gICAgICAgICAgICBpZiAocmV0aHJvdyB8fCAhKGVyciBpbnN0YW5jZW9mIEZpbHRlck5vZGUuRmlsdGVyVHJlZUVycm9yKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsZXJ0KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFsZXJ0KGVyci5tZXNzYWdlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdChkYXRhUm93KSB7XG4gICAgICAgIHZhciBvcGVyYXRvciA9IG9wZXJhdG9yc1t0aGlzLm9wZXJhdG9yXSxcbiAgICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yLnNlZWQsXG4gICAgICAgICAgICBub0NoaWxkcmVuRGVmaW5lZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBub0NoaWxkcmVuRGVmaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvci5yZWR1Y2UocmVzdWx0LCBjaGlsZC50ZXN0KGRhdGFSb3cpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvci5yZWR1Y2UocmVzdWx0LCB0ZXN0LmNhbGwoY2hpbGQsIGRhdGFSb3cpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gb3BlcmF0b3IuYWJvcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5vQ2hpbGRyZW5EZWZpbmVkIHx8IChvcGVyYXRvci5uZWdhdGUgPyAhcmVzdWx0IDogcmVzdWx0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZpbGVyIChzdWIpdHJlZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3ludGF4PSdvYmplY3QnXSAtIEEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nIGluZGljYXRpbmcgdGhlIGV4cGVjdGVkIHR5cGUgYW5kIGZvcm1hdCBvZiB0aGUgcmV0dXJuIHZhbHVlOlxuICAgICAqICogYCdvYmplY3QnYCAoZGVmYXVsdCkgd2Fsa3MgdGhlIHRyZWUgdXNpbmcgYHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS91bnN0cnVuZ2lmeXx1bnN0cnVuZ2lmeSgpfWAsIHJlc3BlY3RpbmcgYEpTT04uc3RyaW5naWZ5KClgJ3MgXCJ7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9zdHJpbmdpZnkjdG9KU09OKClfYmVoYXZpb3J8dG9KU09OKCkgYmVoYXZpb3J9LFwiIGFuZCByZXR1cm5pbmcgYSBwbGFpbiBvYmplY3Qgc3VpdGFibGUgZm9yIHJlc3VibWl0dGluZyB0byB7QGxpbmsgRmlsdGVyTm9kZSNzZXRTdGF0ZXxzZXRTdGF0ZX0uXG4gICAgICogKiBgJ0pTT04nYCB3YWxrcyB0aGUgdHJlZSB1c2luZyBge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vc3RyaW5naWZ5I3RvSlNPTigpX2JlaGF2aW9yfEpTT04uc3RyaW5naWZ5KCl9YCwgcmV0dXJuaW5nIGEgSlNPTiBzdHJpbmcgYnkgY2FsbGluZyB0b0pTT04gYXQgZXZlcnkgbm9kZS4gU3VpdGFibGUgZm9yIHRleHQtYmFzZWQgc3RvcmFnZSBtZWRpYS5cbiAgICAgKiAqIGAnU1FMJ2Agd2Fsa3MgdGhlIHRyZWUsIHJldHVybmluZyBhIFNRTCB3aGVyZSBjbGF1c2Ugc3RyaW5nLiBTdWl0YWJsZSBmb3IgY3JlYXRpbmcgU1FMIGBTRUxFQ1RgIHN0YXRlbWVudHMuXG4gICAgICogKiBgJ0NRTCdgIHdhbGtzIHRoZSB0cmVlLCByZXR1cm5pbmcgYSBzdHJpbmcgc3VpdGFibGUgZm9yIGEgSHlwZXJncmlkIGZpbHRlciBjZWxsLiBUaGlzIHN5bnRheCBzaG91bGQgb25seSBiZSBjYWxsZWQgZm9yIGZyb20gYSBzdWJ0cmVlIGNvbnRhaW5pbmcgaG9tb2dlbmVvdXMgY29sdW1uIG5hbWVzIGFuZCBubyBzdWJleHByZXNzaW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRpb25zLnNwYWNlXSAtIFdoZW4gYG9wdGlvbnMuc3ludGF4ID09PSAnSlNPTidgLCBmb3J3YXJkZWQgdG8gYEpTT04uc3RyaW5naWZ5YCdzIHRoaXJkIHBhcmFtZXRlciwgYHNwYWNlYCAoc2VlKS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuc3FsSWRRdHNdIC0gV2hlbiBgb3B0aW9ucy5zeW50YXggPT09ICdTUUwnYCwgZm9yd2FyZGVkIHRvIGBjb25kaXRpb25hbHMucHVzaFNxbElkUXRzKClgLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8c3RyaW5nfSBSZXR1cm5zIG9iamVjdCB3aGVuIGBvcHRpb25zLnN5bnRheCA9PT0gJ29iamVjdCdgOyBvdGhlcndpc2UgcmV0dXJucyBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uIGdldFN0YXRlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgc3ludGF4ID0gb3B0aW9ucyAmJiBvcHRpb25zLnN5bnRheCB8fCAnb2JqZWN0JztcblxuICAgICAgICBzd2l0Y2ggKHN5bnRheCkge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1bnN0cnVuZ2lmeS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdKU09OJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCBvcHRpb25zICYmIG9wdGlvbnMuc3BhY2UpIHx8ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdTUUwnOlxuICAgICAgICAgICAgICAgIHZhciBsZXhlbWUgPSBvcGVyYXRvcnNbdGhpcy5vcGVyYXRvcl0uU1FMLFxuICAgICAgICAgICAgICAgICAgICBxdHMgPSAhdGhpcy5wYXJlbnQgJiYgb3B0aW9ucyAmJiBvcHRpb25zLnNxbElkUXRzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHF0cykge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25hbHMucHVzaFNxbElkUXRzKHF0cyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gaWR4ID8gJyAnICsgbGV4ZW1lLm9wICsgJyAnIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IG9wICsgY2hpbGQuZ2V0U3RhdGUob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBvcCArIGdldFN0YXRlLmNhbGwoY2hpbGQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbmFscy5wb3BTcWxJZFF0cygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxleGVtZS5iZWcgKyAocmVzdWx0IHx8ICdOVUxMIElTIE5VTEwnKSArIGxleGVtZS5lbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0NRTCc6XG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gb3BlcmF0b3JzW3RoaXMub3BlcmF0b3JdLmZpbHRlckNlbGwub3A7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICcgKyBvcGVyYXRvciArICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoaWxkLmdldFN0YXRlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlsdGVyTm9kZS5GaWx0ZXJUcmVlRXJyb3IoJ0V4cGVjdGVkIGNvbmRpdGlvbmFsIGJ1dCBmb3VuZCBzdWJleHByZXNzaW9uIChub3Qgc3VwcG9ydGVkIGluIGZpbHRlciBjZWxsIHN5bnRheCkuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlsdGVyTm9kZS5GaWx0ZXJUcmVlRXJyb3IoJ1Vua25vd24gc3ludGF4IG9wdGlvbiBcIicgKyBzeW50YXggKyAnXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICBvcGVyYXRvcjogdGhpcy5vcGVyYXRvcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkeSA9IHRvSlNPTi5jYWxsKGNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFtrZXldICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hW2tleV0ub3duIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkW2tleV0gIT09IGNoaWxkLnBhcmVudFtrZXldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZHlba2V5XSA9IGNoaWxkW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaGlsZHJlbi5wdXNoKHJlYWR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbn0pO1xuXG4vLyBTb21lIGV2ZW50IGhhbmRsZXJzIGJvdW5kIHRvIEZpbHRlclRyZWUgb2JqZWN0XG5cbmZ1bmN0aW9uIG9uY2hhbmdlKGV2dCkgeyAvLyBjYWxsZWQgaW4gY29udGV4dFxuICAgIHZhciBjdHJsID0gZXZ0LnRhcmdldDtcbiAgICBpZiAoY3RybC5wYXJlbnRFbGVtZW50ID09PSB0aGlzLmVsKSB7XG4gICAgICAgIGlmIChjdHJsLnZhbHVlID09PSAnc3ViZXhwJykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKG5ldyBGaWx0ZXJUcmVlKHtcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogeyBlZGl0b3I6IGN0cmwudmFsdWUgfSxcbiAgICAgICAgICAgICAgICBmb2N1czogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3RybC5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uVHJlZU9wQ2xpY2soZXZ0KSB7IC8vIGNhbGxlZCBpbiBjb250ZXh0XG4gICAgdmFyIGN0cmwgPSBldnQudGFyZ2V0O1xuXG4gICAgaWYgKGN0cmwuY2xhc3NOYW1lID09PSAnZmlsdGVyLXRyZWUtb3AtY2hvaWNlJykge1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gY3RybC52YWx1ZTtcblxuICAgICAgICAvLyBkaXNwbGF5IHN0cmlrZS10aHJvdWdoXG4gICAgICAgIHZhciByYWRpb0J1dHRvbnMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xhYmVsPmlucHV0LmZpbHRlci10cmVlLW9wLWNob2ljZVtuYW1lPScgKyBjdHJsLm5hbWUgKyAnXScpO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHJhZGlvQnV0dG9ucywgZnVuY3Rpb24oY3RybCkge1xuICAgICAgICAgICAgY3RybC5wYXJlbnRFbGVtZW50LnN0eWxlLnRleHREZWNvcmF0aW9uID0gY3RybC5jaGVja2VkID8gJ25vbmUnIDogJ2xpbmUtdGhyb3VnaCc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGRpc3BsYXkgb3BlcmF0b3IgYmV0d2VlbiBmaWx0ZXJzIGJ5IGFkZGluZyBvcGVyYXRvciBzdHJpbmcgYXMgYSBDU1MgY2xhc3Mgb2YgdGhpcyB0cmVlXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcGVyYXRvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCh0aGlzLm9wZXJhdG9yKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3dzIGVycm9yIGlmIGludmFsaWQgZXhwcmVzc2lvbiB0cmVlLlxuICogQ2F1Z2h0IGJ5IHtAbGluayBGaWx0ZXJUcmVlI2ludmFsaWR8RmlsdGVyVHJlZS5wcm90b3R5cGUuaW52YWxpZCgpfS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZm9jdXM9dHJ1ZV0gLSBNb3ZlIGZvY3VzIHRvIG9mZmVuZGluZyBjb250cm9sLlxuICogQHJldHVybnMge3VuZGVmaW5lZH0gaWYgdmFsaWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGludmFsaWQob3B0aW9ucykgeyAvLyBjYWxsZWQgaW4gY29udGV4dFxuICAgIC8vaWYgKHRoaXMgaW5zdGFuY2VvZiBGaWx0ZXJUcmVlICYmICF0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIC8vICAgIHRocm93IG5ldyBGaWx0ZXJOb2RlLkZpbHRlclRyZWVFcnJvcignRW1wdHkgc3ViZXhwcmVzc2lvbiAobm8gZmlsdGVycykuJyk7XG4gICAgLy99XG5cbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjaGlsZC5pbnZhbGlkKG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgaW52YWxpZC5jYWxsKGNoaWxkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyVHJlZTtcbiIsIi8qKiBAbW9kdWxlIGNvbmRpdGlvbmFscyAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnZXh0ZW5kLW1lJykuQmFzZTtcbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xudmFyIHJlZ0V4cExJS0UgPSByZXF1aXJlKCdyZWdleHAtbGlrZScpO1xuXG52YXIgSU4gPSAnSU4nLFxuICAgIE5PVF9JTiA9ICdOT1QgJyArIElOLFxuICAgIExJS0UgPSAnTElLRScsXG4gICAgTk9UX0xJS0UgPSAnTk9UICcgKyBMSUtFLFxuICAgIExJS0VfV0lMRF9DQVJEID0gJyUnLFxuICAgIFNRVCA9ICdcXCcnLFxuICAgIFNQQyA9ICcgJyxcbiAgICBOSUwgPSAnJztcblxudmFyIGlkUXQgPSBbXTtcbnB1c2hTcWxJZFF0cyh7XG4gICAgYmVnOiAnXCInLFxuICAgIGVuZDogJ1wiJ1xufSk7XG5mdW5jdGlvbiBwdXNoU3FsSWRRdHMocXRzKSB7XG4gICAgcmV0dXJuIGlkUXQudW5zaGlmdChxdHMpO1xufVxuZnVuY3Rpb24gcG9wU3FsSWRRdHMoKSB7XG4gICAgcmV0dXJuIGlkUXQuc2hpZnQoKTtcbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBPcGVyYXRvcnMgPSBCYXNlLmV4dGVuZCh7XG4gICAgdW5kZWZpbmVkOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgbWFrZTogZnVuY3Rpb24oKSB7IHJldHVybiAnJzsgfVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbmRpdGlvbmFsc35PcGVyYXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgJzwnOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgPCBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLm1ha2VEaWFkaWMoJzwnLCBhLCBiKTsgfVxuICAgIH0sXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb25kaXRpb25hbHN+T3BlcmF0b3JzLnByb3RvdHlwZVxuICAgICAqL1xuICAgICc8PSc6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSA8PSBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLm1ha2VEaWFkaWMoJzw9JywgYSwgYik7IH1cbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb25kaXRpb25hbHN+T3BlcmF0b3JzLnByb3RvdHlwZVxuICAgICAqL1xuICAgICc9Jzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhID09PSBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLm1ha2VEaWFkaWMoJz0nLCBhLCBiKTsgfVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbmRpdGlvbmFsc35PcGVyYXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgJz49Jzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhID49IGI7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHRoaXMubWFrZURpYWRpYygnPj0nLCBhLCBiKTsgfVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbmRpdGlvbmFsc35PcGVyYXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgJz4nOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgPiBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLm1ha2VEaWFkaWMoJz4nLCBhLCBiKTsgfVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbmRpdGlvbmFsc35PcGVyYXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgJ1xcdTIyNjAnOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgIT09IGI7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHRoaXMubWFrZURpYWRpYygnPD4nLCBhLCBiKTsgfVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbmRpdGlvbmFsc35PcGVyYXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgTElLRToge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiByZWdFeHBMSUtFLmNhY2hlZChiLCB0cnVlKS50ZXN0KGEpOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLm1ha2VEaWFkaWMoTElLRSwgYSwgYik7IH0sXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIC8qKiBAdHlwZSB7cmVsYXRpb25hbE9wZXJhdG9yfVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29uZGl0aW9uYWxzfk9wZXJhdG9ycy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICAnTk9UIExJS0UnOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuICFyZWdFeHBMSUtFLmNhY2hlZChiLCB0cnVlKS50ZXN0KGEpOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLm1ha2VEaWFkaWMoTk9UX0xJS0UsIGEsIGIpOyB9LFxuICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbmRpdGlvbmFsc35PcGVyYXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgSU46IHsgLy8gVE9ETzogY3VycmVudGx5IGZvcmNpbmcgc3RyaW5nIHR5cGluZzsgcmV3b3JrIGNhbGxpbmcgY29kZSB0byByZXNwZWN0IGNvbHVtbiB0eXBlXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGluT3AoYSwgYikgPj0gMDsgfSxcbiAgICAgICAgbWFrZTogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gdGhpcy5tYWtlSU4oSU4sIGEsIGIpOyB9LFxuICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbmRpdGlvbmFsc35PcGVyYXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgJ05PVCBJTic6IHsgLy8gVE9ETzogY3VycmVudGx5IGZvcmNpbmcgc3RyaW5nIHR5cGluZzsgcmV3b3JrIGNhbGxpbmcgY29kZSB0byByZXNwZWN0IGNvbHVtbiB0eXBlXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGluT3AoYSwgYikgPCAwOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLm1ha2VJTihOT1RfSU4sIGEsIGIpOyB9LFxuICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbmRpdGlvbmFsc35PcGVyYXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgQ09OVEFJTlM6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gY29udGFpbnNPcChhLCBiKSA+PSAwOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLm1ha2VMSUtFKExJS0VfV0lMRF9DQVJELCBMSUtFX1dJTERfQ0FSRCwgTElLRSwgYSwgYik7IH0sXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIC8qKiBAdHlwZSB7cmVsYXRpb25hbE9wZXJhdG9yfVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29uZGl0aW9uYWxzfk9wZXJhdG9ycy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICAnTk9UIENPTlRBSU5TJzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBjb250YWluc09wKGEsIGIpIDwgMDsgfSxcbiAgICAgICAgbWFrZTogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gdGhpcy5tYWtlTElLRShMSUtFX1dJTERfQ0FSRCwgTElLRV9XSUxEX0NBUkQsIE5PVF9MSUtFLCBhLCBiKTsgfSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb25kaXRpb25hbHN+T3BlcmF0b3JzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIEJFR0lOUzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IGIgPSAoYiArICcnKS50b0xvd2VyQ2FzZSgpOyByZXR1cm4gYmVnaW5zT3AoYSwgYi5sZW5ndGgpID09PSBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLm1ha2VMSUtFKE5JTCwgTElLRV9XSUxEX0NBUkQsIExJS0UsIGEsIGIpOyB9LFxuICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbmRpdGlvbmFsc35PcGVyYXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgJ05PVCBCRUdJTlMnOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgYiA9IChiICsgJycpLnRvTG93ZXJDYXNlKCk7IHJldHVybiBiZWdpbnNPcChhLCBiLmxlbmd0aCkgIT09IGI7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHRoaXMubWFrZUxJS0UoTklMLCBMSUtFX1dJTERfQ0FSRCwgTk9UX0xJS0UsIGEsIGIpOyB9LFxuICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbmRpdGlvbmFsc35PcGVyYXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgRU5EUzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IGIgPSAoYiArICcnKS50b0xvd2VyQ2FzZSgpOyByZXR1cm4gZW5kc09wKGEsIGIubGVuZ3RoKSA9PT0gYjsgfSxcbiAgICAgICAgbWFrZTogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gdGhpcy5tYWtlTElLRShMSUtFX1dJTERfQ0FSRCwgTklMLCBMSUtFLCBhLCBiKTsgfSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb25kaXRpb25hbHN+T3BlcmF0b3JzLnByb3RvdHlwZVxuICAgICAqL1xuICAgICdOT1QgRU5EUyc6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24oYSwgYikgeyBiID0gKGIgKyAnJykudG9Mb3dlckNhc2UoKTsgcmV0dXJuIGVuZHNPcChhLCBiLmxlbmd0aCkgIT09IGI7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHRoaXMubWFrZUxJS0UoTElLRV9XSUxEX0NBUkQsIE5JTCwgTk9UX0xJS0UsIGEsIGIpOyB9LFxuICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbmRpdGlvbmFsc35PcGVyYXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgbWFrZUxJS0U6IHB1cmVWaXJ0dWFsTWV0aG9kLmJpbmQodGhpcywgJ21ha2VMSUtFJyksXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbmRpdGlvbmFsc35PcGVyYXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgbWFrZUlOOiBwdXJlVmlydHVhbE1ldGhvZC5iaW5kKHRoaXMsICdtYWtlSU4nKSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29uZGl0aW9uYWxzfk9wZXJhdG9ycy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtYWtlRGlhZGljOiBwdXJlVmlydHVhbE1ldGhvZC5iaW5kKHRoaXMsICdtYWtlRGlhZGljJylcbn0pO1xuXG4vLyBzb21lIHN5bm9ueW1zXG5PcGVyYXRvcnMucHJvdG90eXBlWydcXHUyMjY0J10gPSBPcGVyYXRvcnMucHJvdG90eXBlWyc8PSddOyAgLy8gVU5JQ09ERSAnTEVTUy1USEFOIE9SIEVRVUFMIFRPJ1xuT3BlcmF0b3JzLnByb3RvdHlwZVsnXFx1MjI2NSddID0gT3BlcmF0b3JzLnByb3RvdHlwZVsnPj0nXTsgIC8vIFVOSUNPREUgJ0dSRUFURVItVEhBTiBPUiBFUVVBTCBUTydcblxuZnVuY3Rpb24gcHVyZVZpcnR1YWxNZXRob2QobmFtZSkge1xuICAgIHRocm93ICdQdXJlIHZpcnR1YWwgbWV0aG9kIGBDb25kaXRpb25hbHMucHJvdG90eXBlLicgKyBuYW1lICsgJ2AgaGFzIG5vIGltcGxlbWVudGF0aW9uIG9uIHRoaXMgaW5zdGFuY2UuJztcbn1cblxuZnVuY3Rpb24gaW5PcChhLCBiKSB7XG4gICAgcmV0dXJuIGJcbiAgICAgICAgLnRyaW0oKSAvLyByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2UgY2hhcnNcbiAgICAgICAgLnJlcGxhY2UoL1xccyosXFxzKi9nLCAnLCcpIC8vIHJlbW92ZSBhbnkgd2hpdGUtc3BhY2UgY2hhcnMgZnJvbSBhcm91bmQgY29tbWFzXG4gICAgICAgIC5zcGxpdCgnLCcpIC8vIHB1dCBpbiBhbiBhcnJheVxuICAgICAgICAuaW5kZXhPZigoYSArICcnKSk7IC8vIHNlYXJjaCBhcnJheSB3aG9sZSBtYXRjaGVzXG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zT3AoYSwgYikge1xuICAgIHJldHVybiAoYSArICcnKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoKGIgKyAnJykudG9Mb3dlckNhc2UoKSk7XG59XG5cbmZ1bmN0aW9uIGJlZ2luc09wKGEsIGxlbmd0aCkge1xuICAgIHJldHVybiAoYSArICcnKS50b0xvd2VyQ2FzZSgpLnN1YnN0cigwLCBsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBlbmRzT3AoYSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIChhICsgJycpLnRvTG93ZXJDYXNlKCkuc3Vic3RyKC1sZW5ndGgsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHNxRXNjKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvJy9nLCBTUVQgKyBTUVQpO1xufVxuXG5mdW5jdGlvbiBnZXRTcWxTdHJpbmcoc3RyaW5nKSB7XG4gICAgcmV0dXJuIFNRVCArIHNxRXNjKHN0cmluZykgKyBTUVQ7XG59XG5cbmZ1bmN0aW9uIGdldFNxbElkZW50aWZpZXIoaWQpIHtcbiAgICByZXR1cm4gaWRRdFswXS5iZWcgKyBpZCArIGlkUXRbMF0uZW5kO1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgT3BlcmF0b3JzXG4gKiBAcHVibGljXG4gKi9cbnZhciBTcWxPcGVyYXRvcnMgPSBPcGVyYXRvcnMuZXh0ZW5kKHtcbiAgICBtYWtlTElLRTogZnVuY3Rpb24oYmVnLCBlbmQsIG9wLCBhLCBsaWtlUGF0dGVybikge1xuICAgICAgICB2YXIgZXNjYXBlZCA9IGxpa2VQYXR0ZXJuLnJlcGxhY2UoLyhbXFxbXyVcXF1dKS9nLCAnWyQxXScpOyAvLyBlc2NhcGUgYWxsIExJS0UgcmVzZXJ2ZWQgY2hhcnNcbiAgICAgICAgcmV0dXJuIHNxbElkZW50aWZpZXIoYSkgKyBTUEMgKyBvcCArIFNQQyArIGdldFNxbFN0cmluZyhiZWcgKyBlc2NhcGVkICsgZW5kKTtcbiAgICB9LFxuICAgIG1ha2VJTjogZnVuY3Rpb24ob3AsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHNxbElkZW50aWZpZXIoYSkgKyBTUEMgKyBvcCArIFNQQyArICcoJyArIFNRVCArIHNxRXNjKGIpLnJlcGxhY2UoL1xccyosXFxzKi9nLCBTUVQgKyAnLCAnICsgU1FUKSArIFNRVCArICcpJztcbiAgICB9LFxuICAgIG1ha2VEaWFkaWM6IGZ1bmN0aW9uKG9wLCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBzcWxJZGVudGlmaWVyKGEpICsgU1BDICsgb3AgKyBTUEMgKyBzcWxMaXRlcmFsKGIpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBzcWxJZGVudGlmaWVyKHMpIHtcbiAgICByZXR1cm4gcy5saXRlcmFsID8gZ2V0U3FsU3RyaW5nKHMubGl0ZXJhbCkgOiBnZXRTcWxJZGVudGlmaWVyKHMuaWRlbnRpZmllciA/IHMuaWRlbnRpZmllciA6IHMpO1xufVxuXG5mdW5jdGlvbiBzcWxMaXRlcmFsKHMpIHtcbiAgICByZXR1cm4gcy5pZGVudGlmaWVyID8gZ2V0U3FsSWRlbnRpZmllcihzLmlkZW50aWZpZXIpIDogZ2V0U3FsU3RyaW5nKHMubGl0ZXJhbCA/IHMubGl0ZXJhbCA6IHMpO1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgT3BlcmF0b3JzXG4gKi9cbnZhciBGaWx0ZXJDZWxsT3BlcmF0b3JzID0gT3BlcmF0b3JzLmV4dGVuZCh7XG4gICAgbWFrZUxJS0U6IGZ1bmN0aW9uKGJlZywgZW5kLCBvcCwgYSwgbGlrZVBhdHRlcm4pIHtcbiAgICAgICAgdmFyIGVzY2FwZWQgPSBsaWtlUGF0dGVybi5yZXBsYWNlKC8oW1xcW18lXFxdXSkvZywgJ1skMV0nKTsgLy8gZXNjYXBlIGFsbCBMSUtFIHJlc2VydmVkIGNoYXJzXG4gICAgICAgIHJldHVybiBvcC50b0xvd2VyQ2FzZSgpICsgU1BDICsgYmVnICsgZXNjYXBlZCArIGVuZDtcbiAgICB9LFxuICAgIG1ha2VJTjogZnVuY3Rpb24ob3AsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG9wLnRvTG93ZXJDYXNlKCkgKyBTUEMgKyBiLnJlcGxhY2UoL1xccyosXFxzKi9nLCAnLCcpO1xuICAgIH0sXG4gICAgbWFrZURpYWRpYzogZnVuY3Rpb24ob3AsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG9wICsgYjtcbiAgICB9XG59KTtcblxudmFyIGdyb3VwcyA9IHtcbiAgICBlcXVhbGl0eToge1xuICAgICAgICBsYWJlbDogJ0VxdWFsaXR5JyxcbiAgICAgICAgc3VibWVudTogWyc9J11cbiAgICB9LFxuICAgIGluZXF1YWxpdGllczoge1xuICAgICAgICBsYWJlbDogJ0luZXF1YWxpdGllcycsXG4gICAgICAgIHN1Ym1lbnU6IFtcbiAgICAgICAgICAgICc8JyxcbiAgICAgICAgICAgICdcXHUyMjY0JywgLy8gVU5JQ09ERSAnTEVTUy1USEFOIE9SIEVRVUFMIFRPJzsgb24gYSBNYWMsIHR5cGUgb3B0aW9uLWNvbW1hICjiiaQpXG4gICAgICAgICAgICAnXFx1MjI2MCcsIC8vIFVOSUNPREUgJ05PVCBFUVVBTFMnOyBvbiBhIE1hYywgdHlwZSBvcHRpb24tZXF1YWxzICjiiaApXG4gICAgICAgICAgICAnXFx1MjI2NScsIC8vIFVOSUNPREUgJ0dSRUFURVItVEhBTiBPUiBFUVVBTCBUTyc7IG9uIGEgTWFjLCB0eXBlIG9wdGlvbi1wZXJpb2QgKOKJpSlcbiAgICAgICAgICAgICc+J1xuICAgICAgICBdXG4gICAgfSxcbiAgICBzZXRzOiB7XG4gICAgICAgIGxhYmVsOiAnU2V0IHNjYW5zJyxcbiAgICAgICAgc3VibWVudTogWydJTicsICdOT1QgSU4nXVxuICAgIH0sXG4gICAgc3RyaW5nczoge1xuICAgICAgICBsYWJlbDogJ1N0cmluZyBzY2FucycsXG4gICAgICAgIHN1Ym1lbnU6IFtcbiAgICAgICAgICAgICdDT05UQUlOUycsICdOT1QgQ09OVEFJTlMnLFxuICAgICAgICAgICAgJ0JFR0lOUycsICdOT1QgQkVHSU5TJyxcbiAgICAgICAgICAgICdFTkRTJywgJ05PVCBFTkRTJ1xuICAgICAgICBdXG4gICAgfSxcbiAgICBwYXR0ZXJuczoge1xuICAgICAgICBsYWJlbDogJ1BhdHRlcm4gc2NhbnMnLFxuICAgICAgICBzdWJtZW51OiBbJ0xJS0UnLCAnTk9UIExJS0UnXVxuICAgIH1cbn07XG5cbi8vIGFkZCBhIGBuYW1lYCBwcm9wIHRvIGVhY2ggZ3JvdXBcbl8oZ3JvdXBzKS5lYWNoKGZ1bmN0aW9uKGdyb3VwLCBrZXkpIHsgZ3JvdXAubmFtZSA9IGtleTsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6Y29uZGl0aW9uYWxzfk9wZXJhdG9yc31cbiAgICAgKi9cbiAgICBvcGVyYXRvcnM6IG5ldyBPcGVyYXRvcnMoKSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6Y29uZGl0aW9uYWxzflNxbE9wZXJhdG9yc31cbiAgICAgKi9cbiAgICBzcWxPcGVyYXRvcnM6IG5ldyBTcWxPcGVyYXRvcnMoKSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6Y29uZGl0aW9uYWxzfkZpbHRlckNlbGxPcGVyYXRvcnN9XG4gICAgICovXG4gICAgZmlsdGVyQ2VsbE9wZXJhdG9yczogbmV3IEZpbHRlckNlbGxPcGVyYXRvcnMoKSxcblxuICAgIC8qKiBIYXNoIG9mIGxvZ2ljYWwgb3BlcmF0b3IgZ3JvdXBzIGZvciBidWlsZGluZyB5b3VyIG93biBvcGVyYXRvciBkcm9wLWRvd25zLlxuICAgICAqIEVhY2ggZ3JvdXAgaXMgYSB7QGxpbmsgbWVudUl0ZW19IG9iamVjdC4qXG4gICAgICpcbiAgICAgKiBcXCogRm9yIHRoZXNlIGdyb3VwcyB3ZSdyZSB1c2luZyB0aGUgXCJhcnJheSBvZiBzdHJpbmdzXCIgdmFyaWFudCBvZiBgbWVudUl0ZW1gLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgZ3JvdXBzOiBncm91cHMsXG5cbiAgICAvKiogRGVmYXVsdCBvcGVyYXRvciBtZW51IHdoZW4gY29uc2lzdGluZyBvZiBhbGwgb2YgdGhlIGdyb3VwcyBpbiB7QGxpbmsgbW9kdWxlOmNvbmRpdGlvbmFscy5ncm91cHN8Z3JvdXBzfS4gVGhpcyBtZW51IGlzIHVzZWQgd2hlbiBub25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgb3RoZXJ3aXNlIGRlZmluZWQ6XG4gICAgICogKiBUaGUgYG9wTWVudWAgcHJvcGVydHkgb2YgdGhlIGNvbHVtbi4qXG4gICAgICogKiBUaGUgZW50cnkgaW4gdGhlIG5vZGUncyBgdHlwZU9wTWVudWAgaGFzaCBjb3JyZXNwb25kaW5nIHRvIHRoZSBgdHlwZWAgcHJvcGVydHkgb2YgdGhlIGNvbHVtbi4qXG4gICAgICogKiBUaGUgbm9kZSdzIGB0cmVlT3BNZW51YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBcXCogVGhlIHBocmFzZSBfb2YgdGhlIGNvbHVtbl8gYXMgdXNlZCBoZXJlIG1lYW5zIGluIHRoZSBlbGVtZW50IG9mIHRoZSBub2RlJ3MgYHNjaGVtYWAgYXJyYXkgbmFtZWQgZm9yIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29sdW1uLlxuICAgICAqIEB0eXBlIHttZW51SXRlbVtdfVxuICAgICAqL1xuICAgIGRlZmF1bHRPcE1lbnU6IFsgLy8gaGllcmFyY2hpY2FsIG1lbnUgb2YgcmVsYXRpb25hbCBvcGVyYXRvcnNcbiAgICAgICAgZ3JvdXBzLmVxdWFsaXR5LFxuICAgICAgICBncm91cHMuaW5lcXVhbGl0aWVzLFxuICAgICAgICBncm91cHMuc2V0cyxcbiAgICAgICAgZ3JvdXBzLnN0cmluZ3MsXG4gICAgICAgIGdyb3Vwcy5wYXR0ZXJuc1xuICAgIF0sXG4gICAgcHVzaFNxbElkUXRzOiBwdXNoU3FsSWRRdHMsXG4gICAgcG9wU3FsSWRRdHM6IHBvcFNxbElkUXRzXG59O1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NvbnRhaW5pbmdFbD1kb2N1bWVudF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9JyddXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N1ZmZpeD0nJ11cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFt0cmFuc2Zvcm1lcj1tdWx0aUxpbmVUcmltXSAtIEZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBlYWNoIGlucHV0IGNvbnRyb2wncyB0ZXh0IHZhbHVlLlxuICovXG5mdW5jdGlvbiBjb3B5QWxsKGNvbnRhaW5pbmdFbCwgcHJlZml4LCBzZXBhcmF0b3IsIHN1ZmZpeCwgdHJhbnNmb3JtZXIpIHtcbiAgICB2YXIgdGV4dHMgPSBbXSwgbGFzdFRleHRFbCwgdGV4dDtcblxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoKGNvbnRhaW5pbmdFbCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChjb3B5QWxsLnNlbGVjdG9yKSwgZnVuY3Rpb24odGV4dEVsKSB7XG4gICAgICAgIHRleHQgPSAodHJhbnNmb3JtZXIgfHwgbXVsdGlMaW5lVHJpbSkodGV4dEVsLnZhbHVlKTtcbiAgICAgICAgaWYgKHRleHQpIHsgdGV4dHMucHVzaCh0ZXh0KTsgfVxuICAgICAgICBsYXN0VGV4dEVsID0gdGV4dEVsO1xuICAgIH0pO1xuXG4gICAgaWYgKGxhc3RUZXh0RWwpIHtcbiAgICAgICAgY29weShsYXN0VGV4dEVsLCAocHJlZml4IHx8ICcnKSArIHRleHRzLmpvaW4oc2VwYXJhdG9yIHx8ICcnKSArIChzdWZmaXggfHwgJycpKTtcbiAgICB9XG59XG5cbmNvcHlBbGwuc2VsZWN0b3IgPSAnaW5wdXQ6bm90KFt0eXBlXSksIGlucHV0W3R5cGU9dGV4dF0sIHRleHRhcmVhJztcblxuLyoqXG4gKiAxLiBUcmltIHRoZSB0ZXh0IGluIHRoZSBnaXZlbiBpbnB1dCBlbGVtZW50XG4gKiAyLiBzZWxlY3QgaXRcbiAqIDMuIGNvcHkgaXQgdG8gdGhlIGNsaXBib2FyZFxuICogNC4gZGVzZWxlY3QgaXRcbiAqIDUuIHJldHVybiBpdFxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MVGV4dEFyZWFFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0PWVsLnZhbHVlXSAtIFRleHQgdG8gY29weS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8c3RyaW5nfSBUcmltbWVkIHRleHQgaW4gZWxlbWVudCBvciB1bmRlZmluZWQgaWYgdW5hYmxlIHRvIGNvcHkuXG4gKi9cbmZ1bmN0aW9uIGNvcHkoZWwsIHRleHQpIHtcbiAgICB2YXIgcmVzdWx0LCBsYXN0VGV4dDtcblxuICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGxhc3RUZXh0ID0gZWwudmFsdWU7XG4gICAgICAgIGVsLnZhbHVlID0gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZWwudmFsdWU7XG4gICAgfVxuXG4gICAgZWwudmFsdWUgPSBtdWx0aUxpbmVUcmltKHRleHQpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZWwuc2VsZWN0KCk7XG4gICAgICAgIHJlc3VsdCA9IGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChsYXN0VGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbC52YWx1ZSA9IGxhc3RUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsLmJsdXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbXVsdGlMaW5lVHJpbShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXlxccyogKC4qPylcXHMqJC8sICckMScpO1xufVxuXG5jb3B5LmFsbCA9IGNvcHlBbGw7XG5jb3B5Lm11bHRpTGluZVRyaW0gPSBtdWx0aUxpbmVUcmltO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjc3NJbmplY3RvciA9IHJlcXVpcmUoJ2Nzcy1pbmplY3RvcicpO1xuXG52YXIgY3NzOyAvLyBkZWZpbmVkIGJ5IGNvZGUgaW5zZXJ0ZWQgYnkgZ3VscGZpbGUgYmV0d2VlbiBmb2xsb3dpbmcgY29tbWVudHNcbi8qIGluamVjdDpjc3MgKi9cbmNzcyA9ICcuZmlsdGVyLXRyZWV7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjtmb250LXNpemU6MTBwdDtsaW5lLWhlaWdodDoxLjVlbX0uZmlsdGVyLXRyZWUgbGFiZWx7Zm9udC13ZWlnaHQ6NDAwfS5maWx0ZXItdHJlZSBpbnB1dFt0eXBlPWNoZWNrYm94XSwuZmlsdGVyLXRyZWUgaW5wdXRbdHlwZT1yYWRpb117bGVmdDozcHg7bWFyZ2luLXJpZ2h0OjNweH0uZmlsdGVyLXRyZWUgb2x7bWFyZ2luLXRvcDowfS5maWx0ZXItdHJlZT5zZWxlY3R7ZmxvYXQ6cmlnaHQ7Ym9yZGVyOjFweCBkb3R0ZWQgZ3JleTtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JveC1zaGFkb3c6bm9uZX0uZmlsdGVyLXRyZWUtcmVtb3ZlLWJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoxNXB4O2hlaWdodDoxNXB4O2JvcmRlci1yYWRpdXM6OHB4O2JhY2tncm91bmQtY29sb3I6I2U4ODtmb250LXNpemU6MTEuNXB4O2NvbG9yOiNmZmY7dGV4dC1hbGlnbjpjZW50ZXI7bGluZS1oZWlnaHQ6bm9ybWFsO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7bWFyZ2luLXJpZ2h0OjRweDtjdXJzb3I6cG9pbnRlcn0uZmlsdGVyLXRyZWUtcmVtb3ZlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2NvbG9yOiNlODg7Zm9udC13ZWlnaHQ6NzAwO2JveC1zaGFkb3c6cmVkIDAgMCAycHggaW5zZXR9LmZpbHRlci10cmVlLXJlbW92ZS1idXR0b246OmJlZm9yZXtjb250ZW50OlxcJ1xcXFxkN1xcJ30uZmlsdGVyLXRyZWUgbGk6OmFmdGVye2ZvbnQtc2l6ZTo3MCU7Zm9udC1zdHlsZTppdGFsaWM7Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOiMwODB9LmZpbHRlci10cmVlPm9sPmxpOmxhc3QtY2hpbGQ6OmFmdGVye2Rpc3BsYXk6bm9uZX0ub3AtYW5kPm9sLC5vcC1ub3I+b2wsLm9wLW9yPm9se3BhZGRpbmctbGVmdDo1cHg7bWFyZ2luLWxlZnQ6MjdweH0ub3Atb3I+b2w+bGk6OmFmdGVye21hcmdpbi1sZWZ0OjIuNWVtO2NvbnRlbnQ6XFwn4oCUIE9SIOKAlFxcJ30ub3AtYW5kPm9sPmxpOjphZnRlcnttYXJnaW4tbGVmdDoyLjVlbTtjb250ZW50OlxcJ+KAlCBBTkQg4oCUXFwnfS5vcC1ub3I+b2w+bGk6OmFmdGVye21hcmdpbi1sZWZ0OjIuNWVtO2NvbnRlbnQ6XFwn4oCUIE5PUiDigJRcXCd9LmZpbHRlci10cmVlLWVkaXRvcj4qe2ZvbnQtd2VpZ2h0OjcwMH0uZmlsdGVyLXRyZWUtZWRpdG9yPnNwYW57Zm9udC1zaXplOnNtYWxsZXJ9LmZpbHRlci10cmVlLWVkaXRvcj5pbnB1dFt0eXBlPXRleHRde3dpZHRoOjhlbTtwYWRkaW5nOjFweCA1cHggMnB4fS5maWx0ZXItdHJlZS13YXJuaW5ne2JhY2tncm91bmQtY29sb3I6I2ZmYyFpbXBvcnRhbnQ7Ym9yZGVyLWNvbG9yOiNlZGIhaW1wb3J0YW50O2ZvbnQtd2VpZ2h0OjQwMCFpbXBvcnRhbnR9LmZpbHRlci10cmVlLWVycm9ye2JhY2tncm91bmQtY29sb3I6I2ZjYyFpbXBvcnRhbnQ7Ym9yZGVyLWNvbG9yOiNjOTkhaW1wb3J0YW50O2ZvbnQtd2VpZ2h0OjQwMCFpbXBvcnRhbnR9LmZpbHRlci10cmVlLWRlZmF1bHQ+OmVuYWJsZWR7bWFyZ2luOjAgLjRlbTtiYWNrZ3JvdW5kLWNvbG9yOiNkZGQ7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudH0uZmlsdGVyLXRyZWUuZmlsdGVyLXRyZWUtdHlwZS1jb2x1bW4tZmlsdGVycz5vbD5saTpub3QoOmxhc3QtY2hpbGQpe3BhZGRpbmctYm90dG9tOi43NWVtO2JvcmRlci1ib3R0b206M3B4IGRvdWJsZSAjMDgwO21hcmdpbi1ib3R0b206Ljc1ZW19LmZpbHRlci10cmVlIC5mb290bm90ZXN7bWFyZ2luOjAgMCA2cHg7Zm9udC1zaXplOjhwdDtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6bm9ybWFsO3doaXRlLXNwYWNlOm5vcm1hbDtjb2xvcjojYzAwfS5maWx0ZXItdHJlZSAuZm9vdG5vdGVzPnB7bWFyZ2luOjB9LmZpbHRlci10cmVlIC5mb290bm90ZXM+dWx7bWFyZ2luOi0zcHggMCAwO3BhZGRpbmctbGVmdDoxN3B4O3RleHQtaW5kZXg6LTZweH0uZmlsdGVyLXRyZWUgLmZvb3Rub3Rlcz51bD5saXttYXJnaW46MnB4IDB9LmZpbHRlci10cmVlIC5mb290bm90ZXMgLmZpZWxkLW5hbWUsLmZpbHRlci10cmVlIC5mb290bm90ZXMgLmZpZWxkLXZhbHVle2ZvbnQtd2VpZ2h0OjcwMDtmb250LXN0eWxlOm5vcm1hbH0uZmlsdGVyLXRyZWUgLmZvb3Rub3RlcyAuZmllbGQtdmFsdWV7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO2NvbG9yOiMwMDA7YmFja2dyb3VuZC1jb2xvcjojZGRkO3BhZGRpbmc6MCA1cHg7bWFyZ2luOjAgM3B4O2JvcmRlci1yYWRpdXM6M3B4fS5maWx0ZXItdHJlZS1jaG9vc2Vye3Bvc2l0aW9uOmFic29sdXRlO291dGxpbmU6MDtib3gtc2hhZG93OjVweCA1cHggMTBweCBncmV5O3otaW5kZXg6MDtib3JkZXI6MXB4IHNvbGlkICMwMDA7Ym9yZGVyLXJhZGl1czowIDVweCA1cHg7YmFja2dyb3VuZC1jb2xvcjojZmZmZmUwO2ZvbnQtc3R5bGU6aXRhbGljO2ZvbnQtc2l6ZTo5MCV9LmZpbHRlci10cmVlLWNob29zZXI+b3B0aW9ue3BhZGRpbmc6NHB4IDZweH0uZmlsdGVyLXRyZWUtY2hvb3Nlcj5vcHRpb246bm90KDpsYXN0LWNoaWxkKXtib3JkZXItYm90dG9tOjFweCBkYXNoZWQgIzY2Nn0nO1xuLyogZW5kaW5qZWN0ICovXG5cbm1vZHVsZS5leHBvcnRzID0gY3NzSW5qZWN0b3IuYmluZCh0aGlzLCBjc3MsICdmaWx0ZXItdHJlZS1iYXNlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZU5hbWUsXG4gICAgcmVPcCA9IC9eKCg9fD49P3w8Wz49XT8pfChOT1QgKT8oTElLRXxJTilcXGIpL2ksIC8vIG1hdGNoWzFdXG4gICAgcmVMaXQgPSAvXicoXFxkKyknLyxcbiAgICByZUxpdEFueXdoZXJlID0gLycoXFxkKyknLyxcbiAgICByZUluID0gL15cXCgoLio/KVxcKS8sXG4gICAgcmVCb29sID0gL14oQU5EfE9SKVxcYi9pLFxuICAgIHJlR3JvdXAgPSAvXihOT1QgPyk/XFwoL2k7XG5cbnZhciBTUVQgPSAnXFwnJztcblxudmFyIGxpdGVyYWxzO1xuXG52YXIgaWRRdCA9IFtdO1xucHVzaFNxbElkUXRzKHtcbiAgICBiZWc6ICdcIicsXG4gICAgZW5kOiAnXCInXG59KTtcbmZ1bmN0aW9uIHB1c2hTcWxJZFF0cyhxdHMpIHtcbiAgICByZU5hbWUgPSBuZXcgUmVnRXhwKCdeKCcgKyBxdHMuYmVnICsgJyguKz8pJyArIHF0cy5lbmQgKyAnfChbQS1aX11bQS1aX0BcXFxcJCNdKilcXFxcYiknLCAnaScpOyAvLyBtYXRjaFsyXSB8fCBtYXRjaFszXVxuICAgIHJldHVybiBpZFF0LnVuc2hpZnQocXRzKTtcblxufVxuZnVuY3Rpb24gcG9wU3FsSWRRdHMoKSB7XG4gICAgcmV0dXJuIGlkUXQuc2hpZnQoKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VyKHdoZXJlQ2xhdXNlLCBvcHRpb25zKSB7XG4gICAgdmFyIHdoZXJlVHJlZTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHB1c2hTcWxJZFF0cyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICB3aGVyZVRyZWUgPSB3YWxrKHN0cmlwTGl0ZXJhbHMod2hlcmVDbGF1c2UpKTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHBvcFNxbElkUXRzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdoZXJlVHJlZTtcbn1cbnBhcnNlci5wdXNoU3FsSWRRdHMgPSBwdXNoU3FsSWRRdHM7XG5wYXJzZXIucG9wU3FsSWRRdHMgPSBwb3BTcWxJZFF0cztcblxuZnVuY3Rpb24gd2Fsayh0KSB7XG4gICAgdmFyIG0sIG5hbWUsIG9wLCBhcmcsIGJvb2wsIHRva2VuLCB0b2tlbnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB0ID0gdC50cmltKCk7XG5cbiAgICB3aGlsZSAoaSA8IHQubGVuZ3RoKSB7XG4gICAgICAgIG0gPSB0LnN1YnN0cihpKS5tYXRjaChyZUdyb3VwKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHZhciBub3QgPSAhIW1bMV07XG5cbiAgICAgICAgICAgIGkgKz0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSwgdiA9IDE7IGogPCB0Lmxlbmd0aCAmJiB2OyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAodFtqXSA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgICsrdjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRbal0gPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICAtLXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBcIilcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IHdhbGsodC5zdWJzdHIoaSwgaiAtIDEgLSBpKSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vdCkge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5vcGVyYXRvciAhPT0gJ29wLW9yJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgT1IgaW4gTk9UKC4uLikgc3ViZXhwcmVzc2lvbiBidXQgZm91bmQgJyArIHRva2VuLm9wZXJhdG9yLnN1YnN0cigzKS50b1VwcGVyQ2FzZSgpICsgJy4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbi5vcGVyYXRvciA9ICdvcC1ub3InO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG0gPSB0LnN1YnN0cihpKS5tYXRjaChyZU5hbWUpO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGlkZW50aWZpZXIgb3IgcXVvdGVkIGlkZW50aWZpZXIuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWUgPSBtWzJdIHx8IG1bM107XG4gICAgICAgICAgICBpZiAoIS9eW0EtWl9dL2kudGVzdCh0W2ldKSkgeyBpICs9IDI7IH1cbiAgICAgICAgICAgIGkgKz0gbmFtZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICh0W2ldID09PSAnICcpIHsgKytpOyB9XG4gICAgICAgICAgICBtID0gdC5zdWJzdHIoaSkubWF0Y2gocmVPcCk7XG4gICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgcmVsYXRpb25hbCBvcGVyYXRvci4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBtWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpICs9IG9wLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKHRbaV0gPT09ICcgJykgeyArK2k7IH1cbiAgICAgICAgICAgIGlmIChtWzRdICYmIG1bNF0udG9VcHBlckNhc2UoKSA9PT0gJ0lOJykge1xuICAgICAgICAgICAgICAgIG0gPSB0LnN1YnN0cihpKS5tYXRjaChyZUluKTtcbiAgICAgICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHBhcmVudGhlc2l6ZWQgbGlzdC4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmcgPSBtWzFdO1xuICAgICAgICAgICAgICAgIGkgKz0gYXJnLmxlbmd0aCArIDI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtID0gYXJnLm1hdGNoKHJlTGl0QW55d2hlcmUpKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcucmVwbGFjZShyZUxpdEFueXdoZXJlLCBsaXRlcmFsc1ttWzFdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtID0gdC5zdWJzdHIoaSkubWF0Y2gocmVMaXQpO1xuICAgICAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgc3RyaW5nIGxpdGVyYWwuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJnID0gbVsxXTtcbiAgICAgICAgICAgICAgICBpICs9IGFyZy5sZW5ndGggKyAyO1xuICAgICAgICAgICAgICAgIGFyZyA9IGxpdGVyYWxzW2FyZ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogbmFtZSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogb3AsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbDogYXJnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICAgIGlmIChpIDwgdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0W2ldID09PSAnICcpIHsgKytpOyB9XG4gICAgICAgICAgICBtID0gdC5zdWJzdHIoaSkubWF0Y2gocmVCb29sKTtcbiAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBib29sZWFuIG9wZWFyYXRvci4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9vbCA9IG1bMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGkgKz0gYm9vbC5sZW5ndGg7XG4gICAgICAgICAgICBib29sID0gJ29wLScgKyBib29sO1xuICAgICAgICAgICAgaWYgKHRva2Vucy5vcGVyYXRvciAmJiB0b2tlbnMub3BlcmF0b3IgIT09IGJvb2wpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgc2FtZSBib29sZWFuIG9wZXJhdG9yIHRocm91Z2hvdXQgc3ViZXhwcmVzc2lvbi4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW5zLm9wZXJhdG9yID0gYm9vbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0W2ldID09PSAnICcpIHsgKytpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgdG9rZW5zLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgPyB0b2tlbnNbMF1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB0b2tlbnMub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IHRva2Vuc1xuICAgICAgICAgICAgfVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwTGl0ZXJhbHModCkge1xuICAgIHZhciBpID0gMCwgaiA9IDAsIGs7XG5cbiAgICBsaXRlcmFscyA9IFtdO1xuXG4gICAgd2hpbGUgKChqID0gdC5pbmRleE9mKFNRVCwgaikpID49IDApIHtcbiAgICAgICAgayA9IGo7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGsgPSB0LmluZGV4T2YoU1FULCBrICsgMSk7XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgJyArIFNRVCArICcgKHNpbmdsZSBxdW90ZSkuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodFsrK2tdID09PSBTUVQpO1xuICAgICAgICBsaXRlcmFscy5wdXNoKHQuc2xpY2UoKytqLCAtLWspLnJlcGxhY2UoLycnL2csIFNRVCkpO1xuICAgICAgICB0ID0gdC5zdWJzdHIoMCwgaikgKyBpICsgdC5zdWJzdHIoayk7XG4gICAgICAgIGogPSBqICsgMSArIChpICsgJycpLmxlbmd0aCArIDE7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZXI7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVtcGxleCA9IHJlcXVpcmUoJ3RlbXBsZXgnKTtcblxudmFyIHRlbXBsYXRlcyA9IHtcblxuICAgIHN1YnRyZWU6IGZ1bmN0aW9uKCkge1xuLypcbjxzcGFuIGNsYXNzPVwiZmlsdGVyLXRyZWVcIj5cbiAgICBNYXRjaFxuICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJmaWx0ZXItdHJlZS1vcC1jaG9pY2VcIiBuYW1lPVwidHJlZU9wezF9XCIgdmFsdWU9XCJvcC1vclwiPmFueTwvbGFiZWw+XG4gICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImZpbHRlci10cmVlLW9wLWNob2ljZVwiIG5hbWU9XCJ0cmVlT3B7MX1cIiB2YWx1ZT1cIm9wLWFuZFwiPmFsbDwvbGFiZWw+XG4gICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImZpbHRlci10cmVlLW9wLWNob2ljZVwiIG5hbWU9XCJ0cmVlT3B7MX1cIiB2YWx1ZT1cIm9wLW5vclwiPm5vbmU8L2xhYmVsPlxuICAgIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgPHNlbGVjdD5cbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiPk5ldyBleHByZXNzaW9uJmhlbGxpcDs8L29wdGlvbj5cbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInN1YmV4cFwiIHN0eWxlPVwiYm9yZGVyLWJvdHRvbToxcHggc29saWQgYmxhY2tcIj5TdWJleHByZXNzaW9uPC9vcHRpb24+XG4gICAgPC9zZWxlY3Q+XG4gICAgPG9sPjwvb2w+XG48L3NwYW4+XG4qL1xuICAgIH0sXG5cbiAgICBjb2x1bW5GaWx0ZXI6IGZ1bmN0aW9uKCkge1xuLypcbjxzcGFuIGNsYXNzPVwiZmlsdGVyLXRyZWVcIj5cbiAgICA8c3Ryb25nPjxzcGFuPnsyfSA8L3NwYW4+Y29sdW1uIGZpbHRlciBzdWJleHByZXNzaW9uOjwvc3Ryb25nPjxicj5cbiAgICBNYXRjaFxuICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJmaWx0ZXItdHJlZS1vcC1jaG9pY2VcIiBuYW1lPVwidHJlZU9wezF9XCIgdmFsdWU9XCJvcC1vclwiPmFueTwvbGFiZWw+XG4gICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImZpbHRlci10cmVlLW9wLWNob2ljZVwiIG5hbWU9XCJ0cmVlT3B7MX1cIiB2YWx1ZT1cIm9wLWFuZFwiPmFsbDwvbGFiZWw+XG4gICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImZpbHRlci10cmVlLW9wLWNob2ljZVwiIG5hbWU9XCJ0cmVlT3B7MX1cIiB2YWx1ZT1cIm9wLW5vclwiPm5vbmU8L2xhYmVsPlxuICAgIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgPHNlbGVjdD5cbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiPk5ldyBleHByZXNzaW9uJmhlbGxpcDs8L29wdGlvbj5cbiAgICA8L3NlbGVjdD5cbiAgICA8b2w+PC9vbD5cbjwvc3Bhbj5cbiovXG4gICAgfSxcblxuICAgIGNvbHVtbkZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuLypcbjxzcGFuIGNsYXNzPVwiZmlsdGVyLXRyZWUgZmlsdGVyLXRyZWUtdHlwZS1jb2x1bW4tZmlsdGVyc1wiPlxuICAgIE1hdGNoIDxzdHJvbmc+YWxsPC9zdHJvbmc+IG9mIHRoZSBmb2xsb3dpbmcgY29sdW1uIGZpbHRlcnM6XG4gICAgPG9sPjwvb2w+XG48L3NwYW4+XG4qL1xuICAgIH0sXG5cbiAgICBsb2NrZWRDb2x1bW46IGZ1bmN0aW9uKCkge1xuLypcbjxzcGFuPlxuICAgIHsxOmVuY29kZX1cbiAgICA8aW5wdXQgdHlwZT1cImhpZGRlblwiIHZhbHVlPVwiezJ9XCI+XG48L3NwYW4+XG4qL1xuICAgIH0sXG5cbiAgICAnY29sdW1uLUNRTC1zeW50YXgnOiBmdW5jdGlvbigpIHtcbi8qXG48bGk+XG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjb3B5XCI+PC9idXR0b24+XG4gICAgPGRpdiBjbGFzcz1cImZpbHRlci10cmVlLXJlbW92ZS1idXR0b25cIiB0aXRsZT1cImRlbGV0ZSBjb25kaXRpb25hbFwiPjwvZGl2PlxuICAgIHsxfTpcbiAgICA8aW5wdXQgbmFtZT1cInsyfVwiIGNsYXNzPVwiezR9XCIgdmFsdWU9XCJ7MzplbmNvZGV9XCI+XG48L2xpPlxuKi9cbiAgICB9LFxuXG4gICAgJ2NvbHVtbi1TUUwtc3ludGF4JzogZnVuY3Rpb24oKSB7XG4vKlxuPGxpPlxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY29weVwiPjwvYnV0dG9uPlxuICAgIDxkaXYgY2xhc3M9XCJmaWx0ZXItdHJlZS1yZW1vdmUtYnV0dG9uXCIgdGl0bGU9XCJkZWxldGUgY29uZGl0aW9uYWxcIj48L2Rpdj5cbiAgICB7MX06XG4gICAgPHRleHRhcmVhIG5hbWU9XCJ7Mn1cIiByb3dzPVwiMVwiIGNsYXNzPVwiezR9XCI+ezM6ZW5jb2RlfTwvdGV4dGFyZWE+XG48L2xpPlxuKi9cbiAgICB9LFxuXG4gICAgcmVtb3ZlQnV0dG9uOiBmdW5jdGlvbigpIHtcbi8qXG48ZGl2IGNsYXNzPVwiZmlsdGVyLXRyZWUtcmVtb3ZlLWJ1dHRvblwiIHRpdGxlPVwiZGVsZXRlIGNvbmRpdGlvbmFsXCI+PC9kaXY+XG4qL1xuICAgIH0sXG5cbiAgICBub3RlOiBmdW5jdGlvbigpIHtcbi8qXG48ZGl2IGNsYXNzPVwiZm9vdG5vdGVzXCI+XG4gICAgPGRpdiBjbGFzcz1cImZvb3Rub3RlXCI+PC9kaXY+XG4gICAgPHA+U2VsZWN0IGEgbmV3IHZhbHVlIG9yIGRlbGV0ZSB0aGUgZXhwcmVzc2lvbiBhbHRvZ2V0aGVyLjwvcD5cbjwvZGl2PlxuKi9cbiAgICB9LFxuXG4gICAgbm90ZXM6IGZ1bmN0aW9uKCkge1xuLypcbjxkaXYgY2xhc3M9XCJmb290bm90ZXNcIj5cbiAgIDxwPk5vdGUgdGhlIGZvbGxvd2luZyBlcnJvciBjb25kaXRpb25zOjwvcD5cbiAgIDx1bCBjbGFzcz1cImZvb3Rub3RlXCI+PC91bD5cbiAgIDxwPlNlbGVjdCBuZXcgdmFsdWVzIG9yIGRlbGV0ZSB0aGUgZXhwcmVzc2lvbiBhbHRvZ2V0aGVyLjwvcD5cbjwvZGl2PlxuKi9cbiAgICB9LFxuXG4gICAgb3B0aW9uTWlzc2luZzogZnVuY3Rpb24oKSB7XG4vKlxuVGhlIHJlcXVlc3RlZCB2YWx1ZSBvZiA8c3BhbiBjbGFzcz1cImZpZWxkLW5hbWVcIj57MTplbmNvZGV9PC9zcGFuPlxuKDxzcGFuIGNsYXNzPVwiZmllbGQtdmFsdWVcIj57MjplbmNvZGV9PC9zcGFuPikgaXMgbm90IHZhbGlkLlxuKi9cbiAgICB9XG5cbn07XG5cbnZhciBleHRyYWN0ID0gL1xcL1xcKlxccyooW15dKz8pXFxzK1xcKlxcLy87IC8vIGZpbmRzIHRoZSBzdHJpbmcgaW5zaWRlIHRoZSAvKiAuLi4gKi87IHRoZSBncm91cCBleGNsdWRlcyB0aGUgd2hpdGVzcGFjZVxudmFyIGVuY29kZXJzID0gL1xceyhcXGQrKVxcOmVuY29kZVxcfS9nO1xuXG5mdW5jdGlvbiBnZXQodGVtcGxhdGVOYW1lKSB7XG4gICAgdmFyIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgdGV4dCA9IHRlbXBsYXRlc1t0ZW1wbGF0ZU5hbWVdLnRvU3RyaW5nKCkubWF0Y2goZXh0cmFjdClbMV07XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdGV4dCA9IGRyZXNzKHRleHQsIGVuY29kZXJzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdGVtcC50ZXh0Q29udGVudCA9IGFyZ3Nba2V5XTtcbiAgICAgICAgYXJnc1trZXldID0gdGVtcC5pbm5lckhUTUw7XG4gICAgfSk7XG5cbiAgICB0ZW1wLmlubmVySFRNTCA9IHRlbXBsZXguYXBwbHkodGhpcywgW3RleHRdLmNvbmNhdChhcmdzKSk7XG5cbiAgICAvLyBpZiBvbmx5IG9uZSBIVE1MRWxlbWVudCwgcmV0dXJuIGl0OyBvdGhlcndpc2UgZW50aXJlIGxpc3Qgb2Ygbm9kZXNcbiAgICByZXR1cm4gdGVtcC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdGVtcC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSA/IHRlbXAuZmlyc3RDaGlsZCA6IHRlbXAuY2hpbGROb2Rlcztcbn1cblxuZnVuY3Rpb24gZHJlc3ModGV4dCwgcmVnZXgsIHRyYW5zZm9ybWVyKSB7XG4gICAgdmFyIGtleXMsIG1hdGNoZXMgPSB7fTtcblxuICAgIHJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChrZXlzID0gcmVnZXguZXhlYyh0ZXh0KSkpIHtcbiAgICAgICAgbWF0Y2hlc1trZXlzWzFdXSA9IHRydWU7XG4gICAgfVxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhtYXRjaGVzKTtcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAga2V5cy5mb3JFYWNoKHRyYW5zZm9ybWVyKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZWdleCwgJ3skMX0nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZWRlZiB7ZnVuY3Rpb259IG9wZXJhdGlvblJlZHVjZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcFxuICogQHBhcmFtIHtib29sZWFufSBxXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgb3BlcmF0b3IgdG8gdGhlIHR3byBwYXJhbWV0ZXJzLlxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtvcGVyYXRpb25SZWR1Y2VyfVxuICovXG5mdW5jdGlvbiBBTkQocCwgcSkge1xuICAgIHJldHVybiBwICYmIHE7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtvcGVyYXRpb25SZWR1Y2VyfVxuICovXG5mdW5jdGlvbiBPUihwLCBxKSB7XG4gICAgcmV0dXJuIHAgfHwgcTtcbn1cblxuLyoqIEB0eXBlZGVmIHtvYmVqY3R9IHRyZWVPcGVyYXRvclxuICogQGRlc2MgRWFjaCBgdHJlZU9wZXJhdG9yYCBvYmplY3QgZGVzY3JpYmVzIHR3byB0aGluZ3M6XG4gKlxuICogMS4gSG93IHRvIHRha2UgdGhlIHRlc3QgcmVzdWx0cyBvZiBfbl8gY2hpbGQgbm9kZXMgYnkgYXBwbHlpbmcgdGhlIG9wZXJhdG9yIHRvIGFsbCB0aGUgcmVzdWx0cyB0byBcInJlZHVjZVwiIGl0IGRvd24gdG8gYSBzaW5nbGUgcmVzdWx0LlxuICogMi4gSG93IHRvIGdlbmVyYXRlIFNRTCBXSEVSRSBjbGF1c2Ugc3ludGF4IHRoYXQgYXBwbGllcyB0aGUgb3BlcmF0b3IgdG8gX25fIGNoaWxkIG5vZGVzLlxuICpcbiAqIEBwcm9wZXJ0eSB7b3BlcmF0aW9uUmVkdWNlcn0gcmVkdWNlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNlZWQgLVxuICogQHByb3BlcnR5IHtib29sZWFufSBhYm9ydCAtXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG5lZ2F0ZSAtXG4gKiBAcHJvcGVydHkge3N0cmluZ30gU1FMLm9wIC1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBTUUwuYmVnIC1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBTUUwuZW5kIC1cbiAqL1xuXG4vKiogQSBoYXNoIG9mIHtAbGluayB0cmVlT3BlcmF0b3J9IG9iamVjdHMuXG4gKiBAdHlwZSB7b2JqZWN0fVxuICovXG52YXIgdHJlZU9wZXJhdG9ycyA9IHtcbiAgICAnb3AtYW5kJzoge1xuICAgICAgICByZWR1Y2U6IEFORCxcbiAgICAgICAgc2VlZDogdHJ1ZSxcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICBuZWdhdGU6IGZhbHNlLFxuICAgICAgICBmaWx0ZXJDZWxsOiB7XG4gICAgICAgICAgICBvcDogJ2FuZCdcbiAgICAgICAgfSxcbiAgICAgICAgU1FMOiB7XG4gICAgICAgICAgICBvcDogJ0FORCcsXG4gICAgICAgICAgICBiZWc6ICcoJyxcbiAgICAgICAgICAgIGVuZDogJyknXG4gICAgICAgIH1cbiAgICB9LFxuICAgICdvcC1vcic6IHtcbiAgICAgICAgcmVkdWNlOiBPUixcbiAgICAgICAgc2VlZDogZmFsc2UsXG4gICAgICAgIGFib3J0OiB0cnVlLFxuICAgICAgICBuZWdhdGU6IGZhbHNlLFxuICAgICAgICBmaWx0ZXJDZWxsOiB7XG4gICAgICAgICAgICBvcDogJ29yJ1xuICAgICAgICB9LFxuICAgICAgICBTUUw6IHtcbiAgICAgICAgICAgIG9wOiAnT1InLFxuICAgICAgICAgICAgYmVnOiAnKCcsXG4gICAgICAgICAgICBlbmQ6ICcpJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICAnb3Atbm9yJzoge1xuICAgICAgICByZWR1Y2U6IE9SLFxuICAgICAgICBzZWVkOiBmYWxzZSxcbiAgICAgICAgYWJvcnQ6IHRydWUsXG4gICAgICAgIG5lZ2F0ZTogdHJ1ZSxcbiAgICAgICAgZmlsdGVyQ2VsbDoge1xuICAgICAgICAgICAgb3A6ICdub3InXG4gICAgICAgIH0sXG4gICAgICAgIFNRTDoge1xuICAgICAgICAgICAgb3A6ICdPUicsXG4gICAgICAgICAgICBiZWc6ICdOT1QgKCcsXG4gICAgICAgICAgICBlbmQ6ICcpJ1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmVlT3BlcmF0b3JzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxudmFyIGNzc0luamVjdG9yID0gcmVxdWlyZSgnY3NzLWluamVjdG9yJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEZpbkJhclxuICogQHN1bW1hcnkgQ3JlYXRlIGEgc2Nyb2xsYmFyIG9iamVjdC5cbiAqIEBkZXNjIENyZWF0aW5nIGEgc2Nyb2xsYmFyIGlzIGEgdGhyZWUtc3RlcCBwcm9jZXNzOlxuICpcbiAqIDEuIEluc3RhbnRpYXRlIHRoZSBzY3JvbGxiYXIgb2JqZWN0IGJ5IGNhbGxpbmcgdGhpcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi4gVXBvbiBpbnN0YW50aWF0aW9uLCB0aGUgRE9NIGVsZW1lbnQgZm9yIHRoZSBzY3JvbGxiYXIgKHdpdGggYSBzaW5nbGUgY2hpbGQgZWxlbWVudCBmb3IgdGhlIHNjcm9sbGJhciBcInRodW1iXCIpIGlzIGNyZWF0ZWQgYnV0IGlzIG5vdCBpbnNlcnQgaXQgaW50byB0aGUgRE9NLlxuICogMi4gQWZ0ZXIgaW5zdGFudGlhdGlvbiwgaXQgaXMgdGhlIGNhbGxlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGluc2VydCB0aGUgc2Nyb2xsYmFyLCB7QGxpbmsgRmluQmFyI2Jhcnx0aGlzLmJhcn0sIGludG8gdGhlIERPTS5cbiAqIDMuIEFmdGVyIGluc2VydGlvbiwgdGhlIGNhbGxlciBtdXN0IGNhbGwge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9IGF0IGxlYXN0IG9uY2UgdG8gc2l6ZSBhbmQgcG9zaXRpb24gdGhlIHNjcm9sbGJhciBhbmQgaXRzIHRodW1iLiBBZnRlciB0aGF0LCBgcmVzaXplKClgIHNob3VsZCBhbHNvIGJlIGNhbGxlZCByZXBlYXRlZGx5IG9uIHJlc2l6ZSBldmVudHMgKGFzIHRoZSBjb250ZW50IGVsZW1lbnQgaXMgYmVpbmcgcmVzaXplZCkuXG4gKlxuICogU3VnZ2VzdGVkIGNvbmZpZ3VyYXRpb25zOlxuICogKiBfKipVbmJvdW5kKipfPGJyLz5cbiAqIFRoZSBzY3JvbGxiYXIgc2VydmVzIG1lcmVseSBhcyBhIHNpbXBsZSByYW5nZSAoc2xpZGVyKSBjb250cm9sLiBPbWl0IGJvdGggYG9wdGlvbnMub25jaGFuZ2VgIGFuZCBgb3B0aW9ucy5jb250ZW50YC5cbiAqICogXyoqQm91bmQgdG8gdmlydHVhbCBjb250ZW50IGVsZW1lbnQqKl88YnIvPlxuICogVmlydHVhbCBjb250ZW50IGlzIHByb2plY3RlZCBpbnRvIHRoZSBlbGVtZW50IHVzaW5nIGEgY3VzdG9tIGV2ZW50IGhhbmRsZXIgc3VwcGxpZWQgYnkgdGhlIHByb2dyYW1tZXIgaW4gYG9wdGlvbnMub25jaGFuZ2VgLiBBIHR5cGljYWwgdXNlIGNhc2Ugd291bGQgYmUgdG8gaGFuZGxlIHNjcm9sbGluZyBvZiB0aGUgdmlydHVhbCBjb250ZW50LiBPdGhlciB1c2UgY2FzZXMgaW5jbHVkZSBkYXRhIHRyYW5zZm9ybWF0aW9ucywgZ3JhcGhpY3MgdHJhbnNmb3JtYXRpb25zLCBfZXRjLl9cbiAqICogXyoqQm91bmQgdG8gcmVhbCBjb250ZW50KipfPGJyLz5cbiAqIFNldCBgb3B0aW9ucy5jb250ZW50YCB0byB0aGUgXCJyZWFsXCIgY29udGVudCBlbGVtZW50IGJ1dCBvbWl0IGBvcHRpb25zLm9uY2hhbmdlYC4gVGhpcyB3aWxsIGNhdXNlIHRoZSBzY3JvbGxiYXIgdG8gdXNlIHRoZSBidWlsdC1pbiBldmVudCBoYW5kbGVyIChgdGhpcy5zY3JvbGxSZWFsQ29udGVudGApIHdoaWNoIGltcGxlbWVudHMgc21vb3RoIHNjcm9sbGluZyBvZiB0aGUgY29udGVudCBlbGVtZW50IHdpdGhpbiB0aGUgY29udGFpbmVyLlxuICpcbiAqIEBwYXJhbSB7ZmluYmFyT3B0aW9uc30gW29wdGlvbnM9e31dIC0gT3B0aW9ucyBvYmplY3QuIFNlZSB0aGUgdHlwZSBkZWZpbml0aW9uIGZvciBtZW1iZXIgZGV0YWlscy5cbiAqL1xuZnVuY3Rpb24gRmluQmFyKG9wdGlvbnMpIHtcblxuICAgIC8vIG1ha2UgYm91bmQgdmVyc2lvbnMgb2YgYWxsIHRoZSBtb3VzZSBldmVudCBoYW5kbGVyXG4gICAgdmFyIGJvdW5kID0gdGhpcy5fYm91bmQgPSB7fTtcbiAgICBmb3IgKGtleSBpbiBoYW5kbGVyc1RvQmVCb3VuZCkge1xuICAgICAgICBib3VuZFtrZXldID0gaGFuZGxlcnNUb0JlQm91bmRba2V5XS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHRodW1iXG4gICAgICogQHN1bW1hcnkgVGhlIGdlbmVyYXRlZCBzY3JvbGxiYXIgdGh1bWIgZWxlbWVudC5cbiAgICAgKiBAZGVzYyBUaGUgdGh1bWIgZWxlbWVudCdzIHBhcmVudCBlbGVtZW50IGlzIGFsd2F5cyB0aGUge0BsaW5rIEZpbkJhciNiYXJ8YmFyfSBlbGVtZW50LlxuICAgICAqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyB0eXBpY2FsbHkgcmVmZXJlbmNlZCBpbnRlcm5hbGx5IG9ubHkuIFRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGUgdGh1bWIgZWxlbWVudCBpcyBtYWludGFpbmVkIGJ5IGBfY2FsY1RodW1iKClgLlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgdmFyIHRodW1iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGh1bWIuY2xhc3NMaXN0LmFkZCgndGh1bWInKTtcbiAgICB0aHVtYi5vbmNsaWNrID0gYm91bmQuc2hvcnRTdG9wO1xuICAgIHRodW1iLm9ubW91c2VvdmVyID0gYm91bmQub25tb3VzZW92ZXI7XG4gICAgdGhpcy50aHVtYiA9IHRodW1iO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgYmFyXG4gICAgICogQHN1bW1hcnkgVGhlIGdlbmVyYXRlZCBzY3JvbGxiYXIgZWxlbWVudC5cbiAgICAgKiBAZGVzYyBUaGUgY2FsbGVyIGluc2VydHMgdGhpcyBlbGVtZW50IGludG8gdGhlIERPTSAodHlwaWNhbGx5IGludG8gdGhlIGNvbnRlbnQgY29udGFpbmVyKSBhbmQgdGhlbiBjYWxscyBpdHMge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFRodXMgdGhlIG5vZGUgdHJlZSBpcyB0eXBpY2FsbHk6XG4gICAgICogKiBBICoqY29udGVudCBjb250YWluZXIqKiBlbGVtZW50LCB3aGljaCBjb250YWluczpcbiAgICAgKiAgICAqIFRoZSBjb250ZW50IGVsZW1lbnQocylcbiAgICAgKiAgICAqIFRoaXMgKipzY3JvbGxiYXIgZWxlbWVudCoqLCB3aGljaCBpbiB0dXJuIGNvbnRhaW5zOlxuICAgICAqICAgICAgICAqIFRoZSAqKnRodW1iIGVsZW1lbnQqKlxuICAgICAqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBiYXIuY2xhc3NMaXN0LmFkZCgnZmluYmFyLXZlcnRpY2FsJyk7XG5cbiAgICBiYXIuYXBwZW5kQ2hpbGQodGh1bWIpO1xuICAgIGlmICh0aGlzLnBhZ2luZykge1xuICAgICAgICBiYXIub25jbGljayA9IGJvdW5kLm9uY2xpY2s7XG4gICAgfVxuICAgIHRoaXMuYmFyID0gYmFyO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBwcmVzZXRzXG4gICAgdGhpcy5vcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCc7XG4gICAgdGhpcy5fbWluID0gdGhpcy5faW5kZXggPSAwO1xuICAgIHRoaXMuX21heCA9IDEwMDtcblxuICAgIC8vIG9wdGlvbnNcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcblxuICAgICAgICAgICAgY2FzZSAnaW5kZXgnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgICAgICAgdmFsaWRSYW5nZShvcHRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbiA9IG9wdGlvbi5taW47XG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4ID0gb3B0aW9uLm1heDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gb3B0aW9uLm1heCAtIG9wdGlvbi5taW4gKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAga2V5LmNoYXJBdCgwKSAhPT0gJ18nICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBGaW5CYXIucHJvdG90eXBlW2tleV0gIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGUgcHJvdG90eXBlIGRlZmF1bHRzIGZvciBzdGFuZGFyZCA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dGVuZCB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyAoZm9yIHVzZSBpbiBvbmNoYW5nZSBldmVudCBoYW5kbGVycylcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3NzSW5qZWN0b3IoY3NzRmluQmFycywgJ2ZpbmJhci1iYXNlJywgb3B0aW9ucy5jc3NTdHlsZXNoZWV0UmVmZXJlbmNlRWxlbWVudCk7XG59XG5cbkZpbkJhci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgc2Nyb2xsYmFyIG9yaWVudGF0aW9uLlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IgdG8gZWl0aGVyIGAndmVydGljYWwnYCBvciBgJ2hvcml6b250YWwnYC4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBVc2VmdWwgdmFsdWVzIGFyZSBgJ3ZlcnRpY2FsJ2AgKHRoZSBkZWZhdWx0KSBvciBgJ2hvcml6b250YWwnYC5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSByZXNldHMgYHRoaXMub2hgIGFuZCBgdGhpcy5kZWx0YVByb3BgIGFuZCBjaGFuZ2VzIHRoZSBjbGFzcyBuYW1lcyBzbyBhcyB0byByZXBvc2l0aW9uIHRoZSBzY3JvbGxiYXIgYXMgcGVyIHRoZSBDU1MgcnVsZXMgZm9yIHRoZSBuZXcgb3JpZW50YXRpb24uXG4gICAgICogQGRlZmF1bHQgJ3ZlcnRpY2FsJ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXQgb3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSB0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBuYW1lIG9oXG4gICAgICAgICAqIEBzdW1tYXJ5IDx1Pk88L3U+cmllbnRhdGlvbiA8dT5oPC91PmFzaCBmb3IgdGhpcyBzY3JvbGxiYXIuXG4gICAgICAgICAqIEBkZXNjIFNldCBieSB0aGUgYG9yaWVudGF0aW9uYCBzZXR0ZXIgdG8gZWl0aGVyIHRoZSB2ZXJ0aWNhbCBvciB0aGUgaG9yaXpvbnRhbCBvcmllbnRhdGlvbiBoYXNoLiBUaGUgcHJvcGVydHkgc2hvdWxkIGFsd2F5cyBiZSBzeW5jaHJvbml6ZWQgd2l0aCBgb3JpZW50YXRpb25gOyBkbyBub3QgdXBkYXRlIGRpcmVjdGx5IVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG9iamVjdCBpcyB1c2VkIGludGVybmFsbHkgdG8gYWNjZXNzIHNjcm9sbGJhcnMnIERPTSBlbGVtZW50IHByb3BlcnRpZXMgaW4gYSBnZW5lcmFsaXplZCB3YXkgd2l0aG91dCBuZWVkaW5nIHRvIGNvbnN0YW50bHkgcXVlcnkgdGhlIHNjcm9sbGJhciBvcmllbnRhdGlvbi4gRm9yIGV4YW1wbGUsIGluc3RlYWQgb2YgZXhwbGljaXRseSBjb2RpbmcgYHRoaXMuYmFyLnRvcGAgZm9yIGEgdmVydGljYWwgc2Nyb2xsYmFyIGFuZCBgdGhpcy5iYXIubGVmdGAgZm9yIGEgaG9yaXpvbnRhbCBzY3JvbGxiYXIsIHNpbXBseSBjb2RlIGB0aGlzLmJhclt0aGlzLm9oLmxlYWRpbmddYCBpbnN0ZWFkLiBTZWUgdGhlIHtAbGluayBvcmllbnRhdGlvbkhhc2hUeXBlfSBkZWZpbml0aW9uIGZvciBkZXRhaWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG9iamVjdCBpcyB1c2VmdWwgZXh0ZXJuYWxseSBmb3IgY29kaW5nIGdlbmVyYWxpemVkIHtAbGluayBmaW5iYXJPbkNoYW5nZX0gZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMgdGhhdCBzZXJ2ZSBib3RoIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjcm9sbGJhcnMuXG4gICAgICAgICAqIEB0eXBlIHtvcmllbnRhdGlvbkhhc2hUeXBlfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vaCA9IG9yaWVudGF0aW9uSGFzaGVzW3RoaXMuX29yaWVudGF0aW9uXTtcblxuICAgICAgICBpZiAoIXRoaXMub2gpIHtcbiAgICAgICAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBgb3B0aW9ucy5fb3JpZW50YXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgZGVsdGFQcm9wXG4gICAgICAgICAqIEBzdW1tYXJ5IFRoZSBuYW1lIG9mIHRoZSBgV2hlZWxFdmVudGAgcHJvcGVydHkgdGhpcyBzY3JvbGxiYXIgc2hvdWxkIGxpc3RlbiB0by5cbiAgICAgICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZWZ1bCB2YWx1ZXMgYXJlIGAnZGVsdGFYJ2AsIGAnZGVsdGFZJ2AsIG9yIGAnZGVsdGFaJ2AuIEEgdmFsdWUgb2YgYG51bGxgIG1lYW5zIHRvIGlnbm9yZSBtb3VzZSB3aGVlbCBldmVudHMgZW50aXJlbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBtb3VzZSB3aGVlbCBpcyBvbmUtZGltZW5zaW9uYWwgYW5kIG9ubHkgZW1pdHMgZXZlbnRzIHdpdGggYGRlbHRhWWAgZGF0YS4gVGhpcyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBzbyB0aGF0IHlvdSBjYW4gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb2YgYCdkZWx0YVgnYCB3aXRoIGEgdmFsdWUgb2YgYCdkZWx0YVknYCBvbiB5b3VyIGhvcml6b250YWwgc2Nyb2xsYmFyIHByaW1hcmlseSB0byBhY2NvbW1vZGF0ZSBjZXJ0YWluIFwicGFub3JhbWljXCIgaW50ZXJmYWNlIGRlc2lnbnMgd2hlcmUgdGhlIG1vdXNlIHdoZWVsIHNob3VsZCBjb250cm9sIGhvcml6b250YWwgcmF0aGVyIHRoYW4gdmVydGljYWwgc2Nyb2xsaW5nLiBKdXN0IGdpdmUgYHsgZGVsdGFQcm9wOiAnZGVsdGFZJyB9YCBpbiB5b3VyIGhvcml6b250YWwgc2Nyb2xsYmFyIGluc3RhbnRpYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIENhdmVhdDogTm90ZSB0aGF0IGEgMi1maW5nZXIgZHJhZyBvbiBhbiBBcHBsZSB0cmFja3BhZCBlbWl0cyBldmVudHMgd2l0aCBfYm90aF8gYGRlbHRhWCBgIGFuZCBgZGVsdGFZYCBkYXRhIHNvIHlvdSBtaWdodCB3YW50IHRvIGRlbGF5IG1ha2luZyB0aGUgYWJvdmUgYWRqdXN0bWVudCB1bnRpbCB5b3UgY2FuIGRldGVybWluZSB0aGF0IHlvdSBhcmUgZ2V0dGluZyBZIGRhdGEgb25seSB3aXRoIG5vIFggZGF0YSBhdCBhbGwgKHdoaWNoIGlzIGEgc3VyZSBiZXQgeW91IG9uIGEgbW91c2Ugd2hlZWwgcmF0aGVyIHRoYW4gYSB0cmFja3BhZCkuXG5cbiAgICAgICAgICogQHR5cGUge29iamVjdHxudWxsfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWx0YVByb3AgPSB0aGlzLm9oLmRlbHRhO1xuXG4gICAgICAgIHRoaXMuYmFyLmNsYXNzTmFtZSA9IHRoaXMuYmFyLmNsYXNzTmFtZS5yZXBsYWNlKC8odmVydGljYWx8aG9yaXpvbnRhbCkvZywgb3JpZW50YXRpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLmJhci5zdHlsZS5jc3NUZXh0IHx8IHRoaXMudGh1bWIuc3R5bGUuY3NzVGV4dCkge1xuICAgICAgICAgICAgdGhpcy5iYXIucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgdGhpcy50aHVtYi5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ2FsbGJhY2sgZm9yIHNjcm9sbCBldmVudHMuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvciB2aWEgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC4gQWZ0ZXIgaW5zdGFudGlhdGlvbiwgYHRoaXMub25jaGFuZ2VgIG1heSBiZSB1cGRhdGVkIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogVGhpcyBldmVudCBoYW5kbGVyIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgb2YgdGhlIHNjcm9sbGJhciBpcyBjaGFuZ2VkIHRocm91Z2ggdXNlciBpbnRlcmFjdGlvbi4gVGhlIHR5cGljYWwgdXNlIGNhc2UgaXMgd2hlbiB0aGUgY29udGVudCBpcyBzY3JvbGxlZC4gSXQgaXMgY2FsbGVkIHdpdGggdGhlIGBGaW5CYXJgIG9iamVjdCBhcyBpdHMgY29udGV4dCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHNjcm9sbGJhciAoaXRzIGluZGV4LCByb3VuZGVkKSBhcyB0aGUgb25seSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBTZXQgdGhpcyBwcm9wZXJ0eSB0byBgbnVsbGAgdG8gc3RvcCBlbWl0dGluZyBzdWNoIGV2ZW50cy5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyKXxudWxsfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgb25jaGFuZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byB0aGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0LlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdCB3aWxsIGFsd2F5cyBpbmNsdWRlIGBmaW5iYXItdmVydGljYWxgIChvciBgZmluYmFyLWhvcml6b250YWxgIGJhc2VkIG9uIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uKS4gV2hlbmV2ZXIgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gc29tZSB2YWx1ZSwgZmlyc3QgdGhlIG9sZCBwcmVmaXgrb3JpZW50YXRpb24gaXMgcmVtb3ZlZCBmcm9tIHRoZSBiYXIgZWxlbWVudCdzIGNsYXNzIGxpc3Q7IHRoZW4gdGhlIG5ldyBwcmVmaXgrb3JpZW50YXRpb24gaXMgYWRkZWQgdG8gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdC4gVGhpcyBwcm9wZXJ0eSBjYXVzZXMgX2FuIGFkZGl0aW9uYWxfIGNsYXNzIG5hbWUgdG8gYmUgYWRkZWQgdG8gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdC4gVGhlcmVmb3JlLCB0aGlzIHByb3BlcnR5IHdpbGwgb25seSBhZGQgYXQgbW9zdCBvbmUgYWRkaXRpb25hbCBjbGFzcyBuYW1lIHRvIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogVG8gcmVtb3ZlIF9jbGFzc25hbWUtb3JpZW50YXRpb25fIGZyb20gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdCwgc2V0IHRoaXMgcHJvcGVydHkgdG8gYSBmYWxzeSB2YWx1ZSwgc3VjaCBhcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiA+IE5PVEU6IFlvdSBvbmx5IG5lZWQgdG8gc3BlY2lmeSBhbiBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgd2hlbiB5b3UgbmVlZCB0byBoYXZlIG11bGx0aXBsZSBkaWZmZXJlbnQgc3R5bGVzIG9mIHNjcm9sbGJhcnMgb24gdGhlIHNhbWUgcGFnZS4gSWYgdGhpcyBpcyBub3QgYSByZXF1aXJlbWVudCwgdGhlbiB5b3UgZG9uJ3QgbmVlZCB0byBtYWtlIGEgbmV3IGNsYXNzOyB5b3Ugd291bGQganVzdCBjcmVhdGUgc29tZSBhZGRpdGlvbmFsIHJ1bGVzIHVzaW5nIHRoZSBzYW1lIHNlbGVjdG9ycyBpbiB0aGUgYnVpbHQtaW4gc3R5bGVzaGVldCAoLi4vY3NzL2ZpbmJhcnMuY3NzKTpcbiAgICAgKiAqYGRpdi5maW5iYXItdmVydGljYWxgIChvciBgZGl2LmZpbmJhci1ob3Jpem9udGFsYCkgZm9yIHRoZSBzY3JvbGxiYXJcbiAgICAgKiAqYGRpdi5maW5iYXItdmVydGljYWwgPiBkaXZgIChvciBgZGl2LmZpbmJhci1ob3Jpem9udGFsID4gZGl2YCkgZm9yIHRoZSBcInRodW1iLlwiXG4gICAgICpcbiAgICAgKiBPZiBjb3Vyc2UsIHlvdXIgcnVsZXMgc2hvdWxkIGNvbWUgYWZ0ZXIgdGhlIGJ1aWx0LWlucy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IGNsYXNzUHJlZml4KHByZWZpeCkge1xuICAgICAgICBpZiAodGhpcy5fY2xhc3NQcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3NQcmVmaXggKyB0aGlzLm9yaWVudGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NsYXNzUHJlZml4ID0gcHJlZml4O1xuXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5hZGQocHJlZml4ICsgJy0nICsgdGhpcy5vcmllbnRhdGlvbik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldCBjbGFzc1ByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzUHJlZml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBpbmNyZW1lbnRcbiAgICAgKiBAc3VtbWFyeSBOdW1iZXIgb2Ygc2Nyb2xsYmFyIGluZGV4IHVuaXRzIHJlcHJlc2VudGluZyBhIHBhZ2VmdWwuIFVzZWQgZXhjbHVzaXZlbHkgZm9yIHBhZ2luZyB1cCBhbmQgZG93biBhbmQgZm9yIHNldHRpbmcgdGh1bWIgc2l6ZSByZWxhdGl2ZSB0byBjb250ZW50IHNpemUuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBDYW4gYWxzbyBiZSBnaXZlbiBhcyBhIHBhcmFtZXRlciB0byB0aGUge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplfSBtZXRob2QsIHdoaWNoIGlzIHBlcnRpbmVudCBiZWNhdXNlIGNvbnRlbnQgYXJlYSBzaXplIGNoYW5nZXMgYWZmZWN0IHRoZSBkZWZpbml0aW9uIG9mIGEgXCJwYWdlZnVsLlwiIEhvd2V2ZXIsIHlvdSBvbmx5IG5lZWQgdG8gZG8gdGhpcyBpZiB0aGlzIHZhbHVlIGlzIGJlaW5nIHVzZWQuIEl0IG5vdCB1c2VkIHdoZW46XG4gICAgICogKiB5b3UgZGVmaW5lIGBwYWdpbmcudXBgIGFuZCBgcGFnaW5nLmRvd25gXG4gICAgICogKiB5b3VyIHNjcm9sbGJhciBpcyB1c2luZyBgc2Nyb2xsUmVhbENvbnRlbnRgXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluY3JlbWVudDogMSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGJhclN0eWxlc1xuICAgICAqIEBzdW1tYXJ5IFNjcm9sbGJhciBzdHlsZXMgdG8gYmUgYXBwbGllZCBieSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0uXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgdmFsdWUgdG8gYmUgYXNzaWduZWQgdG8ge0BsaW5rIEZpbkJhciNzdHlsZXN8c3R5bGVzfSBvbiBlYWNoIGNhbGwgdG8ge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9LiBUaGF0IGlzLCBhIGhhc2ggb2YgdmFsdWVzIHRvIGJlIGNvcGllZCB0byB0aGUgc2Nyb2xsYmFyIGVsZW1lbnQncyBzdHlsZSBvYmplY3Qgb24gcmVzaXplOyBvciBgbnVsbGAgZm9yIG5vbmUuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc3R5bGV8c3R5bGV9XG4gICAgICogQHR5cGUge2ZpbmJhclN0eWxlc3xudWxsfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgYmFyU3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc3R5bGVcbiAgICAgKiBAc3VtbWFyeSBBZGRpdGlvbmFsIHNjcm9sbGJhciBzdHlsZXMuXG4gICAgICogQGRlc2MgU2VlIHR5cGUgZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLiBUaGVzZSBzdHlsZXMgYXJlIGFwcGxpZWQgZGlyZWN0bHkgdG8gdGhlIHNjcm9sbGJhcidzIGBiYXJgIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBWYWx1ZXMgYXJlIGFkanVzdGVkIGFzIGZvbGxvd3MgYmVmb3JlIGJlaW5nIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQ6XG4gICAgICogMS4gSW5jbHVkZWQgXCJwc2V1ZG8tcHJvcGVydHlcIiBuYW1lcyBmcm9tIHRoZSBzY3JvbGxiYXIncyBvcmllbnRhdGlvbiBoYXNoLCB7QGxpbmsgRmluQmFyI29ofG9ofSwgYXJlIHRyYW5zbGF0ZWQgdG8gYWN0dWFsIHByb3BlcnR5IG5hbWVzIGJlZm9yZSBiZWluZyBhcHBsaWVkLlxuICAgICAqIDIuIFdoZW4gdGhlcmUgYXJlIG1hcmdpbnMsIHBlcmNlbnRhZ2VzIGFyZSB0cmFuc2xhdGVkIHRvIGFic29sdXRlIHBpeGVsIHZhbHVlcyBiZWNhdXNlIENTUyBpZ25vcmVzIG1hcmdpbnMgaW4gaXRzIHBlcmNlbnRhZ2UgY2FsY3VsYXRpb25zLlxuICAgICAqIDMuIElmIHlvdSBnaXZlIGEgdmFsdWUgd2l0aG91dCBhIHVuaXQgKGEgcmF3IG51bWJlciksIFwicHhcIiB1bml0IGlzIGFwcGVuZGVkLlxuICAgICAqXG4gICAgICogR2VuZXJhbCBub3RlczpcbiAgICAgKiAxLiBJdCBpcyBhbHdheXMgcHJlZmVyYWJsZSB0byBzcGVjaWZ5IHN0eWxlcyB2aWEgYSBzdHlsZXNoZWV0LiBPbmx5IHNldCB0aGlzIHByb3BlcnR5IHdoZW4geW91IG5lZWQgdG8gc3BlY2lmaWNhbGx5IG92ZXJyaWRlIChhKSBzdHlsZXNoZWV0IHZhbHVlKHMpLlxuICAgICAqIDIuIENhbiBiZSBzZXQgZGlyZWN0bHkgb3IgdmlhIGNhbGxzIHRvIHRoZSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemV9IG1ldGhvZC5cbiAgICAgKiAzLiBTaG91bGQgb25seSBiZSBzZXQgYWZ0ZXIgdGhlIHNjcm9sbGJhciBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAgICogNC4gQmVmb3JlIGFwcGx5aW5nIHRoZXNlIG5ldyB2YWx1ZXMgdG8gdGhlIGVsZW1lbnQsIF9hbGxfIGluLWxpbmUgc3R5bGUgdmFsdWVzIGFyZSByZXNldCAoYnkgcmVtb3ZpbmcgdGhlIGVsZW1lbnQncyBgc3R5bGVgIGF0dHJpYnV0ZSksIGV4cG9zaW5nIGluaGVyaXRlZCB2YWx1ZXMgKGZyb20gc3R5bGVzaGVldHMpLlxuICAgICAqIDUuIEVtcHR5IG9iamVjdCBoYXMgbm8gZWZmZWN0LlxuICAgICAqIDYuIEZhbHNleSB2YWx1ZSBpbiBwbGFjZSBvZiBvYmplY3QgaGFzIG5vIGVmZmVjdC5cbiAgICAgKlxuICAgICAqID4gQ0FWRUFUOiBEbyBub3QgYXR0ZW1wdCB0byB0cmVhdCB0aGUgb2JqZWN0IHlvdSBhc3NpZ24gdG8gdGhpcyBwcm9wZXJ0eSBhcyBpZiBpdCB3ZXJlIGB0aGlzLmJhci5zdHlsZWAuIFNwZWNpZmljYWxseSwgY2hhbmdpbmcgdGhpcyBvYmplY3QgYWZ0ZXIgYXNzaWduaW5nIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3Qgb24gdGhlIHNjcm9sbGJhci4gWW91IG11c3QgYXNzaWduIGl0IGFnYWluIGlmIHlvdSB3YW50IGl0IHRvIGhhdmUgYW4gZWZmZWN0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI2JhclN0eWxlc3xiYXJTdHlsZXN9XG4gICAgICogQHR5cGUge2ZpbmJhclN0eWxlc31cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBzdHlsZShzdHlsZXMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdHlsZXMgPSBleHRlbmQoe30sIHN0eWxlcywgdGhpcy5fYXV4U3R5bGVzKSk7XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYmFyID0gdGhpcy5iYXIsXG4gICAgICAgICAgICAgICAgYmFyUmVjdCA9IGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciB8fCBiYXIucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIG9oID0gdGhpcy5vaDtcblxuICAgICAgICAgICAgLy8gQmVmb3JlIGFwcGx5aW5nIG5ldyBzdHlsZXMsIHJldmVydCBhbGwgc3R5bGVzIHRvIHZhbHVlcyBpbmhlcml0ZWQgZnJvbSBzdHlsZXNoZWV0c1xuICAgICAgICAgICAgYmFyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gc3R5bGVzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIG9oKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG9oW2tleV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIodmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gKHZhbCB8fCAwKSArICdweCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvJSQvLnRlc3QodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGJhciBzaXplIGdpdmVuIGFzIHBlcmNlbnRhZ2Ugb2YgY29udGFpbmVyLCBpZiBiYXIgaGFzIG1hcmdpbnMsIHJlc3RhdGUgc2l6ZSBpbiBwaXhlbHMgbGVzcyBtYXJnaW5zLlxuICAgICAgICAgICAgICAgICAgICAvLyAoSWYgbGVmdCBhcyBwZXJjZW50YWdlLCBDU1MncyBjYWxjdWxhdGlvbiB3aWxsIG5vdCBleGNsdWRlIG1hcmdpbnMuKVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZW50ZWQgPSBheGlzW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5zID0gYmFyUmVjdFtvcmllbnRlZC5tYXJnaW5MZWFkaW5nXSArIGJhclJlY3Rbb3JpZW50ZWQubWFyZ2luVHJhaWxpbmddO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFyZ2lucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQodmFsLCAxMCkgLyAxMDAgKiBjb250YWluZXJSZWN0W29yaWVudGVkLnNpemVdIC0gbWFyZ2lucyArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBiYXIuc3R5bGVba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBuYW1lIHBhZ2luZ1xuICAgICAqIEBzdW1tYXJ5IEVuYWJsZSBwYWdlIHVwL2RuIGNsaWNrcy5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIElmIHRydXRoeSwgbGlzdGVuIGZvciBjbGlja3MgaW4gcGFnZS11cCBhbmQgcGFnZS1kb3duIHJlZ2lvbnMgb2Ygc2Nyb2xsYmFyLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0LCBjYWxsIGAucGFnaW5nLnVwKClgIG9uIHBhZ2UtdXAgY2xpY2tzIGFuZCBgLnBhZ2luZy5kb3duKClgIHdpbGwgYmUgY2FsbGVkIG9uIHBhZ2UtZG93biBjbGlja3MuXG4gICAgICpcbiAgICAgKiBDaGFuZ2luZyB0aGUgdHJ1dGhpbmVzcyBvZiB0aGlzIHZhbHVlIGFmdGVyIGluc3RhbnRpYXRpb24gY3VycmVudGx5IGhhcyBubyBlZmZlY3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW58b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFnaW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgcmFuZ2VcbiAgICAgKiBAc3VtbWFyeSBTZXR0ZXIgZm9yIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHNjcm9sbCB2YWx1ZXMuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gVGhlc2UgdmFsdWVzIGFyZSB0aGUgbGltaXRzIGZvciB7QGxpbmsgRm9vQmFyI2luZGV4fGluZGV4fS5cbiAgICAgKlxuICAgICAqIFRoZSBzZXR0ZXIgYWNjZXB0cyBhbiBvYmplY3Qgd2l0aCBleGFjdGx5IHR3byBudW1lcmljIHByb3BlcnRpZXM6IGAubWluYCB3aGljaCBtdXN0IGJlIGxlc3MgdGhhbiBgLm1heGAuIFRoZSB2YWx1ZXMgYXJlIGV4dHJhY3RlZCBhbmQgdGhlIG9iamVjdCBpcyBkaXNjYXJkZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZ2V0dGVyIHJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggYC5taW5gIGFuZCAnLm1heGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7cmFuZ2VUeXBlfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IHJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHZhbGlkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB0aGlzLl9taW4gPSByYW5nZS5taW47XG4gICAgICAgIHRoaXMuX21heCA9IHJhbmdlLm1heDtcbiAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IHJhbmdlLm1heCAtIHJhbmdlLm1pbiArIDE7XG4gICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmluZGV4OyAvLyByZS1jbGFtcFxuICAgIH0sXG4gICAgZ2V0IHJhbmdlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluOiB0aGlzLl9taW4sXG4gICAgICAgICAgICBtYXg6IHRoaXMuX21heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbmRleCB2YWx1ZSBvZiB0aGUgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIFRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzY3JvbGwgdGh1bWIuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgdmFsdWUgY2xhbXBzIGl0IHRvIHtAbGluayBGaW5CYXIjbWlufG1pbn0uLntAbGluayBGaW5CYXIjbWF4fG1heH0sIHNjcm9sbCB0aGUgY29udGVudCwgYW5kIG1vdmVzIHRodW1iLlxuICAgICAqXG4gICAgICogR2V0dGluZyB0aGlzIHZhbHVlIHJldHVybnMgdGhlIGN1cnJlbnQgaW5kZXguIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGluIHRoZSByYW5nZSBgbWluYC4uYG1heGAuIEl0IGlzIGludGVudGlvbmFsbHkgbm90IHJvdW5kZWQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyB2YWx1ZSBhcyBhbiBhbHRlcm5hdGl2ZSB0byAob3IgaW4gYWRkaXRpb24gdG8pIHVzaW5nIHRoZSB7QGxpbmsgRmluQmFyI29uY2hhbmdlfG9uY2hhbmdlfSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNfc2V0U2Nyb2xsfF9zZXRTY3JvbGx9XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBpbmRleChpZHgpIHtcbiAgICAgICAgaWR4ID0gTWF0aC5taW4odGhpcy5fbWF4LCBNYXRoLm1heCh0aGlzLl9taW4sIGlkeCkpOyAvLyBjbGFtcCBpdFxuICAgICAgICB0aGlzLl9zZXRTY3JvbGwoaWR4KTtcbiAgICAgICAgLy8gdGhpcy5fc2V0VGh1bWJTaXplKCk7XG4gICAgfSxcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSBNb3ZlIHRoZSB0aHVtYi5cbiAgICAgKiBAZGVzYyBBbHNvIGRpc3BsYXlzIHRoZSBpbmRleCB2YWx1ZSBpbiB0aGUgdGVzdCBwYW5lbCBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIGlkeCAtIFRoZSBuZXcgc2Nyb2xsIGluZGV4LCBhIHZhbHVlIGluIHRoZSByYW5nZSBgbWluYC4uYG1heGAuXG4gICAgICogQHBhcmFtIFtzY2FsZWQ9ZihpZHgpXSAtIFRoZSBuZXcgdGh1bWIgcG9zaXRpb24gaW4gcGl4ZWxzIGFuZCBzY2FsZWQgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5pbmcge0BsaW5rIEZpbkJhciNiYXJ8YmFyfSBlbGVtZW50LCBpLmUuLCBhIHByb3BvcnRpb25hbCBudW1iZXIgaW4gdGhlIHJhbmdlIGAwYC4uYHRodW1iTWF4YC4gV2hlbiBvbWl0dGVkLCBhIGZ1bmN0aW9uIG9mIGBpZHhgIGlzIHVzZWQuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBfc2V0U2Nyb2xsOiBmdW5jdGlvbiAoaWR4LCBzY2FsZWQpIHtcbiAgICAgICAgdGhpcy5faW5kZXggPSBpZHg7XG5cbiAgICAgICAgLy8gRGlzcGxheSB0aGUgaW5kZXggdmFsdWUgaW4gdGhlIHRlc3QgcGFuZWxcbiAgICAgICAgaWYgKHRoaXMudGVzdFBhbmVsSXRlbSAmJiB0aGlzLnRlc3RQYW5lbEl0ZW0uaW5kZXggaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRlc3RQYW5lbEl0ZW0uaW5kZXguaW5uZXJIVE1MID0gTWF0aC5yb3VuZChpZHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2tcbiAgICAgICAgaWYgKHRoaXMub25jaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25jaGFuZ2UuY2FsbCh0aGlzLCBNYXRoLnJvdW5kKGlkeCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgdGh1bWJcbiAgICAgICAgaWYgKHNjYWxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY2FsZWQgPSAoaWR4IC0gdGhpcy5fbWluKSAvICh0aGlzLl9tYXggLSB0aGlzLl9taW4pICogdGhpcy5fdGh1bWJNYXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHVtYi5zdHlsZVt0aGlzLm9oLmxlYWRpbmddID0gc2NhbGVkICsgJ3B4JztcbiAgICB9LFxuXG4gICAgc2Nyb2xsUmVhbENvbnRlbnQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSB0aGlzLmNvbnRlbnQucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHNpemVQcm9wID0gdGhpcy5vaC5zaXplLFxuICAgICAgICAgICAgbWF4U2Nyb2xsID0gTWF0aC5tYXgoMCwgdGhpcy5jb250ZW50W3NpemVQcm9wXSAtIGNvbnRhaW5lclJlY3Rbc2l6ZVByb3BdKSxcbiAgICAgICAgICAgIC8vc2Nyb2xsID0gTWF0aC5taW4oaWR4LCBtYXhTY3JvbGwpO1xuICAgICAgICAgICAgc2Nyb2xsID0gKGlkeCAtIHRoaXMuX21pbikgLyAodGhpcy5fbWF4IC0gdGhpcy5fbWluKSAqIG1heFNjcm9sbDtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc2Nyb2xsOiAnICsgc2Nyb2xsKTtcbiAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlW3RoaXMub2gubGVhZGluZ10gPSAtc2Nyb2xsICsgJ3B4JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVjYWxjdWxhdGUgdGh1bWIgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIG1ldGhvZCByZWNhbGN1bGF0ZXMgdGhlIHRodW1iIHNpemUgYW5kIHBvc2l0aW9uLiBDYWxsIGl0IG9uY2UgYWZ0ZXIgaW5zZXJ0aW5nIHlvdXIgc2Nyb2xsYmFyIGludG8gdGhlIERPTSwgYW5kIHJlcGVhdGVkbHkgd2hpbGUgcmVzaXppbmcgdGhlIHNjcm9sbGJhciAod2hpY2ggdHlwaWNhbGx5IGhhcHBlbnMgd2hlbiB0aGUgc2Nyb2xsYmFyJ3MgcGFyZW50IGlzIHJlc2l6ZWQgYnkgdXNlci5cbiAgICAgKlxuICAgICAqID4gVGhpcyBmdW5jdGlvbiBzaGlmdHMgYXJncyBpZiBmaXJzdCBhcmcgb21pdHRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5jcmVtZW50PXRoaXMuaW5jcmVtZW50XSAtIFJlc2V0cyB7QGxpbmsgRm9vQmFyI2luY3JlbWVudHxpbmNyZW1lbnR9IChzZWUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmaW5iYXJTdHlsZXN9IFtiYXJTdHlsZXM9dGhpcy5iYXJTdHlsZXNdIC0gKFNlZSB0eXBlIGRlZmluaXRpb24gZm9yIGRldGFpbHMuKSBTY3JvbGxiYXIgc3R5bGVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGJhciBlbGVtZW50LlxuICAgICAqXG4gICAgICogT25seSBzcGVjaWZ5IGEgYGJhclN0eWxlc2Agb2JqZWN0IHdoZW4geW91IG5lZWQgdG8gb3ZlcnJpZGUgc3R5bGVzaGVldCB2YWx1ZXMuIElmIHByb3ZpZGVkLCBiZWNvbWVzIHRoZSBuZXcgZGVmYXVsdCAoYHRoaXMuYmFyU3R5bGVzYCksIGZvciB1c2UgYXMgYSBkZWZhdWx0IG9uIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICpcbiAgICAgKiBJdCBpcyBnZW5lcmFsbHkgdGhlIGNhc2UgdGhhdCB0aGUgc2Nyb2xsYmFyJ3MgbmV3IHBvc2l0aW9uIGlzIHN1ZmZpY2llbnRseSBkZXNjcmliZWQgYnkgdGhlIGN1cnJlbnQgc3R5bGVzLiBUaGVyZWZvcmUsIGl0IGlzIHVudXN1YWwgdG8gbmVlZCB0byBwcm92aWRlIGEgYGJhclN0eWxlc2Agb2JqZWN0IG9uIGV2ZXJ5IGNhbGwgdG8gYHJlc2l6ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RmluQmFyfSBTZWxmIGZvciBjaGFpbmluZy5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24gKGluY3JlbWVudCwgYmFyU3R5bGVzKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmJhcjtcblxuICAgICAgICBpZiAoIWJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vdCBpbiBET00geWV0IHNvIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciB8fCBiYXIucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gc2hpZnQgYXJncyBpZiBpZiAxc3QgYXJnIG9taXR0ZWRcbiAgICAgICAgaWYgKHR5cGVvZiBpbmNyZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBiYXJTdHlsZXMgPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICBpbmNyZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0eWxlID0gdGhpcy5iYXJTdHlsZXMgPSBiYXJTdHlsZXMgfHwgdGhpcy5iYXJTdHlsZXM7XG5cbiAgICAgICAgLy8gQm91bmQgdG8gcmVhbCBjb250ZW50OiBDb250ZW50IHdhcyBnaXZlbiBidXQgbm8gb25jaGFuZ2UgaGFuZGxlci5cbiAgICAgICAgLy8gU2V0IHVwIC5vbmNoYW5nZSwgLmNvbnRhaW5lclNpemUsIGFuZCAuaW5jcmVtZW50LlxuICAgICAgICAvLyBOb3RlIHRoaXMgb25seSBtYWtlcyBzZW5zZSBpZiB5b3VyIGluZGV4IHVuaXQgaXMgcGl4ZWxzLlxuICAgICAgICBpZiAodGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub25jaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2hhbmdlID0gdGhpcy5zY3JvbGxSZWFsQ29udGVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gdGhpcy5jb250ZW50W3RoaXMub2guc2l6ZV07XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXggPSB0aGlzLmNvbnRlbnRTaXplIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbmNoYW5nZSA9PT0gdGhpcy5zY3JvbGxSZWFsQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJTaXplID0gY29udGFpbmVyUmVjdFt0aGlzLm9oLnNpemVdO1xuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQgPSB0aGlzLmNvbnRhaW5lclNpemUgLyAodGhpcy5jb250ZW50U2l6ZSAtIHRoaXMuY29udGFpbmVyU2l6ZSkgKiAodGhpcy5fbWF4IC0gdGhpcy5fbWluKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZSA9IDE7XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudCA9IGluY3JlbWVudCB8fCB0aGlzLmluY3JlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMudGVzdFBhbmVsSXRlbSA9IHRoaXMudGVzdFBhbmVsSXRlbSB8fCB0aGlzLl9hZGRUZXN0UGFuZWxJdGVtKCk7XG4gICAgICAgIHRoaXMuX3NldFRodW1iU2l6ZSgpO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuZGVsdGFQcm9wICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9ib3VuZC5vbndoZWVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTaG9ydGVuIHRyYWlsaW5nIGVuZCBvZiBzY3JvbGxiYXIgYnkgdGhpY2tuZXNzIG9mIHNvbWUgb3RoZXIgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIEluIHRoZSBcImNsYXNzaWNhbFwiIHNjZW5hcmlvIHdoZXJlIHZlcnRpY2FsIHNjcm9sbCBiYXIgaXMgb24gdGhlIHJpZ2h0IGFuZCBob3Jpem9udGFsIHNjcm9sbGJhciBpcyBvbiB0aGUgYm90dG9tLCB5b3Ugd2FudCB0byBzaG9ydGVuIHRoZSBcInRyYWlsaW5nIGVuZFwiIChib3R0b20gYW5kIHJpZ2h0IGVuZHMsIHJlc3BlY3RpdmVseSkgb2YgYXQgbGVhc3Qgb25lIG9mIHRoZW0gc28gdGhleSBkb24ndCBvdmVybGF5LlxuICAgICAqXG4gICAgICogVGhpcyBjb252ZW5pZW5jZSBmdW5jdGlvbiBpcyBhbiBwcm9ncmFtbWF0aWMgYWx0ZXJuYXRpdmUgdG8gaGFyZGNvZGluZyB0aGUgY29ycmVjdCBzdHlsZSB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlIGluIHlvdXIgc3R5bGVzaGVldDsgb3Igc2V0dGluZyB0aGUgY29ycmVjdCBzdHlsZSB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlIGluIHRoZSB7QGxpbmsgRmluQmFyI2JhclN0eWxlc3xiYXJTdHlsZXN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNmb3Jlc2hvcnRlbkJ5fGZvcmVzaG9ydGVuQnl9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgc2hvcnRlbkJ5OiBmdW5jdGlvbiAob3RoZXJGaW5CYXIpIHsgcmV0dXJuIHRoaXMuc2hvcnRlbkVuZEJ5KCd0cmFpbGluZycsIG90aGVyRmluQmFyKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNob3J0ZW4gbGVhZGluZyBlbmQgb2Ygc2Nyb2xsYmFyIGJ5IHRoaWNrbmVzcyBvZiBzb21lIG90aGVyIHNjcm9sbGJhci5cbiAgICAgKiBAZGVzYyBTdXBwb3J0cyBub24tY2xhc3NpY2FsIHNjcm9sbGJhciBzY2VuYXJpb3Mgd2hlcmUgdmVydGljYWwgc2Nyb2xsIGJhciBtYXkgYmUgb24gbGVmdCBhbmQgaG9yaXpvbnRhbCBzY3JvbGxiYXIgbWF5IGJlIG9uIHRvcCwgaW4gd2hpY2ggY2FzZSB5b3Ugd2FudCB0byBzaG9ydGVuIHRoZSBcImxlYWRpbmcgZW5kXCIgcmF0aGVyIHRoYW4gdGhlIHRyYWlsaW5nIGVuZC5cbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc2hvcnRlbkJ5fHNob3J0ZW5CeX0uXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZm9yZXNob3J0ZW5CeTogZnVuY3Rpb24gKG90aGVyRmluQmFyKSB7IHJldHVybiB0aGlzLnNob3J0ZW5FbmRCeSgnbGVhZGluZycsIG90aGVyRmluQmFyKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdlbmVyYWxpemVkIHNob3J0ZW5pbmcgZnVuY3Rpb24uXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI3Nob3J0ZW5CeXxzaG9ydGVuQnl9LlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNmb3Jlc2hvcnRlbkJ5fGZvcmVzaG9ydGVuQnl9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aGljaEVuZCAtIGEgQ1NTIHN0eWxlIHByb3BlcnR5IG5hbWUgb3IgYW4gb3JpZW50YXRpb24gaGFzaCBuYW1lIHRoYXQgdHJhbnNsYXRlcyB0byBhIENTUyBzdHlsZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqIEBwYXJhbSB7RmluQmFyfG51bGx9IG90aGVyRmluQmFyIC0gT3RoZXIgc2Nyb2xsYmFyIHRvIGF2b2lkIGJ5IHNob3J0ZW5pbmcgdGhpcyBvbmU7IGBudWxsYCByZW1vdmVzIHRoZSB0cmFpbGluZyBzcGFjZVxuICAgICAqIEByZXR1cm5zIHtGaW5CYXJ9IEZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIHNob3J0ZW5FbmRCeTogZnVuY3Rpb24gKHdoaWNoRW5kLCBvdGhlckZpbkJhcikge1xuICAgICAgICBpZiAoIW90aGVyRmluQmFyKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXV4U3R5bGVzO1xuICAgICAgICB9IGVsc2UgaWYgKG90aGVyRmluQmFyIGluc3RhbmNlb2YgRmluQmFyICYmIG90aGVyRmluQmFyLm9yaWVudGF0aW9uICE9PSB0aGlzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG90aGVyRmluQmFyLmJhciksXG4gICAgICAgICAgICAgICAgb29oID0gb3JpZW50YXRpb25IYXNoZXNbb3RoZXJGaW5CYXIub3JpZW50YXRpb25dO1xuICAgICAgICAgICAgdGhpcy5fYXV4U3R5bGVzID0ge307XG4gICAgICAgICAgICB0aGlzLl9hdXhTdHlsZXNbd2hpY2hFbmRdID0gb3RoZXJTdHlsZVtvb2gudGhpY2tuZXNzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN1bW1hcnkgU2V0cyB0aGUgcHJvcG9ydGlvbmFsIHRodW1iIHNpemUgYW5kIGhpZGVzIHRodW1iIHdoZW4gMTAwJS5cbiAgICAgKiBAZGVzYyBUaGUgdGh1bWIgc2l6ZSBoYXMgYW4gYWJzb2x1dGUgbWluaW11bSBvZiAyMCAocGl4ZWxzKS5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIF9zZXRUaHVtYlNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9oID0gdGhpcy5vaCxcbiAgICAgICAgICAgIHRodW1iQ29tcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMudGh1bWIpLFxuICAgICAgICAgICAgdGh1bWJNYXJnaW5MZWFkaW5nID0gcGFyc2VJbnQodGh1bWJDb21wW29oLm1hcmdpbkxlYWRpbmddKSxcbiAgICAgICAgICAgIHRodW1iTWFyZ2luVHJhaWxpbmcgPSBwYXJzZUludCh0aHVtYkNvbXBbb2gubWFyZ2luVHJhaWxpbmddKSxcbiAgICAgICAgICAgIHRodW1iTWFyZ2lucyA9IHRodW1iTWFyZ2luTGVhZGluZyArIHRodW1iTWFyZ2luVHJhaWxpbmcsXG4gICAgICAgICAgICBiYXJTaXplID0gdGhpcy5iYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbb2guc2l6ZV0sXG4gICAgICAgICAgICB0aHVtYlNpemUgPSBNYXRoLm1heCgyMCwgYmFyU2l6ZSAqIHRoaXMuY29udGFpbmVyU2l6ZSAvIHRoaXMuY29udGVudFNpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lclNpemUgPCB0aGlzLmNvbnRlbnRTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgdGhpcy50aHVtYi5zdHlsZVtvaC5zaXplXSA9IHRodW1iU2l6ZSArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgX3RodW1iTWF4XG4gICAgICAgICAqIEBzdW1tYXJ5IE1heGltdW0gb2Zmc2V0IG9mIHRodW1iJ3MgbGVhZGluZyBlZGdlLlxuICAgICAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBwaXhlbCBvZmZzZXQgd2l0aGluIHRoZSBzY3JvbGxiYXIgb2YgdGhlIHRodW1iIHdoZW4gaXQgaXMgYXQgaXRzIG1heGltdW0gcG9zaXRpb24gYXQgdGhlIGV4dHJlbWUgZW5kIG9mIGl0cyByYW5nZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB2YWx1ZSB0YWtlcyBpbnRvIGFjY291bnQgdGhlIG5ld2x5IGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgdGh1bWIgZWxlbWVudCAoaW5jbHVkaW5nIGl0cyBtYXJnaW5zKSBhbmQgdGhlIGlubmVyIHNpemUgb2YgdGhlIHNjcm9sbGJhciAodGhlIHRodW1iJ3MgY29udGFpbmluZyBlbGVtZW50LCBpbmNsdWRpbmcgX2l0c18gbWFyZ2lucykuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IFNjcm9sbGJhciBwYWRkaW5nIGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgYW5kIGFzc3VtZWQgdG8gYmUgMCBpbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBhbmQgaXMgYXNzdW1lZCB0byBiZSBgMGA7IHVzZSB0aHVtYiBtYXJnaW5zIGluIHBsYWNlIG9mIHNjcm9sbGJhciBwYWRkaW5nLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGh1bWJNYXggPSBiYXJTaXplIC0gdGh1bWJTaXplIC0gdGh1bWJNYXJnaW5zO1xuXG4gICAgICAgIHRoaXMuX3RodW1iTWFyZ2luTGVhZGluZyA9IHRodW1iTWFyZ2luTGVhZGluZzsgLy8gdXNlZCBpbiBtb3VzZWRvd25cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVtb3ZlIHRoZSBzY3JvbGxiYXIuXG4gICAgICogQGRlc2MgVW5ob29rcyBhbGwgdGhlIGV2ZW50IGhhbmRsZXJzIGFuZCB0aGVuIHJlbW92ZXMgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NLiBBbHdheXMgY2FsbCB0aGlzIG1ldGhvZCBwcmlvciB0byBkaXNwb3Npbmcgb2YgdGhlIHNjcm9sbGJhciBvYmplY3QuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZWRvd24nKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgKHRoaXMuY29udGFpbmVyIHx8IHRoaXMuYmFyLnBhcmVudEVsZW1lbnQpLl9yZW1vdmVFdnQoJ3doZWVsJywgdGhpcy5fYm91bmQub253aGVlbCk7XG5cbiAgICAgICAgdGhpcy5iYXIub25jbGljayA9XG4gICAgICAgICAgICB0aGlzLnRodW1iLm9uY2xpY2sgPVxuICAgICAgICAgICAgICAgIHRoaXMudGh1bWIub25tb3VzZW92ZXIgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRodW1iLnRyYW5zaXRpb25lbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHVtYi5vbm1vdXNlb3V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLmJhci5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gX2FkZFRlc3RQYW5lbEl0ZW1cbiAgICAgKiBAc3VtbWFyeSBBcHBlbmQgYSB0ZXN0IHBhbmVsIGVsZW1lbnQuXG4gICAgICogQGRlc2MgSWYgdGhlcmUgaXMgYSB0ZXN0IHBhbmVsIGluIHRoZSBET00gKHR5cGljYWxseSBhbiBgPG9sPi4uLjwvb2w+YCBlbGVtZW50KSB3aXRoIGNsYXNzIG5hbWVzIG9mIGJvdGggYHRoaXMuY2xhc3NQcmVmaXhgIGFuZCBgJ3Rlc3QtcGFuZWwnYCAob3IsIGJhcnJpbmcgdGhhdCwgYW55IGVsZW1lbnQgd2l0aCBjbGFzcyBuYW1lIGAndGVzdC1wYW5lbCdgKSwgYW4gYDxsaT4uLi48L2xpPmAgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGFwcGVuZGVkIHRvIGl0LiBUaGlzIG5ldyBlbGVtZW50IHdpbGwgY29udGFpbiBhIHNwYW4gZm9yIGVhY2ggY2xhc3MgbmFtZSBnaXZlbi5cbiAgICAgKlxuICAgICAqIFlvdSBzaG91bGQgZGVmaW5lIGEgQ1NTIHNlbGVjdG9yIGAubGlzdGVuaW5nYCBmb3IgdGhlc2Ugc3BhbnMuIFRoaXMgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byB0aGUgc3BhbnMgdG8gYWx0ZXIgdGhlaXIgYXBwZWFyYW5jZSB3aGVuIGEgbGlzdGVuZXIgaXMgYWRkZWQgd2l0aCB0aGF0IGNsYXNzIG5hbWUgKHByZWZpeGVkIHdpdGggJ29uJykuXG4gICAgICpcbiAgICAgKiAoVGhpcyBpcyBhbiBpbnRlcm5hbCBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbmNlIGJ5IHRoZSBjb25zdHJ1Y3RvciBvbiBldmVyeSBpbnN0YW50aWF0aW9uLilcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudHx1bmRlZmluZWR9IFRoZSBhcHBlbmRlZCBgPGxpPi4uLjwvbGk+YCBlbGVtZW50IG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIHRlc3QgcGFuZWwuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBfYWRkVGVzdFBhbmVsSXRlbTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGVzdFBhbmVsSXRlbSxcbiAgICAgICAgICAgIHRlc3RQYW5lbEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHRoaXMuX2NsYXNzUHJlZml4ICsgJy50ZXN0LXBhbmVsJykgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRlc3QtcGFuZWwnKTtcblxuICAgICAgICBpZiAodGVzdFBhbmVsRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMgPSBbICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnLCAnaW5kZXgnIF0sXG4gICAgICAgICAgICAgICAgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocGFydE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmlubmVySFRNTCArPSAnPHNwYW4gY2xhc3M9XCInICsgcGFydE5hbWUgKyAnXCI+JyArIHBhcnROYW1lLnJlcGxhY2UoJ21vdXNlJywgJycpICsgJzwvc3Bhbj4nO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbSk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW0gPSB7fTtcbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocGFydE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0ZXN0UGFuZWxJdGVtW3BhcnROYW1lXSA9IGl0ZW0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShwYXJ0TmFtZSlbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXN0UGFuZWxJdGVtO1xuICAgIH0sXG5cbiAgICBfYWRkRXZ0OiBmdW5jdGlvbiAoZXZ0TmFtZSkge1xuICAgICAgICB2YXIgc3B5ID0gdGhpcy50ZXN0UGFuZWxJdGVtICYmIHRoaXMudGVzdFBhbmVsSXRlbVtldnROYW1lXTtcbiAgICAgICAgaWYgKHNweSkgeyBzcHkuY2xhc3NMaXN0LmFkZCgnbGlzdGVuaW5nJyk7IH1cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZ0TmFtZSwgdGhpcy5fYm91bmRbJ29uJyArIGV2dE5hbWVdKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUV2dDogZnVuY3Rpb24gKGV2dE5hbWUpIHtcbiAgICAgICAgdmFyIHNweSA9IHRoaXMudGVzdFBhbmVsSXRlbSAmJiB0aGlzLnRlc3RQYW5lbEl0ZW1bZXZ0TmFtZV07XG4gICAgICAgIGlmIChzcHkpIHsgc3B5LmNsYXNzTGlzdC5yZW1vdmUoJ2xpc3RlbmluZycpOyB9XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dE5hbWUsIHRoaXMuX2JvdW5kWydvbicgKyBldnROYW1lXSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBvYmpuID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAob2Jqbikge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iam4pIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IG9iam5ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiB2YWxpZFJhbmdlKHJhbmdlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyYW5nZSksXG4gICAgICAgIHZhbGlkID0gIGtleXMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICB0eXBlb2YgcmFuZ2UubWluID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHJhbmdlLm1heCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHJhbmdlLm1pbiA8PSByYW5nZS5tYXg7XG5cbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIC5yYW5nZSBvYmplY3QuJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYW5kbGVyc1RvQmVCb3VuZFxuICogQHR5cGUge29iamVjdH1cbiAqIEBkZXNjIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCBhcmUgYWxsIERPTSBldmVudCBoYW5kbGVycyB0aGF0IGFyZSBib3VuZCBieSB0aGUgRmluQmFyIGNvbnN0cnVjdG9yIHRvIGVhY2ggbmV3IGluc3RhbmNlLiBJbiBvdGhlciB3b3JkcywgdGhlIGB0aGlzYCB2YWx1ZSBvZiB0aGVzZSBoYW5kbGVycywgb25jZSBib3VuZCwgcmVmZXIgdG8gdGhlIEZpbkJhciBvYmplY3QgYW5kIG5vdCB0byB0aGUgZXZlbnQgZW1pdHRlci4gXCJEbyBub3QgY29uc3VtZSByYXcuXCJcbiAqL1xudmFyIGhhbmRsZXJzVG9CZUJvdW5kID0ge1xuICAgIHNob3J0U3RvcDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIG9ud2hlZWw6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdGhpcy5pbmRleCArPSBldnRbdGhpcy5kZWx0YVByb3BdO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBvbmNsaWNrOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHZhciB0aHVtYkJveCA9IHRoaXMudGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBnb2luZ1VwID0gZXZ0W3RoaXMub2guY29vcmRpbmF0ZV0gPCB0aHVtYkJveFt0aGlzLm9oLmxlYWRpbmddO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYWdpbmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5wYWdpbmdbZ29pbmdVcCA/ICd1cCcgOiAnZG93biddKE1hdGgucm91bmQodGhpcy5pbmRleCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmRleCArPSBnb2luZ1VwID8gLXRoaXMuaW5jcmVtZW50IDogdGhpcy5pbmNyZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHRoZSB0aHVtYiBnbG93IG1vbWVudGFyaWx5XG4gICAgICAgIHRoaXMudGh1bWIuY2xhc3NMaXN0LmFkZCgnaG92ZXInKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnRodW1iLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbiB3YWl0Rm9ySXQoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB3YWl0Rm9ySXQpO1xuICAgICAgICAgICAgc2VsZi5fYm91bmQub25tb3VzZXVwKGV2dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZW92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHVtYi5jbGFzc0xpc3QuYWRkKCdob3ZlcicpO1xuICAgICAgICB0aGlzLnRodW1iLm9ubW91c2VvdXQgPSB0aGlzLl9ib3VuZC5vbm1vdXNlb3V0O1xuICAgICAgICB0aGlzLl9hZGRFdnQoJ21vdXNlZG93bicpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlb3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2Vkb3duJyk7XG4gICAgICAgIHRoaXMudGh1bWIub25tb3VzZW92ZXIgPSB0aGlzLl9ib3VuZC5vbm1vdXNlb3ZlcjtcbiAgICAgICAgdGhpcy50aHVtYi5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcicpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlZG93bjogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdnQoJ21vdXNlZG93bicpO1xuICAgICAgICB0aGlzLnRodW1iLm9ubW91c2VvdmVyID0gdGhpcy50aHVtYi5vbm1vdXNlb3V0ID0gbnVsbDtcblxuICAgICAgICB2YXIgdGh1bWJCb3ggPSB0aGlzLnRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnBpbk9mZnNldCA9IGV2dFt0aGlzLm9oLmF4aXNdIC0gdGh1bWJCb3hbdGhpcy5vaC5sZWFkaW5nXSArIHRoaXMuYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3RoaXMub2gubGVhZGluZ10gKyB0aGlzLl90aHVtYk1hcmdpbkxlYWRpbmc7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG5cbiAgICAgICAgdGhpcy5fYWRkRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fYWRkRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZW1vdmU6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIHNjYWxlZCA9IE1hdGgubWluKHRoaXMuX3RodW1iTWF4LCBNYXRoLm1heCgwLCBldnRbdGhpcy5vaC5heGlzXSAtIHRoaXMucGluT2Zmc2V0KSk7XG4gICAgICAgIHZhciBpZHggPSBzY2FsZWQgLyB0aGlzLl90aHVtYk1heCAqICh0aGlzLl9tYXggLSB0aGlzLl9taW4pICsgdGhpcy5fbWluO1xuXG4gICAgICAgIHRoaXMuX3NldFNjcm9sbChpZHgsIHNjYWxlZCk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZXVwOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2Vtb3ZlJyk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2V1cCcpO1xuXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnYXV0byc7XG5cbiAgICAgICAgdmFyIHRodW1iQm94ID0gdGhpcy50aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGh1bWJCb3gubGVmdCA8PSBldnQuY2xpZW50WCAmJiBldnQuY2xpZW50WCA8PSB0aHVtYkJveC5yaWdodCAmJlxuICAgICAgICAgICAgdGh1bWJCb3gudG9wIDw9IGV2dC5jbGllbnRZICYmIGV2dC5jbGllbnRZIDw9IHRodW1iQm94LmJvdHRvbVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kLm9ubW91c2VvdmVyKGV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZC5vbm1vdXNlb3V0KGV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbnZhciBvcmllbnRhdGlvbkhhc2hlcyA9IHtcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgICBjb29yZGluYXRlOiAgICAgJ2NsaWVudFknLFxuICAgICAgICBheGlzOiAgICAgICAgICAgJ3BhZ2VZJyxcbiAgICAgICAgc2l6ZTogICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICBvdXRzaWRlOiAgICAgICAgJ3JpZ2h0JyxcbiAgICAgICAgaW5zaWRlOiAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgbGVhZGluZzogICAgICAgICd0b3AnLFxuICAgICAgICB0cmFpbGluZzogICAgICAgJ2JvdHRvbScsXG4gICAgICAgIG1hcmdpbkxlYWRpbmc6ICAnbWFyZ2luVG9wJyxcbiAgICAgICAgbWFyZ2luVHJhaWxpbmc6ICdtYXJnaW5Cb3R0b20nLFxuICAgICAgICB0aGlja25lc3M6ICAgICAgJ3dpZHRoJyxcbiAgICAgICAgZGVsdGE6ICAgICAgICAgICdkZWx0YVknXG4gICAgfSxcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICAgIGNvb3JkaW5hdGU6ICAgICAnY2xpZW50WCcsXG4gICAgICAgIGF4aXM6ICAgICAgICAgICAncGFnZVgnLFxuICAgICAgICBzaXplOiAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgb3V0c2lkZTogICAgICAgICdib3R0b20nLFxuICAgICAgICBpbnNpZGU6ICAgICAgICAgJ3RvcCcsXG4gICAgICAgIGxlYWRpbmc6ICAgICAgICAnbGVmdCcsXG4gICAgICAgIHRyYWlsaW5nOiAgICAgICAncmlnaHQnLFxuICAgICAgICBtYXJnaW5MZWFkaW5nOiAgJ21hcmdpbkxlZnQnLFxuICAgICAgICBtYXJnaW5UcmFpbGluZzogJ21hcmdpblJpZ2h0JyxcbiAgICAgICAgdGhpY2tuZXNzOiAgICAgICdoZWlnaHQnLFxuICAgICAgICBkZWx0YTogICAgICAgICAgJ2RlbHRhWCdcbiAgICB9XG59O1xuXG52YXIgYXhpcyA9IHtcbiAgICB0b3A6ICAgICd2ZXJ0aWNhbCcsXG4gICAgYm90dG9tOiAndmVydGljYWwnLFxuICAgIGhlaWdodDogJ3ZlcnRpY2FsJyxcbiAgICBsZWZ0OiAgICdob3Jpem9udGFsJyxcbiAgICByaWdodDogICdob3Jpem9udGFsJyxcbiAgICB3aWR0aDogICdob3Jpem9udGFsJ1xufTtcblxudmFyIGNzc0ZpbkJhcnM7IC8vIGRlZmluaXRpb24gaW5zZXJ0ZWQgYnkgZ3VscGZpbGUgYmV0d2VlbiBmb2xsb3dpbmcgY29tbWVudHNcbi8qIGluamVjdDpjc3MgKi9cbmNzc0ZpbkJhcnMgPSAnZGl2LmZpbmJhci1ob3Jpem9udGFsLGRpdi5maW5iYXItdmVydGljYWx7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luOjNweH1kaXYuZmluYmFyLWhvcml6b250YWw+LnRodW1iLGRpdi5maW5iYXItdmVydGljYWw+LnRodW1ie3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2QzZDNkMzstd2Via2l0LWJveC1zaGFkb3c6MCAwIDFweCAjMDAwOy1tb3otYm94LXNoYWRvdzowIDAgMXB4ICMwMDA7Ym94LXNoYWRvdzowIDAgMXB4ICMwMDA7Ym9yZGVyLXJhZGl1czo0cHg7bWFyZ2luOjJweDtvcGFjaXR5Oi40O3RyYW5zaXRpb246b3BhY2l0eSAuNXN9ZGl2LmZpbmJhci1ob3Jpem9udGFsPi50aHVtYi5ob3ZlcixkaXYuZmluYmFyLXZlcnRpY2FsPi50aHVtYi5ob3ZlcntvcGFjaXR5OjE7dHJhbnNpdGlvbjpvcGFjaXR5IC41c31kaXYuZmluYmFyLXZlcnRpY2Fse3RvcDowO2JvdHRvbTowO3JpZ2h0OjA7d2lkdGg6MTFweH1kaXYuZmluYmFyLXZlcnRpY2FsPi50aHVtYnt0b3A6MDtyaWdodDowO3dpZHRoOjdweH1kaXYuZmluYmFyLWhvcml6b250YWx7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7aGVpZ2h0OjExcHh9ZGl2LmZpbmJhci1ob3Jpem9udGFsPi50aHVtYntsZWZ0OjA7Ym90dG9tOjA7aGVpZ2h0OjdweH0nO1xuLyogZW5kaW5qZWN0ICovXG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHRocm93ICdmaW5iYXJzOiAnICsgbXNnO1xufVxuXG4vLyBJbnRlcmZhY2Vcbm1vZHVsZS5leHBvcnRzID0gRmluQmFyO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlY3Rhbmd1bGFyID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKTtcblxudmFyIGdlc3R1cmVzID0gcmVxdWlyZSgnLi9qcy9wb2x5bWVyZ2VzdHVyZXMuZGV2LmpzJyk7XG52YXIgR3JhcGhpY3NDb250ZXh0ID0gcmVxdWlyZSgnLi9qcy9HcmFwaGljc0NvbnRleHQuanMnKTtcblxudmFyIFJFU0laRV9QT0xMSU5HX0lOVEVSVkFMID0gMjAwLFxuICAgIHBhaW50YWJsZXMgPSBbXSxcbiAgICByZXNpemFibGVzID0gW10sXG4gICAgcGFpbnRMb29wUnVubmluZyA9IHRydWUsXG4gICAgcmVzaXplTG9vcFJ1bm5pbmcgPSB0cnVlLFxuICAgIGNoYXJNYXAgPSBtYWtlQ2hhck1hcCgpO1xuXG5mdW5jdGlvbiBDYW52YXMoZGl2LCBjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZG91YmxlQ2xpY2tEZWxheSA9IG9wdGlvbnMuZG91YmxlQ2xpY2tEZWxheSB8fCAzMjU7XG5cbiAgICB0aGlzLmRyYWdFbmR0aW1lID0gRGF0ZS5ub3coKTtcblxuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgdGhpcy5jYW52YXMuc3R5bGUub3V0bGluZSA9ICdub25lJztcblxuICAgIC8vIHRoaXMuZm9jdXNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIC8vIHRoaXMuZm9jdXNlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIC8vIHRoaXMuZm9jdXNlci5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLnpJbmRleCA9ICctMSc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgLy8gdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5mb2N1c2VyKTtcblxuICAgIHRoaXMuY2FudmFzQ1RYID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmdjID0gbmV3IEdyYXBoaWNzQ29udGV4dCh0aGlzLmNhbnZhc0NUWCk7XG5cbiAgICB0aGlzLmJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuYnVmZmVyQ1RYID0gdGhpcy5idWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmJ1ZmZlckdDID0gbmV3IEdyYXBoaWNzQ29udGV4dCh0aGlzLmJ1ZmZlckNUWCk7XG5cbiAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoLTEsIC0xKTtcbiAgICB0aGlzLmRyYWdzdGFydCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgtMSwgLTEpO1xuICAgIC8vdGhpcy5vcmlnaW4gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgcmVjdGFuZ3VsYXIuUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xuICAgIHRoaXMuaGFzTW91c2UgPSBmYWxzZTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzTW91c2UgfHwgc2VsZi5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHNlbGYuZmlubW91c2Vtb3ZlKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5tb3VzZXVwKGUpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbndoZWVsbW92ZWQoZSk7XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5rZXlkb3duKGUpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmtleXVwKGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYW52YXMub25tb3VzZW92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5oYXNNb3VzZSA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5mb2N1c2dhaW5lZChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmZvY3VzbG9zdChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmlubW91c2Vkb3duKGUpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmhhc01vdXNlID0gZmFsc2U7XG4gICAgICAgIHNlbGYuZmlubW91c2VvdXQoZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluY2xpY2soZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluY29udGV4dG1lbnUoZSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3RhcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW50YXAoZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ2hvbGRwdWxzZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5ob2xkcHVsc2UoZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ2ZsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmZsaWNrKGUpO1xuICAgIH0pO1xuICAgIGdlc3R1cmVzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5jYW52YXMsICdyZWxlYXNlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbnJlbGVhc2UoZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3RyYWNrc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmludHJhY2tzdGFydChlKTtcbiAgICB9KTtcbiAgICBnZXN0dXJlcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuY2FudmFzLCAndHJhY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmludHJhY2soZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3RyYWNrZW5kJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbnRyYWNrZW5kKGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgIHRoaXMuY2FudmFzLmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgdGhpcy5iZWdpblJlc2l6aW5nKCk7XG4gICAgdGhpcy5iZWdpblBhaW50aW5nKCk7XG59XG5cbkNhbnZhcy5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENhbnZhcy5wcm90b3R5cGUuY29uc3RydWN0b3IsXG4gICAgZGl2OiBudWxsLFxuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBnZXN0dXJlczogZ2VzdHVyZXMsIC8vIFRPRE86IHdoeSBkbyB3ZSBuZWVkIHRoaXM/ICh3YXMgcHJldmlvdXNseSBhdCBib3R0b20gb2YgZmlsZSlcbiAgICBjYW52YXM6IG51bGwsXG4gICAgY2FudmFzQ1RYOiBudWxsLFxuICAgIGZvY3VzZXI6IG51bGwsXG4gICAgYnVmZmVyOiBudWxsLFxuICAgIGN0eDogbnVsbCxcbiAgICBtb3VzZUxvY2F0aW9uOiBudWxsLFxuICAgIGhvbGRQdWxzZUNvdW50OiAtMSxcbiAgICBkcmFnc3RhcnQ6IG51bGwsXG4gICAgb3JpZ2luOiBudWxsLFxuICAgIGJvdW5kczogbnVsbCxcbiAgICBkaXJ0eTogZmFsc2UsXG4gICAgc2l6ZTogbnVsbCxcbiAgICBtb3VzZWRvd246IGZhbHNlLFxuICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICByZXBlYXRLZXlDb3VudDogMCxcbiAgICByZXBlYXRLZXk6IG51bGwsXG4gICAgcmVwZWF0S2V5U3RhcnRUaW1lOiAwLFxuICAgIGN1cnJlbnRLZXlzOiBbXSxcbiAgICBoYXNNb3VzZTogZmFsc2UsXG4gICAgbGFzdERvdWJsZUNsaWNrVGltZTogMCxcbiAgICBkcmFnRW5kVGltZTogMCxcbiAgICBsYXN0UmVwYWludFRpbWU6IDAsXG5cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgc3RvcFBhaW50TG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhaW50TG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgcmVzdGFydFBhaW50TG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChwYWludExvb3BSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgcnVubmluZ1xuICAgICAgICB9XG4gICAgICAgIHBhaW50TG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGFpbnRMb29wRnVuY3Rpb24pO1xuICAgIH0sXG5cbiAgICBzdG9wUmVzaXplTG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc2l6ZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlc3RhcnRSZXNpemVMb29wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlc2l6ZUxvb3BSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgcnVubmluZ1xuICAgICAgICB9XG4gICAgICAgIHJlc2l6ZUxvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgc2V0SW50ZXJ2YWwocmVzaXphYmxlc0xvb3BGdW5jdGlvbiwgMjAwKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3BQYWludGluZygpO1xuICAgICAgICB0aGlzLnN0b3BSZXNpemluZygpO1xuICAgIH0sXG5cbiAgICB1c2VIaURQSTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5yZXNvbHZlUHJvcGVydHkoJ3VzZUhpRFBJJyk7XG4gICAgfSxcblxuICAgIHVzZUJpdEJsaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQucmVzb2x2ZVByb3BlcnR5KCd1c2VCaXRCbGl0Jyk7XG4gICAgfSxcblxuICAgIGdldEZQUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcHMgPSB0aGlzLmNvbXBvbmVudC5yZXNvbHZlUHJvcGVydHkoJ3JlcGFpbnRJbnRlcnZhbFJhdGUnKTtcbiAgICAgICAgcmV0dXJuIGZwcyA/IHBhcnNlSW50KGZwcykgOiAwO1xuICAgIH0sXG5cbiAgICB0aWNrUGFpbnQ6IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICB2YXIgZnBzID0gdGhpcy5nZXRGUFMoKTtcbiAgICAgICAgaWYgKGZwcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDEwMDAgLyBmcHM7XG5cbiAgICAgICAgdmFyIGVsYXBzZWQgPSBub3cgLSB0aGlzLmxhc3RSZXBhaW50VGltZTtcbiAgICAgICAgaWYgKGVsYXBzZWQgPiBpbnRlcnZhbCAmJiB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZXBhaW50VGltZSA9IG5vdyAtIChlbGFwc2VkICUgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJlZ2luUGFpbnRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnRpY2tQYWludGVyID0gZnVuY3Rpb24obm93KSB7XG4gICAgICAgICAgICBzZWxmLnRpY2tQYWludChub3cpO1xuICAgICAgICB9O1xuICAgICAgICBwYWludGFibGVzLnB1c2godGhpcyk7XG4gICAgfSxcblxuICAgIHN0b3BQYWludGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhaW50YWJsZXMuc3BsaWNlKHBhaW50YWJsZXMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgfSxcblxuICAgIGJlZ2luUmVzaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMudGlja1Jlc2l6ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuY2hlY2tzaXplKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlc2l6YWJsZXMucHVzaCh0aGlzKTtcbiAgICB9LFxuXG4gICAgc3RvcFJlc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzaXphYmxlcy5zcGxpY2UocmVzaXphYmxlcy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICB9LFxuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJlZ2luUGFpbnRpbmcoKTtcbiAgICAgICAgdGhpcy5iZWdpblJlc2l6aW5nKCk7XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3BQYWludGluZygpO1xuICAgICAgICB0aGlzLnN0b3BSZXNpemluZygpO1xuICAgIH0sXG5cbiAgICBjaGVja3NpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3RoaXMgaXMgZXhwZW5zaXZlIGxldHMgZG8gaXQgYXQgc29tZSBtb2R1bG9cbiAgICAgICAgdmFyIHNpemVOb3cgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKHNpemVOb3cud2lkdGggIT09IHRoaXMuc2l6ZS53aWR0aCB8fCBzaXplTm93LmhlaWdodCAhPT0gdGhpcy5zaXplLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5zaXplQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNpemVDaGFuZ2VkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJveCA9IHRoaXMuc2l6ZSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5idWZmZXIud2lkdGggPSBib3gud2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuYnVmZmVyLmhlaWdodCA9IGJveC5oZWlnaHQ7XG5cbiAgICAgICAgLy9maXggYWxhIHNpciBzcGlua2EsIHNlZVxuICAgICAgICAvL2h0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9oaWRwaS9cbiAgICAgICAgLy9qdXN0IGFkZCAnaGRwaScgYXMgYW4gYXR0cmlidXRlIHRvIHRoZSBmaW4tY2FudmFzIHRhZ1xuICAgICAgICB2YXIgcmF0aW8gPSAxO1xuICAgICAgICB2YXIgdXNlQml0QmxpdCA9IHRoaXMudXNlQml0QmxpdCgpO1xuICAgICAgICB2YXIgaXNISURQSSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICYmIHRoaXMudXNlSGlEUEkoKTtcbiAgICAgICAgaWYgKGlzSElEUEkpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgICAgIHZhciBiYWNraW5nU3RvcmVSYXRpbyA9IHRoaXMuY2FudmFzQ1RYLndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDVFgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDVFgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAgICAgICAgIHJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICAgICAgICAgICAgLy90aGlzLmNhbnZhc0NUWC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5idWZmZXIud2lkdGggPSB3aWR0aCAqIHJhdGlvO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmJ1ZmZlci5oZWlnaHQgPSBoZWlnaHQgKiByYXRpbztcblxuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMuYnVmZmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSB0aGlzLmJ1ZmZlci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIHRoaXMuYnVmZmVyQ1RYLnNjYWxlKHJhdGlvLCByYXRpbyk7XG4gICAgICAgIGlmIChpc0hJRFBJICYmICF1c2VCaXRCbGl0KSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90aGlzLm9yaWdpbiA9IG5ldyByZWN0YW5ndWxhci5Qb2ludChNYXRoLnJvdW5kKHRoaXMuc2l6ZS5sZWZ0KSwgTWF0aC5yb3VuZCh0aGlzLnNpemUudG9wKSk7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbmV3IHJlY3Rhbmd1bGFyLlJlY3RhbmdsZSgwLCAwLCBib3gud2lkdGgsIGJveC5oZWlnaHQpO1xuICAgICAgICAvL3NldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb21wID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIGlmIChjb21wKSB7XG4gICAgICAgICAgICBjb21wLnNldEJvdW5kcyh0aGlzLmJvdW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNpemVOb3RpZmljYXRpb24oKTtcbiAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICAvL30pO1xuICAgIH0sXG5cbiAgICByZXNpemVOb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3RvIGJlIG92ZXJyaWRkZW5cbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzO1xuICAgIH0sXG5cbiAgICBwYWludE5vdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zYWZlUGFpbnRJbW1lZGlhdGVseShmdW5jdGlvbihnYykge1xuICAgICAgICAgICAgZ2MuY2xlYXJSZWN0KDAsIDAsIHNlbGYuY2FudmFzLndpZHRoLCBzZWxmLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgY29tcCA9IHNlbGYuY29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wLnBhaW50KGdjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2FmZVBhaW50SW1tZWRpYXRlbHk6IGZ1bmN0aW9uKHBhaW50RnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHVzZUJpdEJsaXQgPSB0aGlzLnVzZUJpdEJsaXQoKSxcbiAgICAgICAgICAgIGdjID0gdXNlQml0QmxpdCA/IHRoaXMuYnVmZmVyR0MgOiB0aGlzLmdjO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2Muc2F2ZSgpO1xuICAgICAgICAgICAgcGFpbnRGdW5jdGlvbihnYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBnYy5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZUJpdEJsaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmbHVzaEJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci53aWR0aCA+IDAgJiYgdGhpcy5idWZmZXIuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNDVFguZHJhd0ltYWdlKHRoaXMuYnVmZmVyLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwYXRjaE5ld0V2ZW50OiBmdW5jdGlvbihldmVudCwgbmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsIHx8IHt9XG4gICAgICAgIH07XG4gICAgICAgIGRldGFpbC5kZXRhaWwucHJpbWl0aXZlRXZlbnQgPSBldmVudDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIGRldGFpbCkpO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50OiBmdW5jdGlvbihldmVudCwgbmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIGRldGFpbCA9IGRldGFpbCB8fCB7fTtcbiAgICAgICAgZGV0YWlsLm1vdXNlID0gdGhpcy5tb3VzZUxvY2F0aW9uO1xuICAgICAgICBkZXRhaWwua2V5cyA9IHRoaXMuY3VycmVudEtleXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZXZlbnQsIG5hbWUsIGRldGFpbCk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpICYmIHRoaXMubW91c2Vkb3duKSB7XG4gICAgICAgICAgICB0aGlzLmJlRHJhZ2dpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1kcmFnc3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRyYWdzdGFydCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCh0aGlzLm1vdXNlTG9jYXRpb24ueCwgdGhpcy5tb3VzZUxvY2F0aW9uLnkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5tb3VzZUxvY2F0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZHJhZycsIHtcbiAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuZHJhZ3N0YXJ0LFxuICAgICAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvdW5kcy5jb250YWlucyh0aGlzLm1vdXNlTG9jYXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtbW91c2Vtb3ZlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlubW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMubW91c2VEb3duTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLm1vdXNlZG93biA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLW1vdXNlZG93bicsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGFrZUZvY3VzKCk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNldXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZHJhZ2VuZCcsIHtcbiAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuZHJhZ3N0YXJ0LFxuICAgICAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5iZU5vdERyYWdnaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbmR0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtbW91c2V1cCcsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vdGhpcy5tb3VzZUxvY2F0aW9uID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KC0xLCAtMSk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNlb3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5tb3VzZWRvd24pIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgtMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1tb3VzZW91dCcpO1xuICAgIH0sXG5cbiAgICBmaW53aGVlbG1vdmVkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSB8fCAhdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtd2hlZWxtb3ZlZCcsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbmNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLmRvdWJsZUNsaWNrVGltZXIgJiYgRGF0ZS5ub3coKSAtIHRoaXMubGFzdENsaWNrVGltZSA8IHRoaXMuZG91YmxlQ2xpY2tEZWxheSkge1xuICAgICAgICAgICAgLy90aGlzIGlzIGEgZG91YmxlIGNsaWNrLi4uXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kb3VibGVDbGlja1RpbWVyKTsgLy8gcHJldmVudCBjbGljayBldmVudFxuICAgICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5maW5kYmxjbGljayhlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENsaWNrVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWNsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMuZG91YmxlQ2xpY2tEZWxheSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlucmVsZWFzZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmhvbGRQdWxzZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXJlbGVhc2UnKTtcbiAgICB9LFxuXG4gICAgZmluZmxpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZmxpY2snLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW50cmFja3N0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXRyYWNrc3RhcnQnKTtcbiAgICB9LFxuXG4gICAgZmludHJhY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtdHJhY2snKTtcbiAgICB9LFxuXG4gICAgZmludHJhY2tlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXRyYWNrZW5kJyk7XG4gICAgfSxcblxuICAgIGZpbmhvbGQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWhvbGQnLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5ob2xkcHVsc2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWhvbGRwdWxzZScsIHtcbiAgICAgICAgICAgIGNvdW50OiB0aGlzLmhvbGRQdWxzZUNvdW50KytcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbnRhcDogZnVuY3Rpb24oZSkge1xuICAgICAgICAvL3RoaXMgbm9uc2Vuc2UgaXMgdG8gaG9sZCBhIHRhcCBpZiBpdCdzIHJlYWxseSBhIGRvdWJsZSBjbGlja1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgZGlmID0gbm93IC0gdGhpcy5sYXN0RG91YmxlQ2xpY2tUaW1lO1xuICAgICAgICBpZiAoZGlmIDwgMzAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy9kcmFnZW5kIGlzIGFsc28gY2F1c2luZyBhIHRhcFxuICAgICAgICAvL2xldHMgZml4IHRoaXMgaGVyZVxuICAgICAgICBpZiAobm93IC0gdGhpcy5kcmFnRW5kdGltZSA8IDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl9maW50YXAoZSk7XG4gICAgICAgIH0sIDE4MCk7XG4gICAgfSxcblxuICAgIF9maW50YXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy90aGlzIG5vbnNlbnNlIGlzIHRvIGhvbGQgYSB0YXAgaWYgaXQncyByZWFsbHkgYSBkb3VibGUgY2xpY2tcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBkaWYgPSBub3cgLSB0aGlzLmxhc3REb3VibGVDbGlja1RpbWU7XG4gICAgICAgIGlmIChkaWYgPCAzMDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93bkxvY2F0aW9uKSB7IC8vIG1heWJlIG5vIG1vdXNlZG93biBvbiBhIHBob25lP1xuICAgICAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5tb3VzZURvd25Mb2NhdGlvbjsgLy8gbW91c2UgbWF5IGhhdmUgbW92ZWQgc2luY2UgbW91c2Vkb3duXG4gICAgICAgICAgICB0aGlzLm1vdXNlRG93bkxvY2F0aW9uID0gdW5kZWZpbmVkOyAvLyBjb25zdW1lIGl0IChtYXliZSBub3QgbmVlZGVkOyBvbmNlIGEgbW91c2Vkb3duIGFsd2F5cyBhIG1vdXNlZG93bilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy10YXAnLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5kYmxjbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmxhc3REb3VibGVDbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZGJsY2xpY2snLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdkYmxjbGljaycsIHRoaXMuY3VycmVudEtleXMpO1xuICAgIH0sXG5cbiAgICBnZXRDaGFyTWFwOiBmdW5jdGlvbigpIHsgLy9UT0RPOiBUaGlzIGlzIHN0YXRpYy4gTWFrZSBpdCBhIHByb3BlcnR5IG9mIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgcmV0dXJuIGNoYXJNYXA7XG4gICAgfSxcblxuICAgIGZpbmtleWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIga2V5Q2hhciA9IGUuc2hpZnRLZXkgPyBjaGFyTWFwW2Uua2V5Q29kZV1bMV0gOiBjaGFyTWFwW2Uua2V5Q29kZV1bMF07XG4gICAgICAgIGlmIChlLnJlcGVhdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0S2V5ID09PSBrZXlDaGFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEtleSA9IGtleUNoYXI7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEtleXMuaW5kZXhPZihrZXlDaGFyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEtleXMucHVzaChrZXlDaGFyKTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKGtleUNoYXIsIGUua2V5Q29kZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdFdmVudChlLCAnZmluLWNhbnZhcy1rZXlkb3duJywge1xuICAgICAgICAgICAgYWx0OiBlLmFsdEtleSxcbiAgICAgICAgICAgIGN0cmw6IGUuY3RybEtleSxcbiAgICAgICAgICAgIGNoYXI6IGtleUNoYXIsXG4gICAgICAgICAgICBjb2RlOiBlLmNoYXJDb2RlLFxuICAgICAgICAgICAga2V5OiBlLmtleUNvZGUsXG4gICAgICAgICAgICBtZXRhOiBlLm1ldGFLZXksXG4gICAgICAgICAgICByZXBlYXRDb3VudDogdGhpcy5yZXBlYXRLZXlDb3VudCxcbiAgICAgICAgICAgIHJlcGVhdFN0YXJ0VGltZTogdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUsXG4gICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGUua2V5SWRlbnRpZmllcixcbiAgICAgICAgICAgIGN1cnJlbnRLZXlzOiB0aGlzLmN1cnJlbnRLZXlzLnNsaWNlKDApXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5rZXl1cDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIga2V5Q2hhciA9IGUuc2hpZnRLZXkgPyBjaGFyTWFwW2Uua2V5Q29kZV1bMV0gOiBjaGFyTWFwW2Uua2V5Q29kZV1bMF07XG4gICAgICAgIHRoaXMuY3VycmVudEtleXMuc3BsaWNlKHRoaXMuY3VycmVudEtleXMuaW5kZXhPZihrZXlDaGFyKSwgMSk7XG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVwZWF0S2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMta2V5dXAnLCB7XG4gICAgICAgICAgICBhbHQ6IGUuYWx0S2V5LFxuICAgICAgICAgICAgY3RybDogZS5jdHJsS2V5LFxuICAgICAgICAgICAgY2hhcjoga2V5Q2hhcixcbiAgICAgICAgICAgIGNvZGU6IGUuY2hhckNvZGUsXG4gICAgICAgICAgICBrZXk6IGUua2V5Q29kZSxcbiAgICAgICAgICAgIG1ldGE6IGUubWV0YUtleSxcbiAgICAgICAgICAgIHJlcGVhdDogZS5yZXBlYXQsXG4gICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGUua2V5SWRlbnRpZmllcixcbiAgICAgICAgICAgIGN1cnJlbnRLZXlzOiB0aGlzLmN1cnJlbnRLZXlzLnNsaWNlKDApXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5mb2N1c2dhaW5lZDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtZ2FpbmVkJyk7XG4gICAgfSxcblxuICAgIGZpbmZvY3VzbG9zdDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtbG9zdCcpO1xuICAgIH0sXG5cbiAgICBmaW5jb250ZXh0bWVudTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5jdHJsS2V5ICYmIHRoaXMuY3VycmVudEtleXMuaW5kZXhPZignQ1RSTCcpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5cy5wdXNoKCdDVFJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyICYmIERhdGUubm93KCkgLSB0aGlzLmxhc3RDbGlja1RpbWUgPCB0aGlzLmRvdWJsZUNsaWNrRGVsYXkpIHtcbiAgICAgICAgICAgIC8vdGhpcyBpcyBhIGRvdWJsZSBjbGljay4uLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyKTsgLy8gcHJldmVudCBjb250ZXh0IG1lbnUgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5maW5kYmxjbGljayhlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENsaWNrVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdWJsZVJpZ2h0Q2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtY29udGV4dC1tZW51Jywge1xuICAgICAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMuZG91YmxlQ2xpY2tEZWxheSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVwYWludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcHMgPSB0aGlzLmdldEZQUygpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFwYWludExvb3BSdW5uaW5nIHx8IGZwcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE1vdXNlTG9jYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZUxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBnZXRPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludChyZWN0LmxlZnQsIHJlY3QudG9wKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIGdldExvY2FsOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBwID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KGUuY2xpZW50WCAtIHJlY3QubGVmdCwgZS5jbGllbnRZIC0gcmVjdC50b3ApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5jYW52YXM7XG4gICAgfSxcblxuICAgIHRha2VGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYW52YXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBiZURyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICBiZU5vdERyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICBpc0RyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ2dpbmc7XG4gICAgfSxcblxuICAgIGRpc2FibGVEb2N1bWVudEVsZW1lbnRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCArICctd2Via2l0LXVzZXItc2VsZWN0OiBub25lJztcbiAgICB9LFxuXG4gICAgZW5hYmxlRG9jdW1lbnRFbGVtZW50U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgc3R5bGUuY3NzVGV4dCA9IHN0eWxlLmNzc1RleHQucmVwbGFjZSgnLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZScsICcnKTtcbiAgICB9LFxuXG4gICAgc2V0Rm9jdXNhYmxlOiBmdW5jdGlvbih0cnV0aHkpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VyLnN0eWxlLmRpc3BsYXkgPSB0cnV0aHkgPyAnJyA6ICdub25lJztcbiAgICB9LFxuXG4gICAgaXNSaWdodENsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBpc1JpZ2h0TUI7XG4gICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICBpZiAoJ3doaWNoJyBpbiBlKSB7IC8vIEdlY2tvIChGaXJlZm94KSwgV2ViS2l0IChTYWZhcmkvQ2hyb21lKSAmIE9wZXJhXG4gICAgICAgICAgICBpc1JpZ2h0TUIgPSBlLndoaWNoID09PSAzO1xuICAgICAgICB9IGVsc2UgaWYgKCdidXR0b24nIGluIGUpIHsgLy8gSUUsIE9wZXJhXG4gICAgICAgICAgICBpc1JpZ2h0TUIgPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNSaWdodE1CO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHBhaW50TG9vcEZ1bmN0aW9uKG5vdykge1xuICAgIGlmICghcGFpbnRMb29wUnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpbnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFpbnRhYmxlc1tpXS50aWNrUGFpbnRlcihub3cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShwYWludExvb3BGdW5jdGlvbik7XG59XG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGFpbnRMb29wRnVuY3Rpb24pO1xuXG5mdW5jdGlvbiByZXNpemFibGVzTG9vcEZ1bmN0aW9uKG5vdykge1xuICAgIGlmICghcmVzaXplTG9vcFJ1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2l6YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc2l6YWJsZXNbaV0udGlja1Jlc2l6ZXIobm93KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnNldEludGVydmFsKHJlc2l6YWJsZXNMb29wRnVuY3Rpb24sIFJFU0laRV9QT0xMSU5HX0lOVEVSVkFMKTtcblxuZnVuY3Rpb24gbWFrZUNoYXJNYXAoKSB7XG4gICAgdmFyIG1hcCA9IFtdO1xuXG4gICAgdmFyIGVtcHR5ID0gWycnLCAnJ107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIG1hcFtpXSA9IGVtcHR5O1xuICAgIH1cblxuICAgIG1hcFsyN10gPSBbJ0VTQycsICdFU0NTSElGVCddO1xuICAgIG1hcFsxOTJdID0gWydgJywgJ34nXTtcbiAgICBtYXBbNDldID0gWycxJywgJyEnXTtcbiAgICBtYXBbNTBdID0gWycyJywgJ0AnXTtcbiAgICBtYXBbNTFdID0gWyczJywgJyMnXTtcbiAgICBtYXBbNTJdID0gWyc0JywgJyQnXTtcbiAgICBtYXBbNTNdID0gWyc1JywgJyUnXTtcbiAgICBtYXBbNTRdID0gWyc2JywgJ14nXTtcbiAgICBtYXBbNTVdID0gWyc3JywgJyYnXTtcbiAgICBtYXBbNTZdID0gWyc4JywgJyonXTtcbiAgICBtYXBbNTddID0gWyc5JywgJygnXTtcbiAgICBtYXBbNDhdID0gWycwJywgJyknXTtcbiAgICBtYXBbMTg5XSA9IFsnLScsICdfJ107XG4gICAgbWFwWzE4N10gPSBbJz0nLCAnKyddO1xuICAgIG1hcFs4XSA9IFsnQkFDS1NQQUNFJywgJ0JBQ0tTUEFDRVNISUZUJ107XG4gICAgbWFwWzQ2XSA9IFsnREVMRVRFJywgJ0RFTEVURVNISUZUJ107XG4gICAgbWFwWzldID0gWydUQUInLCAnVEFCU0hJRlQnXTtcbiAgICBtYXBbODFdID0gWydxJywgJ1EnXTtcbiAgICBtYXBbODddID0gWyd3JywgJ1cnXTtcbiAgICBtYXBbNjldID0gWydlJywgJ0UnXTtcbiAgICBtYXBbODJdID0gWydyJywgJ1InXTtcbiAgICBtYXBbODRdID0gWyd0JywgJ1QnXTtcbiAgICBtYXBbODldID0gWyd5JywgJ1knXTtcbiAgICBtYXBbODVdID0gWyd1JywgJ1UnXTtcbiAgICBtYXBbNzNdID0gWydpJywgJ0knXTtcbiAgICBtYXBbNzldID0gWydvJywgJ08nXTtcbiAgICBtYXBbODBdID0gWydwJywgJ1AnXTtcbiAgICBtYXBbMjE5XSA9IFsnWycsICd7J107XG4gICAgbWFwWzIyMV0gPSBbJ10nLCAnfSddO1xuICAgIG1hcFsyMjBdID0gWydcXFxcJywgJ3wnXTtcbiAgICBtYXBbMjIwXSA9IFsnQ0FQU0xPQ0snLCAnQ0FQU0xPQ0tTSElGVCddO1xuICAgIG1hcFs2NV0gPSBbJ2EnLCAnQSddO1xuICAgIG1hcFs4M10gPSBbJ3MnLCAnUyddO1xuICAgIG1hcFs2OF0gPSBbJ2QnLCAnRCddO1xuICAgIG1hcFs3MF0gPSBbJ2YnLCAnRiddO1xuICAgIG1hcFs3MV0gPSBbJ2cnLCAnRyddO1xuICAgIG1hcFs3Ml0gPSBbJ2gnLCAnSCddO1xuICAgIG1hcFs3NF0gPSBbJ2onLCAnSiddO1xuICAgIG1hcFs3NV0gPSBbJ2snLCAnSyddO1xuICAgIG1hcFs3Nl0gPSBbJ2wnLCAnTCddO1xuICAgIG1hcFsxODZdID0gWyc7JywgJzonXTtcbiAgICBtYXBbMjIyXSA9IFsnXFwnJywgJ3wnXTtcbiAgICBtYXBbMTNdID0gWydSRVRVUk4nLCAnUkVUVVJOU0hJRlQnXTtcbiAgICBtYXBbMTZdID0gWydTSElGVCcsICdTSElGVCddO1xuICAgIG1hcFs5MF0gPSBbJ3onLCAnWiddO1xuICAgIG1hcFs4OF0gPSBbJ3gnLCAnWCddO1xuICAgIG1hcFs2N10gPSBbJ2MnLCAnQyddO1xuICAgIG1hcFs4Nl0gPSBbJ3YnLCAnViddO1xuICAgIG1hcFs2Nl0gPSBbJ2InLCAnQiddO1xuICAgIG1hcFs3OF0gPSBbJ24nLCAnTiddO1xuICAgIG1hcFs3N10gPSBbJ20nLCAnTSddO1xuICAgIG1hcFsxODhdID0gWycsJywgJzwnXTtcbiAgICBtYXBbMTkwXSA9IFsnLicsICc+J107XG4gICAgbWFwWzE5MV0gPSBbJy8nLCAnPyddO1xuICAgIG1hcFsxNl0gPSBbJ1NISUZUJywgJ1NISUZUJ107XG4gICAgbWFwWzE3XSA9IFsnQ1RSTCcsICdDVFJMU0hJRlQnXTtcbiAgICBtYXBbMThdID0gWydBTFQnLCAnQUxUU0hJRlQnXTtcbiAgICBtYXBbOTFdID0gWydDT01NQU5ETEVGVCcsICdDT01NQU5ETEVGVFNISUZUJ107XG4gICAgbWFwWzMyXSA9IFsnU1BBQ0UnLCAnU1BBQ0VTSElGVCddO1xuICAgIG1hcFs5M10gPSBbJ0NPTU1BTkRSSUdIVCcsICdDT01NQU5EUklHSFRTSElGVCddO1xuICAgIG1hcFsxOF0gPSBbJ0FMVCcsICdBTFRTSElGVCddO1xuICAgIG1hcFszOF0gPSBbJ1VQJywgJ1VQU0hJRlQnXTtcbiAgICBtYXBbMzddID0gWydMRUZUJywgJ0xFRlRTSElGVCddO1xuICAgIG1hcFs0MF0gPSBbJ0RPV04nLCAnRE9XTlNISUZUJ107XG4gICAgbWFwWzM5XSA9IFsnUklHSFQnLCAnUklHSFRTSElGVCddO1xuXG4gICAgbWFwWzMzXSA9IFsnUEFHRVVQJywgJ1BBR0VVUFNISUZUJ107XG4gICAgbWFwWzM0XSA9IFsnUEFHRURPV04nLCAnUEFHRURPV05TSElGVCddO1xuICAgIG1hcFszNV0gPSBbJ1BBR0VSSUdIVCcsICdQQUdFUklHSFRTSElGVCddOyAvLyBFTkRcbiAgICBtYXBbMzZdID0gWydQQUdFTEVGVCcsICdQQUdFTEVGVFNISUZUJ107IC8vIEhPTUVcblxuICAgIG1hcFsxMTJdID0gWydGMScsICdGMVNISUZUJ107XG4gICAgbWFwWzExM10gPSBbJ0YyJywgJ0YyU0hJRlQnXTtcbiAgICBtYXBbMTE0XSA9IFsnRjMnLCAnRjNTSElGVCddO1xuICAgIG1hcFsxMTVdID0gWydGNCcsICdGNFNISUZUJ107XG4gICAgbWFwWzExNl0gPSBbJ0Y1JywgJ0Y1U0hJRlQnXTtcbiAgICBtYXBbMTE3XSA9IFsnRjYnLCAnRjZTSElGVCddO1xuICAgIG1hcFsxMThdID0gWydGNycsICdGN1NISUZUJ107XG4gICAgbWFwWzExOV0gPSBbJ0Y4JywgJ0Y4U0hJRlQnXTtcbiAgICBtYXBbMTIwXSA9IFsnRjknLCAnRjlTSElGVCddO1xuICAgIG1hcFsxMjFdID0gWydGMTAnLCAnRjEwU0hJRlQnXTtcbiAgICBtYXBbMTIyXSA9IFsnRjExJywgJ0YxUzFISUZUJ107XG4gICAgbWFwWzEyM10gPSBbJ0YxMicsICdGMTIxSElGVCddO1xuXG4gICAgcmV0dXJuIG1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb25zb2xlTG9nZ2VyID0gcmVxdWlyZSgnLi9nYy1jb25zb2xlLWxvZ2dlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGdjIC0gVGhlIDItRCBncmFwaGljcyBjb250ZXh0IGZyb20geW91ciBjYW52YXNcbiAqIEBwYXJhbSB7Ym9vbGVhbnxhcGlMb2dnZXJ9IFtsb2dnZXI9dHJ1ZV1cbiAqICogYHRydWVgIHVzZXMgYGdjLWNvbnNvbGUtbG9nZ2VyYCBmdW5jdGlvbiBib3VuZCB0byAnZ2MuJyBhcyBwcmVmaXhcbiAqICogc3RyaW5nIHVzZXMgYGdjLWNvbnNvbGUtbG9nZ2VyYCBmdW5jdGlvbiBib3VuZCB0byBzdHJpbmdcbiAqICogZnVuY3Rpb24gdXNlZCBhcyBpc1xuICovXG5mdW5jdGlvbiBHcmFwaGljc0NvbnRleHQoZ2MsIGxvZ2dlcikge1xuICAgIHRoaXMuZ2MgPSBnYztcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVXRUJLSVQgPSAvXndlYmtpdC87XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiBsb2dnZXIpIHtcblxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgbG9nZ2VyID0gIGNvbnNvbGVMb2dnZXIuYmluZCh1bmRlZmluZWQsIGxvZ2dlciArICcuJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGlmIChsb2dnZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIgPSBjb25zb2xlTG9nZ2VyLmJpbmQodW5kZWZpbmVkLCAnZ2MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICBpZiAobG9nZ2VyLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgIHRocm93ICdHcmFwaGljc0NvbnRleHQ6IFVzZXItc3VwcGxpZWQgQVBJIGxvZ2dlciBmdW5jdGlvbiBkb2VzIG5vdCBhY2NlcHQgdGhyZWUgcGFyYW1ldGVycy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGxvZ2dlciA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFN0dWIgb3V0IGFsbCB0aGUgcHJvdG90eXBlIG1lbWJlcnMgb2YgdGhlIGNhbnZhcyAyRCBncmFwaGljcyBjb250ZXh0OlxuICAgIE9iamVjdC5rZXlzKE9iamVjdC5nZXRQcm90b3R5cGVPZihnYykpLmZvckVhY2goTWFrZVN0dWIpO1xuXG4gICAgLy8gU29tZSBvbGRlciBicm93c2VycyAoZS5nLiwgQ2hyb21lIDQwKSBkaWQgbm90IGhhdmUgYWxsIG1lbWJlcnMgb2YgY2FudmFzXG4gICAgLy8gMkQgZ3JhcGhpY3MgY29udGV4dCBpbiB0aGUgcHJvdG90eXBlIHNvIHdlIG1ha2UgdGhpcyBhZGRpdGlvbmFsIGNhbGw6XG4gICAgT2JqZWN0LmtleXMoZ2MpLmZvckVhY2goTWFrZVN0dWIpO1xuXG4gICAgZnVuY3Rpb24gTWFrZVN0dWIoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgaW4gR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZSB8fCByZVdFQktJVC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdjW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGZba2V5XSA9ICFsb2dnZXIgPyBnY1trZXldLmJpbmQoZ2MpIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlcihrZXksIGFyZ3VtZW50cywgZ2Nba2V5XS5hcHBseShnYywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBnY1trZXldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyID8gbG9nZ2VyKGtleSwgJ2dldHRlcicsIHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdjW2tleV0gPSBsb2dnZXIgPyBsb2dnZXIoa2V5LCAnc2V0dGVyJywgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3NDb250ZXh0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgWUlFTERTID0gJ1xcdTI3RjknOyAvLyBMT05HIFJJR0hUV0FSRFMgRE9VQkxFIEFSUk9XXG5cbmZ1bmN0aW9uIGNvbnNvbGVMb2dnZXIocHJlZml4LCBuYW1lLCBhcmdzLCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc3VsdCA9ICdcIicgKyByZXN1bHQgKyAnXCInO1xuICAgIH1cblxuICAgIG5hbWUgPSBwcmVmaXggKyBuYW1lO1xuXG4gICAgc3dpdGNoIChhcmdzKSB7XG4gICAgICAgIGNhc2UgJ2dldHRlcic6XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCAnPScsIHJlc3VsdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZXR0ZXInOlxuICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZSwgWUlFTERTLCByZXN1bHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDogLy8gbWV0aG9kIGNhbGxcbiAgICAgICAgICAgIG5hbWUgKz0gJygnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignLCAnKSArICcpJztcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCBZSUVMRFMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGVMb2dnZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8vbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGhhc0Z1bGxQYXRoID0gZmFsc2U7XG5cbiAgICAvLyB0ZXN0IGZvciBmdWxsIGV2ZW50IHBhdGggc3VwcG9ydFxuICAgIHZhciBwYXRoVGVzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcbiAgICBpZiAocGF0aFRlc3QuY3JlYXRlU2hhZG93Um9vdCkge1xuICAgICAgICB2YXIgc3IgPSBwYXRoVGVzdC5jcmVhdGVTaGFkb3dSb290KCk7XG4gICAgICAgIHZhciBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBzci5hcHBlbmRDaGlsZChzKTtcbiAgICAgICAgcGF0aFRlc3QuYWRkRXZlbnRMaXN0ZW5lcigndGVzdHBhdGgnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgaWYgKGV2LnBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3BhbiBpcyBpbiB0aGUgZXZlbnQgcGF0aCwgdGhlbiBwYXRoWzBdIGlzIHRoZSByZWFsIHNvdXJjZSBmb3IgYWxsIGV2ZW50c1xuICAgICAgICAgICAgICAgIGhhc0Z1bGxQYXRoID0gZXYucGF0aFswXSA9PT0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGV2ID0gbmV3IEN1c3RvbUV2ZW50KCd0ZXN0cGF0aCcsIHtcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG11c3QgYWRkIG5vZGUgdG8gRE9NIHRvIHRyaWdnZXIgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChwYXRoVGVzdCk7XG4gICAgICAgIHMuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICAgIHBhdGhUZXN0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocGF0aFRlc3QpO1xuICAgICAgICBzciA9IHMgPSBudWxsO1xuICAgIH1cbiAgICBwYXRoVGVzdCA9IG51bGw7XG5cbiAgICB2YXIgdGFyZ2V0ID0ge1xuICAgICAgICBzaGFkb3c6IGZ1bmN0aW9uKGluRWwpIHtcbiAgICAgICAgICAgIGlmIChpbkVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluRWwuc2hhZG93Um9vdCB8fCBpbkVsLndlYmtpdFNoYWRvd1Jvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhblRhcmdldDogZnVuY3Rpb24oc2hhZG93KSB7XG4gICAgICAgICAgICByZXR1cm4gc2hhZG93ICYmIEJvb2xlYW4oc2hhZG93LmVsZW1lbnRGcm9tUG9pbnQpO1xuICAgICAgICB9LFxuICAgICAgICB0YXJnZXRpbmdTaGFkb3c6IGZ1bmN0aW9uKGluRWwpIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zaGFkb3coaW5FbCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5UYXJnZXQocykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb2xkZXJTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgICAgICAgdmFyIG9zID0gc2hhZG93Lm9sZGVyU2hhZG93Um9vdDtcbiAgICAgICAgICAgIGlmICghb3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2UgPSBzaGFkb3cucXVlcnlTZWxlY3Rvcignc2hhZG93Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9zID0gc2Uub2xkZXJTaGFkb3dSb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcztcbiAgICAgICAgfSxcbiAgICAgICAgYWxsU2hhZG93czogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHNoYWRvd3MgPSBbXSxcbiAgICAgICAgICAgICAgICBzID0gdGhpcy5zaGFkb3coZWxlbWVudCk7XG4gICAgICAgICAgICB3aGlsZSAocykge1xuICAgICAgICAgICAgICAgIHNoYWRvd3MucHVzaChzKTtcbiAgICAgICAgICAgICAgICBzID0gdGhpcy5vbGRlclNoYWRvdyhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaGFkb3dzO1xuICAgICAgICB9LFxuICAgICAgICBzZWFyY2hSb290OiBmdW5jdGlvbihpblJvb3QsIHgsIHkpIHtcbiAgICAgICAgICAgIHZhciB0LCBzdCwgc3IsIG9zO1xuICAgICAgICAgICAgaWYgKGluUm9vdCkge1xuICAgICAgICAgICAgICAgIHQgPSBpblJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBlbGVtZW50LCBjaGVjayBpZiBpdCBoYXMgYSBTaGFkb3dSb290XG4gICAgICAgICAgICAgICAgICAgIHNyID0gdGhpcy50YXJnZXRpbmdTaGFkb3codCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpblJvb3QgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzaWJsaW5nIHJvb3RzXG4gICAgICAgICAgICAgICAgICAgIHNyID0gdGhpcy5vbGRlclNoYWRvdyhpblJvb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzZWFyY2ggb3RoZXIgcm9vdHMsIGZhbGwgYmFjayB0byBsaWdodCBkb20gZWxlbWVudFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaFJvb3Qoc3IsIHgsIHkpIHx8IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG93bmVyOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcyA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAvLyB3YWxrIHVwIHVudGlsIHlvdSBoaXQgdGhlIHNoYWRvdyByb290IG9yIGRvY3VtZW50XG4gICAgICAgICAgICB3aGlsZSAocy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZSBvd25lciBlbGVtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGEgRG9jdW1lbnQgb3IgU2hhZG93Um9vdFxuICAgICAgICAgICAgaWYgKHMubm9kZVR5cGUgIT0gTm9kZS5ET0NVTUVOVF9OT0RFICYmIHMubm9kZVR5cGUgIT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcyA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRUYXJnZXQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChoYXNGdWxsUGF0aCAmJiBpbkV2ZW50LnBhdGggJiYgaW5FdmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbkV2ZW50LnBhdGhbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5ID0gaW5FdmVudC5jbGllbnRZO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGxpc3RlbmVyIGlzIGluIHRoZSBzaGFkb3cgcm9vdCwgaXQgaXMgbXVjaCBmYXN0ZXIgdG8gc3RhcnQgdGhlcmVcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5vd25lcihpbkV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAvLyBpZiB4LCB5IGlzIG5vdCBpbiB0aGlzIHJvb3QsIGZhbGwgYmFjayB0byBkb2N1bWVudCBzZWFyY2hcbiAgICAgICAgICAgIGlmICghcy5lbGVtZW50RnJvbVBvaW50KHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgcyA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoUm9vdChzLCB4LCB5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZFRvdWNoQWN0aW9uOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgIGlmIChoYXNGdWxsUGF0aCAmJiBpbkV2ZW50LnBhdGggJiYgaW5FdmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gaW5FdmVudC5wYXRoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuID0gcGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIG4uaGFzQXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uZ2V0QXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IGluRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBuLmhhc0F0dHJpYnV0ZSgndG91Y2gtYWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuLmdldEF0dHJpYnV0ZSgndG91Y2gtYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZSB8fCBuLmhvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXV0byBpcyBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4gXCJhdXRvXCI7XG4gICAgICAgIH0sXG4gICAgICAgIExDQTogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhICYmICFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiAmJiAhYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFiICYmICFhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFzdCBjYXNlLCBhIGlzIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgYiBvciB2aWNlIHZlcnNhXG4gICAgICAgICAgICBpZiAoYS5jb250YWlucyAmJiBhLmNvbnRhaW5zKGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYi5jb250YWlucyAmJiBiLmNvbnRhaW5zKGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWRlcHRoID0gdGhpcy5kZXB0aChhKTtcbiAgICAgICAgICAgIHZhciBiZGVwdGggPSB0aGlzLmRlcHRoKGIpO1xuICAgICAgICAgICAgdmFyIGQgPSBhZGVwdGggLSBiZGVwdGg7XG4gICAgICAgICAgICBpZiAoZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYSA9IHRoaXMud2FsayhhLCBkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYiA9IHRoaXMud2FsayhiLCAtZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoYSAmJiBiICYmIGEgIT09IGIpIHtcbiAgICAgICAgICAgICAgICBhID0gYS5wYXJlbnROb2RlIHx8IGEuaG9zdDtcbiAgICAgICAgICAgICAgICBiID0gYi5wYXJlbnROb2RlIHx8IGIuaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9LFxuICAgICAgICB3YWxrOiBmdW5jdGlvbihuLCB1KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgbiAmJiAoaSA8IHUpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9LFxuICAgICAgICBkZXB0aDogZnVuY3Rpb24obikge1xuICAgICAgICAgICAgdmFyIGQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgICAgICAgICBkKys7XG4gICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZSB8fCBuLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVlcENvbnRhaW5zOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICB2YXIgY29tbW9uID0gdGhpcy5MQ0EoYSwgYik7XG4gICAgICAgICAgICAvLyBpZiBhIGlzIHRoZSBjb21tb24gYW5jZXN0b3IsIGl0IG11c3QgXCJkZWVwbHlcIiBjb250YWluIGJcbiAgICAgICAgICAgIHJldHVybiBjb21tb24gPT09IGE7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2lkZU5vZGU6IGZ1bmN0aW9uKG5vZGUsIHgsIHkpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiAocmVjdC5sZWZ0IDw9IHgpICYmICh4IDw9IHJlY3QucmlnaHQpICYmIChyZWN0LnRvcCA8PSB5KSAmJiAoeSA8PSByZWN0LmJvdHRvbSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIGlmIChoYXNGdWxsUGF0aCAmJiBldmVudC5wYXRoICYmIGV2ZW50LnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcCA9IGV2ZW50LnBhdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuZmluZFRhcmdldChldmVudCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKG4pO1xuICAgICAgICAgICAgICAgICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc2NvcGUudGFyZ2V0RmluZGluZyA9IHRhcmdldDtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBldmVudCwgZmluZHMgdGhlIFwiZGVlcGVzdFwiIG5vZGUgdGhhdCBjb3VsZCBoYXZlIGJlZW4gdGhlIG9yaWdpbmFsIHRhcmdldCBiZWZvcmUgU2hhZG93RE9NIHJldGFyZ2V0dGluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gRXZlbnQgQW4gZXZlbnQgb2JqZWN0IHdpdGggY2xpZW50WCBhbmQgY2xpZW50WSBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIHByb2JhYmxlIGV2ZW50IG9yaWduaW5hdG9yXG4gICAgICovXG4gICAgc2NvcGUuZmluZFRhcmdldCA9IHRhcmdldC5maW5kVGFyZ2V0LmJpbmQodGFyZ2V0KTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBcImNvbnRhaW5lclwiIG5vZGUgZGVlcGx5IGNvbnRhaW5zIHRoZSBcImNvbnRhaW5lZVwiIG5vZGUsIGluY2x1ZGluZyBzaXR1YXRpb25zIHdoZXJlIHRoZSBcImNvbnRhaW5lZVwiIGlzIGNvbnRhaW5lZCBieSBvbmUgb3IgbW9yZSBTaGFkb3dET01cbiAgICAgKiByb290cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHtOb2RlfSBjb250YWluZWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNjb3BlLmRlZXBDb250YWlucyA9IHRhcmdldC5kZWVwQ29udGFpbnMuYmluZCh0YXJnZXQpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgeC95IHBvc2l0aW9uIGlzIGluc2lkZSB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgZnVuY3Rpb24gdXBIYW5kbGVyKGV2ZW50KSB7XG4gICAgICogICAgICAgdmFyIGlubm9kZSA9IFBvbHltZXJHZXN0dXJlcy5pbnNpZGVOb2RlKGV2ZW50LnRhcmdldCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICogICAgICAgaWYgKGlubm9kZSkge1xuICAgICAqICAgICAgICAgLy8gd2FpdCBmb3IgdGFwP1xuICAgICAqICAgICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgICAvLyB0YXAgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFNjcmVlbiBYIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgc2NyZWVuIFkgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNjb3BlLmluc2lkZU5vZGUgPSB0YXJnZXQuaW5zaWRlTm9kZTtcblxufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBzaGFkb3dTZWxlY3Rvcih2KSB7XG4gICAgICAgIHJldHVybiAnaHRtbCAvZGVlcC8gJyArIHNlbGVjdG9yKHYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdG9yKHYpIHtcbiAgICAgICAgcmV0dXJuICdbdG91Y2gtYWN0aW9uPVwiJyArIHYgKyAnXCJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydWxlKHYpIHtcbiAgICAgICAgcmV0dXJuICd7IC1tcy10b3VjaC1hY3Rpb246ICcgKyB2ICsgJzsgdG91Y2gtYWN0aW9uOiAnICsgdiArICc7fSc7XG4gICAgfVxuICAgIHZhciBhdHRyaWIyY3NzID0gW1xuICAgICAgICAnbm9uZScsXG4gICAgICAgICdhdXRvJyxcbiAgICAgICAgJ3Bhbi14JyxcbiAgICAgICAgJ3Bhbi15Jywge1xuICAgICAgICAgICAgcnVsZTogJ3Bhbi14IHBhbi15JyxcbiAgICAgICAgICAgIHNlbGVjdG9yczogW1xuICAgICAgICAgICAgICAgICdwYW4teCBwYW4teScsXG4gICAgICAgICAgICAgICAgJ3Bhbi15IHBhbi14J1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAnbWFuaXB1bGF0aW9uJ1xuICAgIF07XG4gICAgdmFyIHN0eWxlcyA9ICcnO1xuICAgIC8vIG9ubHkgaW5zdGFsbCBzdHlsZXNoZWV0IGlmIHRoZSBicm93c2VyIGhhcyB0b3VjaCBhY3Rpb24gc3VwcG9ydFxuICAgIHZhciBoYXNUb3VjaEFjdGlvbiA9IHR5cGVvZiBkb2N1bWVudC5oZWFkLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnc3RyaW5nJztcbiAgICAvLyBvbmx5IGFkZCBzaGFkb3cgc2VsZWN0b3JzIGlmIHNoYWRvd2RvbSBpcyBzdXBwb3J0ZWRcbiAgICB2YXIgaGFzU2hhZG93Um9vdCA9ICF3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwgJiYgZG9jdW1lbnQuaGVhZC5jcmVhdGVTaGFkb3dSb290O1xuXG4gICAgaWYgKGhhc1RvdWNoQWN0aW9uKSB7XG4gICAgICAgIGF0dHJpYjJjc3MuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICBpZiAoU3RyaW5nKHIpID09PSByKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzICs9IHNlbGVjdG9yKHIpICsgcnVsZShyKSArICdcXG4nO1xuICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyArPSBzaGFkb3dTZWxlY3RvcihyKSArIHJ1bGUocikgKyAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlcyArPSByLnNlbGVjdG9ycy5tYXAoc2VsZWN0b3IpICsgcnVsZShyLnJ1bGUpICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzICs9IHIuc2VsZWN0b3JzLm1hcChzaGFkb3dTZWxlY3RvcikgKyBydWxlKHIucnVsZSkgKyAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gc3R5bGVzO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG59KSgpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbnN0cnVjdG9yIGZvciBuZXcgUG9pbnRlckV2ZW50cy5cbiAqXG4gKiBOZXcgUG9pbnRlciBFdmVudHMgbXVzdCBiZSBnaXZlbiBhIHR5cGUsIGFuZCBhbiBvcHRpb25hbCBkaWN0aW9uYXJ5IG9mXG4gKiBpbml0aWFsaXphdGlvbiBwcm9wZXJ0aWVzLlxuICpcbiAqIER1ZSB0byBjZXJ0YWluIHBsYXRmb3JtIHJlcXVpcmVtZW50cywgZXZlbnRzIHJldHVybmVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gKiBpZGVudGlmeSBhcyBNb3VzZUV2ZW50cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBpblR5cGUgVGhlIHR5cGUgb2YgdGhlIGV2ZW50IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaW5EaWN0XSBBbiBvcHRpb25hbCBkaWN0aW9uYXJ5IG9mIGluaXRpYWwgZXZlbnQgcHJvcGVydGllcy5cbiAqIEByZXR1cm4ge0V2ZW50fSBBIG5ldyBQb2ludGVyRXZlbnQgb2YgdHlwZSBgaW5UeXBlYCBhbmQgaW5pdGlhbGl6ZWQgd2l0aCBwcm9wZXJ0aWVzIGZyb20gYGluRGljdGAuXG4gKi9cbihmdW5jdGlvbihzY29wZSkge1xuXG4gICAgdmFyIE1PVVNFX1BST1BTID0gW1xuICAgICAgICAnYnViYmxlcycsXG4gICAgICAgICdjYW5jZWxhYmxlJyxcbiAgICAgICAgJ3ZpZXcnLFxuICAgICAgICAnZGV0YWlsJyxcbiAgICAgICAgJ3NjcmVlblgnLFxuICAgICAgICAnc2NyZWVuWScsXG4gICAgICAgICdjbGllbnRYJyxcbiAgICAgICAgJ2NsaWVudFknLFxuICAgICAgICAnY3RybEtleScsXG4gICAgICAgICdhbHRLZXknLFxuICAgICAgICAnc2hpZnRLZXknLFxuICAgICAgICAnbWV0YUtleScsXG4gICAgICAgICdidXR0b24nLFxuICAgICAgICAncmVsYXRlZFRhcmdldCcsXG4gICAgICAgICdwYWdlWCcsXG4gICAgICAgICdwYWdlWSdcbiAgICBdO1xuXG4gICAgdmFyIE1PVVNFX0RFRkFVTFRTID0gW1xuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAwLFxuICAgICAgICBudWxsLFxuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgXTtcblxuICAgIHZhciBOT1BfRkFDVE9SWSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHtcbiAgICAgICAgLy8gVE9ETyhkZnJlZWRtKTogdGhpcyBpcyBvdmVycmlkZGVuIGJ5IHRhcCByZWNvZ25pemVyLCBuZWVkcyByZXZpZXdcbiAgICAgICAgcHJldmVudFRhcDogTk9QX0ZBQ1RPUlksXG4gICAgICAgIG1ha2VCYXNlRXZlbnQ6IGZ1bmN0aW9uKGluVHlwZSwgaW5EaWN0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgICAgZS5pbml0RXZlbnQoaW5UeXBlLCBpbkRpY3QuYnViYmxlcyB8fCBmYWxzZSwgaW5EaWN0LmNhbmNlbGFibGUgfHwgZmFsc2UpO1xuICAgICAgICAgICAgZS5wcmV2ZW50VGFwID0gZXZlbnRGYWN0b3J5LnByZXZlbnRUYXAoZSk7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFrZUdlc3R1cmVFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkRpY3QpIHtcbiAgICAgICAgICAgIGluRGljdCA9IGluRGljdCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMubWFrZUJhc2VFdmVudChpblR5cGUsIGluRGljdCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGluRGljdCksIGs7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgayA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGsgIT09ICdidWJibGVzJyAmJiBrICE9PSAnY2FuY2VsYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrXSA9IGluRGljdFtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFrZVBvaW50ZXJFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkRpY3QpIHtcbiAgICAgICAgICAgIGluRGljdCA9IGluRGljdCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMubWFrZUJhc2VFdmVudChpblR5cGUsIGluRGljdCk7XG4gICAgICAgICAgICAvLyBkZWZpbmUgaW5oZXJpdGVkIE1vdXNlRXZlbnQgcHJvcGVydGllc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDIsIHA7IGkgPCBNT1VTRV9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHAgPSBNT1VTRV9QUk9QU1tpXTtcbiAgICAgICAgICAgICAgICBlW3BdID0gaW5EaWN0W3BdIHx8IE1PVVNFX0RFRkFVTFRTW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5idXR0b25zID0gaW5EaWN0LmJ1dHRvbnMgfHwgMDtcblxuICAgICAgICAgICAgLy8gU3BlYyByZXF1aXJlcyB0aGF0IHBvaW50ZXJzIHdpdGhvdXQgcHJlc3N1cmUgc3BlY2lmaWVkIHVzZSAwLjUgZm9yIGRvd25cbiAgICAgICAgICAgIC8vIHN0YXRlIGFuZCAwIGZvciB1cCBzdGF0ZS5cbiAgICAgICAgICAgIHZhciBwcmVzc3VyZSA9IDA7XG4gICAgICAgICAgICBpZiAoaW5EaWN0LnByZXNzdXJlKSB7XG4gICAgICAgICAgICAgICAgcHJlc3N1cmUgPSBpbkRpY3QucHJlc3N1cmU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXNzdXJlID0gZS5idXR0b25zID8gMC41IDogMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHgveSBwcm9wZXJ0aWVzIGFsaWFzZWQgdG8gY2xpZW50WC9ZXG4gICAgICAgICAgICBlLnggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICBlLnkgPSBlLmNsaWVudFk7XG5cbiAgICAgICAgICAgIC8vIGRlZmluZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgUG9pbnRlckV2ZW50IGludGVyZmFjZVxuICAgICAgICAgICAgZS5wb2ludGVySWQgPSBpbkRpY3QucG9pbnRlcklkIHx8IDA7XG4gICAgICAgICAgICBlLndpZHRoID0gaW5EaWN0LndpZHRoIHx8IDA7XG4gICAgICAgICAgICBlLmhlaWdodCA9IGluRGljdC5oZWlnaHQgfHwgMDtcbiAgICAgICAgICAgIGUucHJlc3N1cmUgPSBwcmVzc3VyZTtcbiAgICAgICAgICAgIGUudGlsdFggPSBpbkRpY3QudGlsdFggfHwgMDtcbiAgICAgICAgICAgIGUudGlsdFkgPSBpbkRpY3QudGlsdFkgfHwgMDtcbiAgICAgICAgICAgIGUucG9pbnRlclR5cGUgPSBpbkRpY3QucG9pbnRlclR5cGUgfHwgJyc7XG4gICAgICAgICAgICBlLmh3VGltZXN0YW1wID0gaW5EaWN0Lmh3VGltZXN0YW1wIHx8IDA7XG4gICAgICAgICAgICBlLmlzUHJpbWFyeSA9IGluRGljdC5pc1ByaW1hcnkgfHwgZmFsc2U7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSBpbkRpY3QuX3NvdXJjZSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNjb3BlLmV2ZW50RmFjdG9yeSA9IGV2ZW50RmFjdG9yeTtcbn0pKGV4cG9ydHMpO1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGltcGxlbWVudHMgYW4gbWFwIG9mIHBvaW50ZXIgc3RhdGVzXG4gKi9cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBVU0VfTUFQID0gd2luZG93Lk1hcCAmJiB3aW5kb3cuTWFwLnByb3RvdHlwZS5mb3JFYWNoO1xuICAgIHZhciBQT0lOVEVSU19GTiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBQb2ludGVyTWFwKCkge1xuICAgICAgICBpZiAoVVNFX01BUCkge1xuICAgICAgICAgICAgdmFyIG0gPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBtLnBvaW50ZXJzID0gUE9JTlRFUlNfRk47XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFBvaW50ZXJNYXAucHJvdG90eXBlID0ge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGluSWQsIGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5rZXlzLmluZGV4T2YoaW5JZCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXNbaV0gPSBpbkV2ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleXMucHVzaChpbklkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKGluRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoYXM6IGZ1bmN0aW9uKGluSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleXMuaW5kZXhPZihpbklkKSA+IC0xO1xuICAgICAgICB9LFxuICAgICAgICAnZGVsZXRlJzogZnVuY3Rpb24oaW5JZCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmtleXMuaW5kZXhPZihpbklkKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihpbklkKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMua2V5cy5pbmRleE9mKGluSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2ldO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmtleXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJldHVybiB2YWx1ZSwga2V5LCBtYXBcbiAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdiwgdGhpcy5rZXlzW2ldLCB0aGlzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5Qb2ludGVyTWFwID0gUG9pbnRlck1hcDtcbn0pKGV4cG9ydHMpO1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgQ0xPTkVfUFJPUFMgPSBbXG4gICAgICAgIC8vIE1vdXNlRXZlbnRcbiAgICAgICAgJ2J1YmJsZXMnLFxuICAgICAgICAnY2FuY2VsYWJsZScsXG4gICAgICAgICd2aWV3JyxcbiAgICAgICAgJ2RldGFpbCcsXG4gICAgICAgICdzY3JlZW5YJyxcbiAgICAgICAgJ3NjcmVlblknLFxuICAgICAgICAnY2xpZW50WCcsXG4gICAgICAgICdjbGllbnRZJyxcbiAgICAgICAgJ2N0cmxLZXknLFxuICAgICAgICAnYWx0S2V5JyxcbiAgICAgICAgJ3NoaWZ0S2V5JyxcbiAgICAgICAgJ21ldGFLZXknLFxuICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgJ3JlbGF0ZWRUYXJnZXQnLFxuICAgICAgICAvLyBET00gTGV2ZWwgM1xuICAgICAgICAnYnV0dG9ucycsXG4gICAgICAgIC8vIFBvaW50ZXJFdmVudFxuICAgICAgICAncG9pbnRlcklkJyxcbiAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICdwcmVzc3VyZScsXG4gICAgICAgICd0aWx0WCcsXG4gICAgICAgICd0aWx0WScsXG4gICAgICAgICdwb2ludGVyVHlwZScsXG4gICAgICAgICdod1RpbWVzdGFtcCcsXG4gICAgICAgICdpc1ByaW1hcnknLFxuICAgICAgICAvLyBldmVudCBpbnN0YW5jZVxuICAgICAgICAndHlwZScsXG4gICAgICAgICd0YXJnZXQnLFxuICAgICAgICAnY3VycmVudFRhcmdldCcsXG4gICAgICAgICd3aGljaCcsXG4gICAgICAgICdwYWdlWCcsXG4gICAgICAgICdwYWdlWScsXG4gICAgICAgICd0aW1lU3RhbXAnLFxuICAgICAgICAvLyBnZXN0dXJlIGFkZG9uc1xuICAgICAgICAncHJldmVudFRhcCcsXG4gICAgICAgICd0YXBQcmV2ZW50ZWQnLFxuICAgICAgICAnX3NvdXJjZSdcbiAgICBdO1xuXG4gICAgdmFyIENMT05FX0RFRkFVTFRTID0gW1xuICAgICAgICAvLyBNb3VzZUV2ZW50XG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDAsXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIERPTSBMZXZlbCAzXG4gICAgICAgIDAsXG4gICAgICAgIC8vIFBvaW50ZXJFdmVudFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAnJyxcbiAgICAgICAgMCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIC8vIGV2ZW50IGluc3RhbmNlXG4gICAgICAgICcnLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBmdW5jdGlvbigpIHt9LFxuICAgICAgICBmYWxzZVxuICAgIF07XG5cbiAgICB2YXIgSEFTX1NWR19JTlNUQU5DRSA9ICh0eXBlb2YgU1ZHRWxlbWVudEluc3RhbmNlICE9PSAndW5kZWZpbmVkJyk7XG5cbiAgICB2YXIgZXZlbnRGYWN0b3J5ID0gc2NvcGUuZXZlbnRGYWN0b3J5O1xuXG4gICAgLy8gc2V0IG9mIHJlY29nbml6ZXJzIHRvIHJ1biBmb3IgdGhlIGN1cnJlbnRseSBoYW5kbGVkIGV2ZW50XG4gICAgdmFyIGN1cnJlbnRHZXN0dXJlcztcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbW9kdWxlIGlzIGZvciBub3JtYWxpemluZyBldmVudHMuIE1vdXNlIGFuZCBUb3VjaCBldmVudHMgd2lsbCBiZVxuICAgICAqIGNvbGxlY3RlZCBoZXJlLCBhbmQgZmlyZSBQb2ludGVyRXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBzZW1hbnRpY3MsIG5vXG4gICAgICogbWF0dGVyIHRoZSBzb3VyY2UuXG4gICAgICogRXZlbnRzIGZpcmVkOlxuICAgICAqICAgLSBwb2ludGVyZG93bjogYSBwb2ludGluZyBpcyBhZGRlZFxuICAgICAqICAgLSBwb2ludGVydXA6IGEgcG9pbnRlciBpcyByZW1vdmVkXG4gICAgICogICAtIHBvaW50ZXJtb3ZlOiBhIHBvaW50ZXIgaXMgbW92ZWRcbiAgICAgKiAgIC0gcG9pbnRlcm92ZXI6IGEgcG9pbnRlciBjcm9zc2VzIGludG8gYW4gZWxlbWVudFxuICAgICAqICAgLSBwb2ludGVyb3V0OiBhIHBvaW50ZXIgbGVhdmVzIGFuIGVsZW1lbnRcbiAgICAgKiAgIC0gcG9pbnRlcmNhbmNlbDogYSBwb2ludGVyIHdpbGwgbm8gbG9uZ2VyIGdlbmVyYXRlIGV2ZW50c1xuICAgICAqL1xuICAgIHZhciBkaXNwYXRjaGVyID0ge1xuICAgICAgICBJU19JT1M6IGZhbHNlLFxuICAgICAgICBwb2ludGVybWFwOiBuZXcgc2NvcGUuUG9pbnRlck1hcCgpLFxuICAgICAgICByZXF1aXJlZEdlc3R1cmVzOiBuZXcgc2NvcGUuUG9pbnRlck1hcCgpLFxuICAgICAgICBldmVudE1hcDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgLy8gU2NvcGUgb2JqZWN0cyBmb3IgbmF0aXZlIGV2ZW50cy5cbiAgICAgICAgLy8gVGhpcyBleGlzdHMgZm9yIGVhc2Ugb2YgdGVzdGluZy5cbiAgICAgICAgZXZlbnRTb3VyY2VzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBldmVudFNvdXJjZUxpc3Q6IFtdLFxuICAgICAgICBnZXN0dXJlczogW10sXG4gICAgICAgIC8vIG1hcCBnZXN0dXJlIGV2ZW50IC0+IHtsaXN0ZW5lcnM6IGludCwgaW5kZXg6IGdlc3R1cmVzW2ludF19XG4gICAgICAgIGRlcGVuZGVuY3lNYXA6IHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBkb3duIGFuZCB1cCBhcmUgaW4gdGhlIG1hcCB0byB0cmlnZ2VyIFwicmVnaXN0ZXJcIlxuICAgICAgICAgICAgZG93bjoge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogMCxcbiAgICAgICAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cDoge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogMCxcbiAgICAgICAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VzdHVyZVF1ZXVlOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIG5ldyBldmVudCBzb3VyY2UgdGhhdCB3aWxsIGdlbmVyYXRlIHBvaW50ZXIgZXZlbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgaW5Tb3VyY2VgIG11c3QgY29udGFpbiBhbiBhcnJheSBvZiBldmVudCBuYW1lcyBuYW1lZCBgZXZlbnRzYCwgYW5kXG4gICAgICAgICAqIGZ1bmN0aW9ucyB3aXRoIHRoZSBuYW1lcyBzcGVjaWZpZWQgaW4gdGhlIGBldmVudHNgIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIG5hbWUgZm9yIHRoZSBldmVudCBzb3VyY2VcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBBIG5ldyBzb3VyY2Ugb2YgcGxhdGZvcm0gZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXJTb3VyY2U6IGZ1bmN0aW9uKG5hbWUsIHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIHMgPSBzb3VyY2U7XG4gICAgICAgICAgICB2YXIgbmV3RXZlbnRzID0gcy5ldmVudHM7XG4gICAgICAgICAgICBpZiAobmV3RXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgbmV3RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc1tlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudE1hcFtlXSA9IHNbZV0uYmluZChzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRTb3VyY2VzW25hbWVdID0gcztcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50U291cmNlTGlzdC5wdXNoKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3Rlckdlc3R1cmU6IGZ1bmN0aW9uKG5hbWUsIHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBvYmoubGlzdGVuZXJzID0gMDtcbiAgICAgICAgICAgIG9iai5pbmRleCA9IHRoaXMuZ2VzdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGc7IGkgPCBzb3VyY2UuZXhwb3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGcgPSBzb3VyY2UuZXhwb3Nlc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeU1hcFtnXSA9IG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24oZWxlbWVudCwgaW5pdGlhbCkge1xuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmV2ZW50U291cmNlTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZXM7XG4gICAgICAgICAgICAgICAgKGkgPCBsKSAmJiAoZXMgPSB0aGlzLmV2ZW50U291cmNlTGlzdFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZXZlbnRzb3VyY2UgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICBlcy5yZWdpc3Rlci5jYWxsKGVzLCBlbGVtZW50LCBpbml0aWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmV2ZW50U291cmNlTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZXM7XG4gICAgICAgICAgICAgICAgKGkgPCBsKSAmJiAoZXMgPSB0aGlzLmV2ZW50U291cmNlTGlzdFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZXZlbnRzb3VyY2UgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICBlcy51bnJlZ2lzdGVyLmNhbGwoZXMsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBFVkVOVFNcbiAgICAgICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZEdlc3R1cmVzLnNldChpbkV2ZW50LnBvaW50ZXJJZCwgY3VycmVudEdlc3R1cmVzKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCdkb3duJywgaW5FdmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmU6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIHBpcGUgbW92ZSBldmVudHMgaW50byBnZXN0dXJlIHF1ZXVlIGRpcmVjdGx5XG4gICAgICAgICAgICBpbkV2ZW50LnR5cGUgPSAnbW92ZSc7XG4gICAgICAgICAgICB0aGlzLmZpbGxHZXN0dXJlUXVldWUoaW5FdmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgndXAnLCBpbkV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZWRHZXN0dXJlcy5kZWxldGUoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGluRXZlbnQudGFwUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCd1cCcsIGluRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZEdlc3R1cmVzLmRlbGV0ZShpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEdlc3R1cmVEZXBlbmRlbmN5OiBmdW5jdGlvbihub2RlLCBjdXJyZW50R2VzdHVyZXMpIHtcbiAgICAgICAgICAgIHZhciBnZXN0dXJlc1dhbnRlZCA9IG5vZGUuX3BnRXZlbnRzO1xuICAgICAgICAgICAgaWYgKGdlc3R1cmVzV2FudGVkICYmIGN1cnJlbnRHZXN0dXJlcykge1xuICAgICAgICAgICAgICAgIHZhciBnayA9IE9iamVjdC5rZXlzKGdlc3R1cmVzV2FudGVkKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgciwgcmksIGc7IGkgPCBnay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXN0dXJlXG4gICAgICAgICAgICAgICAgICAgIGcgPSBna1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlc3R1cmVzV2FudGVkW2ddID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9va3VwIGdlc3R1cmUgcmVjb2duaXplclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMuZGVwZW5kZW5jeU1hcFtnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY29nbml6ZXIgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpID0gciA/IHIuaW5kZXggOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHZXN0dXJlc1tyaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBMSVNURU5FUiBMT0dJQ1xuICAgICAgICBldmVudEhhbmRsZXI6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50IG11bHRpcGxlIGRpc3BhdGNoIG9mIGV2ZW50cyBmcm9tXG4gICAgICAgICAgICAvLyBwbGF0Zm9ybSBldmVudHMuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHR3byBlbGVtZW50cyBpbiBkaWZmZXJlbnQgc2NvcGVzXG4gICAgICAgICAgICAvLyBhcmUgc2V0IHVwIHRvIGNyZWF0ZSBwb2ludGVyIGV2ZW50cywgd2hpY2ggaXMgcmVsZXZhbnQgdG8gU2hhZG93IERPTS5cblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBpbkV2ZW50LnR5cGU7XG5cbiAgICAgICAgICAgIC8vIG9ubHkgZ2VuZXJhdGUgdGhlIGxpc3Qgb2YgZGVzaXJlZCBldmVudHMgb24gXCJkb3duXCJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ21vdXNlZG93bicgfHwgdHlwZSA9PT0gJ3BvaW50ZXJkb3duJyB8fCB0eXBlID09PSAnTVNQb2ludGVyRG93bicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluRXZlbnQuX2hhbmRsZWRCeVBHKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHZXN0dXJlcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGluIElPUyBtb2RlLCB0aGVyZSBpcyBvbmx5IGEgbGlzdGVuZXIgb24gdGhlIGRvY3VtZW50LCBzbyB0aGlzIGlzIG5vdCByZS1lbnRyYW50XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuSVNfSU9TKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldiA9IGluRXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdXAgYSBmYWtlIGV2ZW50IHRvIGdpdmUgdG8gdGhlIHBhdGggYnVpbGRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBpbkV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBjdC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGN0LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogaW5FdmVudC5wYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBldmVudCBwYXRoIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGJ1aWxkIGEgcGF0aCBmcm9tIHRhcmdldCBmaW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IGluRXZlbnQucGF0aCB8fCBzY29wZS50YXJnZXRGaW5kaW5nLnBhdGgoZXYpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbjsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEdlc3R1cmVEZXBlbmRlbmN5KG4sIGN1cnJlbnRHZXN0dXJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEdlc3R1cmVEZXBlbmRlbmN5KGluRXZlbnQuY3VycmVudFRhcmdldCwgY3VycmVudEdlc3R1cmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbkV2ZW50Ll9oYW5kbGVkQnlQRykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMuZXZlbnRNYXAgJiYgdGhpcy5ldmVudE1hcFt0eXBlXTtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGZuKGluRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5FdmVudC5faGFuZGxlZEJ5UEcgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAvLyBzZXQgdXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIGxpc3RlbjogZnVuY3Rpb24odGFyZ2V0LCBldmVudHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnRzLmxlbmd0aCwgZTtcbiAgICAgICAgICAgICAgICAoaSA8IGwpICYmIChlID0gZXZlbnRzW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudCh0YXJnZXQsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHVubGlzdGVuOiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudHMubGVuZ3RoLCBlO1xuICAgICAgICAgICAgICAgIChpIDwgbCkgJiYgKGUgPSBldmVudHNbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50KHRhcmdldCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEV2ZW50OiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLmJvdW5kSGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUV2ZW50OiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLmJvdW5kSGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVWRU5UIENSRUFUSU9OIEFORCBUUkFDS0lOR1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBFdmVudCBvZiB0eXBlIGBpblR5cGVgLCBiYXNlZCBvbiB0aGUgaW5mb3JtYXRpb24gaW5cbiAgICAgICAgICogYGluRXZlbnRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5UeXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiBldmVudCB0byBjcmVhdGVcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBBIHBsYXRmb3JtIGV2ZW50IHdpdGggYSB0YXJnZXRcbiAgICAgICAgICogQHJldHVybiB7RXZlbnR9IEEgUG9pbnRlckV2ZW50IG9mIHR5cGUgYGluVHlwZWBcbiAgICAgICAgICovXG4gICAgICAgIG1ha2VFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlUG9pbnRlckV2ZW50KGluVHlwZSwgaW5FdmVudCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gaW5FdmVudC5wcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgIGUudGFwUHJldmVudGVkID0gaW5FdmVudC50YXBQcmV2ZW50ZWQ7XG4gICAgICAgICAgICBlLl90YXJnZXQgPSBlLl90YXJnZXQgfHwgaW5FdmVudC50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbWFrZSBhbmQgZGlzcGF0Y2ggYW4gZXZlbnQgaW4gb25lIGNhbGxcbiAgICAgICAgZmlyZUV2ZW50OiBmdW5jdGlvbihpblR5cGUsIGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5tYWtlRXZlbnQoaW5UeXBlLCBpbkV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgc25hcHNob3Qgb2YgaW5FdmVudCwgd2l0aCB3cml0YWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IEFuIGV2ZW50IHRoYXQgY29udGFpbnMgcHJvcGVydGllcyB0byBjb3B5LlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHNoYWxsb3cgY29waWVzIG9mIGBpbkV2ZW50YCdzXG4gICAgICAgICAqICAgIHByb3BlcnRpZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZUV2ZW50OiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRDb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICBwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDTE9ORV9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHAgPSBDTE9ORV9QUk9QU1tpXTtcbiAgICAgICAgICAgICAgICBldmVudENvcHlbcF0gPSBpbkV2ZW50W3BdIHx8IENMT05FX0RFRkFVTFRTW2ldO1xuICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIFNWR0luc3RhbmNlRWxlbWVudCBzaGFkb3cgdHJlZVxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgPHVzZT4gZWxlbWVudCB0aGF0IGlzIHJlcHJlc2VudGVkIGJ5IHRoZSBpbnN0YW5jZSBmb3IgU2FmYXJpLCBDaHJvbWUsIElFLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGJlaGF2aW9yIGltcGxlbWVudGVkIGJ5IEZpcmVmb3guXG4gICAgICAgICAgICAgICAgaWYgKHAgPT09ICd0YXJnZXQnIHx8IHAgPT09ICdyZWxhdGVkVGFyZ2V0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoSEFTX1NWR19JTlNUQU5DRSAmJiBldmVudENvcHlbcF0gaW5zdGFuY2VvZiBTVkdFbGVtZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q29weVtwXSA9IGV2ZW50Q29weVtwXS5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGtlZXAgdGhlIHNlbWFudGljcyBvZiBwcmV2ZW50RGVmYXVsdFxuICAgICAgICAgICAgZXZlbnRDb3B5LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaW5FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBldmVudENvcHk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudCB0byBpdHMgdGFyZ2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGFuIGV2ZW50IGhhbmRsZXIgcmV0dXJucyB0cnVlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdCA9IGluRXZlbnQuX3RhcmdldDtcbiAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgdC5kaXNwYXRjaEV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGNsb25lIHRoZSBldmVudCBmb3IgdGhlIGdlc3R1cmUgc3lzdGVtIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAvLyBjbG9uZSBhZnRlciBkaXNwYXRjaCB0byBwaWNrIHVwIGdlc3R1cmUgcHJldmVudGlvbiBjb2RlXG4gICAgICAgICAgICAgICAgdmFyIGNsb25lID0gdGhpcy5jbG9uZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGNsb25lLnRhcmdldCA9IHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsR2VzdHVyZVF1ZXVlKGNsb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VzdHVyZVRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgZ2VzdHVyZSBxdWV1ZVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGUsIHJnOyBpIDwgdGhpcy5nZXN0dXJlUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlID0gdGhpcy5nZXN0dXJlUXVldWVbaV07XG4gICAgICAgICAgICAgICAgcmcgPSBlLl9yZXF1aXJlZEdlc3R1cmVzO1xuICAgICAgICAgICAgICAgIGlmIChyZykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgZywgZm47IGogPCB0aGlzLmdlc3R1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHJ1biByZWNvZ25pemVyIGlmIGFuIGVsZW1lbnQgaW4gdGhlIHNvdXJjZSBldmVudCdzIHBhdGggaXMgbGlzdGVuaW5nIGZvciB0aG9zZSBnZXN0dXJlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJnW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHRoaXMuZ2VzdHVyZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBnW2UudHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmNhbGwoZywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nZXN0dXJlUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbEdlc3R1cmVRdWV1ZTogZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgdHJpZ2dlciB0aGUgZ2VzdHVyZSBxdWV1ZSBvbmNlXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2VzdHVyZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmJvdW5kR2VzdHVyZVRyaWdnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXYuX3JlcXVpcmVkR2VzdHVyZXMgPSB0aGlzLnJlcXVpcmVkR2VzdHVyZXMuZ2V0KGV2LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICB0aGlzLmdlc3R1cmVRdWV1ZS5wdXNoKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGlzcGF0Y2hlci5ib3VuZEhhbmRsZXIgPSBkaXNwYXRjaGVyLmV2ZW50SGFuZGxlci5iaW5kKGRpc3BhdGNoZXIpO1xuICAgIGRpc3BhdGNoZXIuYm91bmRHZXN0dXJlVHJpZ2dlciA9IGRpc3BhdGNoZXIuZ2VzdHVyZVRyaWdnZXIuYmluZChkaXNwYXRjaGVyKTtcbiAgICBzY29wZS5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcblxuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgYGdlc3R1cmVgIG9uIGBub2RlYCB3aXRoIHRoZSBgaGFuZGxlcmAgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIElmIGBoYW5kbGVyYCBpcyB0aGUgZmlyc3QgbGlzdGVuZXIgZm9yIGBnZXN0dXJlYCwgdGhlIHVuZGVybHlpbmcgZ2VzdHVyZSByZWNvZ25pemVyIGlzIHRoZW4gZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBnZXN0dXJlXG4gICAgICogQHJldHVybiBCb29sZWFuIGBnZXN0dXJlYCBpcyBhIHZhbGlkIGdlc3R1cmVcbiAgICAgKi9cbiAgICBzY29wZS5hY3RpdmF0ZUdlc3R1cmUgPSBmdW5jdGlvbihub2RlLCBnZXN0dXJlKSB7XG4gICAgICAgIHZhciBnID0gZ2VzdHVyZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgZGVwID0gZGlzcGF0Y2hlci5kZXBlbmRlbmN5TWFwW2ddO1xuICAgICAgICBpZiAoZGVwKSB7XG4gICAgICAgICAgICB2YXIgcmVjb2duaXplciA9IGRpc3BhdGNoZXIuZ2VzdHVyZXNbZGVwLmluZGV4XTtcbiAgICAgICAgICAgIGlmICghbm9kZS5fcGdMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUuX3BnTGlzdGVuZXJzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8oZGZyZWVkbSk6IHJlLWV2YWx1YXRlIGJvb2trZWVwaW5nIHRvIGF2b2lkIHVzaW5nIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoQWN0aW9uID0gcmVjb2duaXplci5kZWZhdWx0QWN0aW9ucyAmJiByZWNvZ25pemVyLmRlZmF1bHRBY3Rpb25zW2ddO1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25Ob2RlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25Ob2RlID0gbm9kZS5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25Ob2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG91Y2hBY3Rpb24gJiYgYWN0aW9uTm9kZSAmJiAhYWN0aW9uTm9kZS5oYXNBdHRyaWJ1dGUoJ3RvdWNoLWFjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbk5vZGUuc2V0QXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nLCB0b3VjaEFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlLl9wZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIG5vZGUuX3BnRXZlbnRzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLl9wZ0V2ZW50c1tnXSA9IChub2RlLl9wZ0V2ZW50c1tnXSB8fCAwKSArIDE7XG4gICAgICAgICAgICBub2RlLl9wZ0xpc3RlbmVycysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCb29sZWFuKGRlcCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTGlzdGVuIGZvciBgZ2VzdHVyZWAgZnJvbSBgbm9kZWAgd2l0aCBgaGFuZGxlcmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ2VzdHVyZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAgICAgKi9cbiAgICBzY29wZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24obm9kZSwgZ2VzdHVyZSwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgc2NvcGUuYWN0aXZhdGVHZXN0dXJlKG5vZGUsIGdlc3R1cmUpO1xuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlYXJzIGRvd24gdGhlIGdlc3R1cmUgY29uZmlndXJhdGlvbiBmb3IgYG5vZGVgXG4gICAgICpcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yIGBnZXN0dXJlYCwgdGhlIHVuZGVybHlpbmcgZ2VzdHVyZSByZWNvZ25pemVyIGlzIGRpc2FibGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdlc3R1cmVcbiAgICAgKiBAcmV0dXJuIEJvb2xlYW4gYGdlc3R1cmVgIGlzIGEgdmFsaWQgZ2VzdHVyZVxuICAgICAqL1xuICAgIHNjb3BlLmRlYWN0aXZhdGVHZXN0dXJlID0gZnVuY3Rpb24obm9kZSwgZ2VzdHVyZSkge1xuICAgICAgICB2YXIgZyA9IGdlc3R1cmUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGRlcCA9IGRpc3BhdGNoZXIuZGVwZW5kZW5jeU1hcFtnXTtcbiAgICAgICAgaWYgKGRlcCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuX3BnTGlzdGVuZXJzID4gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUuX3BnTGlzdGVuZXJzLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5fcGdMaXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnVucmVnaXN0ZXIobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5fcGdFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fcGdFdmVudHNbZ10gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX3BnRXZlbnRzW2ddLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fcGdFdmVudHNbZ10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQm9vbGVhbihkZXApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgYGdlc3R1cmVgIGZyb20gYG5vZGVgIHdpdGggYGhhbmRsZXJgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gICAgICovXG4gICAgc2NvcGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5vZGUsIGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNjb3BlLmRlYWN0aXZhdGVHZXN0dXJlKG5vZGUsIGdlc3R1cmUpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKGV4cG9ydHMpO1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIHBvaW50ZXJtYXAgPSBkaXNwYXRjaGVyLnBvaW50ZXJtYXA7XG4gICAgLy8gcmFkaXVzIGFyb3VuZCB0b3VjaGVuZCB0aGF0IHN3YWxsb3dzIG1vdXNlIGV2ZW50c1xuICAgIHZhciBERURVUF9ESVNUID0gMjU7XG5cbiAgICB2YXIgV0hJQ0hfVE9fQlVUVE9OUyA9IFswLCAxLCA0LCAyXTtcblxuICAgIHZhciBjdXJyZW50QnV0dG9ucyA9IDA7XG5cbiAgICB2YXIgRklSRUZPWF9MSU5VWCA9IC9MaW51eC4qRmlyZWZveFxcLy9pO1xuXG4gICAgdmFyIEhBU19CVVRUT05TID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBmaXJlZm94IG9uIGxpbnV4IHJldHVybnMgc3BlYy1pbmNvcnJlY3QgdmFsdWVzIGZvciBtb3VzZXVwLmJ1dHRvbnNcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQuYnV0dG9ucyNTZWVfYWxzb1xuICAgICAgICAvLyBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzcyNzU5MzAwMy8jbXNnMTZcbiAgICAgICAgaWYgKEZJUkVGT1hfTElOVVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vdXNlRXZlbnQoJ3Rlc3QnLCB7XG4gICAgICAgICAgICAgICAgYnV0dG9uczogMVxuICAgICAgICAgICAgfSkuYnV0dG9ucyA9PT0gMTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSkoKTtcblxuICAgIC8vIGhhbmRsZXIgYmxvY2sgZm9yIG5hdGl2ZSBtb3VzZSBldmVudHNcbiAgICB2YXIgbW91c2VFdmVudHMgPSB7XG4gICAgICAgIFBPSU5URVJfSUQ6IDEsXG4gICAgICAgIFBPSU5URVJfVFlQRTogJ21vdXNlJyxcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgJ21vdXNldXAnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgICAgICAnbW92ZSdcbiAgICAgICAgXSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2hlci51bmxpc3Rlbih0YXJnZXQsIHRoaXMuZXZlbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGFzdFRvdWNoZXM6IFtdLFxuICAgICAgICAvLyBjb2xsaWRlIHdpdGggdGhlIGdsb2JhbCBtb3VzZSBsaXN0ZW5lclxuICAgICAgICBpc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICAgICAgICAgIHZhciB4ID0gaW5FdmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHkgPSBpbkV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGx0cy5sZW5ndGgsIHQ7IGkgPCBsICYmICh0ID0gbHRzW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyB3aWxsIGJlIHN3YWxsb3dlZCBuZWFyIGEgcHJpbWFyeSB0b3VjaGVuZFxuICAgICAgICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpLFxuICAgICAgICAgICAgICAgICAgICBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuICAgICAgICAgICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUICYmIGR5IDw9IERFRFVQX0RJU1QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlRXZlbnQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5wb2ludGVySWQgPSB0aGlzLlBPSU5URVJfSUQ7XG4gICAgICAgICAgICBlLmlzUHJpbWFyeSA9IHRydWU7XG4gICAgICAgICAgICBlLnBvaW50ZXJUeXBlID0gdGhpcy5QT0lOVEVSX1RZUEU7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSAnbW91c2UnO1xuICAgICAgICAgICAgaWYgKCFIQVNfQlVUVE9OUykge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gaW5FdmVudC50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBiaXQgPSBXSElDSF9UT19CVVRUT05TW2luRXZlbnQud2hpY2hdIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCdXR0b25zIHw9IGJpdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QnV0dG9ucyAmPSB+Yml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLmJ1dHRvbnMgPSBjdXJyZW50QnV0dG9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoKGluRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwb2ludGVybWFwLmhhcyh0aGlzLlBPSU5URVJfSUQpO1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgZS50YXJnZXQgPSBzY29wZS5maW5kVGFyZ2V0KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KHRoaXMuUE9JTlRFUl9JRCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIuZG93bihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaChpbkV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBwb2ludGVybWFwLmdldCh0aGlzLlBPSU5URVJfSUQpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBjYXNlIHdoZXJlIHdlIG1pc3NlZCBhIG1vdXNldXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKChIQVNfQlVUVE9OUyA/IGUuYnV0dG9ucyA6IGUud2hpY2gpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUhBU19CVVRUT05TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJ1dHRvbnMgPSBlLmJ1dHRvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5jYW5jZWwoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBNb3VzZShlLmJ1dHRvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5tb3ZlKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZXVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaChpbkV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KHRoaXMuUE9JTlRFUl9JRCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBNb3VzZShlLmJ1dHRvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwTW91c2U6IGZ1bmN0aW9uKGJ1dHRvbnMpIHtcbiAgICAgICAgICAgIGlmIChidXR0b25zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5kZWxldGUodGhpcy5QT0lOVEVSX0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5tb3VzZUV2ZW50cyA9IG1vdXNlRXZlbnRzO1xufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgYWxsU2hhZG93cyA9IHNjb3BlLnRhcmdldEZpbmRpbmcuYWxsU2hhZG93cy5iaW5kKHNjb3BlLnRhcmdldEZpbmRpbmcpO1xuICAgIHZhciBwb2ludGVybWFwID0gZGlzcGF0Y2hlci5wb2ludGVybWFwO1xuICAgIHZhciB0b3VjaE1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbC5iaW5kKEFycmF5LnByb3RvdHlwZS5tYXApO1xuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGxvbmcgZW5vdWdoIHRvIGlnbm9yZSBjb21wYXQgbW91c2UgZXZlbnRzIG1hZGUgYnkgdG91Y2hcbiAgICB2YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG4gICAgdmFyIERFRFVQX0RJU1QgPSAyNTtcbiAgICB2YXIgQ0xJQ0tfQ09VTlRfVElNRU9VVCA9IDIwMDtcbiAgICB2YXIgSFlTVEVSRVNJUyA9IDIwO1xuICAgIHZhciBBVFRSSUIgPSAndG91Y2gtYWN0aW9uJztcbiAgICAvLyBUT0RPKGRmcmVlZG0pOiBkaXNhYmxlIHVudGlsIGh0dHA6Ly9jcmJ1Zy5jb20vMzk5NzY1IGlzIHJlc29sdmVkXG4gICAgLy8gdmFyIEhBU19UT1VDSF9BQ1RJT04gPSBBVFRSSUIgaW4gZG9jdW1lbnQuaGVhZC5zdHlsZTtcbiAgICB2YXIgSEFTX1RPVUNIX0FDVElPTiA9IGZhbHNlO1xuXG4gICAgLy8gaGFuZGxlciBibG9jayBmb3IgbmF0aXZlIHRvdWNoIGV2ZW50c1xuICAgIHZhciB0b3VjaEV2ZW50cyA9IHtcbiAgICAgICAgSVNfSU9TOiBmYWxzZSxcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAndG91Y2hzdGFydCcsXG4gICAgICAgICAgICAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICd0b3VjaGVuZCcsXG4gICAgICAgICAgICAndG91Y2hjYW5jZWwnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgICAgICAnbW92ZSdcbiAgICAgICAgXSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCwgaW5pdGlhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuSVNfSU9TID8gaW5pdGlhbCA6ICFpbml0aWFsKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLklTX0lPUykge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIudW5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbFR5cGVzOiB7XG4gICAgICAgICAgICBFTUlUVEVSOiAnbm9uZScsXG4gICAgICAgICAgICBYU0NST0xMRVI6ICdwYW4teCcsXG4gICAgICAgICAgICBZU0NST0xMRVI6ICdwYW4teScsXG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoQWN0aW9uVG9TY3JvbGxUeXBlOiBmdW5jdGlvbih0b3VjaEFjdGlvbikge1xuICAgICAgICAgICAgdmFyIHQgPSB0b3VjaEFjdGlvbjtcbiAgICAgICAgICAgIHZhciBzdCA9IHRoaXMuc2Nyb2xsVHlwZXM7XG4gICAgICAgICAgICBpZiAodCA9PT0gc3QuRU1JVFRFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT09IHN0LlhTQ1JPTExFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnWCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT09IHN0LllTQ1JPTExFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnWSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnWFknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBQT0lOVEVSX1RZUEU6ICd0b3VjaCcsXG4gICAgICAgIGZpcnN0VG91Y2g6IG51bGwsXG4gICAgICAgIGlzUHJpbWFyeVRvdWNoOiBmdW5jdGlvbihpblRvdWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdFRvdWNoID09PSBpblRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFByaW1hcnlUb3VjaDogZnVuY3Rpb24oaW5Ub3VjaCkge1xuICAgICAgICAgICAgLy8gc2V0IHByaW1hcnkgdG91Y2ggaWYgdGhlcmUgbm8gcG9pbnRlcnMsIG9yIHRoZSBvbmx5IHBvaW50ZXIgaXMgdGhlIG1vdXNlXG4gICAgICAgICAgICBpZiAocG9pbnRlcm1hcC5wb2ludGVycygpID09PSAwIHx8IChwb2ludGVybWFwLnBvaW50ZXJzKCkgPT09IDEgJiYgcG9pbnRlcm1hcC5oYXMoMSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdFRvdWNoID0gaW5Ub3VjaC5pZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RYWSA9IHtcbiAgICAgICAgICAgICAgICAgICAgWDogaW5Ub3VjaC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBZOiBpblRvdWNoLmNsaWVudFlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RUYXJnZXQgPSBpblRvdWNoLnRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxSZXNldENsaWNrQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlUHJpbWFyeVBvaW50ZXI6IGZ1bmN0aW9uKGluUG9pbnRlcikge1xuICAgICAgICAgICAgaWYgKGluUG9pbnRlci5pc1ByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0VG91Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RYWSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldENsaWNrQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xpY2tDb3VudDogMCxcbiAgICAgICAgcmVzZXRJZDogbnVsbCxcbiAgICAgICAgcmVzZXRDbGlja0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldElkID0gbnVsbDtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRJZCA9IHNldFRpbWVvdXQoZm4sIENMSUNLX0NPVU5UX1RJTUVPVVQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWxSZXNldENsaWNrQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzZXRJZCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0eXBlVG9CdXR0b25zOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICAgICAgICByZXQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZFRhcmdldDogZnVuY3Rpb24odG91Y2gsIGlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VG91Y2hFdmVudC50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnlUb3VjaCh0b3VjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhc3RQYXRoID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB0aGlzLmN1cnJlbnRUb3VjaEV2ZW50LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuY3VycmVudFRvdWNoRXZlbnQudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5maW5kVGFyZ2V0KGZhc3RQYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZmluZFRhcmdldCh0b3VjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV1c2UgdGFyZ2V0IHdlIGZvdW5kIGluIHRvdWNoc3RhcnRcbiAgICAgICAgICAgIHJldHVybiBwb2ludGVybWFwLmdldChpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoVG9Qb2ludGVyOiBmdW5jdGlvbihpblRvdWNoKSB7XG4gICAgICAgICAgICB2YXIgY3RlID0gdGhpcy5jdXJyZW50VG91Y2hFdmVudDtcbiAgICAgICAgICAgIHZhciBlID0gZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluVG91Y2gpO1xuICAgICAgICAgICAgLy8gU3BlYyBzcGVjaWZpZXMgdGhhdCBwb2ludGVySWQgMSBpcyByZXNlcnZlZCBmb3IgTW91c2UuXG4gICAgICAgICAgICAvLyBUb3VjaCBpZGVudGlmaWVycyBjYW4gc3RhcnQgYXQgMC5cbiAgICAgICAgICAgIC8vIEFkZCAyIHRvIHRoZSB0b3VjaCBpZGVudGlmaWVyIGZvciBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgdmFyIGlkID0gZS5wb2ludGVySWQgPSBpblRvdWNoLmlkZW50aWZpZXIgKyAyO1xuICAgICAgICAgICAgZS50YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoaW5Ub3VjaCwgaWQpO1xuICAgICAgICAgICAgZS5idWJibGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGUuY2FuY2VsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBlLmRldGFpbCA9IHRoaXMuY2xpY2tDb3VudDtcbiAgICAgICAgICAgIGUuYnV0dG9ucyA9IHRoaXMudHlwZVRvQnV0dG9ucyhjdGUudHlwZSk7XG4gICAgICAgICAgICBlLndpZHRoID0gaW5Ub3VjaC53ZWJraXRSYWRpdXNYIHx8IGluVG91Y2gucmFkaXVzWCB8fCAwO1xuICAgICAgICAgICAgZS5oZWlnaHQgPSBpblRvdWNoLndlYmtpdFJhZGl1c1kgfHwgaW5Ub3VjaC5yYWRpdXNZIHx8IDA7XG4gICAgICAgICAgICBlLnByZXNzdXJlID0gaW5Ub3VjaC53ZWJraXRGb3JjZSB8fCBpblRvdWNoLmZvcmNlIHx8IDAuNTtcbiAgICAgICAgICAgIGUuaXNQcmltYXJ5ID0gdGhpcy5pc1ByaW1hcnlUb3VjaChpblRvdWNoKTtcbiAgICAgICAgICAgIGUucG9pbnRlclR5cGUgPSB0aGlzLlBPSU5URVJfVFlQRTtcbiAgICAgICAgICAgIGUuX3NvdXJjZSA9ICd0b3VjaCc7XG4gICAgICAgICAgICAvLyBmb3J3YXJkIHRvdWNoIHByZXZlbnREZWZhdWx0c1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJzdFhZID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjdGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzc1RvdWNoZXM6IGZ1bmN0aW9uKGluRXZlbnQsIGluRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0bCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUb3VjaEV2ZW50ID0gaW5FdmVudDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCB0LCBwOyBpIDwgdGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ID0gdGxbaV07XG4gICAgICAgICAgICAgICAgcCA9IHRoaXMudG91Y2hUb1BvaW50ZXIodCk7XG4gICAgICAgICAgICAgICAgaWYgKGluRXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KHAucG9pbnRlcklkLCBwLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb2ludGVybWFwLmhhcyhwLnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5GdW5jdGlvbi5jYWxsKHRoaXMsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5FdmVudC50eXBlID09PSAndG91Y2hlbmQnIHx8IGluRXZlbnQuX2NhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuVXBQb2ludGVyKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gRm9yIHNpbmdsZSBheGlzIHNjcm9sbGVycywgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBlbGVtZW50IHNob3VsZCBlbWl0XG4gICAgICAgIC8vIHBvaW50ZXIgZXZlbnRzIG9yIGJlaGF2ZSBhcyBhIHNjcm9sbGVyXG4gICAgICAgIHNob3VsZFNjcm9sbDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RYWSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoQWN0aW9uID0gc2NvcGUudGFyZ2V0RmluZGluZy5maW5kVG91Y2hBY3Rpb24oaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbEF4aXMgPSB0aGlzLnRvdWNoQWN0aW9uVG9TY3JvbGxUeXBlKHRvdWNoQWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsQXhpcyA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgZWxlbWVudCBpcyBhIHRvdWNoLWFjdGlvbjogbm9uZSwgc2hvdWxkIG5ldmVyIHNjcm9sbFxuICAgICAgICAgICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbEF4aXMgPT09ICdYWScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBlbGVtZW50IHNob3VsZCBhbHdheXMgc2Nyb2xsXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgaW50ZW5kZWQgc2Nyb2xsIGF4aXMsIGFuZCBvdGhlciBheGlzXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gc2Nyb2xsQXhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9hID0gc2Nyb2xsQXhpcyA9PT0gJ1knID8gJ1gnIDogJ1knO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGEgPSBNYXRoLmFicyh0WydjbGllbnQnICsgYV0gLSB0aGlzLmZpcnN0WFlbYV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9hID0gTWF0aC5hYnModFsnY2xpZW50JyArIG9hXSAtIHRoaXMuZmlyc3RYWVtvYV0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBkZWx0YSBpbiB0aGUgc2Nyb2xsIGF4aXMgPiBkZWx0YSBvdGhlciBheGlzLCBzY3JvbGwgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGRhID49IGRvYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmluZFRvdWNoOiBmdW5jdGlvbihpblRMLCBpbklkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluVEwubGVuZ3RoLCB0OyBpIDwgbCAmJiAodCA9IGluVExbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodC5pZGVudGlmaWVyID09PSBpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gSW4gc29tZSBpbnN0YW5jZXMsIGEgdG91Y2hzdGFydCBjYW4gaGFwcGVuIHdpdGhvdXQgYSB0b3VjaGVuZC4gVGhpc1xuICAgICAgICAvLyBsZWF2ZXMgdGhlIHBvaW50ZXJtYXAgaW4gYSBicm9rZW4gc3RhdGUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgb24gZXZlcnkgdG91Y2hzdGFydCwgd2UgcmVtb3ZlIHRoZSB0b3VjaGVzIHRoYXQgZGlkIG5vdCBmaXJlIGFcbiAgICAgICAgLy8gdG91Y2hlbmQgZXZlbnQuXG4gICAgICAgIC8vIFRvIGtlZXAgc3RhdGUgZ2xvYmFsbHkgY29uc2lzdGVudCwgd2UgZmlyZSBhXG4gICAgICAgIC8vIHBvaW50ZXJjYW5jZWwgZm9yIHRoaXMgXCJhYmFuZG9uZWRcIiB0b3VjaFxuICAgICAgICB2YWN1dW1Ub3VjaGVzOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGwgPSBpbkV2ZW50LnRvdWNoZXM7XG4gICAgICAgICAgICAvLyBwb2ludGVybWFwLnBvaW50ZXJzKCkgc2hvdWxkIGJlIDwgdGwubGVuZ3RoIGhlcmUsIGFzIHRoZSB0b3VjaHN0YXJ0IGhhcyBub3RcbiAgICAgICAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkIHlldC5cbiAgICAgICAgICAgIGlmIChwb2ludGVybWFwLnBvaW50ZXJzKCkgPj0gdGwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciByZW1vdmUgcG9pbnRlcklkID09IDEsIHdoaWNoIGlzIG1vdXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBUb3VjaCBpZGVudGlmaWVycyBhcmUgMiBzbWFsbGVyIHRoYW4gdGhlaXIgcG9pbnRlcklkLCB3aGljaCBpcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggaW4gcG9pbnRlcm1hcC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gMSAmJiAhdGhpcy5maW5kVG91Y2godGwsIGtleSAtIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgZC5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuZGVsZXRlKHAucG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy52YWN1dW1Ub3VjaGVzKGluRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRQcmltYXJ5VG91Y2goaW5FdmVudC5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgICAgICAgICB0aGlzLmRlZHVwU3ludGhNb3VzZShpbkV2ZW50KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWNrQ291bnQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMuZG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluUG9pbnRlcikge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5kb3duKGluUG9pbnRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKEhBU19UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgICAgICAgICAvLyB0b3VjaGV2ZW50LmNhbmNlbGFibGUgPT0gZmFsc2UgaXMgc2VudCB3aGVuIHRoZSBwYWdlIGlzIHNjcm9sbGluZyB1bmRlciBuYXRpdmUgVG91Y2ggQWN0aW9uIGluIENocm9tZSAzNlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZC9tc2cvaW5wdXQtZGV2L3dIbnl1a2NZQmNBL2I5a210d00xakpRSlxuICAgICAgICAgICAgICAgIGlmIChpbkV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzVG91Y2hlcyhpbkV2ZW50LCB0aGlzLm1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNjcm9sbGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxpbmcgPT09IG51bGwgJiYgdGhpcy5zaG91bGRTY3JvbGwoaW5FdmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMubW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlyc3RYWSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IHQuY2xpZW50WCAtIHRoaXMuZmlyc3RYWS5YO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSB0LmNsaWVudFkgLSB0aGlzLmZpcnN0WFkuWTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRkID49IEhZU1RFUkVTSVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG91Y2hjYW5jZWwoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0WFkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIubW92ZShpblBvaW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICB0b3VjaGVuZDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy5kZWR1cFN5bnRoTW91c2UoaW5FdmVudCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMudXApO1xuICAgICAgICB9LFxuICAgICAgICB1cDogZnVuY3Rpb24oaW5Qb2ludGVyKSB7XG4gICAgICAgICAgICBpblBvaW50ZXIucmVsYXRlZFRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5Qb2ludGVyKTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIudXAoaW5Qb2ludGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuY2FuY2VsKGluUG9pbnRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoY2FuY2VsOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpbkV2ZW50Ll9jYW5jZWwgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzVG91Y2hlcyhpbkV2ZW50LCB0aGlzLmNhbmNlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFuVXBQb2ludGVyOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXBbJ2RlbGV0ZSddKGluUG9pbnRlci5wb2ludGVySWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQcmltYXJ5UG9pbnRlcihpblBvaW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV2ZW50IHN5bnRoIG1vdXNlIGV2ZW50cyBmcm9tIGNyZWF0aW5nIHBvaW50ZXIgZXZlbnRzXG4gICAgICAgIGRlZHVwU3ludGhNb3VzZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGx0cyA9IHNjb3BlLm1vdXNlRXZlbnRzLmxhc3RUb3VjaGVzO1xuICAgICAgICAgICAgdmFyIHQgPSBpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgLy8gb25seSB0aGUgcHJpbWFyeSBmaW5nZXIgd2lsbCBzeW50aCBtb3VzZSBldmVudHNcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeVRvdWNoKHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgeC95IG9mIGxhc3QgdG91Y2hcbiAgICAgICAgICAgICAgICB2YXIgbHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgeTogdC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsdHMucHVzaChsdCk7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gKGZ1bmN0aW9uKGx0cywgbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5iaW5kKG51bGwsIGx0cywgbHQpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIERFRFVQX1RJTUVPVVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHByZXZlbnQgXCJnaG9zdCBjbGlja3NcIiB0aGF0IGNvbWUgZnJvbSBlbGVtZW50cyB0aGF0IHdlcmUgcmVtb3ZlZCBpbiBhIHRvdWNoIGhhbmRsZXJcbiAgICB2YXIgU1RPUF9QUk9QX0ZOID0gRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiB8fCBFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIHggPSBldi5jbGllbnRYLFxuICAgICAgICAgICAgeSA9IGV2LmNsaWVudFk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGEgY2xpY2sgaXMgd2l0aGluIERFRFVQX0RJU1QgcHggcmFkaXVzIG9mIHRoZSB0b3VjaHN0YXJ0XG4gICAgICAgIHZhciBjbG9zZVRvID0gZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0b3VjaC54KSxcbiAgICAgICAgICAgICAgICBkeSA9IE1hdGguYWJzKHkgLSB0b3VjaC55KTtcbiAgICAgICAgICAgIHJldHVybiAoZHggPD0gREVEVVBfRElTVCAmJiBkeSA8PSBERURVUF9ESVNUKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaWYgY2xpY2sgY29vcmRpbmF0ZXMgYXJlIGNsb3NlIHRvIHRvdWNoIGNvb3JkaW5hdGVzLCBhc3N1bWUgdGhlIGNsaWNrIGNhbWUgZnJvbSBhIHRvdWNoXG4gICAgICAgIHZhciB3YXNUb3VjaGVkID0gc2NvcGUubW91c2VFdmVudHMubGFzdFRvdWNoZXMuc29tZShjbG9zZVRvKTtcbiAgICAgICAgLy8gaWYgdGhlIGNsaWNrIGNhbWUgZnJvbSB0b3VjaCwgYW5kIHRoZSB0b3VjaHN0YXJ0IHRhcmdldCBpcyBub3QgaW4gdGhlIHBhdGggb2YgdGhlIGNsaWNrIGV2ZW50LFxuICAgICAgICAvLyB0aGVuIHRoZSB0b3VjaHN0YXJ0IHRhcmdldCB3YXMgcHJvYmFibHkgcmVtb3ZlZCwgYW5kIHRoZSBjbGljayBzaG91bGQgYmUgXCJidXN0ZWRcIlxuICAgICAgICB2YXIgcGF0aCA9IHNjb3BlLnRhcmdldEZpbmRpbmcucGF0aChldik7XG4gICAgICAgIGlmICh3YXNUb3VjaGVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aFtpXSA9PT0gdG91Y2hFdmVudHMuZmlyc3RUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBTVE9QX1BST1BfRk4uY2FsbChldik7XG4gICAgICAgIH1cbiAgICB9LCB0cnVlKTtcblxuICAgIHNjb3BlLnRvdWNoRXZlbnRzID0gdG91Y2hFdmVudHM7XG59KShleHBvcnRzKTtcblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSBzY29wZS5kaXNwYXRjaGVyO1xuICAgIHZhciBwb2ludGVybWFwID0gZGlzcGF0Y2hlci5wb2ludGVybWFwO1xuICAgIHZhciBIQVNfQklUTUFQX1RZUEUgPSB3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgdHlwZW9mIHdpbmRvdy5NU1BvaW50ZXJFdmVudC5NU1BPSU5URVJfVFlQRV9NT1VTRSA9PT0gJ251bWJlcic7XG4gICAgdmFyIG1zRXZlbnRzID0ge1xuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdNU1BvaW50ZXJEb3duJyxcbiAgICAgICAgICAgICdNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICAgICAgICdNU1BvaW50ZXJVcCcsXG4gICAgICAgICAgICAnTVNQb2ludGVyQ2FuY2VsJyxcbiAgICAgICAgXSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2hlci51bmxpc3Rlbih0YXJnZXQsIHRoaXMuZXZlbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgUE9JTlRFUl9UWVBFUzogW1xuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAndW5hdmFpbGFibGUnLFxuICAgICAgICAgICAgJ3RvdWNoJyxcbiAgICAgICAgICAgICdwZW4nLFxuICAgICAgICAgICAgJ21vdXNlJ1xuICAgICAgICBdLFxuICAgICAgICBwcmVwYXJlRXZlbnQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gaW5FdmVudDtcbiAgICAgICAgICAgIGUgPSBkaXNwYXRjaGVyLmNsb25lRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBpZiAoSEFTX0JJVE1BUF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgZS5wb2ludGVyVHlwZSA9IHRoaXMuUE9JTlRFUl9UWVBFU1tpbkV2ZW50LnBvaW50ZXJUeXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUuX3NvdXJjZSA9ICdtcyc7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXBbJ2RlbGV0ZSddKGlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgTVNQb2ludGVyRG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KGluRXZlbnQucG9pbnRlcklkLCBlLnRhcmdldCk7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLmRvd24oZSk7XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlck1vdmU6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBwb2ludGVybWFwLmdldChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLm1vdmUoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlclVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gcG9pbnRlcm1hcC5nZXQoZS5wb2ludGVySWQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlckNhbmNlbDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KGUucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuY2FuY2VsKGUpO1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5tc0V2ZW50cyA9IG1zRXZlbnRzO1xufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IGRpc3BhdGNoZXIucG9pbnRlcm1hcDtcbiAgICB2YXIgcG9pbnRlckV2ZW50cyA9IHtcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAncG9pbnRlcmRvd24nLFxuICAgICAgICAgICAgJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgICAgICdwb2ludGVydXAnLFxuICAgICAgICAgICAgJ3BvaW50ZXJjYW5jZWwnXG4gICAgICAgIF0sXG4gICAgICAgIHByZXBhcmVFdmVudDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSBkaXNwYXRjaGVyLmNsb25lRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSAncG9pbnRlcic7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2hlci51bmxpc3Rlbih0YXJnZXQsIHRoaXMuZXZlbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXBbJ2RlbGV0ZSddKGlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5FdmVudCk7XG4gICAgICAgICAgICBwb2ludGVybWFwLnNldChlLnBvaW50ZXJJZCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5kb3duKGUpO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludGVybW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIubW92ZShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRlcnVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gcG9pbnRlcm1hcC5nZXQoZS5wb2ludGVySWQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50ZXJjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnJlbGF0ZWRUYXJnZXQgPSBzY29wZS5maW5kVGFyZ2V0KGluRXZlbnQpO1xuICAgICAgICAgICAgZS50YXJnZXQgPSBwb2ludGVybWFwLmdldChlLnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLmNhbmNlbChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2NvcGUucG9pbnRlckV2ZW50cyA9IHBvaW50ZXJFdmVudHM7XG59KShleHBvcnRzKTtcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyB0aGUgaGFuZGxlcnMgZm9yIG5hdGl2ZSBwbGF0Zm9ybSBldmVudHMuXG4gKiBGcm9tIGhlcmUsIHRoZSBkaXNwYXRjaGVyIGlzIGNhbGxlZCB0byBjcmVhdGUgdW5pZmllZCBwb2ludGVyIGV2ZW50cy5cbiAqIEluY2x1ZGVkIGFyZSB0b3VjaCBldmVudHMgKHYxKSwgbW91c2UgZXZlbnRzLCBhbmQgTVNQb2ludGVyRXZlbnRzLlxuICovXG4oZnVuY3Rpb24oc2NvcGUpIHtcblxuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgbmF2ID0gd2luZG93Lm5hdmlnYXRvcjtcblxuICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJTb3VyY2UoJ3BvaW50ZXInLCBzY29wZS5wb2ludGVyRXZlbnRzKTtcbiAgICB9IGVsc2UgaWYgKG5hdi5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJTb3VyY2UoJ21zJywgc2NvcGUubXNFdmVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJTb3VyY2UoJ21vdXNlJywgc2NvcGUubW91c2VFdmVudHMpO1xuICAgICAgICBpZiAod2luZG93Lm9udG91Y2hzdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyU291cmNlKCd0b3VjaCcsIHNjb3BlLnRvdWNoRXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdvcmsgYXJvdW5kIGlPUyBidWdzIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzU2MjggYW5kIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY1MDZcbiAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIHZhciBJU19JT1MgPSB1YS5tYXRjaCgvaVBhZHxpUGhvbmV8aVBvZC8pICYmICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcblxuICAgIGRpc3BhdGNoZXIuSVNfSU9TID0gSVNfSU9TO1xuICAgIHNjb3BlLnRvdWNoRXZlbnRzLklTX0lPUyA9IElTX0lPUztcblxuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXIoZG9jdW1lbnQsIHRydWUpO1xufSkoZXhwb3J0cyk7XG5cbi8qKlxuICogVGhpcyBldmVudCBkZW5vdGVzIHRoZSBiZWdpbm5pbmcgb2YgYSBzZXJpZXMgb2YgdHJhY2tpbmcgZXZlbnRzLlxuICpcbiAqIEBtb2R1bGUgUG9pbnRlckdlc3R1cmVzXG4gKiBAc3VibW9kdWxlIEV2ZW50c1xuICogQGNsYXNzIHRyYWNrc3RhcnRcbiAqL1xuLyoqXG4gKiBQaXhlbHMgbW92ZWQgaW4gdGhlIHggZGlyZWN0aW9uIHNpbmNlIHRyYWNrc3RhcnQuXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBkeFxuICovXG4vKipcbiAqIFBpeGVzIG1vdmVkIGluIHRoZSB5IGRpcmVjdGlvbiBzaW5jZSB0cmFja3N0YXJ0LlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgZHlcbiAqL1xuLyoqXG4gKiBQaXhlbHMgbW92ZWQgaW4gdGhlIHggZGlyZWN0aW9uIHNpbmNlIHRoZSBsYXN0IHRyYWNrLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgZGR4XG4gKi9cbi8qKlxuICogUGl4bGVzIG1vdmVkIGluIHRoZSB5IGRpcmVjdGlvbiBzaW5jZSB0aGUgbGFzdCB0cmFjay5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IGRkeVxuICovXG4vKipcbiAqIFRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgY2xpZW50WFxuICovXG4vKipcbiAqIFRoZSBjbGllbnRZIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgY2xpZW50WVxuICovXG4vKipcbiAqIFRoZSBwYWdlWCBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHBhZ2VYXG4gKi9cbi8qKlxuICogVGhlIHBhZ2VZIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgcGFnZVlcbiAqL1xuLyoqXG4gKiBUaGUgc2NyZWVuWCBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHNjcmVlblhcbiAqL1xuLyoqXG4gKiBUaGUgc2NyZWVuWSBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHNjcmVlbllcbiAqL1xuLyoqXG4gKiBUaGUgbGFzdCB4IGF4aXMgZGlyZWN0aW9uIG9mIHRoZSBwb2ludGVyLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgeERpcmVjdGlvblxuICovXG4vKipcbiAqIFRoZSBsYXN0IHkgYXhpcyBkaXJlY3Rpb24gb2YgdGhlIHBvaW50ZXIuXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSB5RGlyZWN0aW9uXG4gKi9cbi8qKlxuICogQSBzaGFyZWQgb2JqZWN0IGJldHdlZW4gYWxsIHRyYWNraW5nIGV2ZW50cy5cbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHRyYWNrSW5mb1xuICovXG4vKipcbiAqIFRoZSBlbGVtZW50IGN1cnJlbnRseSB1bmRlciB0aGUgcG9pbnRlci5cbiAqIEB0eXBlIEVsZW1lbnRcbiAqIEBwcm9wZXJ0eSByZWxhdGVkVGFyZ2V0XG4gKi9cbi8qKlxuICogVGhlIHR5cGUgb2YgcG9pbnRlciB0aGF0IG1ha2UgdGhlIHRyYWNrIGdlc3R1cmUuXG4gKiBAdHlwZSBTdHJpbmdcbiAqIEBwcm9wZXJ0eSBwb2ludGVyVHlwZVxuICovXG4vKipcbiAqXG4gKiBUaGlzIGV2ZW50IGZpcmVzIGZvciBhbGwgcG9pbnRlciBtb3ZlbWVudCBiZWluZyB0cmFja2VkLlxuICpcbiAqIEBjbGFzcyB0cmFja1xuICogQGV4dGVuZHMgdHJhY2tzdGFydFxuICovXG4vKipcbiAqIFRoaXMgZXZlbnQgZmlyZXMgd2hlbiB0aGUgcG9pbnRlciBpcyBubyBsb25nZXIgYmVpbmcgdHJhY2tlZC5cbiAqXG4gKiBAY2xhc3MgdHJhY2tlbmRcbiAqIEBleHRlbmRzIHRyYWNrc3RhcnRcbiAqL1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHNjb3BlLmV2ZW50RmFjdG9yeTtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IG5ldyBzY29wZS5Qb2ludGVyTWFwKCk7XG4gICAgdmFyIHRyYWNrID0ge1xuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICdtb3ZlJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICd0cmFja3N0YXJ0JyxcbiAgICAgICAgICAgICd0cmFjaycsXG4gICAgICAgICAgICAndHJhY2t4JyxcbiAgICAgICAgICAgICd0cmFja3knLFxuICAgICAgICAgICAgJ3RyYWNrZW5kJ1xuICAgICAgICBdLFxuICAgICAgICBkZWZhdWx0QWN0aW9uczoge1xuICAgICAgICAgICAgJ3RyYWNrJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3RyYWNreCc6ICdwYW4teScsXG4gICAgICAgICAgICAndHJhY2t5JzogJ3Bhbi14J1xuICAgICAgICB9LFxuICAgICAgICBXSUdHTEVfVEhSRVNIT0xEOiA0LFxuICAgICAgICBjbGFtcERpcjogZnVuY3Rpb24oaW5EZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGluRGVsdGEgPiAwID8gMSA6IC0xO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjUG9zaXRpb25EZWx0YTogZnVuY3Rpb24oaW5BLCBpbkIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIGlmIChpbkEgJiYgaW5CKSB7XG4gICAgICAgICAgICAgICAgeCA9IGluQi5wYWdlWCAtIGluQS5wYWdlWDtcbiAgICAgICAgICAgICAgICB5ID0gaW5CLnBhZ2VZIC0gaW5BLnBhZ2VZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGZpcmVUcmFjazogZnVuY3Rpb24oaW5UeXBlLCBpbkV2ZW50LCBpblRyYWNraW5nRGF0YSkge1xuICAgICAgICAgICAgdmFyIHQgPSBpblRyYWNraW5nRGF0YTtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5jYWxjUG9zaXRpb25EZWx0YSh0LmRvd25FdmVudCwgaW5FdmVudCk7XG4gICAgICAgICAgICB2YXIgZGQgPSB0aGlzLmNhbGNQb3NpdGlvbkRlbHRhKHQubGFzdE1vdmVFdmVudCwgaW5FdmVudCk7XG4gICAgICAgICAgICBpZiAoZGQueCkge1xuICAgICAgICAgICAgICAgIHQueERpcmVjdGlvbiA9IHRoaXMuY2xhbXBEaXIoZGQueCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluVHlwZSA9PT0gJ3RyYWNreCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGQueSkge1xuICAgICAgICAgICAgICAgIHQueURpcmVjdGlvbiA9IHRoaXMuY2xhbXBEaXIoZGQueSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluVHlwZSA9PT0gJ3RyYWNreScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZ2VzdHVyZVByb3RvID0ge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cmFja0luZm86IHQudHJhY2tJbmZvLFxuICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGluRXZlbnQucmVsYXRlZFRhcmdldCxcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogaW5FdmVudC5wb2ludGVyVHlwZSxcbiAgICAgICAgICAgICAgICBwb2ludGVySWQ6IGluRXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgICAgIF9zb3VyY2U6ICd0cmFjaydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW5UeXBlICE9PSAndHJhY2t5Jykge1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by54ID0gaW5FdmVudC54O1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by5keCA9IGQueDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uZGR4ID0gZGQueDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uY2xpZW50WCA9IGluRXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8ucGFnZVggPSBpbkV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by5zY3JlZW5YID0gaW5FdmVudC5zY3JlZW5YO1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by54RGlyZWN0aW9uID0gdC54RGlyZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluVHlwZSAhPT0gJ3RyYWNreCcpIHtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uZHkgPSBkLnk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLmRkeSA9IGRkLnk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLnkgPSBpbkV2ZW50Lnk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLmNsaWVudFkgPSBpbkV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLnBhZ2VZID0gaW5FdmVudC5wYWdlWTtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uc2NyZWVuWSA9IGluRXZlbnQuc2NyZWVuWTtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8ueURpcmVjdGlvbiA9IHQueURpcmVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlID0gZXZlbnRGYWN0b3J5Lm1ha2VHZXN0dXJlRXZlbnQoaW5UeXBlLCBnZXN0dXJlUHJvdG8pO1xuICAgICAgICAgICAgdC5kb3duVGFyZ2V0LmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbkV2ZW50LmlzUHJpbWFyeSAmJiAoaW5FdmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyA/IGluRXZlbnQuYnV0dG9ucyA9PT0gMSA6IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRvd25FdmVudDogaW5FdmVudCxcbiAgICAgICAgICAgICAgICAgICAgZG93blRhcmdldDogaW5FdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrSW5mbzoge30sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb3ZlRXZlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHhEaXJlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgICAgIHlEaXJlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNraW5nOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwLnRyYWNraW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5jYWxjUG9zaXRpb25EZWx0YShwLmRvd25FdmVudCwgaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3ZlID0gZC54ICogZC54ICsgZC55ICogZC55O1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCB0cmFja2luZyBvbmx5IGlmIGZpbmdlciBtb3ZlcyBtb3JlIHRoYW4gV0lHR0xFX1RIUkVTSE9MRFxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZSA+IHRoaXMuV0lHR0xFX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC50cmFja2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxhc3RNb3ZlRXZlbnQgPSBwLmRvd25FdmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja3N0YXJ0JywgaW5FdmVudCwgcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHAudHJhY2tpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlVHJhY2soJ3RyYWNrJywgaW5FdmVudCwgcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja3gnLCBpbkV2ZW50LCBwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlVHJhY2soJ3RyYWNreScsIGluRXZlbnQsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwLmxhc3RNb3ZlRXZlbnQgPSBpbkV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIHAgPSBwb2ludGVybWFwLmdldChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIGlmIChwLnRyYWNraW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja2VuZCcsIGluRXZlbnQsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLmRlbGV0ZShpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJHZXN0dXJlKCd0cmFjaycsIHRyYWNrKTtcbn0pKGV4cG9ydHMpO1xuXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIHBvaW50ZXIgaXMgaGVsZCBkb3duIGZvciAyMDBtcy5cbiAqXG4gKiBAbW9kdWxlIFBvaW50ZXJHZXN0dXJlc1xuICogQHN1Ym1vZHVsZSBFdmVudHNcbiAqIEBjbGFzcyBob2xkXG4gKi9cbi8qKlxuICogVHlwZSBvZiBwb2ludGVyIHRoYXQgbWFkZSB0aGUgaG9sZGluZyBldmVudC5cbiAqIEB0eXBlIFN0cmluZ1xuICogQHByb3BlcnR5IHBvaW50ZXJUeXBlXG4gKi9cbi8qKlxuICogU2NyZWVuIFggYXhpcyBwb3NpdGlvbiBvZiB0aGUgaGVsZCBwb2ludGVyXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBjbGllbnRYXG4gKi9cbi8qKlxuICogU2NyZWVuIFkgYXhpcyBwb3NpdGlvbiBvZiB0aGUgaGVsZCBwb2ludGVyXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBjbGllbnRZXG4gKi9cbi8qKlxuICogVHlwZSBvZiBwb2ludGVyIHRoYXQgbWFkZSB0aGUgaG9sZGluZyBldmVudC5cbiAqIEB0eXBlIFN0cmluZ1xuICogQHByb3BlcnR5IHBvaW50ZXJUeXBlXG4gKi9cbi8qKlxuICogVGhpcyBldmVudCBpcyBmaXJlZCBldmVyeSAyMDBtcyB3aGlsZSBhIHBvaW50ZXIgaXMgaGVsZCBkb3duLlxuICpcbiAqIEBjbGFzcyBob2xkcHVsc2VcbiAqIEBleHRlbmRzIGhvbGRcbiAqL1xuLyoqXG4gKiBNaWxsaXNlY29uZHMgcG9pbnRlciBoYXMgYmVlbiBoZWxkIGRvd24uXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBob2xkVGltZVxuICovXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGhlbGQgcG9pbnRlciBpcyByZWxlYXNlZCBvciBtb3ZlZC5cbiAqXG4gKiBAY2xhc3MgcmVsZWFzZVxuICovXG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgZXZlbnRGYWN0b3J5ID0gc2NvcGUuZXZlbnRGYWN0b3J5O1xuICAgIHZhciBob2xkID0ge1xuICAgICAgICAvLyB3YWl0IGF0IGxlYXN0IEhPTERfREVMQVkgbXMgYmV0d2VlbiBob2xkIGFuZCBwdWxzZSBldmVudHNcbiAgICAgICAgSE9MRF9ERUxBWTogMjAwLFxuICAgICAgICAvLyBwb2ludGVyIGNhbiBtb3ZlIFdJR0dMRV9USFJFU0hPTEQgcGl4ZWxzIGJlZm9yZSBub3QgY291bnRpbmcgYXMgYSBob2xkXG4gICAgICAgIFdJR0dMRV9USFJFU0hPTEQ6IDE2LFxuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICdtb3ZlJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdob2xkJyxcbiAgICAgICAgICAgICdob2xkcHVsc2UnLFxuICAgICAgICAgICAgJ3JlbGVhc2UnXG4gICAgICAgIF0sXG4gICAgICAgIGhlbGRQb2ludGVyOiBudWxsLFxuICAgICAgICBob2xkSm9iOiBudWxsLFxuICAgICAgICBwdWxzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaG9sZCA9IERhdGUubm93KCkgLSB0aGlzLmhlbGRQb2ludGVyLnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5oZWxkID8gJ2hvbGRwdWxzZScgOiAnaG9sZCc7XG4gICAgICAgICAgICB0aGlzLmZpcmVIb2xkKHR5cGUsIGhvbGQpO1xuICAgICAgICAgICAgdGhpcy5oZWxkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5ob2xkSm9iKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVIb2xkKCdyZWxlYXNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhlbGQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGVsZFBvaW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ob2xkSm9iID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKGluRXZlbnQuaXNQcmltYXJ5ICYmICF0aGlzLmhlbGRQb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxkUG9pbnRlciA9IGluRXZlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBpbkV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLmhvbGRKb2IgPSBzZXRJbnRlcnZhbCh0aGlzLnB1bHNlLmJpbmQodGhpcyksIHRoaXMuSE9MRF9ERUxBWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWxkUG9pbnRlciAmJiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJJZCA9PT0gaW5FdmVudC5wb2ludGVySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWxkUG9pbnRlciAmJiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJJZCA9PT0gaW5FdmVudC5wb2ludGVySWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WCAtIHRoaXMuaGVsZFBvaW50ZXIuY2xpZW50WDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGluRXZlbnQuY2xpZW50WSAtIHRoaXMuaGVsZFBvaW50ZXIuY2xpZW50WTtcbiAgICAgICAgICAgICAgICBpZiAoKHggKiB4ICsgeSAqIHkpID4gdGhpcy5XSUdHTEVfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaXJlSG9sZDogZnVuY3Rpb24oaW5UeXBlLCBpbkhvbGRUaW1lKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IHRoaXMuaGVsZFBvaW50ZXIucG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcklkOiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJJZCxcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmhlbGRQb2ludGVyLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5oZWxkUG9pbnRlci5jbGllbnRZLFxuICAgICAgICAgICAgICAgIF9zb3VyY2U6ICdob2xkJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbkhvbGRUaW1lKSB7XG4gICAgICAgICAgICAgICAgcC5ob2xkVGltZSA9IGluSG9sZFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlR2VzdHVyZUV2ZW50KGluVHlwZSwgcCk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyR2VzdHVyZSgnaG9sZCcsIGhvbGQpO1xufSkoZXhwb3J0cyk7XG5cbi8qKlxuICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgcG9pbnRlciBxdWlja2x5IGdvZXMgZG93biBhbmQgdXAsIGFuZCBpcyB1c2VkIHRvXG4gKiBkZW5vdGUgYWN0aXZhdGlvbi5cbiAqXG4gKiBBbnkgZ2VzdHVyZSBldmVudCBjYW4gcHJldmVudCB0aGUgdGFwIGV2ZW50IGZyb20gYmVpbmcgY3JlYXRlZCBieSBjYWxsaW5nXG4gKiBgZXZlbnQucHJldmVudFRhcGAuXG4gKlxuICogQW55IHBvaW50ZXIgZXZlbnQgY2FuIHByZXZlbnQgdGhlIHRhcCBieSBzZXR0aW5nIHRoZSBgdGFwUHJldmVudGVkYCBwcm9wZXJ0eVxuICogb24gaXRzZWxmLlxuICpcbiAqIEBtb2R1bGUgUG9pbnRlckdlc3R1cmVzXG4gKiBAc3VibW9kdWxlIEV2ZW50c1xuICogQGNsYXNzIHRhcFxuICovXG4vKipcbiAqIFggYXhpcyBwb3NpdGlvbiBvZiB0aGUgdGFwLlxuICogQHByb3BlcnR5IHhcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIFkgYXhpcyBwb3NpdGlvbiBvZiB0aGUgdGFwLlxuICogQHByb3BlcnR5IHlcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIFR5cGUgb2YgdGhlIHBvaW50ZXIgdGhhdCBtYWRlIHRoZSB0YXAuXG4gKiBAcHJvcGVydHkgcG9pbnRlclR5cGVcbiAqIEB0eXBlIFN0cmluZ1xuICovXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHNjb3BlLmV2ZW50RmFjdG9yeTtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IG5ldyBzY29wZS5Qb2ludGVyTWFwKCk7XG4gICAgdmFyIHRhcCA9IHtcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAnZG93bicsXG4gICAgICAgICAgICAndXAnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICd0YXAnXG4gICAgICAgIF0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbkV2ZW50LmlzUHJpbWFyeSAmJiAhaW5FdmVudC50YXBQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLnNldChpbkV2ZW50LnBvaW50ZXJJZCwge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGluRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBpbkV2ZW50LmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIHg6IGluRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgeTogaW5FdmVudC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZFRhcDogZnVuY3Rpb24oZSwgZG93blN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgdGFwID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhbGxvdyBsZWZ0IGNsaWNrIHRvIHRhcCBmb3IgbW91c2VcbiAgICAgICAgICAgICAgICB0YXAgPSAoZS5idXR0b25zIF4gMSkgJiYgKGRvd25TdGF0ZS5idXR0b25zICYgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFwICYmICFlLnRhcFByZXZlbnRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmIChzdGFydCAmJiB0aGlzLnNob3VsZFRhcChpbkV2ZW50LCBzdGFydCkpIHtcbiAgICAgICAgICAgICAgICAvLyB1cC5yZWxhdGVkVGFyZ2V0IGlzIHRhcmdldCBjdXJyZW50bHkgdW5kZXIgZmluZ2VyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBzY29wZS50YXJnZXRGaW5kaW5nLkxDQShzdGFydC50YXJnZXQsIGluRXZlbnQucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBldmVudEZhY3RvcnkubWFrZUdlc3R1cmVFdmVudCgndGFwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpbkV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBpbkV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGluRXZlbnQuZGV0YWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IGluRXZlbnQucG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVySWQ6IGluRXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx0S2V5OiBpbkV2ZW50LmFsdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmxLZXk6IGluRXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFLZXk6IGluRXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0S2V5OiBpbkV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgX3NvdXJjZTogJ3RhcCdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVybWFwLmRlbGV0ZShpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHBhdGNoIGV2ZW50RmFjdG9yeSB0byByZW1vdmUgaWQgZnJvbSB0YXAncyBwb2ludGVybWFwIGZvciBwcmV2ZW50VGFwIGNhbGxzXG4gICAgZXZlbnRGYWN0b3J5LnByZXZlbnRUYXAgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGUudGFwUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBvaW50ZXJtYXAuZGVsZXRlKGUucG9pbnRlcklkKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJHZXN0dXJlKCd0YXAnLCB0YXApO1xufSkoZXhwb3J0cyk7XG5cbi8qXG4gKiBCYXNpYyBzdHJhdGVneTogZmluZCB0aGUgZmFydGhlc3QgYXBhcnQgcG9pbnRzLCB1c2UgYXMgZGlhbWV0ZXIgb2YgY2lyY2xlXG4gKiByZWFjdCB0byBzaXplIGNoYW5nZSBhbmQgcm90YXRpb24gb2YgdGhlIGNob3JkXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIHBvaW50ZXItZ2VzdHVyZXNcbiAqIEBzdWJtb2R1bGUgRXZlbnRzXG4gKiBAY2xhc3MgcGluY2hcbiAqL1xuLyoqXG4gKiBTY2FsZSBvZiB0aGUgcGluY2ggem9vbSBnZXN0dXJlXG4gKiBAcHJvcGVydHkgc2NhbGVcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIENlbnRlciBYIHBvc2l0aW9uIG9mIHBvaW50ZXJzIGNhdXNpbmcgcGluY2hcbiAqIEBwcm9wZXJ0eSBjZW50ZXJYXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuLyoqXG4gKiBDZW50ZXIgWSBwb3NpdGlvbiBvZiBwb2ludGVycyBjYXVzaW5nIHBpbmNoXG4gKiBAcHJvcGVydHkgY2VudGVyWVxuICogQHR5cGUgTnVtYmVyXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIHBvaW50ZXItZ2VzdHVyZXNcbiAqIEBzdWJtb2R1bGUgRXZlbnRzXG4gKiBAY2xhc3Mgcm90YXRlXG4gKi9cbi8qKlxuICogQW5nbGUgKGluIGRlZ3JlZXMpIG9mIHJvdGF0aW9uLiBNZWFzdXJlZCBmcm9tIHN0YXJ0aW5nIHBvc2l0aW9ucyBvZiBwb2ludGVycy5cbiAqIEBwcm9wZXJ0eSBhbmdsZVxuICogQHR5cGUgTnVtYmVyXG4gKi9cbi8qKlxuICogQ2VudGVyIFggcG9zaXRpb24gb2YgcG9pbnRlcnMgY2F1c2luZyByb3RhdGlvblxuICogQHByb3BlcnR5IGNlbnRlclhcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIENlbnRlciBZIHBvc2l0aW9uIG9mIHBvaW50ZXJzIGNhdXNpbmcgcm90YXRpb25cbiAqIEBwcm9wZXJ0eSBjZW50ZXJZXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSBzY29wZS5kaXNwYXRjaGVyO1xuICAgIHZhciBldmVudEZhY3RvcnkgPSBzY29wZS5ldmVudEZhY3Rvcnk7XG4gICAgdmFyIHBvaW50ZXJtYXAgPSBuZXcgc2NvcGUuUG9pbnRlck1hcCgpO1xuICAgIHZhciBSQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcbiAgICB2YXIgcGluY2ggPSB7XG4gICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgJ2Rvd24nLFxuICAgICAgICAgICAgJ3VwJyxcbiAgICAgICAgICAgICdtb3ZlJyxcbiAgICAgICAgICAgICdjYW5jZWwnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdwaW5jaHN0YXJ0JyxcbiAgICAgICAgICAgICdwaW5jaCcsXG4gICAgICAgICAgICAncGluY2hlbmQnLFxuICAgICAgICAgICAgJ3JvdGF0ZSdcbiAgICAgICAgXSxcbiAgICAgICAgZGVmYXVsdEFjdGlvbnM6IHtcbiAgICAgICAgICAgICdwaW5jaCc6ICdub25lJyxcbiAgICAgICAgICAgICdyb3RhdGUnOiAnbm9uZSdcbiAgICAgICAgfSxcbiAgICAgICAgcmVmZXJlbmNlOiB7fSxcbiAgICAgICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIGluRXZlbnQpO1xuICAgICAgICAgICAgaWYgKHBvaW50ZXJtYXAucG9pbnRlcnMoKSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY2FsY0Nob3JkKCk7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5jYWxjQW5nbGUocG9pbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBkaWFtZXRlcjogcG9pbnRzLmRpYW1ldGVyLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHNjb3BlLnRhcmdldEZpbmRpbmcuTENBKHBvaW50cy5hLnRhcmdldCwgcG9pbnRzLmIudGFyZ2V0KVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVQaW5jaCgncGluY2hzdGFydCcsIHBvaW50cy5kaWFtZXRlciwgcG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBwID0gcG9pbnRlcm1hcC5nZXQoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgdmFyIG51bSA9IHBvaW50ZXJtYXAucG9pbnRlcnMoKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51bSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlICdwaW5jaGVuZCcgYmVmb3JlIGRlbGV0aW5nIHBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY2FsY0Nob3JkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBpbmNoKCdwaW5jaGVuZCcsIHBvaW50cy5kaWFtZXRlciwgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5kZWxldGUoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAocG9pbnRlcm1hcC5oYXMoaW5FdmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludGVybWFwLnBvaW50ZXJzKCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY1BpbmNoUm90YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudXAoaW5FdmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpcmVQaW5jaDogZnVuY3Rpb24odHlwZSwgZGlhbWV0ZXIsIHBvaW50cykge1xuICAgICAgICAgICAgdmFyIHpvb20gPSBkaWFtZXRlciAvIHRoaXMucmVmZXJlbmNlLmRpYW1ldGVyO1xuICAgICAgICAgICAgdmFyIGUgPSBldmVudEZhY3RvcnkubWFrZUdlc3R1cmVFdmVudCh0eXBlLCB7XG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNjYWxlOiB6b29tLFxuICAgICAgICAgICAgICAgIGNlbnRlclg6IHBvaW50cy5jZW50ZXIueCxcbiAgICAgICAgICAgICAgICBjZW50ZXJZOiBwb2ludHMuY2VudGVyLnksXG4gICAgICAgICAgICAgICAgX3NvdXJjZTogJ3BpbmNoJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZS50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlyZVJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIHBvaW50cykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLnJvdW5kKChhbmdsZSAtIHRoaXMucmVmZXJlbmNlLmFuZ2xlKSAlIDM2MCk7XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlR2VzdHVyZUV2ZW50KCdyb3RhdGUnLCB7XG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBkaWZmLFxuICAgICAgICAgICAgICAgIGNlbnRlclg6IHBvaW50cy5jZW50ZXIueCxcbiAgICAgICAgICAgICAgICBjZW50ZXJZOiBwb2ludHMuY2VudGVyLnksXG4gICAgICAgICAgICAgICAgX3NvdXJjZTogJ3BpbmNoJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZS50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY1BpbmNoUm90YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmNhbGNDaG9yZCgpO1xuICAgICAgICAgICAgdmFyIGRpYW1ldGVyID0gcG9pbnRzLmRpYW1ldGVyO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5jYWxjQW5nbGUocG9pbnRzKTtcbiAgICAgICAgICAgIGlmIChkaWFtZXRlciAhPSB0aGlzLnJlZmVyZW5jZS5kaWFtZXRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBpbmNoKCdwaW5jaCcsIGRpYW1ldGVyLCBwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuZ2xlICE9IHRoaXMucmVmZXJlbmNlLmFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUm90YXRlKGFuZ2xlLCBwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxjQ2hvcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgICAgICAgICBwb2ludGVybWFwLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJzLnB1c2gocCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gMDtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHdpdGggYXQgbGVhc3QgdHdvIHBvaW50ZXJzXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0ge1xuICAgICAgICAgICAgICAgIGE6IHBvaW50ZXJzWzBdLFxuICAgICAgICAgICAgICAgIGI6IHBvaW50ZXJzWzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHgsIHksIGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBwb2ludGVyc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBwb2ludGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHBvaW50ZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5hYnMoYS5jbGllbnRYIC0gYi5jbGllbnRYKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IE1hdGguYWJzKGEuY2xpZW50WSAtIGIuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgICAgIGQgPSB4ICsgeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgPiBkaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiBhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGI6IGJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ID0gTWF0aC5hYnMocG9pbnRzLmEuY2xpZW50WCArIHBvaW50cy5iLmNsaWVudFgpIC8gMjtcbiAgICAgICAgICAgIHkgPSBNYXRoLmFicyhwb2ludHMuYS5jbGllbnRZICsgcG9pbnRzLmIuY2xpZW50WSkgLyAyO1xuICAgICAgICAgICAgcG9pbnRzLmNlbnRlciA9IHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb2ludHMuZGlhbWV0ZXIgPSBkaXN0O1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY0FuZ2xlOiBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcG9pbnRzLmEuY2xpZW50WCAtIHBvaW50cy5iLmNsaWVudFg7XG4gICAgICAgICAgICB2YXIgeSA9IHBvaW50cy5hLmNsaWVudFkgLSBwb2ludHMuYi5jbGllbnRZO1xuICAgICAgICAgICAgcmV0dXJuICgzNjAgKyBNYXRoLmF0YW4yKHksIHgpICogUkFEX1RPX0RFRykgJSAzNjA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJHZXN0dXJlKCdwaW5jaCcsIHBpbmNoKTtcbn0pKGV4cG9ydHMpOyIsIi8vIGxpc3QtZHJhZ29uIG5vZGUgbW9kdWxlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vb3BlbmZpbi9saXN0LWRyYWdvblxuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3NzSW5qZWN0b3IgPSByZXF1aXJlKCdjc3MtaW5qZWN0b3InKTtcbnZhciBmb3JtYXQgPSByZXF1aXJlKCd0ZW1wbGV4Jyk7XG5cbnZhciBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRSA9IG51bGw7ICAvLyBudWxsIHJlbW92ZXMgdGhlIHN0eWxlXG5cbnZhciB0cmFuc2Zvcm0sIHRpbWVyLCBzY3JvbGxWZWxvY2l0eSwgY3NzTGlzdERyYWdvbjtcblxuLyogaW5qZWN0OmNzcyAqL1xuY3NzTGlzdERyYWdvbiA9ICdkaXYuZHJhZ29uLWxpc3R7cG9zaXRpb246cmVsYXRpdmU7YmFja2dyb3VuZC1jb2xvcjojZmZmfWRpdi5kcmFnb24tbGlzdD5kaXYsZGl2LmRyYWdvbi1saXN0PnVse3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDtyaWdodDowfWRpdi5kcmFnb24tbGlzdD5kaXZ7dGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjojMDA3OTZiO2NvbG9yOiNmZmY7Ym94LXNoYWRvdzowIDNweCA2cHggcmdiYSgwLDAsMCwuMTYpLDAgM3B4IDZweCByZ2JhKDAsMCwwLC4yMyk7b3ZlcmZsb3c6aGlkZGVuO3doaXRlLXNwYWNlOm5vd3JhcH1kaXYuZHJhZ29uLWxpc3Q+dWx7b3ZlcmZsb3cteTphdXRvO2JvdHRvbTowO21hcmdpbjowO3BhZGRpbmc6MDtib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLC4xMiksMCAxcHggMnB4IHJnYmEoMCwwLDAsLjI0KX1kaXYuZHJhZ29uLWxpc3Q+dWw+bGksbGkuZHJhZ29uLXBvcHt3aGl0ZS1zcGFjZTpub3dyYXA7bGlzdC1zdHlsZS10eXBlOm5vbmU7Ym9yZGVyOjAgc29saWQgI2Y0ZjRmNDtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZTBlMGUwO2N1cnNvcjptb3ZlO3RyYW5zaXRpb246Ym9yZGVyLXRvcC13aWR0aCAuMnN9ZGl2LmRyYWdvbi1saXN0PnVsPmxpOmxhc3QtY2hpbGR7aGVpZ2h0OjA7Ym9yZGVyLWJvdHRvbTpub25lfWxpLmRyYWdvbi1wb3B7cG9zaXRpb246Zml4ZWQ7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI2UwZTBlMDtsZWZ0OjA7dG9wOjA7b3ZlcmZsb3cteDpoaWRkZW47Ym94LXNoYWRvdzpyZ2JhKDAsMCwwLC4xODgyMzUpIDAgMTBweCAyMHB4LHJnYmEoMCwwLDAsLjIyNzQ1MSkgMCA2cHggNnB4fSc7XG4vKiBlbmRpbmplY3QgKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3IgTGlzdERyYWdvblxuICpcbiAqIEBkZXNjIFRoaXMgb2JqZWN0IHNlcnZpY2VzIGEgc2V0IG9mIGl0ZW0gbGlzdHMgdGhhdCBhbGxvdyBkcmFnZ2luZyBhbmQgZHJvcHBpbmcgaXRlbXMgd2l0aGluIGFuZCBiZXR3ZWVuIGxpc3RzIGluIGEgc2V0LlxuICpcbiAqIFR3byBzdHJhdGVnaWVzIGFyZSBzdXBwb3J0ZWQ6XG4gKlxuICogMS4gU3VwcGx5IHlvdXIgb3duIEhUTUwgbWFya3VwIGFuZCBsZXQgdGhlIEFQSSBidWlsZCB0aGUgaXRlbSBtb2RlbHMgZm9yIHlvdS5cbiAqICAgIFRvIHVzZSB0aGlzIHN0cmF0ZWd5LCBzY3JpcHQgeW91ciBIVE1MIGFuZCBwcm92aWRlIG9uZSBvZiB0aGVzZTpcbiAqICAgICogYW4gYXJyYXkgb2YgYWxsIHRoZSBsaXN0IGl0ZW0gKGA8bGk+YCkgdGFnc1xuICogICAgKiBhIENTUyBzZWxlY3RvciB0aGF0IHBvaW50cyB0byBhbGwgdGhlIGxpc3QgaXRlbSB0YWdzXG4gKiAyLiBTdXBwbHkgeW91ciBvd24gaXRlbSBtb2RlbHMgYW5kIGxldCB0aGUgQVBJIGJ1aWxkIHRoZSBIVE1MIG1hcmt1cCBmb3IgeW91LlxuICogICAgVG8gdXNlIHRoaXMgc3RyYXRlZ3ksIHByb3ZpZGUgYW4gYXJyYXkgb2YgbW9kZWwgbGlzdHMuXG4gKlxuICogVGhlIG5ldyBMaXN0RHJhZ29uIG9iamVjdCdzIGBtb2RlbExpc3RzYCBwcm9wZXJ0eSByZWZlcmVuY2VzIHRoZSBhcnJheSBvZiBtb2RlbCBsaXN0cyB0aGUgQVBJIGNvbnN0cnVjdGVkIGZvciB5b3UgaW4gc3RyYXRlZ3kgIzEgb3IgdGhlIGFycmF5IG9mIG1vZGVsIGxpc3RzIHlvdSBzdXBwbGllZCBmb3Igc3RyYXRlZ3kgIzIuXG4gKlxuICogQWZ0ZXIgdGhlIHVzZXIgcGVyZm9ybXMgYSBzdWNjZXNzZnVsIGRyYWctYW5kLWRyb3Agb3BlcmF0aW9uLCB0aGUgcG9zaXRpb24gb2YgdGhlIG1vZGVsIHJlZmVyZW5jZXMgd2l0aGluIHRoZSBgbW9kZWxMaXN0c2AgYXJyYXkgaXMgcmVhcnJhbmdlZC4gKFRoZSBtb2RlbHMgdGhlbXNlbHZlcyBhcmUgdGhlIG9yaWdpbmFsIG9iamVjdHMgYXMgc3VwcGxpZWQgaW4gdGhlIG1vZGVsIGxpc3RzOyB0aGV5IGFyZSBub3QgcmVidWlsdCBvciBhbHRlcmVkIGluIGFueSB3YXkuIEp1c3QgdGhlIHJlZmVyZW5jZXMgdG8gdGhlbSBhcmUgbW92ZWQgYXJvdW5kLilcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50W118bW9kZWxMaXN0VHlwZVtdfSBzZWxlY3Rvck9yTW9kZWxMaXN0cyAtIFlvdSBtdXN0IHN1cHBseSBvbmUgb2YgdGhlIGl0ZW1zIGluICoqYm9sZCoqIGJlbG93OlxuICpcbiAqIDEuIF9Gb3Igc3RyYXRlZ3kgIzEgYWJvdmUgKEFQSSBjcmVhdGVzIG1vZGVscyBmcm9tIHN1cHBsaWVkIGVsZW1lbnRzKTpfIEFsbCB0aGUgbGlzdCBpdGVtIChgPGxpPmApIERPTSBlbGVtZW50cyBvZiBhbGwgdGhlIGxpc3RzIHlvdSB3YW50IHRoZSBuZXcgb2JqZWN0IHRvIG1hbmFnZSwgYXMgZWl0aGVyOlxuICogICAgMS4gKipBIENTUyBzZWxlY3RvcjsqKiBfb3JfXG4gKiAgICAyLiAqKkFuIGFycmF5IG9mIERPTSBlbGVtZW50cyoqXG4gKiAyLiBfRm9yIHN0cmF0ZWd5ICMyIGFib3ZlIChBUEkgY3JlYXRlcyBlbGVtZW50cyBmcm9tIHN1cHBsaWVkIG1vZGVscyk6XyAqKkFuIGFycmF5IG9mIG1vZGVsIGxpc3RzLCoqIGVhY2ggb2Ygd2hpY2ggaXMgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4gKiAgICAxLiBBbiBhcnJheSBvZiBpdGVtIG1vZGVscyAod2l0aCB2YXJpb3VzIG9wdGlvbiBwcm9wZXJ0aWVzIGhhbmdpbmcgb2ZmIG9mIGl0KTsgX2FuZC9vcl9cbiAqICAgIDIuIEEge0BsaW5rIG1vZGVsTGlzdFR5cGV9IG9iamVjdCB3aXRoIHRob3NlIHNhbWUgdmFyaW91cyBvcHRpb24gcHJvcGVydGllcyBpbmNsdWRpbmcgdGhlIHJlcXVpcmVkIGBtb2RlbHNgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhhdCBzYW1lIGFycmF5IG9mIGl0ZW0gbW9kZWxzLlxuICpcbiAqIEluIGVpdGhlciBjYXNlICgyLjEgb3IgMi4yKSwgZWFjaCBlbGVtZW50IG9mIHN1Y2ggYXJyYXlzIG9mIGl0ZW0gbW9kZWxzIG1heSB0YWtlIHRoZSBmb3JtIG9mOlxuICogKiBBIHN0cmluZyBwcmltaXRpdmU7IF9vcl9cbiAqICogQSB7QGxpbmsgaXRlbU1vZGVsVHlwZX0gb2JqZWN0IHdpdGggYSB2YXJpb3VzIG9wdGlvbiBwcm9wZXJ0aWVzIGluY2x1ZGluZyB0aGUgcmVxdWlyZWQgYGxhYmVsYCBwcm9wZXJ0eSBjb250YWluaW5nIGEgc3RyaW5nIHByaW1pdGl2ZS5cbiAqXG4gKiBSZWdhcmRpbmcgdGhlc2Ugc3RyaW5nIHByaW1pdGl2ZXMsIGVhY2ggaXMgZWl0aGVyOlxuICogKiBBIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGxpc3QgaXRlbTsgX29yX1xuICogKiBBIGZvcm1hdCBzdHJpbmcgd2l0aCBvdGhlciBwcm9wZXJ0eSB2YWx1ZXMgbWVyZ2VkIGluLCB0aGUgcmVzdWx0IG9mIHdoaWNoIGlzIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgbGlzdCBpdGVtLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gLSBZb3UgbWF5IHN1cHBseSBcImdsb2JhbFwiIHRlbXBsYXRlIHZhcmlhYmxlcyBoZXJlLCByZXByZXNlbnRpbmcgdGhlIFwib3V0ZXIgc2NvcGUsXCIgYWZ0ZXIgZmlyc3Qgc2VhcmNoaW5nIGVhY2ggbW9kZWwgYW5kIHRoZW4gZWFjaCBtb2RlbCBsaXN0LlxuICogQHBhcmFtIHt1bmRlZmluZWR8bnVsbHxFbGVtZW50fHN0cmluZ30gW2Nzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50XSAtIERldGVybWluZXMgd2hlcmUgdG8gaW5zZXJ0IHRoZSBzdHlsZXNoZWV0LiAoVGhpcyBpcyB0aGUgb25seSBmb3JtYWwgb3B0aW9uLikgUGFzc2VkIHRvIGNzcy1pbmplY3RvciwgdGhlIG92ZXJsb2FkcyBhcmUgKGZyb20gY3NzLWluamVjdG9yIGRvY3MpOlxuICogKiBgdW5kZWZpbmVkYCB0eXBlIChvciBvbWl0dGVkKTogaW5qZWN0cyBzdHlsZXNoZWV0IGF0IHRvcCBvZiBgPGhlYWQ+Li4uPC9oZWFkPmAgZWxlbWVudFxuICogKiBgbnVsbGAgdmFsdWU6IGluamVjdHMgc3R5bGVzaGVldCBhdCBib3R0b20gb2YgYDxoZWFkPi4uLjwvaGVhZD5gIGVsZW1lbnRcbiAqICogYEVsZW1lbnRgIHR5cGU6IGluamVjdHMgc3R5bGVzaGVldCBpbW1lZGlhdGVseSBiZWZvcmUgZ2l2ZW4gZWxlbWVudCwgd2hlcmV2ZXIgaXQgaXMgZm91bmQuXG4gKiAqIGBzdHJpbmdgIHR5cGU6IGluamVjdHMgc3R5bGVzaGVldCBpbW1lZGlhdGVseSBiZWZvcmUgZ2l2ZW4gZmlyc3QgZWxlbWVudCBmb3VuZCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIGNzcyBzZWxlY3Rvci5cbiAqL1xuZnVuY3Rpb24gTGlzdERyYWdvbihzZWxlY3Rvck9yTW9kZWxMaXN0cywgb3B0aW9ucykge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpc3REcmFnb24pKSB7XG4gICAgICAgIHRocm93IGVycm9yKCdOb3QgY2FsbGVkIHdpdGggXCJuZXdcIiBrZXl3b3JkLicpO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcywgbW9kZWxMaXN0cywgaXRlbXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICh0eXBlb2Ygc2VsZWN0b3JPck1vZGVsTGlzdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGl0ZW1zID0gdG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yT3JNb2RlbExpc3RzKSk7XG4gICAgICAgIG1vZGVsTGlzdHMgPSBjcmVhdGVNb2RlbExpc3RzRnJvbUxpc3RFbGVtZW50cyhpdGVtcyk7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rvck9yTW9kZWxMaXN0c1swXSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgaXRlbXMgPSB0b0FycmF5KHNlbGVjdG9yT3JNb2RlbExpc3RzKTtcbiAgICAgICAgbW9kZWxMaXN0cyA9IGNyZWF0ZU1vZGVsTGlzdHNGcm9tTGlzdEVsZW1lbnRzKGl0ZW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXJhbSBpcyBhcnJheSBvZiBtb2RlbCBsaXN0c1xuICAgICAgICAvLyBidWlsZCBuZXcgPHVsPiBlbGVtZW50KHMpIGZvciBlYWNoIGxpc3QgYW5kIHB1dCBpbiBgLm1vZGVsTGlzdHNgO1xuICAgICAgICAvLyBmaWxsIGAuaXRlbXNgIGFycmF5IHdpdGggPGxpPiBlbGVtZW50cyBmcm9tIHRoZXNlIG5ldyA8dWw+IGVsZW1lbnRzXG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIG1vZGVsTGlzdHMgPSBjcmVhdGVMaXN0RWxlbWVudHNGcm9tTW9kZWxMaXN0cyhzZWxlY3Rvck9yTW9kZWxMaXN0cywgb3B0aW9ucyk7XG4gICAgICAgIG1vZGVsTGlzdHMuZm9yRWFjaChmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQodG9BcnJheShsaXN0LmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGknKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBncmFiIHdoZWVsIGV2ZW50cyBhbmQgZG9uJ3QgbGV0ICdlbSBidWJibGVcbiAgICBtb2RlbExpc3RzLmZvckVhY2goZnVuY3Rpb24gKG1vZGVsTGlzdCkge1xuICAgICAgICBtb2RlbExpc3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGNhcHR1cmVFdmVudCk7XG4gICAgfSk7XG5cbiAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtRWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSAoaXRlbUVsZW1lbnQgIT09IGl0ZW1FbGVtZW50LnBhcmVudEVsZW1lbnQubGFzdEVsZW1lbnRDaGlsZClcbiAgICAgICAgICAgID8gc2VsZi5hZGRFdnQoaXRlbUVsZW1lbnQsICdtb3VzZWRvd24nLCBpdGVtRWxlbWVudCwgdHJ1ZSlcbiAgICAgICAgICAgIDogeyBlbGVtZW50OiBpdGVtRWxlbWVudCB9O1xuXG4gICAgICAgIC8qIGBpdGVtLm1vZGVsYCBub3QgY3VycmVudGx5IG5lZWRlZCBzbyBjb21tZW50ZWQgb3V0IGhlcmUuXG4gICAgICAgICAqIChPcmlnaW5hbGx5IHVzZWQgZm9yIHJlYnVpbGRpbmcgbW9kZWxMaXN0cyBmb3IgZmluYWxcbiAgICAgICAgICogcmVwb3J0aW5nLCBtb2RlbExpc3RzIGFyZSBub3cgc3BsaWNlZCBvbiBldmVyeSBzdWNjZXNzZnVsXG4gICAgICAgICAqIGRyYWctYW5kLWRyb3Agb3BlcmF0aW9uIHNvIHRoZXkncmUgYWx3YXlzIHVwIHRvIGRhdGUuKVxuXG4gICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5pdGVtQ29vcmRpbmF0ZXMoaXRlbUVsZW1lbnQpO1xuICAgICAgICAgaXRlbS5tb2RlbCA9IHRoaXMubW9kZWxMaXN0c1tvcmlnaW4ubGlzdF0ubW9kZWxzW29yaWdpbi5pdGVtXTtcblxuICAgICAgICAgKi9cblxuICAgICAgICBpdGVtc1tpbmRleF0gPSBpdGVtO1xuICAgIH0pO1xuXG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zZm9ybScgaW4gaXRlbXNbMF0uZWxlbWVudC5zdHlsZVxuICAgICAgICA/ICd0cmFuc2Zvcm0nIC8vIENocm9tZSA0NSBhbmQgRmlyZWZveCA0MFxuICAgICAgICA6ICctd2Via2l0LXRyYW5zZm9ybSc7IC8vIFNhZmFyaSA4XG5cbiAgICAvLyBzZXQgdXAgdGhlIG5ldyBvYmplY3RcbiAgICB0aGlzLm1vZGVsTGlzdHMgPSBtb2RlbExpc3RzO1xuICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgdGhpcy5jYWxsYmFjayA9IHt9O1xuXG4gICAgY3NzSW5qZWN0b3IoY3NzTGlzdERyYWdvbiwgJ2xpc3QtZHJhZ29uLWJhc2UnLCBvcHRpb25zLmNzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50KTtcblxufVxuXG5MaXN0RHJhZ29uLnByb3RvdHlwZSA9IHtcblxuICAgIGFkZEV2dDogZnVuY3Rpb24gKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGRvTm90QmluZCkge1xuICAgICAgICB2YXIgYmluZGluZyA9IHtcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXJzW3R5cGVdLmJpbmQodGFyZ2V0LCB0aGlzKSxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGxpc3RlbmVyIHx8IHdpbmRvd1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZG9Ob3RCaW5kKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVdID0gYmluZGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmRpbmcuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGJpbmRpbmcuaGFuZGxlcik7XG5cbiAgICAgICAgcmV0dXJuIGJpbmRpbmc7XG4gICAgfSxcblxuICAgIHJlbW92ZUV2dDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW3R5cGVdO1xuICAgICAgICBkZWxldGUgdGhpcy5iaW5kaW5nc1t0eXBlXTtcbiAgICAgICAgYmluZGluZy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgYmluZGluZy5oYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGRyYWcgJiBkcm9wIGV2ZW50cyAobW91c2Vtb3ZlLCBtb3VzZXVwLCBhbmQgdHJhbnNpdGlvbmVuZClcbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLmJpbmRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbdHlwZV07XG4gICAgICAgICAgICBiaW5kaW5nLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBiaW5kaW5nLmhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgbW91c2Vkb3duIGV2ZW50cyBmcm9tIGFsbCBsaXN0IGl0ZW1zXG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGl0ZW0uZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBpdGVtLmhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gd2hlZWwgZXZlbnRzIG9uIHRoZSBsaXN0IGVsZW1lbnRzXG4gICAgICAgIHRoaXMubW9kZWxMaXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbExpc3QpIHtcbiAgICAgICAgICAgIG1vZGVsTGlzdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgY2FwdHVyZUV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHBvaW50SW5MaXN0UmVjdHM6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbExpc3RzLmZpbmQoZnVuY3Rpb24gKG1vZGVsTGlzdCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBtb2RlbExpc3QuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAgIHdpbmRvdy5zY3JvbGxYICsgcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogICAgd2luZG93LnNjcm9sbFkgKyByZWN0LnRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogIHdpbmRvdy5zY3JvbGxYICsgcmVjdC5yaWdodCxcbiAgICAgICAgICAgICAgICBib3R0b206IHdpbmRvdy5zY3JvbGxZICsgcmVjdC5ib3R0b20sXG4gICAgICAgICAgICAgICAgd2lkdGg6ICByZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1vZGVsTGlzdC5yZWN0ID0gcmVjdDtcblxuICAgICAgICAgICAgaWYgKHBvaW50SW5SZWN0KHBvaW50LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIG1vZGVsTGlzdC5yZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZm91bmRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcG9pbnRJbkl0ZW1SZWN0czogZnVuY3Rpb24gKHBvaW50LCBleGNlcHQxLCBleGNlcHQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gaXRlbS5lbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBlbGVtZW50ICE9PSBleGNlcHQxICYmXG4gICAgICAgICAgICAgICAgZWxlbWVudCAhPT0gZXhjZXB0MiAmJlxuICAgICAgICAgICAgICAgIHBvaW50SW5SZWN0KHBvaW50LCBpdGVtLnJlY3QpXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gZ2V0IHBvc2l0aW9ucyBvZiBhbGwgbGlzdCBpdGVtcyBpbiBwYWdlIGNvb3JkcyAobm9ybWFsaXplZCBmb3Igd2luZG93IGFuZCBsaXN0IHNjcm9sbGluZylcbiAgICBnZXRBbGxJdGVtQm91bmRpbmdSZWN0czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbW9kZWxMaXN0cyA9IHRoaXMubW9kZWxMaXN0cywgaGVpZ2h0O1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBpdGVtRWxlbWVudCA9IGl0ZW0uZWxlbWVudCxcbiAgICAgICAgICAgICAgICBsaXN0RWxlbWVudCA9IGl0ZW1FbGVtZW50LnBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgbGlzdCA9IG1vZGVsTGlzdHMuZmluZChmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdC5lbGVtZW50ID09PSBsaXN0RWxlbWVudDsgfSk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBvbWl0dGVkOiBkZWZhdWx0IHRvIHRydWVcbiAgICAgICAgICAgICAgICBsaXN0LmlzRHJvcFRhcmdldCA9PT0gdW5kZWZpbmVkIHx8XG5cbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbjogdXNlIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgIHR5cGVvZiBsaXN0LmlzRHJvcFRhcmdldCA9PT0gJ2Z1bmN0aW9uJyAmJiBsaXN0LmlzRHJvcFRhcmdldCgpIHx8XG5cbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2U6IHVzZSB0cnV0aGluZXNzIG9mIGdpdmVuIHZhbHVlXG4gICAgICAgICAgICAgICAgbGlzdC5pc0Ryb3BUYXJnZXRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gaXRlbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHJlY3QuYm90dG9tO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1FbGVtZW50ID09PSBsaXN0RWxlbWVudC5sYXN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IGxpc3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdHRvbSA8IHJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSByZWN0LnRvcCArIChoZWlnaHQgfHwgNTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogICB3aW5kb3cuc2Nyb2xsWCArIHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6ICB3aW5kb3cuc2Nyb2xsWCArIHJlY3QucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogICAgd2luZG93LnNjcm9sbFkgKyByZWN0LnRvcCAgICArIGxpc3RFbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiB3aW5kb3cuc2Nyb2xsWSArIGJvdHRvbSArIGxpc3RFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpdGVtLnJlY3QgPSByZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVpbnNlcnQ6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlO1xuICAgICAgICBzdHlsZS53aWR0aCA9IHN0eWxlW3RyYW5zZm9ybV0gPSBzdHlsZS50cmFuc2l0aW9uID0gUkVWRVJUX1RPX1NUWUxFU0hFRVRfVkFMVUU7XG5cbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdvbi1wb3AnKTtcblxuICAgICAgICB0aGlzLmRyb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgICAgICAgdGhpcy5kcm9wLnN0eWxlLmJvcmRlclRvcFdpZHRoID0gUkVWRVJUX1RPX1NUWUxFU0hFRVRfVkFMVUU7XG4gICAgICAgIHRoaXMuZHJvcC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0YXJnZXQsIHRoaXMuZHJvcCk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuZHJvcDtcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJuIGFuIG9iamVjdCB7IGl0ZW06IDxpdGVtIGluZGV4IHdpdGhpbiBsaXN0PiwgbGlzdDogPGxpc3QgaW5kZXggd2l0aGluIGxpc3Qgb2YgbGlzdHM+IH1cbiAgICBpdGVtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBsaXN0RWxlbWVudCA9IGl0ZW0ucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgIGNvb3JkcyA9IHsgaXRlbTogMCB9O1xuXG4gICAgICAgIHdoaWxlICgoaXRlbSA9IGl0ZW0ucHJldmlvdXNFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgICsrY29vcmRzLml0ZW07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGVsTGlzdHMuZmluZChmdW5jdGlvbiAobGlzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGNvb3Jkcy5saXN0ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gbGlzdC5lbGVtZW50ID09PSBsaXN0RWxlbWVudDsgLy8gc3RvcCB3aGVuIHdlIGZpbmQgdGhlIG9uZSB3ZSBiZWxvbmcgdG9cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9XG5cbn07XG5cbnZhciBoYW5kbGVycyA9IHtcbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uIChkcmFnb24sIGV2dCkge1xuXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7ICAvL3ByZXZlbnRzIHVzZXIgc2VsZWN0aW9uIG9mIHJlbmRlcmVkIG5vZGVzIGR1cmluZyBkcmFnXG5cbiAgICAgICAgaWYgKGRyYWdvbi5kcm9wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgZHJhZ29uLnJlY3QgPSByZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogICBNYXRoLnJvdW5kKHJlY3QubGVmdCAtIDEpLFxuICAgICAgICAgICAgdG9wOiAgICBNYXRoLnJvdW5kKHJlY3QudG9wIC0gMSksXG4gICAgICAgICAgICByaWdodDogIE1hdGgucm91bmQocmVjdC5yaWdodCksXG4gICAgICAgICAgICBib3R0b206IE1hdGgucm91bmQocmVjdC5ib3R0b20pLFxuICAgICAgICAgICAgd2lkdGg6ICBNYXRoLnJvdW5kKHJlY3Qud2lkdGgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHJlY3QuaGVpZ2h0KVxuICAgICAgICB9O1xuXG4gICAgICAgIGRyYWdvbi5waW4gPSB7XG4gICAgICAgICAgICB4OiB3aW5kb3cuc2Nyb2xsWCArIGV2dC5jbGllbnRYLFxuICAgICAgICAgICAgeTogd2luZG93LnNjcm9sbFkgKyBldnQuY2xpZW50WVxuICAgICAgICB9O1xuXG4gICAgICAgIGRyYWdvbi5vcmlnaW4gPSBkcmFnb24uaXRlbUNvb3JkaW5hdGVzKHRoaXMpO1xuXG4gICAgICAgIGlmIChkcmFnb24uY2FsbGJhY2suZ3JhYmJlZCkge1xuICAgICAgICAgICAgZHJhZ29uLmNhbGxiYWNrLmdyYWJiZWQuY2FsbCh0aGlzLCBkcmFnb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZHJhZ29uLmdldEFsbEl0ZW1Cb3VuZGluZ1JlY3RzKCk7XG5cbiAgICAgICAgZHJhZ29uLmRyb3AgPSB0aGlzLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgZHJhZ29uLmRyb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgICAgICAgZHJhZ29uLmRyb3Auc3R5bGUuYm9yZGVyVG9wV2lkdGggPSByZWN0LmhlaWdodCArICdweCc7XG5cbiAgICAgICAgdGhpcy5zdHlsZS53aWR0aCA9IHJlY3Qud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gICAgICAgIHRoaXMuc3R5bGVbdHJhbnNmb3JtXSA9IHRyYW5zbGF0ZShcbiAgICAgICAgICAgIHJlY3QubGVmdCAtIHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICAgICAgcmVjdC50b3AgIC0gd2luZG93LnNjcm9sbFlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdkcmFnb24tcG9wJyk7XG4gICAgICAgIHRoaXMuc3R5bGUuekluZGV4ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZHJhZ29uLm1vZGVsTGlzdHNbMF0uY29udGFpbmVyLnBhcmVudEVsZW1lbnQpLnpJbmRleDtcblxuICAgICAgICBpZiAoIWRyYWdvbi5jb250YWluZXIpIHtcbiAgICAgICAgICAgIC8vIHdhbGsgYmFjayB0byBjbG9zZXN0IHNoYWRvdyByb290IE9SIGJvZHkgdGFnIE9SIHJvb3QgdGFnXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChjb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIFNoYWRvd1Jvb3QgIT09ICd1bmRlZmluZWQnICYmIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnRhZ05hbWUgPT09ICdCT0RZJ1xuICAgICAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyYWdvbi5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIH1cblxuICAgICAgICBkcmFnb24uY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMpO1xuXG4gICAgICAgIHJlY3QubGVmdCAgICs9IHdpbmRvdy5zY3JvbGxYO1xuICAgICAgICByZWN0LnRvcCAgICArPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgcmVjdC5yaWdodCAgKz0gd2luZG93LnNjcm9sbFg7XG4gICAgICAgIHJlY3QuYm90dG9tICs9IHdpbmRvdy5zY3JvbGxZO1xuXG4gICAgICAgIGRyYWdvbi5hZGRFdnQodGhpcywgJ21vdXNlbW92ZScpO1xuICAgICAgICBkcmFnb24uYWRkRXZ0KHRoaXMsICdtb3VzZXVwJyk7XG4gICAgfSxcblxuICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGRyYWdvbiwgZXZ0KSB7XG4gICAgICAgIGRyYWdvbi5kcm9wLnN0eWxlLnRyYW5zaXRpb24gPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTtcblxuICAgICAgICB2YXIgaG92ZXJMaXN0ID0gZHJhZ29uLnBvaW50SW5MaXN0UmVjdHMoeyB4OiBldnQuY2xpZW50WCwgeTogZXZ0LmNsaWVudFkgfSkgfHwgZHJhZ29uLm1vc3RSZWNlbnRIb3Zlckxpc3Q7XG5cbiAgICAgICAgaWYgKGhvdmVyTGlzdCkge1xuICAgICAgICAgICAgdmFyIGR4ID0gZXZ0LmNsaWVudFggLSBkcmFnb24ucGluLngsXG4gICAgICAgICAgICAgICAgZHkgPSBldnQuY2xpZW50WSAtIGRyYWdvbi5waW4ueTtcblxuICAgICAgICAgICAgZHJhZ29uLm1vc3RSZWNlbnRIb3Zlckxpc3QgPSBob3Zlckxpc3Q7XG5cbiAgICAgICAgICAgIHZhciBtYXhTY3JvbGxZID0gaG92ZXJMaXN0LmVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gaG92ZXJMaXN0LnJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHkgPSBldnQuY2xpZW50WSArIHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICAgICAgICAgIG1hZ25pdHVkZTtcblxuICAgICAgICAgICAgaWYgKG1heFNjcm9sbFkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbGlzdCBpcyBzY3JvbGxhYmxlIChpcyB0YWxsZXIgdGhhbiByZWN0KVxuICAgICAgICAgICAgICAgIGlmIChob3Zlckxpc3QuZWxlbWVudC5zY3JvbGxUb3AgPiAwICYmIChtYWduaXR1ZGUgPSB5IC0gKGhvdmVyTGlzdC5yZWN0LnRvcCArIDUpKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91c2UgbmVhciBvciBhYm92ZSB0b3AgYW5kIGxpc3QgaXMgbm90IHNjcm9sbGVkIHRvIHRvcCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRBdXRvU2Nyb2xsVGltZXIobWFnbml0dWRlLCAwLCBob3Zlckxpc3QuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChob3Zlckxpc3QuZWxlbWVudC5zY3JvbGxUb3AgPCBtYXhTY3JvbGxZICYmIChtYWduaXR1ZGUgPSB5IC0gKGhvdmVyTGlzdC5yZWN0LmJvdHRvbSAtIDEgLSA1KSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdXNlIG5lYXIgb3IgYmVsb3cgYm90dG9tIGFuZCBsaXN0IG5vdCBzY3JvbGxlZCB0byBib3R0b20geWV0XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0QXV0b1Njcm9sbFRpbWVyKG1hZ25pdHVkZSwgbWF4U2Nyb2xsWSwgaG92ZXJMaXN0LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdXNlIGluc2lkZVxuICAgICAgICAgICAgICAgICAgICByZXNldEF1dG9TY3JvbGxUaW1lcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG90aGVyID0gZHJhZ29uLnBvaW50SW5JdGVtUmVjdHMoe1xuICAgICAgICAgICAgICAgIHg6IGV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IGRyYWdvbi5yZWN0LmJvdHRvbSArIHdpbmRvdy5zY3JvbGxZICsgZHkgKyBob3Zlckxpc3QuZWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgIH0sIHRoaXMsIGRyYWdvbi5kcm9wKTtcblxuICAgICAgICAgICAgdGhpcy5zdHlsZVt0cmFuc2Zvcm1dID0gdHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgIGRyYWdvbi5yZWN0LmxlZnQgLSB3aW5kb3cuc2Nyb2xsWCArIGR4LFxuICAgICAgICAgICAgICAgIGRyYWdvbi5yZWN0LnRvcCAtIHdpbmRvdy5zY3JvbGxZICsgZHlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gb3RoZXIuZWxlbWVudDtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb24gPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmJvcmRlclRvcFdpZHRoID0gZHJhZ29uLmRyb3Auc3R5bGUuYm9yZGVyVG9wV2lkdGg7XG4gICAgICAgICAgICAgICAgZHJhZ29uLmRyb3Auc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBudWxsO1xuICAgICAgICAgICAgICAgIGRyYWdvbi5kcm9wID0gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3VzZXVwOiBmdW5jdGlvbiAoZHJhZ29uLCBldnQpIHtcbiAgICAgICAgcmVzZXRBdXRvU2Nyb2xsVGltZXIoKTtcbiAgICAgICAgZHJhZ29uLnJlbW92ZUV2dCgnbW91c2Vtb3ZlJyk7XG4gICAgICAgIGRyYWdvbi5yZW1vdmVFdnQoJ21vdXNldXAnKTtcblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgdmFyIG5ld1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxYICsgbmV3UmVjdC5sZWZ0ID09PSBkcmFnb24ucmVjdC5sZWZ0ICYmXG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsWSArIG5ld1JlY3QudG9wID09PSBkcmFnb24ucmVjdC50b3BcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkcmFnb24ucmVpbnNlcnQodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZHJvcFJlY3QgPSBkcmFnb24uZHJvcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgZHJhZ29uLmFkZEV2dCh0aGlzLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTsgLy9yZXZlcnRzIHRvIDIwMG1zXG4gICAgICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVbdHJhbnNmb3JtXSA9IHRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICBkcm9wUmVjdC5sZWZ0IC0gd2luZG93LnNjcm9sbFgsXG4gICAgICAgICAgICAgICAgZHJvcFJlY3QudG9wIC0gd2luZG93LnNjcm9sbFlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdHJhbnNpdGlvbmVuZDogZnVuY3Rpb24gKGRyYWdvbiwgZXZ0KSB7XG4gICAgICAgIGlmIChldnQucHJvcGVydHlOYW1lID09PSB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGRyYWdvbi5yZW1vdmVFdnQoJ3RyYW5zaXRpb25lbmQnKTtcbiAgICAgICAgICAgIGRyYWdvbi5yZWluc2VydCh0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTsgLy9yZXZlcnRzIHRvIGJvcmRlci10b3Atd2lkdGhcblxuICAgICAgICAgICAgdmFyIG1vZGVsID0gZHJhZ29uLm1vZGVsTGlzdHNbZHJhZ29uLm9yaWdpbi5saXN0XS5zcGxpY2UoZHJhZ29uLm9yaWdpbi5pdGVtLCAxKVswXTtcbiAgICAgICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IGRyYWdvbi5pdGVtQ29vcmRpbmF0ZXModGhpcyk7XG4gICAgICAgICAgICBkcmFnb24ubW9kZWxMaXN0c1tkZXN0aW5hdGlvbi5saXN0XS5zcGxpY2UoZGVzdGluYXRpb24uaXRlbSwgMCwgbW9kZWwpO1xuXG4gICAgICAgICAgICBpZiAoZHJhZ29uLmNhbGxiYWNrLmRyb3BwZWQpIHtcbiAgICAgICAgICAgICAgICBkcmFnb24uY2FsbGJhY2suZHJvcHBlZC5jYWxsKHRoaXMsIGRyYWdvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiByZXNldEF1dG9TY3JvbGxUaW1lcihtYWduaXR1ZGUsIGxpbWl0LCBlbGVtZW50KSB7XG4gICAgaWYgKCFtYWduaXR1ZGUpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIHNjcm9sbFZlbG9jaXR5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hhbmdlRGlyZWN0aW9uID1cbiAgICAgICAgICAgIHNjcm9sbFZlbG9jaXR5ICA8ICAwICYmIG1hZ25pdHVkZSAgPj0gMCB8fFxuICAgICAgICAgICAgc2Nyb2xsVmVsb2NpdHkgPT09IDAgJiYgbWFnbml0dWRlICE9PSAwIHx8XG4gICAgICAgICAgICBzY3JvbGxWZWxvY2l0eSAgPiAgMCAmJiBtYWduaXR1ZGUgIDw9IDA7XG4gICAgICAgIHNjcm9sbFZlbG9jaXR5ID0gbWFnbml0dWRlID4gMCA/IE1hdGgubWluKDUwLCBtYWduaXR1ZGUpIDogTWF0aC5tYXgoLTUwLCBtYWduaXR1ZGUpO1xuICAgICAgICBpZiAoY2hhbmdlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wICsgc2Nyb2xsVmVsb2NpdHk7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFZlbG9jaXR5IDwgMCAmJiBzY3JvbGxUb3AgPCBsaW1pdCB8fCBzY3JvbGxWZWxvY2l0eSA+IDAgJiYgc2Nyb2xsVG9wID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBsaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTI1KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2VPYmplY3QpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlT2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gcG9pbnRJblJlY3QocG9pbnQsIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC50b3AgPD0gcG9pbnQueSAmJiBwb2ludC55IDw9IHJlY3QuYm90dG9tXG4gICAgICAgICYmIHJlY3QubGVmdCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gcmVjdC5yaWdodDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlKGxlZnQsIHRvcCkge1xuICAgIHJldHVybiAndHJhbnNsYXRlKCdcbiAgICAgICAgKyBNYXRoLmZsb29yKGxlZnQgKyB3aW5kb3cuc2Nyb2xsWCkgKyAncHgsJ1xuICAgICAgICArIE1hdGguZmxvb3IodG9wICsgd2luZG93LnNjcm9sbFkpICsgJ3B4KSc7XG59XG5cbmZ1bmN0aW9uIGh0bWxFbmNvZGUoc3RyaW5nKSB7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nKTtcblxuICAgIHJldHVybiBkb2N1bWVudFxuICAgICAgICAuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgICAgIC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSlcbiAgICAgICAgLnBhcmVudE5vZGVcbiAgICAgICAgLmlubmVySFRNTDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGA8dWw+Li4uPC91bD5gIGVsZW1lbnRzIGFuZCBpbnNlcnRzIHRoZW0gaW50byBhbiBgZWxlbWVudGAgcHJvcGVydHkgb24gZWFjaCBtb2RlbC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbExpc3RzXG4gKiBAcmV0dXJucyBgbW9kZWxMaXN0c2BcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGlzdEVsZW1lbnRzRnJvbU1vZGVsTGlzdHMobW9kZWxMaXN0cywgb3B0aW9ucykge1xuICAgIHZhciB0ZW1wbGF0ZUxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCAne2xhYmVsfSc7XG5cbiAgICBtb2RlbExpc3RzLmZvckVhY2goZnVuY3Rpb24gKG1vZGVsTGlzdCwgbGlzdEluZGV4KSB7XG4gICAgICAgIHZhciBsaXN0TGFiZWwgPSBtb2RlbExpc3QubGFiZWwgfHwgdGVtcGxhdGVMYWJlbCxcbiAgICAgICAgICAgIGxpc3RIdG1sRW5jb2RlID0gbW9kZWxMaXN0Lmh0bWxFbmNvZGUgIT09IHVuZGVmaW5lZCAmJiBtb2RlbExpc3QuaHRtbEVuY29kZSB8fCBvcHRpb25zLmh0bWxFbmNvZGUsXG4gICAgICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIGxpc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcblxuICAgICAgICBpZiAobW9kZWxMaXN0Lm1vZGVscykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobW9kZWxMaXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kZWxzJykge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbExpc3QubW9kZWxzW2tleV0gPSBtb2RlbExpc3Rba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vZGVsTGlzdHNbbGlzdEluZGV4XSA9IG1vZGVsTGlzdCA9IG1vZGVsTGlzdC5tb2RlbHM7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZWxMaXN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIG1vZGVsTGlzdC5tb2RlbHMgPSBtb2RlbExpc3Q7IC8vIHBvaW50IHRvIHNlbGZcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yKCdMaXN0IFt7MX1dIG5vdCBhbiBhcnJheSBvZiBtb2RlbHMgKHdpdGggb3Igd2l0aG91dCBhZGRpdGlvbmFsIHByb3BlcnRpZXMpIE9SICcgK1xuICAgICAgICAgICAgICAgICdhbiBvYmplY3QgKHdpdGggYSBgbW9kZWxzYCBwcm9wZXJ0eSBjb250YWluaW5nIGFuIGFycmF5IG9mIG1vZGVscykuJywgbGlzdEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGVsTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgdmFyIG1vZGVsTGFiZWwgPSBtb2RlbC5sYWJlbCB8fCBsaXN0TGFiZWwsXG4gICAgICAgICAgICAgICAgbW9kZWxIdG1sRW5jb2RlID0gbW9kZWwuaHRtbEVuY29kZSAhPT0gdW5kZWZpbmVkICYmIG1vZGVsLmh0bWxFbmNvZGUgfHwgbGlzdEh0bWxFbmNvZGUsXG4gICAgICAgICAgICAgICAgbW9kZWxPYmplY3QgPSB0eXBlb2YgbW9kZWwgPT09ICdvYmplY3QnID8gbW9kZWwgOiB7IGxhYmVsOiBtb2RlbH0sXG4gICAgICAgICAgICAgICAgbGFiZWwgPSBmb3JtYXQuY2FsbChbbW9kZWxPYmplY3QsIG1vZGVsTGlzdCwgb3B0aW9uc10sIG1vZGVsTGFiZWwpLFxuICAgICAgICAgICAgICAgIGl0ZW1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblxuICAgICAgICAgICAgaXRlbUVsZW1lbnQuaW5uZXJIVE1MID0gbW9kZWxIdG1sRW5jb2RlID8gaHRtbEVuY29kZShsYWJlbCkgOiBsYWJlbDtcblxuICAgICAgICAgICAgbGlzdEVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbUVsZW1lbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhcHBlbmQgdGhlIGZpbmFsIFwiZmVuY2Vwb3N0XCIgaXRlbSAtLSBkcm9wIHRhcmdldCBhdCBib3R0b20gb2YgbGlzdCBhZnRlciBhbGwgaXRlbXNcbiAgICAgICAgdmFyIGl0ZW1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgaXRlbUVsZW1lbnQuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG4gICAgICAgIGxpc3RFbGVtZW50LmFwcGVuZENoaWxkKGl0ZW1FbGVtZW50KTtcblxuICAgICAgICAvLyBhcHBlbmQgaGVhZGVyIHRvIGNvbnRhaW5lclxuICAgICAgICBpZiAobW9kZWxMaXN0LnRpdGxlKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBoZWFkZXIuaW5uZXJIVE1MID0gbGlzdEh0bWxFbmNvZGUgPyBodG1sRW5jb2RlKG1vZGVsTGlzdC50aXRsZSkgOiBtb2RlbExpc3QudGl0bGU7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChsaXN0RWxlbWVudCk7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBtb2RlbExpc3QuY3NzQ2xhc3NOYW1lcyB8fCBvcHRpb25zLmNzc0NsYXNzTmFtZXMgfHwgJ2RyYWdvbi1saXN0JztcbiAgICAgICAgbW9kZWxMaXN0LmVsZW1lbnQgPSBsaXN0RWxlbWVudDtcbiAgICAgICAgbW9kZWxMaXN0LmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9KTtcblxuICAgIHJldHVybiBtb2RlbExpc3RzO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGAubW9kZWxMaXN0c2AgYXJyYXkgd2l0aCB0aGVzZSA8bGk+IGVsZW1lbnRzJyBwYXJlbnQgPHVsPiBlbGVtZW50c1xuICogQHBhcmFtIHtFbGVtZW50W119IGxpc3RJdGVtRWxlbWVudHNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kZWxMaXN0c0Zyb21MaXN0RWxlbWVudHMobGlzdEl0ZW1FbGVtZW50cykge1xuICAgIHZhciBtb2RlbExpc3RzID0gW107XG5cbiAgICBsaXN0SXRlbUVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW1FbGVtZW50KSB7XG4gICAgICAgIHZhciBsaXN0RWxlbWVudCA9IGl0ZW1FbGVtZW50LnBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICBjb250YWluZXIgPSBsaXN0RWxlbWVudC5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgbW9kZWxzID0gW107XG4gICAgICAgIGlmICghbW9kZWxMaXN0cy5maW5kKGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0LmVsZW1lbnQgPT09IGxpc3RFbGVtZW50OyB9KSkge1xuICAgICAgICAgICAgdG9BcnJheShsaXN0RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaScpKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtRWxlbWVudCAhPT0gbGlzdEVsZW1lbnQubGFzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbHMucHVzaChpdGVtRWxlbWVudC5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbW9kZWxzLmVsZW1lbnQgPSBsaXN0RWxlbWVudDtcbiAgICAgICAgICAgIG1vZGVscy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgICAgICBtb2RlbExpc3RzLnB1c2gobW9kZWxzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1vZGVsTGlzdHM7XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVFdmVudChldnQpIHtcbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIGVycm9yKCkge1xuICAgIHJldHVybiAnbGlzdC1kcmFnb246ICcgKyBmb3JtYXQuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59XG5cbi8vIHRoaXMgaW50ZXJmYWNlIGNvbnNpc3RzIHNvbGVseSBvZiB0aGUgcHJvdG90eXBhbCBvYmplY3QgY29uc3RydWN0b3Jcbm1vZHVsZS5leHBvcnRzID0gTGlzdERyYWdvbjtcbiIsIjsoZnVuY3Rpb24gKCkgeyAvLyBjbG9zdXJlIGZvciB3ZWIgYnJvd3NlcnNcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbn0gZWxzZSB7XG4gIC8vIGp1c3Qgc2V0IHRoZSBnbG9iYWwgZm9yIG5vbi1ub2RlIHBsYXRmb3Jtcy5cbiAgdGhpcy5MUlVDYWNoZSA9IExSVUNhY2hlXG59XG5cbmZ1bmN0aW9uIGhPUCAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuZnVuY3Rpb24gbmFpdmVMZW5ndGggKCkgeyByZXR1cm4gMSB9XG5cbnZhciBkaWRUeXBlV2FybmluZyA9IGZhbHNlXG5mdW5jdGlvbiB0eXBlQ2hlY2tLZXkoa2V5KSB7XG4gIGlmICghZGlkVHlwZVdhcm5pbmcgJiYgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGtleSAhPT0gJ251bWJlcicpIHtcbiAgICBkaWRUeXBlV2FybmluZyA9IHRydWVcbiAgICBjb25zb2xlLmVycm9yKG5ldyBUeXBlRXJyb3IoXCJMUlU6IGtleSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlci4gQWxtb3N0IGNlcnRhaW5seSBhIGJ1ZyEgXCIgKyB0eXBlb2Yga2V5KS5zdGFjaylcbiAgfVxufVxuXG5mdW5jdGlvbiBMUlVDYWNoZSAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTFJVQ2FjaGUpKVxuICAgIHJldHVybiBuZXcgTFJVQ2FjaGUob3B0aW9ucylcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKVxuICAgIG9wdGlvbnMgPSB7IG1heDogb3B0aW9ucyB9XG5cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fVxuXG4gIHRoaXMuX21heCA9IG9wdGlvbnMubWF4XG4gIC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cbiAgaWYgKCF0aGlzLl9tYXggfHwgISh0eXBlb2YgdGhpcy5fbWF4ID09PSBcIm51bWJlclwiKSB8fCB0aGlzLl9tYXggPD0gMCApXG4gICAgdGhpcy5fbWF4ID0gSW5maW5pdHlcblxuICB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yID0gb3B0aW9ucy5sZW5ndGggfHwgbmFpdmVMZW5ndGhcbiAgaWYgKHR5cGVvZiB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvciA9IG5haXZlTGVuZ3RoXG5cbiAgdGhpcy5fYWxsb3dTdGFsZSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgdGhpcy5fbWF4QWdlID0gb3B0aW9ucy5tYXhBZ2UgfHwgbnVsbFxuICB0aGlzLl9kaXNwb3NlID0gb3B0aW9ucy5kaXNwb3NlXG4gIHRoaXMucmVzZXQoKVxufVxuXG4vLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIG1heCBjaGFuZ2VzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgXCJtYXhcIixcbiAgeyBzZXQgOiBmdW5jdGlvbiAobUwpIHtcbiAgICAgIGlmICghbUwgfHwgISh0eXBlb2YgbUwgPT09IFwibnVtYmVyXCIpIHx8IG1MIDw9IDAgKSBtTCA9IEluZmluaXR5XG4gICAgICB0aGlzLl9tYXggPSBtTFxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA+IHRoaXMuX21heCkgdHJpbSh0aGlzKVxuICAgIH1cbiAgLCBnZXQgOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXggfVxuICAsIGVudW1lcmFibGUgOiB0cnVlXG4gIH0pXG5cbi8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbGVuZ3RoQ2FsY3VsYXRvciBjaGFuZ2VzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgXCJsZW5ndGhDYWxjdWxhdG9yXCIsXG4gIHsgc2V0IDogZnVuY3Rpb24gKGxDKSB7XG4gICAgICBpZiAodHlwZW9mIGxDICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvciA9IG5haXZlTGVuZ3RoXG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHRoaXMuX2l0ZW1Db3VudFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICB0aGlzLl9jYWNoZVtrZXldLmxlbmd0aCA9IDFcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvciA9IGxDXG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVba2V5XS5sZW5ndGggPSB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yKHRoaXMuX2NhY2hlW2tleV0udmFsdWUpXG4gICAgICAgICAgdGhpcy5fbGVuZ3RoICs9IHRoaXMuX2NhY2hlW2tleV0ubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA+IHRoaXMuX21heCkgdHJpbSh0aGlzKVxuICAgIH1cbiAgLCBnZXQgOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yIH1cbiAgLCBlbnVtZXJhYmxlIDogdHJ1ZVxuICB9KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcImxlbmd0aFwiLFxuICB7IGdldCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xlbmd0aCB9XG4gICwgZW51bWVyYWJsZSA6IHRydWVcbiAgfSlcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcIml0ZW1Db3VudFwiLFxuICB7IGdldCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2l0ZW1Db3VudCB9XG4gICwgZW51bWVyYWJsZSA6IHRydWVcbiAgfSlcblxuTFJVQ2FjaGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgaSA9IDBcbiAgdmFyIGl0ZW1Db3VudCA9IHRoaXMuX2l0ZW1Db3VudFxuXG4gIGZvciAodmFyIGsgPSB0aGlzLl9tcnUgLSAxOyBrID49IDAgJiYgaSA8IGl0ZW1Db3VudDsgay0tKSBpZiAodGhpcy5fbHJ1TGlzdFtrXSkge1xuICAgIGkrK1xuICAgIHZhciBoaXQgPSB0aGlzLl9scnVMaXN0W2tdXG4gICAgaWYgKGlzU3RhbGUodGhpcywgaGl0KSkge1xuICAgICAgZGVsKHRoaXMsIGhpdClcbiAgICAgIGlmICghdGhpcy5fYWxsb3dTdGFsZSkgaGl0ID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGlmIChoaXQpIHtcbiAgICAgIGZuLmNhbGwodGhpc3AsIGhpdC52YWx1ZSwgaGl0LmtleSwgdGhpcylcbiAgICB9XG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBrZXlzID0gbmV3IEFycmF5KHRoaXMuX2l0ZW1Db3VudClcbiAgdmFyIGkgPSAwXG4gIGZvciAodmFyIGsgPSB0aGlzLl9tcnUgLSAxOyBrID49IDAgJiYgaSA8IHRoaXMuX2l0ZW1Db3VudDsgay0tKSBpZiAodGhpcy5fbHJ1TGlzdFtrXSkge1xuICAgIHZhciBoaXQgPSB0aGlzLl9scnVMaXN0W2tdXG4gICAga2V5c1tpKytdID0gaGl0LmtleVxuICB9XG4gIHJldHVybiBrZXlzXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkodGhpcy5faXRlbUNvdW50KVxuICB2YXIgaSA9IDBcbiAgZm9yICh2YXIgayA9IHRoaXMuX21ydSAtIDE7IGsgPj0gMCAmJiBpIDwgdGhpcy5faXRlbUNvdW50OyBrLS0pIGlmICh0aGlzLl9scnVMaXN0W2tdKSB7XG4gICAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3Rba11cbiAgICB2YWx1ZXNbaSsrXSA9IGhpdC52YWx1ZVxuICB9XG4gIHJldHVybiB2YWx1ZXNcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGlzcG9zZSAmJiB0aGlzLl9jYWNoZSkge1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy5fY2FjaGUpIHtcbiAgICAgIHRoaXMuX2Rpc3Bvc2UoaywgdGhpcy5fY2FjaGVba10udmFsdWUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gIHRoaXMuX2xydUxpc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpIC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcbiAgdGhpcy5fbXJ1ID0gMCAvLyBtb3N0IHJlY2VudGx5IHVzZWRcbiAgdGhpcy5fbHJ1ID0gMCAvLyBsZWFzdCByZWNlbnRseSB1c2VkXG4gIHRoaXMuX2xlbmd0aCA9IDAgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gIHRoaXMuX2l0ZW1Db3VudCA9IDBcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBbXVxuICB2YXIgaSA9IDBcblxuICBmb3IgKHZhciBrID0gdGhpcy5fbXJ1IC0gMTsgayA+PSAwICYmIGkgPCB0aGlzLl9pdGVtQ291bnQ7IGstLSkgaWYgKHRoaXMuX2xydUxpc3Rba10pIHtcbiAgICB2YXIgaGl0ID0gdGhpcy5fbHJ1TGlzdFtrXVxuICAgIGlmICghaXNTdGFsZSh0aGlzLCBoaXQpKSB7XG4gICAgICAvL0RvIG5vdCBzdG9yZSBzdGFsZWQgaGl0c1xuICAgICAgKytpXG4gICAgICBhcnIucHVzaCh7XG4gICAgICAgIGs6IGhpdC5rZXksXG4gICAgICAgIHY6IGhpdC52YWx1ZSxcbiAgICAgICAgZTogaGl0Lm5vdyArIChoaXQubWF4QWdlIHx8IDApXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy9hcnIgaGFzIHRoZSBtb3N0IHJlYWQgZmlyc3RcbiAgcmV0dXJuIGFyclxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZHVtcExydSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xydUxpc3Rcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXMuX21heEFnZVxuICB0eXBlQ2hlY2tLZXkoa2V5KVxuXG4gIHZhciBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvcih2YWx1ZSlcblxuICBpZiAoaE9QKHRoaXMuX2NhY2hlLCBrZXkpKSB7XG4gICAgaWYgKGxlbiA+IHRoaXMuX21heCkge1xuICAgICAgZGVsKHRoaXMsIHRoaXMuX2NhY2hlW2tleV0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICBpZiAodGhpcy5fZGlzcG9zZSlcbiAgICAgIHRoaXMuX2Rpc3Bvc2Uoa2V5LCB0aGlzLl9jYWNoZVtrZXldLnZhbHVlKVxuXG4gICAgdGhpcy5fY2FjaGVba2V5XS5ub3cgPSBub3dcbiAgICB0aGlzLl9jYWNoZVtrZXldLm1heEFnZSA9IG1heEFnZVxuICAgIHRoaXMuX2NhY2hlW2tleV0udmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMuX2xlbmd0aCArPSAobGVuIC0gdGhpcy5fY2FjaGVba2V5XS5sZW5ndGgpXG4gICAgdGhpcy5fY2FjaGVba2V5XS5sZW5ndGggPSBsZW5cbiAgICB0aGlzLmdldChrZXkpXG5cbiAgICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KVxuICAgICAgdHJpbSh0aGlzKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHZhciBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSwgdGhpcy5fbXJ1KyssIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgLy8gb3ZlcnNpemVkIG9iamVjdHMgZmFsbCBvdXQgb2YgY2FjaGUgYXV0b21hdGljYWxseS5cbiAgaWYgKGhpdC5sZW5ndGggPiB0aGlzLl9tYXgpIHtcbiAgICBpZiAodGhpcy5fZGlzcG9zZSkgdGhpcy5fZGlzcG9zZShrZXksIHZhbHVlKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdGhpcy5fbGVuZ3RoICs9IGhpdC5sZW5ndGhcbiAgdGhpcy5fbHJ1TGlzdFtoaXQubHVdID0gdGhpcy5fY2FjaGVba2V5XSA9IGhpdFxuICB0aGlzLl9pdGVtQ291bnQgKytcblxuICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KVxuICAgIHRyaW0odGhpcylcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICB0eXBlQ2hlY2tLZXkoa2V5KVxuICBpZiAoIWhPUCh0aGlzLl9jYWNoZSwga2V5KSkgcmV0dXJuIGZhbHNlXG4gIHZhciBoaXQgPSB0aGlzLl9jYWNoZVtrZXldXG4gIGlmIChpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICB0eXBlQ2hlY2tLZXkoa2V5KVxuICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHR5cGVDaGVja0tleShrZXkpXG4gIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3RbdGhpcy5fbHJ1XVxuICBkZWwodGhpcywgaGl0KVxuICByZXR1cm4gaGl0IHx8IG51bGxcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdHlwZUNoZWNrS2V5KGtleSlcbiAgZGVsKHRoaXMsIHRoaXMuX2NhY2hlW2tleV0pXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGFycikge1xuICAvL3Jlc2V0IHRoZSBjYWNoZVxuICB0aGlzLnJlc2V0KCk7XG5cbiAgdmFyIG5vdyA9IERhdGUubm93KClcbiAgLy9BIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICBmb3IgKHZhciBsID0gYXJyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tICkge1xuICAgIHZhciBoaXQgPSBhcnJbbF1cbiAgICB0eXBlQ2hlY2tLZXkoaGl0LmspXG4gICAgdmFyIGV4cGlyZXNBdCA9IGhpdC5lIHx8IDBcbiAgICBpZiAoZXhwaXJlc0F0ID09PSAwKSB7XG4gICAgICAvL3RoZSBpdGVtIHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwaXJhdGlvbiBpbiBhIG5vbiBhZ2VkIGNhY2hlXG4gICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXhBZ2UgPSBleHBpcmVzQXQgLSBub3dcbiAgICAgIC8vZG9udCBhZGQgYWxyZWFkeSBleHBpcmVkIGl0ZW1zXG4gICAgICBpZiAobWF4QWdlID4gMCkgdGhpcy5zZXQoaGl0LmssIGhpdC52LCBtYXhBZ2UpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldCAoc2VsZiwga2V5LCBkb1VzZSkge1xuICB0eXBlQ2hlY2tLZXkoa2V5KVxuICB2YXIgaGl0ID0gc2VsZi5fY2FjaGVba2V5XVxuICBpZiAoaGl0KSB7XG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIGhpdClcbiAgICAgIGlmICghc2VsZi5fYWxsb3dTdGFsZSkgaGl0ID0gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb1VzZSkgdXNlKHNlbGYsIGhpdClcbiAgICB9XG4gICAgaWYgKGhpdCkgaGl0ID0gaGl0LnZhbHVlXG4gIH1cbiAgcmV0dXJuIGhpdFxufVxuXG5mdW5jdGlvbiBpc1N0YWxlKHNlbGYsIGhpdCkge1xuICBpZiAoIWhpdCB8fCAoIWhpdC5tYXhBZ2UgJiYgIXNlbGYuX21heEFnZSkpIHJldHVybiBmYWxzZVxuICB2YXIgc3RhbGUgPSBmYWxzZTtcbiAgdmFyIGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vd1xuICBpZiAoaGl0Lm1heEFnZSkge1xuICAgIHN0YWxlID0gZGlmZiA+IGhpdC5tYXhBZ2VcbiAgfSBlbHNlIHtcbiAgICBzdGFsZSA9IHNlbGYuX21heEFnZSAmJiAoZGlmZiA+IHNlbGYuX21heEFnZSlcbiAgfVxuICByZXR1cm4gc3RhbGU7XG59XG5cbmZ1bmN0aW9uIHVzZSAoc2VsZiwgaGl0KSB7XG4gIHNoaWZ0TFUoc2VsZiwgaGl0KVxuICBoaXQubHUgPSBzZWxmLl9tcnUgKytcbiAgc2VsZi5fbHJ1TGlzdFtoaXQubHVdID0gaGl0XG59XG5cbmZ1bmN0aW9uIHRyaW0gKHNlbGYpIHtcbiAgd2hpbGUgKHNlbGYuX2xydSA8IHNlbGYuX21ydSAmJiBzZWxmLl9sZW5ndGggPiBzZWxmLl9tYXgpXG4gICAgZGVsKHNlbGYsIHNlbGYuX2xydUxpc3Rbc2VsZi5fbHJ1XSlcbn1cblxuZnVuY3Rpb24gc2hpZnRMVSAoc2VsZiwgaGl0KSB7XG4gIGRlbGV0ZSBzZWxmLl9scnVMaXN0WyBoaXQubHUgXVxuICB3aGlsZSAoc2VsZi5fbHJ1IDwgc2VsZi5fbXJ1ICYmICFzZWxmLl9scnVMaXN0W3NlbGYuX2xydV0pIHNlbGYuX2xydSArK1xufVxuXG5mdW5jdGlvbiBkZWwgKHNlbGYsIGhpdCkge1xuICBpZiAoaGl0KSB7XG4gICAgaWYgKHNlbGYuX2Rpc3Bvc2UpIHNlbGYuX2Rpc3Bvc2UoaGl0LmtleSwgaGl0LnZhbHVlKVxuICAgIHNlbGYuX2xlbmd0aCAtPSBoaXQubGVuZ3RoXG4gICAgc2VsZi5faXRlbUNvdW50IC0tXG4gICAgZGVsZXRlIHNlbGYuX2NhY2hlWyBoaXQua2V5IF1cbiAgICBzaGlmdExVKHNlbGYsIGhpdClcbiAgfVxufVxuXG4vLyBjbGFzc3ksIHNpbmNlIFY4IHByZWZlcnMgcHJlZGljdGFibGUgb2JqZWN0cy5cbmZ1bmN0aW9uIEVudHJ5IChrZXksIHZhbHVlLCBsdSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICB0aGlzLmtleSA9IGtleVxuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5sdSA9IGx1XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMubm93ID0gbm93XG4gIGlmIChtYXhBZ2UpIHRoaXMubWF4QWdlID0gbWF4QWdlXG59XG5cbn0pKClcbiIsIi8qIVxuICogbXVzdGFjaGUuanMgLSBMb2dpYy1sZXNzIHt7bXVzdGFjaGV9fSB0ZW1wbGF0ZXMgd2l0aCBKYXZhU2NyaXB0XG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzXG4gKi9cblxuLypnbG9iYWwgZGVmaW5lOiBmYWxzZSBNdXN0YWNoZTogdHJ1ZSovXG5cbihmdW5jdGlvbiBkZWZpbmVNdXN0YWNoZSAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiB0eXBlb2YgZXhwb3J0cy5ub2RlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMpOyAvLyBDb21tb25KU1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7IC8vIEFNRFxuICB9IGVsc2Uge1xuICAgIGdsb2JhbC5NdXN0YWNoZSA9IHt9O1xuICAgIGZhY3RvcnkoZ2xvYmFsLk11c3RhY2hlKTsgLy8gc2NyaXB0LCB3c2gsIGFzcFxuICB9XG59KHRoaXMsIGZ1bmN0aW9uIG11c3RhY2hlRmFjdG9yeSAobXVzdGFjaGUpIHtcblxuICB2YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheVBvbHlmaWxsIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vcmUgY29ycmVjdCB0eXBlb2Ygc3RyaW5nIGhhbmRsaW5nIGFycmF5XG4gICAqIHdoaWNoIG5vcm1hbGx5IHJldHVybnMgdHlwZW9mICdvYmplY3QnXG4gICAqL1xuICBmdW5jdGlvbiB0eXBlU3RyIChvYmopIHtcbiAgICByZXR1cm4gaXNBcnJheShvYmopID8gJ2FycmF5JyA6IHR5cGVvZiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAgKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOdWxsIHNhZmUgd2F5IG9mIGNoZWNraW5nIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCxcbiAgICogaW5jbHVkaW5nIGl0cyBwcm90b3R5cGUsIGhhcyBhIGdpdmVuIHByb3BlcnR5XG4gICAqL1xuICBmdW5jdGlvbiBoYXNQcm9wZXJ0eSAob2JqLCBwcm9wTmFtZSkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAocHJvcE5hbWUgaW4gb2JqKTtcbiAgfVxuXG4gIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vaXNzdWVzLmFwYWNoZS5vcmcvamlyYS9icm93c2UvQ09VQ0hEQi01NzdcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8xODlcbiAgdmFyIHJlZ0V4cFRlc3QgPSBSZWdFeHAucHJvdG90eXBlLnRlc3Q7XG4gIGZ1bmN0aW9uIHRlc3RSZWdFeHAgKHJlLCBzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVnRXhwVGVzdC5jYWxsKHJlLCBzdHJpbmcpO1xuICB9XG5cbiAgdmFyIG5vblNwYWNlUmUgPSAvXFxTLztcbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChzdHJpbmcpIHtcbiAgICByZXR1cm4gIXRlc3RSZWdFeHAobm9uU3BhY2VSZSwgc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBlbnRpdHlNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxuICAgICcvJzogJyYjeDJGOycsXG4gICAgJ2AnOiAnJiN4NjA7JyxcbiAgICAnPSc6ICcmI3gzRDsnXG4gIH07XG5cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoL1smPD5cIidgPVxcL10vZywgZnVuY3Rpb24gZnJvbUVudGl0eU1hcCAocykge1xuICAgICAgcmV0dXJuIGVudGl0eU1hcFtzXTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB3aGl0ZVJlID0gL1xccyovO1xuICB2YXIgc3BhY2VSZSA9IC9cXHMrLztcbiAgdmFyIGVxdWFsc1JlID0gL1xccyo9LztcbiAgdmFyIGN1cmx5UmUgPSAvXFxzKlxcfS87XG4gIHZhciB0YWdSZSA9IC8jfFxcXnxcXC98PnxcXHt8Jnw9fCEvO1xuXG4gIC8qKlxuICAgKiBCcmVha3MgdXAgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgc3RyaW5nIGludG8gYSB0cmVlIG9mIHRva2Vucy4gSWYgdGhlIGB0YWdzYFxuICAgKiBhcmd1bWVudCBpcyBnaXZlbiBoZXJlIGl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0d28gc3RyaW5nIHZhbHVlczogdGhlXG4gICAqIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFncyB1c2VkIGluIHRoZSB0ZW1wbGF0ZSAoZS5nLiBbIFwiPCVcIiwgXCIlPlwiIF0pLiBPZlxuICAgKiBjb3Vyc2UsIHRoZSBkZWZhdWx0IGlzIHRvIHVzZSBtdXN0YWNoZXMgKGkuZS4gbXVzdGFjaGUudGFncykuXG4gICAqXG4gICAqIEEgdG9rZW4gaXMgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCA0IGVsZW1lbnRzLiBUaGUgZmlyc3QgZWxlbWVudCBpcyB0aGVcbiAgICogbXVzdGFjaGUgc3ltYm9sIHRoYXQgd2FzIHVzZWQgaW5zaWRlIHRoZSB0YWcsIGUuZy4gXCIjXCIgb3IgXCImXCIuIElmIHRoZSB0YWdcbiAgICogZGlkIG5vdCBjb250YWluIGEgc3ltYm9sIChpLmUuIHt7bXlWYWx1ZX19KSB0aGlzIGVsZW1lbnQgaXMgXCJuYW1lXCIuIEZvclxuICAgKiBhbGwgdGV4dCB0aGF0IGFwcGVhcnMgb3V0c2lkZSBhIHN5bWJvbCB0aGlzIGVsZW1lbnQgaXMgXCJ0ZXh0XCIuXG4gICAqXG4gICAqIFRoZSBzZWNvbmQgZWxlbWVudCBvZiBhIHRva2VuIGlzIGl0cyBcInZhbHVlXCIuIEZvciBtdXN0YWNoZSB0YWdzIHRoaXMgaXNcbiAgICogd2hhdGV2ZXIgZWxzZSB3YXMgaW5zaWRlIHRoZSB0YWcgYmVzaWRlcyB0aGUgb3BlbmluZyBzeW1ib2wuIEZvciB0ZXh0IHRva2Vuc1xuICAgKiB0aGlzIGlzIHRoZSB0ZXh0IGl0c2VsZi5cbiAgICpcbiAgICogVGhlIHRoaXJkIGFuZCBmb3VydGggZWxlbWVudHMgb2YgdGhlIHRva2VuIGFyZSB0aGUgc3RhcnQgYW5kIGVuZCBpbmRpY2VzLFxuICAgKiByZXNwZWN0aXZlbHksIG9mIHRoZSB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUuXG4gICAqXG4gICAqIFRva2VucyB0aGF0IGFyZSB0aGUgcm9vdCBub2RlIG9mIGEgc3VidHJlZSBjb250YWluIHR3byBtb3JlIGVsZW1lbnRzOiAxKSBhblxuICAgKiBhcnJheSBvZiB0b2tlbnMgaW4gdGhlIHN1YnRyZWUgYW5kIDIpIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgYXRcbiAgICogd2hpY2ggdGhlIGNsb3NpbmcgdGFnIGZvciB0aGF0IHNlY3Rpb24gYmVnaW5zLlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICBpZiAoIXRlbXBsYXRlKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgdmFyIHNlY3Rpb25zID0gW107ICAgICAvLyBTdGFjayB0byBob2xkIHNlY3Rpb24gdG9rZW5zXG4gICAgdmFyIHRva2VucyA9IFtdOyAgICAgICAvLyBCdWZmZXIgdG8gaG9sZCB0aGUgdG9rZW5zXG4gICAgdmFyIHNwYWNlcyA9IFtdOyAgICAgICAvLyBJbmRpY2VzIG9mIHdoaXRlc3BhY2UgdG9rZW5zIG9uIHRoZSBjdXJyZW50IGxpbmVcbiAgICB2YXIgaGFzVGFnID0gZmFsc2U7ICAgIC8vIElzIHRoZXJlIGEge3t0YWd9fSBvbiB0aGUgY3VycmVudCBsaW5lP1xuICAgIHZhciBub25TcGFjZSA9IGZhbHNlOyAgLy8gSXMgdGhlcmUgYSBub24tc3BhY2UgY2hhciBvbiB0aGUgY3VycmVudCBsaW5lP1xuXG4gICAgLy8gU3RyaXBzIGFsbCB3aGl0ZXNwYWNlIHRva2VucyBhcnJheSBmb3IgdGhlIGN1cnJlbnQgbGluZVxuICAgIC8vIGlmIHRoZXJlIHdhcyBhIHt7I3RhZ319IG9uIGl0IGFuZCBvdGhlcndpc2Ugb25seSBzcGFjZS5cbiAgICBmdW5jdGlvbiBzdHJpcFNwYWNlICgpIHtcbiAgICAgIGlmIChoYXNUYWcgJiYgIW5vblNwYWNlKSB7XG4gICAgICAgIHdoaWxlIChzcGFjZXMubGVuZ3RoKVxuICAgICAgICAgIGRlbGV0ZSB0b2tlbnNbc3BhY2VzLnBvcCgpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwYWNlcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBoYXNUYWcgPSBmYWxzZTtcbiAgICAgIG5vblNwYWNlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG9wZW5pbmdUYWdSZSwgY2xvc2luZ1RhZ1JlLCBjbG9zaW5nQ3VybHlSZTtcbiAgICBmdW5jdGlvbiBjb21waWxlVGFncyAodGFnc1RvQ29tcGlsZSkge1xuICAgICAgaWYgKHR5cGVvZiB0YWdzVG9Db21waWxlID09PSAnc3RyaW5nJylcbiAgICAgICAgdGFnc1RvQ29tcGlsZSA9IHRhZ3NUb0NvbXBpbGUuc3BsaXQoc3BhY2VSZSwgMik7XG5cbiAgICAgIGlmICghaXNBcnJheSh0YWdzVG9Db21waWxlKSB8fCB0YWdzVG9Db21waWxlLmxlbmd0aCAhPT0gMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhZ3M6ICcgKyB0YWdzVG9Db21waWxlKTtcblxuICAgICAgb3BlbmluZ1RhZ1JlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAodGFnc1RvQ29tcGlsZVswXSkgKyAnXFxcXHMqJyk7XG4gICAgICBjbG9zaW5nVGFnUmUgPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMV0pKTtcbiAgICAgIGNsb3NpbmdDdXJseVJlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCgnfScgKyB0YWdzVG9Db21waWxlWzFdKSk7XG4gICAgfVxuXG4gICAgY29tcGlsZVRhZ3ModGFncyB8fCBtdXN0YWNoZS50YWdzKTtcblxuICAgIHZhciBzY2FubmVyID0gbmV3IFNjYW5uZXIodGVtcGxhdGUpO1xuXG4gICAgdmFyIHN0YXJ0LCB0eXBlLCB2YWx1ZSwgY2hyLCB0b2tlbiwgb3BlblNlY3Rpb247XG4gICAgd2hpbGUgKCFzY2FubmVyLmVvcygpKSB7XG4gICAgICBzdGFydCA9IHNjYW5uZXIucG9zO1xuXG4gICAgICAvLyBNYXRjaCBhbnkgdGV4dCBiZXR3ZWVuIHRhZ3MuXG4gICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKG9wZW5pbmdUYWdSZSk7XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGkgPCB2YWx1ZUxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2hyID0gdmFsdWUuY2hhckF0KGkpO1xuXG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjaHIpKSB7XG4gICAgICAgICAgICBzcGFjZXMucHVzaCh0b2tlbnMubGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9uU3BhY2UgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2Vucy5wdXNoKFsgJ3RleHQnLCBjaHIsIHN0YXJ0LCBzdGFydCArIDEgXSk7XG4gICAgICAgICAgc3RhcnQgKz0gMTtcblxuICAgICAgICAgIC8vIENoZWNrIGZvciB3aGl0ZXNwYWNlIG9uIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAgICAgaWYgKGNociA9PT0gJ1xcbicpXG4gICAgICAgICAgICBzdHJpcFNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTWF0Y2ggdGhlIG9wZW5pbmcgdGFnLlxuICAgICAgaWYgKCFzY2FubmVyLnNjYW4ob3BlbmluZ1RhZ1JlKSlcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGhhc1RhZyA9IHRydWU7XG5cbiAgICAgIC8vIEdldCB0aGUgdGFnIHR5cGUuXG4gICAgICB0eXBlID0gc2Nhbm5lci5zY2FuKHRhZ1JlKSB8fCAnbmFtZSc7XG4gICAgICBzY2FubmVyLnNjYW4od2hpdGVSZSk7XG5cbiAgICAgIC8vIEdldCB0aGUgdGFnIHZhbHVlLlxuICAgICAgaWYgKHR5cGUgPT09ICc9Jykge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGVxdWFsc1JlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuKGVxdWFsc1JlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3snKSB7XG4gICAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ0N1cmx5UmUpO1xuICAgICAgICBzY2FubmVyLnNjYW4oY3VybHlSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICAgIHR5cGUgPSAnJic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hdGNoIHRoZSBjbG9zaW5nIHRhZy5cbiAgICAgIGlmICghc2Nhbm5lci5zY2FuKGNsb3NpbmdUYWdSZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgdGFnIGF0ICcgKyBzY2FubmVyLnBvcyk7XG5cbiAgICAgIHRva2VuID0gWyB0eXBlLCB2YWx1ZSwgc3RhcnQsIHNjYW5uZXIucG9zIF07XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cbiAgICAgIGlmICh0eXBlID09PSAnIycgfHwgdHlwZSA9PT0gJ14nKSB7XG4gICAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnLycpIHtcbiAgICAgICAgLy8gQ2hlY2sgc2VjdGlvbiBuZXN0aW5nLlxuICAgICAgICBvcGVuU2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuXG4gICAgICAgIGlmICghb3BlblNlY3Rpb24pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbm9wZW5lZCBzZWN0aW9uIFwiJyArIHZhbHVlICsgJ1wiIGF0ICcgKyBzdGFydCk7XG5cbiAgICAgICAgaWYgKG9wZW5TZWN0aW9uWzFdICE9PSB2YWx1ZSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25hbWUnIHx8IHR5cGUgPT09ICd7JyB8fCB0eXBlID09PSAnJicpIHtcbiAgICAgICAgbm9uU3BhY2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgICAgLy8gU2V0IHRoZSB0YWdzIGZvciB0aGUgbmV4dCB0aW1lIGFyb3VuZC5cbiAgICAgICAgY29tcGlsZVRhZ3ModmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gb3BlbiBzZWN0aW9ucyB3aGVuIHdlJ3JlIGRvbmUuXG4gICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICAgIGlmIChvcGVuU2VjdGlvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgc2VjdGlvbiBcIicgKyBvcGVuU2VjdGlvblsxXSArICdcIiBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gICAgcmV0dXJuIG5lc3RUb2tlbnMoc3F1YXNoVG9rZW5zKHRva2VucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmVzIHRoZSB2YWx1ZXMgb2YgY29uc2VjdXRpdmUgdGV4dCB0b2tlbnMgaW4gdGhlIGdpdmVuIGB0b2tlbnNgIGFycmF5XG4gICAqIHRvIGEgc2luZ2xlIHRva2VuLlxuICAgKi9cbiAgZnVuY3Rpb24gc3F1YXNoVG9rZW5zICh0b2tlbnMpIHtcbiAgICB2YXIgc3F1YXNoZWRUb2tlbnMgPSBbXTtcblxuICAgIHZhciB0b2tlbiwgbGFzdFRva2VuO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuWzBdID09PSAndGV4dCcgJiYgbGFzdFRva2VuICYmIGxhc3RUb2tlblswXSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuWzFdICs9IHRva2VuWzFdO1xuICAgICAgICAgIGxhc3RUb2tlblszXSA9IHRva2VuWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNxdWFzaGVkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNxdWFzaGVkVG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1zIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCBpbnRvIGEgbmVzdGVkIHRyZWUgc3RydWN0dXJlIHdoZXJlXG4gICAqIHRva2VucyB0aGF0IHJlcHJlc2VudCBhIHNlY3Rpb24gaGF2ZSB0d28gYWRkaXRpb25hbCBpdGVtczogMSkgYW4gYXJyYXkgb2ZcbiAgICogYWxsIHRva2VucyB0aGF0IGFwcGVhciBpbiB0aGF0IHNlY3Rpb24gYW5kIDIpIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWxcbiAgICogdGVtcGxhdGUgdGhhdCByZXByZXNlbnRzIHRoZSBlbmQgb2YgdGhhdCBzZWN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gbmVzdFRva2VucyAodG9rZW5zKSB7XG4gICAgdmFyIG5lc3RlZFRva2VucyA9IFtdO1xuICAgIHZhciBjb2xsZWN0b3IgPSBuZXN0ZWRUb2tlbnM7XG4gICAgdmFyIHNlY3Rpb25zID0gW107XG5cbiAgICB2YXIgdG9rZW4sIHNlY3Rpb247XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb2xsZWN0b3IgPSB0b2tlbls0XSA9IFtdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICBzZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG4gICAgICAgICAgc2VjdGlvbls1XSA9IHRva2VuWzJdO1xuICAgICAgICAgIGNvbGxlY3RvciA9IHNlY3Rpb25zLmxlbmd0aCA+IDAgPyBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXVs0XSA6IG5lc3RlZFRva2VucztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lc3RlZFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNpbXBsZSBzdHJpbmcgc2Nhbm5lciB0aGF0IGlzIHVzZWQgYnkgdGhlIHRlbXBsYXRlIHBhcnNlciB0byBmaW5kXG4gICAqIHRva2VucyBpbiB0ZW1wbGF0ZSBzdHJpbmdzLlxuICAgKi9cbiAgZnVuY3Rpb24gU2Nhbm5lciAoc3RyaW5nKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy50YWlsID0gc3RyaW5nO1xuICAgIHRoaXMucG9zID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGFpbCBpcyBlbXB0eSAoZW5kIG9mIHN0cmluZykuXG4gICAqL1xuICBTY2FubmVyLnByb3RvdHlwZS5lb3MgPSBmdW5jdGlvbiBlb3MgKCkge1xuICAgIHJldHVybiB0aGlzLnRhaWwgPT09ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmllcyB0byBtYXRjaCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgKiBSZXR1cm5zIHRoZSBtYXRjaGVkIHRleHQgaWYgaXQgY2FuIG1hdGNoLCB0aGUgZW1wdHkgc3RyaW5nIG90aGVyd2lzZS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLnNjYW4gPSBmdW5jdGlvbiBzY2FuIChyZSkge1xuICAgIHZhciBtYXRjaCA9IHRoaXMudGFpbC5tYXRjaChyZSk7XG5cbiAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICE9PSAwKVxuICAgICAgcmV0dXJuICcnO1xuXG4gICAgdmFyIHN0cmluZyA9IG1hdGNoWzBdO1xuXG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKTtcbiAgICB0aGlzLnBvcyArPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcblxuICAvKipcbiAgICogU2tpcHMgYWxsIHRleHQgdW50aWwgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBjYW4gYmUgbWF0Y2hlZC4gUmV0dXJuc1xuICAgKiB0aGUgc2tpcHBlZCBzdHJpbmcsIHdoaWNoIGlzIHRoZSBlbnRpcmUgdGFpbCBpZiBubyBtYXRjaCBjYW4gYmUgbWFkZS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLnNjYW5VbnRpbCA9IGZ1bmN0aW9uIHNjYW5VbnRpbCAocmUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnRhaWwuc2VhcmNoKHJlKSwgbWF0Y2g7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICBtYXRjaCA9IHRoaXMudGFpbDtcbiAgICAgICAgdGhpcy50YWlsID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICBtYXRjaCA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG1hdGNoID0gdGhpcy50YWlsLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIH1cblxuICAgIHRoaXMucG9zICs9IG1hdGNoLmxlbmd0aDtcblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHJlbmRlcmluZyBjb250ZXh0IGJ5IHdyYXBwaW5nIGEgdmlldyBvYmplY3QgYW5kXG4gICAqIG1haW50YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIENvbnRleHQgKHZpZXcsIHBhcmVudENvbnRleHQpIHtcbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIHRoaXMuY2FjaGUgPSB7ICcuJzogdGhpcy52aWV3IH07XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29udGV4dCB1c2luZyB0aGUgZ2l2ZW4gdmlldyB3aXRoIHRoaXMgY29udGV4dFxuICAgKiBhcyB0aGUgcGFyZW50LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKHZpZXcpIHtcbiAgICByZXR1cm4gbmV3IENvbnRleHQodmlldywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoaXMgY29udGV4dCwgdHJhdmVyc2luZ1xuICAgKiB1cCB0aGUgY29udGV4dCBoaWVyYXJjaHkgaWYgdGhlIHZhbHVlIGlzIGFic2VudCBpbiB0aGlzIGNvbnRleHQncyB2aWV3LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gbG9va3VwIChuYW1lKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcblxuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHZhbHVlID0gY2FjaGVbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgbmFtZXMsIGluZGV4LCBsb29rdXBIaXQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignLicpID4gMCkge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dC52aWV3O1xuICAgICAgICAgIG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgIGluZGV4ID0gMDtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzaW5nIHRoZSBkb3Qgbm90aW9uIHBhdGggaW4gYG5hbWVgLCB3ZSBkZXNjZW5kIHRocm91Z2ggdGhlXG4gICAgICAgICAgICogbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUbyBiZSBjZXJ0YWluIHRoYXQgdGhlIGxvb2t1cCBoYXMgYmVlbiBzdWNjZXNzZnVsLCB3ZSBoYXZlIHRvXG4gICAgICAgICAgICogY2hlY2sgaWYgdGhlIGxhc3Qgb2JqZWN0IGluIHRoZSBwYXRoIGFjdHVhbGx5IGhhcyB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgKiB3ZSBhcmUgbG9va2luZyBmb3IuIFdlIHN0b3JlIHRoZSByZXN1bHQgaW4gYGxvb2t1cEhpdGAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGlzIGlzIHNwZWNpYWxseSBuZWNlc3NhcnkgZm9yIHdoZW4gdGhlIHZhbHVlIGhhcyBiZWVuIHNldCB0b1xuICAgICAgICAgICAqIGB1bmRlZmluZWRgIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGxvb2tpbmcgdXAgcGFyZW50IGNvbnRleHRzLlxuICAgICAgICAgICAqKi9cbiAgICAgICAgICB3aGlsZSAodmFsdWUgIT0gbnVsbCAmJiBpbmRleCA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBuYW1lcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICBsb29rdXBIaXQgPSBoYXNQcm9wZXJ0eSh2YWx1ZSwgbmFtZXNbaW5kZXhdKTtcblxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtuYW1lc1tpbmRleCsrXV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dC52aWV3W25hbWVdO1xuICAgICAgICAgIGxvb2t1cEhpdCA9IGhhc1Byb3BlcnR5KGNvbnRleHQudmlldywgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va3VwSGl0KVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgY2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpXG4gICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwodGhpcy52aWV3KTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQSBXcml0ZXIga25vd3MgaG93IHRvIHRha2UgYSBzdHJlYW0gb2YgdG9rZW5zIGFuZCByZW5kZXIgdGhlbSB0byBhXG4gICAqIHN0cmluZywgZ2l2ZW4gYSBjb250ZXh0LiBJdCBhbHNvIG1haW50YWlucyBhIGNhY2hlIG9mIHRlbXBsYXRlcyB0b1xuICAgKiBhdm9pZCB0aGUgbmVlZCB0byBwYXJzZSB0aGUgc2FtZSB0ZW1wbGF0ZSB0d2ljZS5cbiAgICovXG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGlzIHdyaXRlci5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHRva2Vuc1xuICAgKiB0aGF0IGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBwYXJzZS5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgIHZhciB0b2tlbnMgPSBjYWNoZVt0ZW1wbGF0ZV07XG5cbiAgICBpZiAodG9rZW5zID09IG51bGwpXG4gICAgICB0b2tlbnMgPSBjYWNoZVt0ZW1wbGF0ZV0gPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0YWdzKTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZ2gtbGV2ZWwgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgd2l0aFxuICAgKiB0aGUgZ2l2ZW4gYHZpZXdgLlxuICAgKlxuICAgKiBUaGUgb3B0aW9uYWwgYHBhcnRpYWxzYCBhcmd1bWVudCBtYXkgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlXG4gICAqIG5hbWVzIGFuZCB0ZW1wbGF0ZXMgb2YgcGFydGlhbHMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGVtcGxhdGUuIEl0IG1heVxuICAgKiBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGxvYWQgcGFydGlhbCB0ZW1wbGF0ZXMgb24gdGhlIGZseVxuICAgKiB0aGF0IHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50OiB0aGUgbmFtZSBvZiB0aGUgcGFydGlhbC5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpIHtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgdmFyIGNvbnRleHQgPSAodmlldyBpbnN0YW5jZW9mIENvbnRleHQpID8gdmlldyA6IG5ldyBDb250ZXh0KHZpZXcpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCB0ZW1wbGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvdy1sZXZlbCBtZXRob2QgdGhhdCByZW5kZXJzIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCB1c2luZ1xuICAgKiB0aGUgZ2l2ZW4gYGNvbnRleHRgIGFuZCBgcGFydGlhbHNgLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgYG9yaWdpbmFsVGVtcGxhdGVgIGlzIG9ubHkgZXZlciB1c2VkIHRvIGV4dHJhY3QgdGhlIHBvcnRpb25cbiAgICogb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgd2FzIGNvbnRhaW5lZCBpbiBhIGhpZ2hlci1vcmRlciBzZWN0aW9uLlxuICAgKiBJZiB0aGUgdGVtcGxhdGUgZG9lc24ndCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLCB0aGlzIGFyZ3VtZW50IG1heVxuICAgKiBiZSBvbWl0dGVkLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbnMgPSBmdW5jdGlvbiByZW5kZXJUb2tlbnMgKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgYnVmZmVyID0gJyc7XG5cbiAgICB2YXIgdG9rZW4sIHN5bWJvbCwgdmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIHN5bWJvbCA9IHRva2VuWzBdO1xuXG4gICAgICBpZiAoc3ltYm9sID09PSAnIycpIHZhbHVlID0gdGhpcy5yZW5kZXJTZWN0aW9uKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICdeJykgdmFsdWUgPSB0aGlzLnJlbmRlckludmVydGVkKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICc+JykgdmFsdWUgPSB0aGlzLnJlbmRlclBhcnRpYWwodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJyYnKSB2YWx1ZSA9IHRoaXMudW5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnbmFtZScpIHZhbHVlID0gdGhpcy5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAndGV4dCcpIHZhbHVlID0gdGhpcy5yYXdWYWx1ZSh0b2tlbik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBidWZmZXIgKz0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiByZW5kZXJTZWN0aW9uICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZW5kZXIgYW4gYXJiaXRyYXJ5IHRlbXBsYXRlXG4gICAgLy8gaW4gdGhlIGN1cnJlbnQgY29udGV4dCBieSBoaWdoZXItb3JkZXIgc2VjdGlvbnMuXG4gICAgZnVuY3Rpb24gc3ViUmVuZGVyICh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHNlbGYucmVuZGVyKHRlbXBsYXRlLCBjb250ZXh0LCBwYXJ0aWFscyk7XG4gICAgfVxuXG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGogPCB2YWx1ZUxlbmd0aDsgKytqKSB7XG4gICAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlW2pdKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUZW1wbGF0ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMgd2l0aG91dCB0aGUgb3JpZ2luYWwgdGVtcGxhdGUnKTtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgcG9ydGlvbiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB0aGUgc2VjdGlvbiBjb250YWlucy5cbiAgICAgIHZhbHVlID0gdmFsdWUuY2FsbChjb250ZXh0LnZpZXcsIG9yaWdpbmFsVGVtcGxhdGUuc2xpY2UodG9rZW5bM10sIHRva2VuWzVdKSwgc3ViUmVuZGVyKTtcblxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJJbnZlcnRlZCA9IGZ1bmN0aW9uIHJlbmRlckludmVydGVkICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgICAvLyBVc2UgSmF2YVNjcmlwdCdzIGRlZmluaXRpb24gb2YgZmFsc3kuIEluY2x1ZGUgZW1wdHkgYXJyYXlzLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg2XG4gICAgaWYgKCF2YWx1ZSB8fCAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSlcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyUGFydGlhbCA9IGZ1bmN0aW9uIHJlbmRlclBhcnRpYWwgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscykge1xuICAgIGlmICghcGFydGlhbHMpIHJldHVybjtcblxuICAgIHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24ocGFydGlhbHMpID8gcGFydGlhbHModG9rZW5bMV0pIDogcGFydGlhbHNbdG9rZW5bMV1dO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRoaXMucGFyc2UodmFsdWUpLCBjb250ZXh0LCBwYXJ0aWFscywgdmFsdWUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUudW5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiB1bmVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiBlc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIG11c3RhY2hlLmVzY2FwZSh2YWx1ZSk7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yYXdWYWx1ZSA9IGZ1bmN0aW9uIHJhd1ZhbHVlICh0b2tlbikge1xuICAgIHJldHVybiB0b2tlblsxXTtcbiAgfTtcblxuICBtdXN0YWNoZS5uYW1lID0gJ211c3RhY2hlLmpzJztcbiAgbXVzdGFjaGUudmVyc2lvbiA9ICcyLjIuMSc7XG4gIG11c3RhY2hlLnRhZ3MgPSBbICd7eycsICd9fScgXTtcblxuICAvLyBBbGwgaGlnaC1sZXZlbCBtdXN0YWNoZS4qIGZ1bmN0aW9ucyB1c2UgdGhpcyB3cml0ZXIuXG4gIHZhciBkZWZhdWx0V3JpdGVyID0gbmV3IFdyaXRlcigpO1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhlIGRlZmF1bHQgd3JpdGVyLlxuICAgKi9cbiAgbXVzdGFjaGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLmNsZWFyQ2FjaGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIHRlbXBsYXRlIGluIHRoZSBkZWZhdWx0IHdyaXRlciBhbmQgcmV0dXJucyB0aGVcbiAgICogYXJyYXkgb2YgdG9rZW5zIGl0IGNvbnRhaW5zLiBEb2luZyB0aGlzIGFoZWFkIG9mIHRpbWUgYXZvaWRzIHRoZSBuZWVkIHRvXG4gICAqIHBhcnNlIHRlbXBsYXRlcyBvbiB0aGUgZmx5IGFzIHRoZXkgYXJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVzdGFjaGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGB0ZW1wbGF0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHZpZXdgIGFuZCBgcGFydGlhbHNgIHVzaW5nIHRoZVxuICAgKiBkZWZhdWx0IHdyaXRlci5cbiAgICovXG4gIG11c3RhY2hlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGVtcGxhdGUhIFRlbXBsYXRlIHNob3VsZCBiZSBhIFwic3RyaW5nXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdidXQgXCInICsgdHlwZVN0cih0ZW1wbGF0ZSkgKyAnXCIgd2FzIGdpdmVuIGFzIHRoZSBmaXJzdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50IGZvciBtdXN0YWNoZSNyZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKScpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLnJlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjQueC4sXG4gIC8qZXNsaW50LWRpc2FibGUgKi8gLy8gZXNsaW50IHdhbnRzIGNhbWVsIGNhc2VkIGZ1bmN0aW9uIG5hbWVcbiAgbXVzdGFjaGUudG9faHRtbCA9IGZ1bmN0aW9uIHRvX2h0bWwgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgc2VuZCkge1xuICAgIC8qZXNsaW50LWVuYWJsZSovXG5cbiAgICB2YXIgcmVzdWx0ID0gbXVzdGFjaGUucmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihzZW5kKSkge1xuICAgICAgc2VuZChyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIGVzY2FwaW5nIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIHVzZXIgbWF5IG92ZXJyaWRlIGl0LlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzI0NFxuICBtdXN0YWNoZS5lc2NhcGUgPSBlc2NhcGVIdG1sO1xuXG4gIC8vIEV4cG9ydCB0aGVzZSBtYWlubHkgZm9yIHRlc3RpbmcsIGJ1dCBhbHNvIGZvciBhZHZhbmNlZCB1c2FnZS5cbiAgbXVzdGFjaGUuU2Nhbm5lciA9IFNjYW5uZXI7XG4gIG11c3RhY2hlLkNvbnRleHQgPSBDb250ZXh0O1xuICBtdXN0YWNoZS5Xcml0ZXIgPSBXcml0ZXI7XG5cbn0pKTtcbiIsIi8qIG9iamVjdC1pdGVyYXRvcnMuanMgLSBNaW5pIFVuZGVyc2NvcmUgbGlicmFyeVxuICogYnkgSm9uYXRoYW4gRWl0ZW5cbiAqXG4gKiBUaGUgbWV0aG9kcyBiZWxvdyBvcGVyYXRlIG9uIG9iamVjdHMgKGJ1dCBub3QgYXJyYXlzKSBzaW1pbGFybHlcbiAqIHRvIFVuZGVyc2NvcmUgKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNjb2xsZWN0aW9ucykuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L29iamVjdC1pdGVyYXRvcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3VtbWFyeSBXcmFwIGFuIG9iamVjdCBmb3Igb25lIG1ldGhvZCBjYWxsLlxuICogQERlc2MgTm90ZSB0aGF0IHRoZSBgbmV3YCBrZXl3b3JkIGlzIG5vdCBuZWNlc3NhcnkuXG4gKiBAcGFyYW0ge29iamVjdHxudWxsfHVuZGVmaW5lZH0gb2JqZWN0IC0gYG51bGxgIG9yIGB1bmRlZmluZWRgIGlzIHRyZWF0ZWQgYXMgYW4gZW1wdHkgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybiB7V3JhcHBlcn0gVGhlIHdyYXBwZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBXcmFwcGVyKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcmFwcGVyKSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyYXBwZXIob2JqZWN0KTtcbiAgICB9XG4gICAgdGhpcy5vcmlnaW5hbFZhbHVlID0gb2JqZWN0O1xuICAgIHRoaXMubyA9IG9iamVjdCB8fCB7fTtcbn1cblxuLyoqXG4gKiBAbmFtZSBXcmFwcGVyLmNoYWluXG4gKiBAc3VtbWFyeSBXcmFwIGFuIG9iamVjdCBmb3IgYSBjaGFpbiBvZiBtZXRob2QgY2FsbHMuXG4gKiBARGVzYyBDYWxscyB0aGUgY29uc3RydWN0b3IgYFdyYXBwZXIoKWAgYW5kIG1vZGlmaWVzIHRoZSB3cmFwcGVyIGZvciBjaGFpbmluZy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge1dyYXBwZXJ9IFRoZSB3cmFwcGVkIG9iamVjdC5cbiAqL1xuV3JhcHBlci5jaGFpbiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgd3JhcHBlZCA9IFdyYXBwZXIob2JqZWN0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgd3JhcHBlZC5jaGFpbmluZyA9IHRydWU7XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG59O1xuXG5XcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBVbndyYXAgYW4gb2JqZWN0IHdyYXBwZWQgd2l0aCB7QGxpbmsgV3JhcHBlci5jaGFpbnxXcmFwcGVyLmNoYWluKCl9LlxuICAgICAqIEByZXR1cm4ge29iamVjdHxudWxsfHVuZGVmaW5lZH0gVGhlIHZhbHVlIG9yaWdpbmFsbHkgd3JhcHBlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbZWFjaF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI2VhY2gpIG1ldGhvZDogSXRlcmF0ZSBvdmVyIHRoZSBtZW1iZXJzIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgY2FsbGluZyBgaXRlcmF0ZWUoKWAgd2l0aCBlYWNoLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IGAodmFsdWUsIGtleSwgb2JqZWN0KWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBpcyB1bmRlZmluZWQ7IGFuIGAuZWFjaGAgbG9vcCBjYW5ub3QgYmUgYnJva2VuIG91dCBvZiAodXNlIHtAbGluayBXcmFwcGVyI2ZpbmR8LmZpbmR9IGluc3RlYWQpLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYGl0ZXJhdGVlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHtXcmFwcGVyfSBUaGUgd3JhcHBlZCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uIChpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubztcbiAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpdGVyYXRlZS5jYWxsKHRoaXMsIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgfSwgY29udGV4dCB8fCBvKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW2ZpbmRdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNmaW5kKSBtZXRob2Q6IExvb2sgdGhyb3VnaCBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHJldHVybmluZyB0aGUgZmlyc3Qgb25lIHRoYXQgcGFzc2VzIGEgdHJ1dGggdGVzdCAoYHByZWRpY2F0ZWApLCBvciBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBwYXNzZXMgdGhlIHRlc3QuIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgYWNjZXB0YWJsZSBtZW1iZXIsIGFuZCBkb2Vzbid0IG5lY2Vzc2FyaWx5IHRyYXZlcnNlIHRoZSBlbnRpcmUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBgKHZhbHVlLCBrZXksIG9iamVjdClgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHRydXRoeSBpZiB0aGUgbWVtYmVyIHBhc3NlcyB0aGUgdGVzdCBhbmQgZmFsc3kgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYHByZWRpY2F0ZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBwcmVkaWNhdGVgLiAoT3RoZXJ3aXNlLCB0aGUgYHRoaXNgIHZhbHVlIHdpbGwgYmUgdGhlIHVud3JhcHBlZCBvYmplY3QuKVxuICAgICAqIEByZXR1cm4geyp9IFRoZSBmb3VuZCBwcm9wZXJ0eSdzIHZhbHVlLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGZpbmQ6IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBPYmplY3Qua2V5cyhvKS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLmNhbGwodGhpcywgb1trZXldLCBrZXksIG8pO1xuICAgICAgICAgICAgfSwgY29udGV4dCB8fCBvKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9bcmVzdWx0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtmaWx0ZXJdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNmaWx0ZXIpIG1ldGhvZDogTG9vayB0aHJvdWdoIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgcmV0dXJuaW5nIHRoZSB2YWx1ZXMgb2YgYWxsIG1lbWJlcnMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdCAoYHByZWRpY2F0ZWApLCBvciBlbXB0eSBhcnJheSBpZiBubyB2YWx1ZSBwYXNzZXMgdGhlIHRlc3QuIFRoZSBmdW5jdGlvbiBhbHdheXMgdHJhdmVyc2VzIHRoZSBlbnRpcmUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBgKHZhbHVlLCBrZXksIG9iamVjdClgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHRydXRoeSBpZiB0aGUgbWVtYmVyIHBhc3NlcyB0aGUgdGVzdCBhbmQgZmFsc3kgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYHByZWRpY2F0ZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBwcmVkaWNhdGVgLiAoT3RoZXJ3aXNlLCB0aGUgYHRoaXNgIHZhbHVlIHdpbGwgYmUgdGhlIHVud3JhcHBlZCBvYmplY3QuKVxuICAgICAqIEByZXR1cm4geyp9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzLCBvW2tleV0sIGtleSwgbykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjb250ZXh0IHx8IG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW21hcF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI21hcCkgbWV0aG9kOiBQcm9kdWNlcyBhIG5ldyBhcnJheSBvZiB2YWx1ZXMgYnkgbWFwcGluZyBlYWNoIHZhbHVlIGluIGxpc3QgdGhyb3VnaCBhIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIChgaXRlcmF0ZWVgKS4gVGhlIGZ1bmN0aW9uIGFsd2F5cyB0cmF2ZXJzZXMgdGhlIGVudGlyZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBGb3IgZWFjaCBtZW1iZXIgb2YgdGhlIHdyYXBwZWQgb2JqZWN0LCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogYCh2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGNvbmNhdGVuYXRlZCB0byB0aGUgZW5kIG9mIHRoZSBuZXcgYXJyYXkuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIElmIGdpdmVuLCBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIHRoaXMgb2JqZWN0LiBJbiBvdGhlciB3b3JkcywgdGhpcyBvYmplY3QgYmVjb21lcyB0aGUgYHRoaXNgIHZhbHVlIGluIHRoZSBjYWxscyB0byBgcHJlZGljYXRlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgbWFwOiBmdW5jdGlvbiAoaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZXJhdGVlLmNhbGwodGhpcywgb1trZXldLCBrZXksIG8pKTtcbiAgICAgICAgICAgIH0sIGNvbnRleHQgfHwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbcmVkdWNlXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jcmVkdWNlKSBtZXRob2Q6IEJvaWwgZG93biB0aGUgdmFsdWVzIG9mIGFsbCB0aGUgbWVtYmVycyBvZiB0aGUgd3JhcHBlZCBvYmplY3QgaW50byBhIHNpbmdsZSB2YWx1ZS4gYG1lbW9gIGlzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24sIGFuZCBlYWNoIHN1Y2Nlc3NpdmUgc3RlcCBvZiBpdCBzaG91bGQgYmUgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlKClgLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogYChtZW1vLCB2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgdGhlIG5ldyB2YWx1ZSBvZiBgbWVtb2AgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFttZW1vXSAtIElmIG5vIG1lbW8gaXMgcGFzc2VkIHRvIHRoZSBpbml0aWFsIGludm9jYXRpb24gb2YgcmVkdWNlLCB0aGUgaXRlcmF0ZWUgaXMgbm90IGludm9rZWQgb24gdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3QuIFRoZSBmaXJzdCBlbGVtZW50IGlzIGluc3RlYWQgcGFzc2VkIGFzIHRoZSBtZW1vIGluIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBpdGVyYXRlZSBvbiB0aGUgbmV4dCBlbGVtZW50IGluIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYGl0ZXJhdGVlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgb2YgYG1lbW9gIFwicmVkdWNlZFwiIGFzIHBlciBgaXRlcmF0ZWVgLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlZHVjZTogZnVuY3Rpb24gKGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpZHgpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gKCFpZHggJiYgbWVtbyA9PT0gdW5kZWZpbmVkKSA/IG9ba2V5XSA6IGl0ZXJhdGVlKG1lbW8sIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgICAgIH0sIGNvbnRleHQgfHwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW2V4dGVuZF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI2V4dGVuZCkgbWV0aG9kOiBDb3B5IGFsbCBvZiB0aGUgcHJvcGVydGllcyBpbiBlYWNoIG9mIHRoZSBgc291cmNlYCBvYmplY3QgcGFyYW1ldGVyKHMpIG92ZXIgdG8gdGhlICh3cmFwcGVkKSBkZXN0aW5hdGlvbiBvYmplY3QgKHRodXMgbXV0YXRpbmcgaXQpLiBJdCdzIGluLW9yZGVyLCBzbyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbGFzdCBgc291cmNlYCBvYmplY3Qgd2lsbCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgbmFtZSBpbiBwcmV2aW91cyBhcmd1bWVudHMgb3IgaW4gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiA+IFRoaXMgbWV0aG9kIGNvcGllcyBvd24gbWVtYmVycyBhcyB3ZWxsIGFzIG1lbWJlcnMgaW5oZXJpdGVkIGZyb20gcHJvdG90eXBlIGNoYWluLlxuICAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzb3VyY2UgLSBWYWx1ZXMgb2YgYG51bGxgIG9yIGB1bmRlZmluZWRgIGFyZSB0cmVhdGVkIGFzIGVtcHR5IHBsYWluIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7V3JhcHBlcnxvYmplY3R9IFRoZSB3cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdCBpZiBjaGFpbmluZyBpcyBpbiBlZmZlY3Q7IG90aGVyd2lzZSB0aGUgdW53cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBleHRlbmQ6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbmluZyA/IHRoaXMgOiBvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtleHRlbmRPd25dKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNleHRlbmRPd24pIG1ldGhvZDogTGlrZSB7QGxpbmsgV3JhcHBlciNleHRlbmR8ZXh0ZW5kfSwgYnV0IG9ubHkgY29waWVzIGl0cyBcIm93blwiIHByb3BlcnRpZXMgb3ZlciB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzb3VyY2UgLSBWYWx1ZXMgb2YgYG51bGxgIG9yIGB1bmRlZmluZWRgIGFyZSB0cmVhdGVkIGFzIGVtcHR5IHBsYWluIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7V3JhcHBlcnxvYmplY3R9IFRoZSB3cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdCBpZiBjaGFpbmluZyBpcyBpbiBlZmZlY3Q7IG90aGVyd2lzZSB0aGUgdW53cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBleHRlbmRPd246IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBXcmFwcGVyKG9iamVjdCkuZWFjaChmdW5jdGlvbiAodmFsLCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICAgICAgICAgICAgb1trZXldID0gdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbmluZyA/IHRoaXMgOiBvO1xuICAgIH1cbn07XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmRcbmlmICghQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRlbmQtbmF0aXZlXG4gICAgICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGggPj4+IDA7XG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV3JhcHBlcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUdFWFBfSU5ESVJFQ1RJT04gPSAvXihcXHcrKVxcKChcXHcrKVxcKSQvOyAgLy8gZmluZHMgY29tcGxldGUgcGF0dGVybiBhKGIpIHdoZXJlIGJvdGggYSBhbmQgYiBhcmUgcmVnZXggXCJ3b3Jkc1wiXG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSB2YWx1ZUl0ZW1cbiAqIFlvdSBzaG91bGQgc3VwcGx5IGJvdGggYG5hbWVgIGFuZCBgYWxpYXNgIGJ1dCB5b3UgY291bGQgb21pdCBvbmUgb3IgdGhlIG90aGVyIGFuZCB3aGljaGV2ZXIgeW91IHByb3ZpZGUgd2lsbCBiZSB1c2VkIGZvciBib3RoLlxuICogPiBJZiB5b3Ugb25seSBnaXZlIHRoZSBgbmFtZWAgcHJvcGVydHksIHlvdSBtaWdodCBhcyB3ZWxsIGp1c3QgZ2l2ZSBhIHN0cmluZyBmb3Ige0BsaW5rIG1lbnVJdGVtfSByYXRoZXIgdGhhbiB0aGlzIG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZT1hbGlhc10gLSBWYWx1ZSBvZiBgdmFsdWVgIGF0dHJpYnV0ZSBvZiBgPG9wdGlvbj4uLi48L29wdGlvbj5gIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2FsaWFzPW5hbWVdIC0gVGV4dCBvZiBgPG9wdGlvbj4uLi48L29wdGlvbj5gIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVdIE9uZSBvZiB0aGUga2V5cyBvZiBgdGhpcy5jb252ZXJ0ZXJzYC4gSWYgbm90IG9uZSBvZiB0aGVzZSAoaW5jbHVkaW5nIGB1bmRlZmluZWRgKSwgZmllbGQgdmFsdWVzIHdpbGwgYmUgdGVzdGVkIHdpdGggYSBzdHJpbmcgY29tcGFyaXNvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2hpZGRlbj1mYWxzZV1cbiAqL1xuXG4vKiogQHR5cGVkZWYge29iamVjdHxtZW51SXRlbVtdfSBzdWJtZW51SXRlbVxuICogQHN1bW1hcnkgSGllcmFyY2hpY2FsIGFycmF5IG9mIHNlbGVjdCBsaXN0IGl0ZW1zLlxuICogQGRlc2MgRGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIHRoZSBsaXN0IG9mIGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgYW5kIGA8b3B0Z3JvdXA+Li4uPC9vcHRncm91cD5gIGVsZW1lbnRzIHRoYXQgbWFrZSB1cCBhIGA8c2VsZWN0Pi4uLjwvc2VsZWN0PmAgZWxlbWVudC5cbiAqXG4gKiA+IEFsdGVybmF0ZSBmb3JtOiBJbnN0ZWFkIG9mIGFuIG9iamVjdCB3aXRoIGEgYG1lbnVgIHByb3BlcnR5IGNvbnRhaW5pbmcgYW4gYXJyYXksIG1heSBpdHNlbGYgYmUgdGhhdCBhcnJheS4gQm90aCBmb3JtcyBoYXZlIHRoZSBvcHRpb25hbCBgbGFiZWxgIHByb3BlcnR5LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbF0gLSBEZWZhdWx0cyB0byBhIGdlbmVyYXRlZCBzdHJpbmcgb2YgdGhlIGZvcm0gXCJHcm91cCBuWy5tXS4uLlwiIHdoZXJlIGVhY2ggZGVjaW1hbCBwb3NpdGlvbiByZXByZXNlbnRzIGEgbGV2ZWwgb2YgdGhlIG9wdGdyb3VwIGhpZXJhcmNoeS5cbiAqIEBwcm9wZXJ0eSB7bWVudUl0ZW1bXX0gc3VibWVudVxuICovXG5cbi8qKiBAdHlwZWRlZiB7c3RyaW5nfHZhbHVlSXRlbXxzdWJtZW51SXRlbX0gbWVudUl0ZW1cbiAqIE1heSBiZSBvbmUgb2YgdGhyZWUgcG9zc2libGUgdHlwZXMgdGhhdCBzcGVjaWZ5IGVpdGhlciBhbiBgPG9wdGlvbj4uLi4uPC9vcHRpb24+YCBlbGVtZW50IG9yIGFuIGA8b3B0Z3JvdXA+Li4uLjwvb3B0Z3JvdXA+YCBlbGVtZW50IGFzIGZvbGxvd3M6XG4gKiAqIElmIGEgYHN0cmluZ2AsIHNwZWNpZmllcyB0aGUgdGV4dCBvZiBhbiBgPG9wdGlvbj4uLi4uPC9vcHRpb24+YCBlbGVtZW50IHdpdGggbm8gYHZhbHVlYCBhdHRyaWJ1dGUuIChJbiB0aGUgYWJzZW5jZSBvZiBhIGB2YWx1ZWAgYXR0cmlidXRlLCB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBvZiB0aGUgZWxlbWVudCBkZWZhdWx0cyB0byB0aGUgdGV4dC4pXG4gKiAqIElmIHNoYXBlZCBsaWtlIGEge0BsaW5rIHZhbHVlSXRlbX0gb2JqZWN0LCBzcGVjaWZpZXMgYm90aCB0aGUgdGV4dCBhbmQgdmFsdWUgb2YgYW4gYDxvcHRpb24uLi4uPC9vcHRpb24+YCBlbGVtZW50LlxuICogKiBJZiBzaGFwZWQgbGlrZSBhIHtAbGluayBzdWJtZW51SXRlbX0gb2JqZWN0IChvciBpdHMgYWx0ZXJuYXRlIGFycmF5IGZvcm0pLCBzcGVjaWZpZXMgYW4gYDxvcHRncm91cD4uLi4uPC9vcHRncm91cD5gIGVsZW1lbnQuXG4gKi9cblxuLyoqXG4gKiBAc3VtbWFyeSBCdWlsZHMgYSBuZXcgbWVudSBwcmVwb3B1bGF0ZWQgd2l0aCBpdGVtcyBhbmQgZ3JvdXBzLlxuICogQGRlc2MgVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgbmV3IHBvcC11cCBtZW51IChhLmsuYS4gXCJkcm9wLWRvd25cIikuIFRoaXMgaXMgYSBgPHNlbGVjdD4uLi48L3NlbGVjdD5gIGVsZW1lbnQsIHByZXBvcHVsYXRlZCB3aXRoIGl0ZW1zIChgPG9wdGlvbj4uLi48L29wdGlvbj5gIGVsZW1lbnRzKSBhbmQgZ3JvdXBzIChgPG9wdGdyb3VwPi4uLjwvb3B0Z3JvdXA+YCBlbGVtZW50cykuXG4gKiA+IEJvbnVzOiBUaGlzIGZ1bmN0aW9uIGFsc28gYnVpbGRzIGBpbnB1dCB0eXBlPXRleHRgIGVsZW1lbnRzLlxuICogQG1lbWJlck9mIHBvcE1lbnVcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBlbCAtIE11c3QgYmUgb25lIG9mIChjYXNlLXNlbnNpdGl2ZSk6XG4gKiAqIHRleHQgYm94IC0gYW4gYEhUTUxJbnB1dEVsZW1lbnRgIHRvIHVzZSBhbiBleGlzdGluZyBlbGVtZW50IG9yIGAnSU5QVVQnYCB0byBjcmVhdGUgYSBuZXcgb25lXG4gKiAqIGRyb3AtZG93biAtIGFuIGBIVE1MU2VsZWN0RWxlbWVudGAgdG8gdXNlIGFuIGV4aXN0aW5nIGVsZW1lbnQgb3IgYCdTRUxFQ1QnYCB0byBjcmVhdGUgYSBuZXcgb25lXG4gKiAqIHN1Ym1lbnUgLSBhbiBgSFRNTE9wdEdyb3VwRWxlbWVudGAgdG8gdXNlIGFuIGV4aXN0aW5nIGVsZW1lbnQgb3IgYCdPUFRHUk9VUCdgIHRvIGNyZWF0ZSBhIG5ldyBvbmUgKG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seSlcbiAqXG4gKiBAcGFyYW0ge21lbnVJdGVtW119IFttZW51XSAtIEhpZXJhcmNoaWNhbCBsaXN0IG9mIHN0cmluZ3MgdG8gYWRkIGFzIGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgb3IgYDxvcHRncm91cD4uLi4uPC9vcHRncm91cD5gIGVsZW1lbnRzLiBPbWl0dGluZyBjcmVhdGVzIGEgdGV4dCBib3guXG4gKlxuICogQHBhcmFtIHtudWxsfHN0cmluZ30gW29wdGlvbnMucHJvbXB0PScnXSAtIEFkZHMgYW4gaW5pdGlhbCBgPG9wdGlvbj4uLi48L29wdGlvbj5gIGVsZW1lbnQgdG8gdGhlIGRyb3AtZG93biB3aXRoIHRoaXMgdmFsdWUgaW4gcGFyZW50aGVzZXMgYXMgaXRzIGB0ZXh0YDsgYW5kIGVtcHR5IHN0cmluZyBhcyBpdHMgYHZhbHVlYC4gRGVmYXVsdCBpcyBlbXB0eSBzdHJpbmcsIHdoaWNoIGNyZWF0ZXMgYSBibGFuayBwcm9tcHQ7IGBudWxsYCBzdXBwcmVzc2VzIHByb21wdCBhbHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc29ydF0gLSBXaGV0aGVyIHRvIGFscGhhIHNvcnQgb3Igbm90LiBJZiB0cnV0aHksIHNvcnRzIGVhY2ggb3B0Z3JvdXAgb24gaXRzIGBsYWJlbGA7IGFuZCBlYWNoIHNlbGVjdCBvcHRpb24gb24gaXRzIHRleHQgKGl0cyBgYWxpYXNgIGlmIGdpdmVuOyBvciBpdHMgYG5hbWVgIGlmIG5vdCkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMuYmxhY2tsaXN0XSAtIE9wdGlvbmFsIGxpc3Qgb2YgbWVudSBpdGVtIG5hbWVzIHRvIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gW29wdGlvbnMuYnJlYWRjcnVtYnNdIC0gTGlzdCBvZiBvcHRpb24gZ3JvdXAgc2VjdGlvbiBudW1iZXJzIChyb290IGlzIHNlY3Rpb24gMCkuIChGb3IgaW50ZXJuYWwgdXNlLilcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFwcGVuZD1mYWxzZV0gLSBXaGVuIGBlbGAgaXMgYW4gZXhpc3RpbmcgYDxzZWxlY3Q+YCBFbGVtZW50LCBnaXZpbmcgdHJ1dGh5IHZhbHVlIGFkZHMgdGhlIG5ldyBjaGlsZHJlbiB3aXRob3V0IGZpcnN0IHJlbW92aW5nIGV4aXN0aW5nIGNoaWxkcmVuLlxuICpcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBFaXRoZXIgYSBgPHNlbGVjdD5gIG9yIGA8b3B0Z3JvdXA+YCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBidWlsZChlbCwgbWVudSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHByb21wdCA9IG9wdGlvbnMucHJvbXB0LFxuICAgICAgICBibGFja2xpc3QgPSBvcHRpb25zLmJsYWNrbGlzdCxcbiAgICAgICAgc29ydCA9IG9wdGlvbnMuc29ydCxcbiAgICAgICAgYnJlYWRjcnVtYnMgPSBvcHRpb25zLmJyZWFkY3J1bWJzIHx8IFtdLFxuICAgICAgICBwYXRoID0gYnJlYWRjcnVtYnMgPyBicmVhZGNydW1icy5qb2luKCcuJykgKyAnLicgOiAnJyxcbiAgICAgICAgdGFnTmFtZTtcblxuICAgIGlmIChlbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgdGFnTmFtZSA9IGVsLnRhZ05hbWU7XG4gICAgICAgIGlmICghb3B0aW9ucy5hcHBlbmQpIHtcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9ICcnOyAvLyByZW1vdmUgYWxsIDxvcHRpb24+IGFuZCA8b3B0Z3JvdXA+IGVsZW1lbnRzXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0YWdOYW1lID0gZWw7XG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAobWVudSkge1xuICAgICAgICB2YXIgYWRkLCBuZXdPcHRpb247XG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICAgICAgYWRkID0gZWwuYWRkO1xuICAgICAgICAgICAgaWYgKHByb21wdCkge1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbiA9IG5ldyBPcHRpb24ocHJvbXB0LCAnJyk7XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uLmlubmVySFRNTCArPSAnJmhlbGxpcDsnO1xuICAgICAgICAgICAgICAgIGVsLmFkZChuZXdPcHRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9tcHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbC5hZGQobmV3IE9wdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZCA9IGVsLmFwcGVuZENoaWxkO1xuICAgICAgICAgICAgZWwubGFiZWwgPSBwcm9tcHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc29ydCkge1xuICAgICAgICAgICAgbWVudSA9IG1lbnUuc2xpY2UoKS5zb3J0KGl0ZW1Db21wYXJhdG9yKTsgLy8gc29ydGVkIGNsb25lXG4gICAgICAgIH1cblxuICAgICAgICBtZW51LmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0ZW0gaXMgb2YgZm9ybSBhKGIpIGFuZCB0aGVyZSBpcyBhbiBmdW5jdGlvbiBhIGluIG9wdGlvbnMsIHRoZW4gaXRlbSA9IG9wdGlvbnMuYShiKVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGlyZWN0aW9uID0gaXRlbS5tYXRjaChSRUdFWFBfSU5ESVJFQ1RJT04pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGluZGlyZWN0aW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGluZGlyZWN0aW9uWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IG9wdGlvbnNbYV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGYoYik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnYnVpbGQ6IEV4cGVjdGVkIG9wdGlvbnMuJyArIGEgKyAnIHRvIGJlIGEgZnVuY3Rpb24uJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1Ym1lbnUgPSBpdGVtLnN1Ym1lbnUgfHwgaXRlbTtcbiAgICAgICAgICAgIGlmIChzdWJtZW51IGluc3RhbmNlb2YgQXJyYXkpIHtcblxuICAgICAgICAgICAgICAgIHZhciBncm91cE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFkY3J1bWJzOiBicmVhZGNydW1icy5jb25jYXQoaW5kZXggKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0OiBpdGVtLmxhYmVsIHx8ICdHcm91cCAnICsgcGF0aCArIChpbmRleCArIDEpLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBzb3J0LFxuICAgICAgICAgICAgICAgICAgICBibGFja2xpc3Q6IGJsYWNrbGlzdFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgb3B0Z3JvdXAgPSBidWlsZCgnT1BUR1JPVVAnLCBzdWJtZW51LCBncm91cE9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGdyb3VwLmNoaWxkRWxlbWVudENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFkZChvcHRncm91cCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdC5pbmRleE9mKGl0ZW0pID49IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZC5jYWxsKGVsLCBuZXcgT3B0aW9uKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uaGlkZGVuKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGl0ZW0ubmFtZSB8fCBpdGVtLmFsaWFzO1xuICAgICAgICAgICAgICAgIGlmICghKGJsYWNrbGlzdCAmJiBibGFja2xpc3QuaW5kZXhPZihuYW1lKSA+PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGQuY2FsbChlbCwgbmV3IE9wdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYWxpYXMgfHwgaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWwudHlwZSA9ICd0ZXh0JztcbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIGl0ZW1Db21wYXJhdG9yKGEsIGIpIHtcbiAgICBhID0gYS5hbGlhcyB8fCBhLm5hbWUgfHwgYS5sYWJlbCB8fCBhO1xuICAgIGIgPSBiLmFsaWFzIHx8IGIubmFtZSB8fCBiLmxhYmVsIHx8IGI7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIGBtZW51YCBmb3IgYSBuYW1lZCBgaXRlbWAuXG4gKiBAbWVtYmVyT2YgcG9wTWVudVxuICogQHBhcmFtIHttZW51SXRlbVtdfSBtZW51XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZHxtZW51SXRlbX0gVGhlIGZvdW5kIGl0ZW0gb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLlxuICovXG5mdW5jdGlvbiBmaW5kSXRlbShtZW51LCBuYW1lKSB7XG4gICAgdmFyIHNoYWxsb3csIGRlZXAsIGl0ZW07XG5cbiAgICBzaGFsbG93ID0gbWVudS5maW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHN1Ym1lbnUgPSBpdGVtLnN1Ym1lbnUgfHwgaXRlbTtcbiAgICAgICAgaWYgKHN1Ym1lbnUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIChkZWVwID0gZmluZEl0ZW0oc3VibWVudSwgbmFtZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChpdGVtLm5hbWUgfHwgaXRlbSkgPT09IG5hbWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0ZW0gPSBkZWVwIHx8IHNoYWxsb3c7XG5cbiAgICByZXR1cm4gaXRlbSAmJiAoaXRlbS5uYW1lID8gaXRlbSA6IHsgbmFtZTogaXRlbSB9KTtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBSZWN1cnNpdmVseSB3YWxrcyBgbWVudWAgYW5kIGNhbGxzIGBpdGVyYXRlZWAgb24gZmllbGQuXG4gKiBAZGVzYyBJdGVyYXRlZSBpcyBjYWxsZWQgd2l0aCBlYWNoIGl0ZW0gKHRlcm1pbmFsIG5vZGUpIGluIHRoZSBtZW51IHRyZWUgYW5kIGEgZmxhdCAwLWJhc2VkIGluZGV4LlxuICpcbiAqIFRoZSBub2RlIHdpbGwgYWx3YXlzIGJlIGEge0BsaW5rIHZhbHVlSXRlbX0gb2JqZWN0OyB3aGVuIGEgYHN0cmluZ2AsIGl0IGlzIGJveGVkIGZvciB5b3UuXG4gKlxuICogQG1lbWJlck9mIHBvcE1lbnVcbiAqIEBwYXJhbSB7bWVudUl0ZW1bXX0gbWVudVxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBpdGVtcyAodGVybWluYWwgbm9kZXMpIGluIHRoZSBtZW51IHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHdhbGsobWVudSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbiA9IDA7XG5cbiAgICBtZW51LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgc3VibWVudSA9IGl0ZW0uc3VibWVudSB8fCBpdGVtO1xuICAgICAgICBpZiAoc3VibWVudSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBuICs9IHdhbGsoc3VibWVudSwgaXRlcmF0ZWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0ZWUoaXRlbS5uYW1lID8gaXRlbSA6IHsgbmFtZTogaXRlbSB9LCBuKTtcbiAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG47XG59XG5cbi8qKlxuICogQHN1bW1hcnkgRm9ybWF0IGl0ZW0gbmFtZSB3aXRoIGl0J3MgYWxpYXMgd2hlbiBhdmFpbGFibGUuXG4gKiBAbWVtYmVyT2YgcG9wTWVudVxuICogQHBhcmFtIHtzdHJpbmd8dmFsdWVJdGVtfSBpdGVtXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIG5hbWUgYW5kIGFsaWFzLlxuICovXG5mdW5jdGlvbiBmb3JtYXRJdGVtKGl0ZW0pIHtcbiAgICB2YXIgcmVzdWx0ID0gaXRlbS5uYW1lIHx8IGl0ZW07XG4gICAgaWYgKGl0ZW0uYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0ID0gJ1wiJyArIGl0ZW0uYWxpYXMgKyAnXCIgKCcgKyByZXN1bHQgKyAnKSc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gaXNHcm91cFByb3h5KHMpIHtcbiAgICByZXR1cm4gUkVHRVhQX0lORElSRUNUSU9OLnRlc3Qocyk7XG59XG5cbi8qKlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgcG9wTWVudSA9IHtcbiAgICBidWlsZDogYnVpbGQsXG4gICAgd2Fsazogd2FsayxcbiAgICBmaW5kSXRlbTogZmluZEl0ZW0sXG4gICAgZm9ybWF0SXRlbTogZm9ybWF0SXRlbSxcbiAgICBpc0dyb3VwUHJveHk6IGlzR3JvdXBQcm94eVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3BNZW51O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWQtb25seSBwcm9wZXJ0eSBhbmQgYXR0YWNoZXMgaXQgdG8gdGhlIHByb3ZpZGVkIGNvbnRleHQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIGZvciBuZXcgcHJvcGVydHkuXG4gKiBAcGFyYW0geyp9IFt2YWx1ZV0gLSBWYWx1ZSBvZiBuZXcgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGFkZFJlYWRPbmx5UHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBQb2ludFxuICpcbiAqIEBkZXNjIFRoaXMgb2JqZWN0IHJlcHJlc2VudHMgYSBzaW5nbGUgcG9pbnQgaW4gYW4gYWJzdHJhY3QgMi1kaW1lbnNpb25hbCBtYXRyaXguXG4gKlxuICogVGhlIHVuaXQgb2YgbWVhc3VyZSBpcyB0eXBpY2FsbHkgcGl4ZWxzLlxuICogKElmIHVzZWQgdG8gbW9kZWwgY29tcHV0ZXIgZ3JhcGhpY3MsIHZlcnRpY2FsIGNvb3JkaW5hdGVzIGFyZSB0eXBpY2FsbHkgbWVhc3VyZWQgZG93bndhcmRzXG4gKiBmcm9tIHRoZSB0b3Agb2YgdGhlIHdpbmRvdy4gVGhpcyBjb252ZW50aW9uIGhvd2V2ZXIgaXMgbm90IGluaGVyZW50IGluIHRoaXMgb2JqZWN0LilcbiAqXG4gKiBOb3RlOiBUaGlzIG9iamVjdCBzaG91bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgbmV3IHBvaW50J3MgYHhgIHByb3BlcnR5XG4gKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSBuZXcgcG9pbnQncyBgeWAgcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgeFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHN1bW1hcnkgVGhpcyBwb2ludCdzIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFBvaW50fGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICd4JywgTnVtYmVyKHgpIHx8IDApO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgeVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHN1bW1hcnkgVGhpcyBwb2ludCdzIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBQb2ludHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAneScsIE51bWJlcih5KSB8fCAwKTtcblxufVxuXG5Qb2ludC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IHBvaW50IHdoaWNoIGlzIHRoaXMgcG9pbnQncyBwb3NpdGlvbiBpbmNyZWFzZWQgYnkgY29vcmRpbmF0ZXMgb2YgZ2l2ZW4gYG9mZnNldGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gb2Zmc2V0IC0gSG9yaXpvbnRhbCBhbmQgdmVydGljYWwgdmFsdWVzIHRvIGFkZCB0byB0aGlzIHBvaW50J3MgY29vcmRpbmF0ZXMuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBsdXM6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgdGhpcy54ICsgb2Zmc2V0LngsXG4gICAgICAgICAgICB0aGlzLnkgKyBvZmZzZXQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IHBvaW50IHdoaWNoIGlzIHRoaXMgcG9pbnQncyBwb3NpdGlvbiBpbmNyZWFzZWQgYnkgZ2l2ZW4gb2Zmc2V0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldFg9MF0gLSBWYWx1ZSB0byBhZGQgdG8gdGhpcyBwb2ludCdzIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldFk9MF0gLSBWYWx1ZSB0byBhZGQgdG8gdGhpcyBwb2ludCdzIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgcGx1c1hZOiBmdW5jdGlvbihvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICB0aGlzLnggKyAob2Zmc2V0WCB8fCAwKSxcbiAgICAgICAgICAgIHRoaXMueSArIChvZmZzZXRZIHx8IDApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gQSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhpcyBwb2ludCdzIHBvc2l0aW9uIGRlY3JlYXNlZCBieSBjb29yZGluYXRlcyBvZiBnaXZlbiBgb2Zmc2V0YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBvZmZzZXQgLSBIb3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCB2YWx1ZXMgdG8gc3VidHJhY3QgZnJvbSB0aGlzIHBvaW50J3MgY29vcmRpbmF0ZXMuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIG1pbnVzOiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMueCAtIG9mZnNldC54LFxuICAgICAgICAgICAgdGhpcy55IC0gb2Zmc2V0LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBgUG9pbnRgIHBvc2l0aW9uZWQgdG8gbGVhc3QgeCBhbmQgbGVhc3QgeSBvZiB0aGlzIHBvaW50IGFuZCBnaXZlbiBgb2Zmc2V0YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtaW46IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICBNYXRoLm1pbih0aGlzLngsIHBvaW50LngpLFxuICAgICAgICAgICAgTWF0aC5taW4odGhpcy55LCBwb2ludC55KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IGBQb2ludGAgcG9zaXRpb25lZCB0byBncmVhdGVzdCB4IGFuZCBncmVhdGVzdCB5IG9mIHRoaXMgcG9pbnQgYW5kIGdpdmVuIGBwb2ludGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludC5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgbWF4OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgTWF0aC5tYXgodGhpcy54LCBwb2ludC54KSxcbiAgICAgICAgICAgIE1hdGgubWF4KHRoaXMueSwgcG9pbnQueSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn0gRGlzdGFuY2UgYmV0d2VlbiBnaXZlbiBgcG9pbnRgIGFuZCB0aGlzIHBvaW50IHVzaW5nIFB5dGhhZ29yZWFuIFRoZW9yZW0gZm9ybXVsYS5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgZnJvbSB3aGljaCB0byBjb21wdXRlIHRoZSBkaXN0YW5jZSB0byB0aGlzIHBvaW50LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkaXN0YW5jZTogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdmFyIGRlbHRhWCA9IHBvaW50LnggLSB0aGlzLngsXG4gICAgICAgICAgICBkZWx0YVkgPSBwb2ludC55IC0gdGhpcy55O1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICBkZWx0YVggKiBkZWx0YVggK1xuICAgICAgICAgICAgZGVsdGFZICogZGVsdGFZXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHk6IGBlcXVhbGAuKV9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBfYm90aF8gY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludCBhcmUgZXhhY3RseSBlcXVhbCB0byB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGVxdWFsczogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChwb2ludCkge1xuICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICB0aGlzLnggPT09IHBvaW50LnggJiZcbiAgICAgICAgICAgICAgICB0aGlzLnkgPT09IHBvaW50Lnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBfYm90aF8gY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludCBhcmUgZ3JlYXRlciB0aGFuIHRob3NlIG9mIGdpdmVuIGBwb2ludGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludFxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBncmVhdGVyVGhhbjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMueCA+IHBvaW50LnggJiZcbiAgICAgICAgICAgIHRoaXMueSA+IHBvaW50LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGxlc3MgdGhhbiB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnRcbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgbGVzc1RoYW46IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnggPCBwb2ludC54ICYmXG4gICAgICAgICAgICB0aGlzLnkgPCBwb2ludC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHkgYGdyZWF0ZXJUaGFuRXF1YWxUb2AuKV9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBfYm90aF8gY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludCBhcmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRob3NlIG9mIGdpdmVuIGBwb2ludGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludFxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBncmVhdGVyVGhhbk9yRXF1YWxUbzogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMueCA+PSBwb2ludC54ICYmXG4gICAgICAgICAgICB0aGlzLnkgPj0gcG9pbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5IGBsZXNzVGhhbkVxdWFsVG9gLilfXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxlc3NUaGFuT3JFcXVhbFRvOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy54IDw9IHBvaW50LnggJiZcbiAgICAgICAgICAgIHRoaXMueSA8PSBwb2ludC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHkgYGlzQ29udGFpbmVkV2l0aGluUmVjdGFuZ2xlYC4pX1xuICAgICAqIEBwYXJhbSByZWN0IHtSZWN0YW5nbGV9IC0gUmVjdGFuZ2xlIHRvIHRlc3QgdGhpcyBwb2ludCBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIHRoaXMgcG9pbnQgaXMgd2l0aGluIGdpdmVuIGByZWN0YC5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgd2l0aGluOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgIHZhciBtaW5YID0gcmVjdC5vcmlnaW4ueCxcbiAgICAgICAgICAgIG1heFggPSBtaW5YICsgcmVjdC5leHRlbnQueDtcbiAgICAgICAgdmFyIG1pblkgPSByZWN0Lm9yaWdpbi55LFxuICAgICAgICAgICAgbWF4WSA9IG1pblkgKyByZWN0LmV4dGVudC55O1xuXG4gICAgICAgIGlmIChyZWN0LmV4dGVudC54IDwgMCkge1xuICAgICAgICAgICAgbWluWCA9IG1heFg7XG4gICAgICAgICAgICBtYXhYID0gcmVjdC5vcmlnaW4ueDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWN0LmV4dGVudC55IDwgMCkge1xuICAgICAgICAgICAgbWluWSA9IG1heFk7XG4gICAgICAgICAgICBtYXhZID0gcmVjdC5vcmlnaW4ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBtaW5YIDw9IHRoaXMueCAmJiB0aGlzLnggPCBtYXhYICYmXG4gICAgICAgICAgICBtaW5ZIDw9IHRoaXMueSAmJiB0aGlzLnkgPCBtYXhZXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuUG9pbnQucHJvdG90eXBlLkVRID0gUG9pbnQucHJvdG90eXBlLmVxdWFscztcblBvaW50LnByb3RvdHlwZS5HVCA9IFBvaW50LnByb3RvdHlwZS5ncmVhdGVyVGhhbjtcblBvaW50LnByb3RvdHlwZS5MVCA9IFBvaW50LnByb3RvdHlwZS5sZXNzVGhhbjtcblBvaW50LnByb3RvdHlwZS5HRSA9IFBvaW50LnByb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWxUbztcblBvaW50LnByb3RvdHlwZS5MRSA9IFBvaW50LnByb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWxUbztcblxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBSZWN0YW5nbGVcbiAqXG4gKiBAZGVzYyBUaGlzIG9iamVjdCByZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSB3aXRoaW4gYW4gYWJzdHJhY3QgMi1kaW1lbnNpb25hbCBtYXRyaXguXG4gKlxuICogVGhlIHVuaXQgb2YgbWVhc3VyZSBpcyB0eXBpY2FsbHkgcGl4ZWxzLlxuICogKElmIHVzZWQgdG8gbW9kZWwgY29tcHV0ZXIgZ3JhcGhpY3MsIHZlcnRpY2FsIGNvb3JkaW5hdGVzIGFyZSB0eXBpY2FsbHkgbWVhc3VyZWQgZG93bndhcmRzXG4gKiBmcm9tIHRoZSB0b3Agb2YgdGhlIHdpbmRvdy4gVGhpcyBjb252ZW50aW9uIGhvd2V2ZXIgaXMgbm90IGluaGVyZW50IGluIHRoaXMgb2JqZWN0LilcbiAqXG4gKiBOb3JtYWxseSwgdGhlIGB4YCBhbmQgYHlgIHBhcmFtZXRlcnMgdG8gdGhlIGNvbnN0cnVjdG9yIGRlc2NyaWJlIHRoZSB1cHBlciBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdC5cbiAqIEhvd2V2ZXIsIG5lZ2F0aXZlIHZhbHVlcyBvZiBgd2lkdGhgIGFuZCBgaGVpZ2h0YCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBnaXZlbiBgeGAgYW5kIGB5YC4gVGhhdCBpcyxcbiAqIGEgbmVnYXRpdmUgdmFsdWUgb2YgdGhlIGB3aWR0aGAgcGFyYW1ldGVyIHdpbGwgZXh0ZW5kIHRoZSByZWN0IHRvIHRoZSBsZWZ0IG9mIHRoZSBnaXZlbiBgeGAgYW5kXG4gKiBhIG5lZ2F0aXZlIHZhbHVlIG9mIHRoZSBgaGVpZ2h0YCBwYXJhbWV0ZXIgd2lsbCBleHRlbmQgdGhlIHJlY3QgYWJvdmUgdGhlIGdpdmVuIGB5YC5cbiAqIEluIGFueSBjYXNlLCBhZnRlciBpbnN0YW50aWF0aW9uIHRoZSBmb2xsb3dpbmcgYXJlIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIHRydWU6XG4gKiAqIFRoZSBgZXh0ZW50YCwgYHdpZHRoYCwgYW5kIGBoZWlnaHRgIHByb3BlcnRpZXMgX2Fsd2F5c18gZ2l2ZSBwb3NpdGl2ZSB2YWx1ZXMuXG4gKiAqIFRoZSBgb3JpZ2luYCwgYHRvcGAsIGFuZCBgbGVmdGAgcHJvcGVydGllcyBfYWx3YXlzXyByZWZsZWN0IHRoZSB1cHBlciBsZWZ0IGNvcm5lci5cbiAqICogVGhlIGBjb3JuZXJgLCBgYm90dG9tYCwgYW5kIGByaWdodGAgcHJvcGVydGllcyBfYWx3YXlzXyByZWZsZWN0IHRoZSBsb3dlciByaWdodCBjb3JuZXIuXG4gKlxuICogTm90ZTogVGhpcyBvYmplY3Qgc2hvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgY29vcmRpbmF0ZSBvZiBzb21lIGNvcm5lciBvZiB0aGUgcmVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIGNvb3JkaW5hdGUgb2Ygc29tZSBjb3JuZXIgb2YgdGhlIHJlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTBdIC0gV2lkdGggb2YgdGhlIG5ldyByZWN0LiBNYXkgYmUgbmVnYXRpdmUgKHNlZSBhYm92ZSkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD0wXSAtIEhlaWdodCBvZiB0aGUgbmV3IHJlY3QuIE1heSBiZSBuZWdhdGl2ZSAoc2VlIGFib3ZlKS5cbiAqL1xuZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgIHggPSBOdW1iZXIoeCkgfHwgMDtcbiAgICB5ID0gTnVtYmVyKHkpIHx8IDA7XG4gICAgd2lkdGggPSBOdW1iZXIod2lkdGgpIHx8IDA7XG4gICAgaGVpZ2h0ID0gTnVtYmVyKGhlaWdodCkgfHwgMDtcblxuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgeCArPSB3aWR0aDtcbiAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgeSArPSBoZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgb3JpZ2luXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBzdW1tYXJ5IFVwcGVyIGxlZnQgY29ybmVyIG9mIHRoaXMgcmVjdC5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rcGxhaW4gUmVjdGFuZ2xlfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAnb3JpZ2luJywgbmV3IFBvaW50KHgsIHkpKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGV4dGVudFxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAc3VtbWFyeSB0aGlzIHJlY3QncyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqIEBkZXNjIFVubGlrZSB0aGUgb3RoZXIgYFBvaW50YCBwcm9wZXJ0aWVzLCBgZXh0ZW50YCBpcyBub3QgYSBnbG9iYWwgY29vcmRpbmF0ZSBwYWlyOyByYXRoZXIgaXQgY29uc2lzdHMgb2YgYSBfd2lkdGhfIChgeGAsIGFsd2F5cyBwb3NpdGl2ZSkgYW5kIGEgX2hlaWdodF8gKGB5YCwgYWx3YXlzIHBvc2l0aXZlKS5cbiAgICAgKlxuICAgICAqIFRoaXMgb2JqZWN0IG1pZ2h0IGJlIG1vcmUgbGVnaXRpbWF0ZWx5IHR5cGVkIGFzIHNvbWV0aGluZyBsaWtlIGBBcmVhYCB3aXRoIHByb3BlcnRpZXMgYHdpZHRoYCBhbmQgYGhlaWdodGA7IGhvd2V2ZXIgd2Ugd2FudGVkIGl0IHRvIGJlIGFibGUgdG8gdXNlIGl0IGVmZmljaWVudGx5IHdpdGggYSBwb2ludCdzIGBwbHVzYCBhbmQgYG1pbnVzYCBtZXRob2RzICh0aGF0IGlzLCB3aXRob3V0IHRob3NlIG1ldGhvZHMgaGF2aW5nIHRvIGNoZWNrIGFuZCBicmFuY2ggb24gdGhlIHR5cGUgb2YgaXRzIHBhcmFtZXRlcikuXG4gICAgICpcbiAgICAgKiBDcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rcGxhaW4gUmVjdGFuZ2xlfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAc2VlIFRoZSB7QGxpbmsgUmVjdGFuZ2xlI2Nvcm5lcnxjb3JuZXJ9IG1ldGhvZC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAnZXh0ZW50JywgbmV3IFBvaW50KHdpZHRoLCBoZWlnaHQpKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGNvcm5lclxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAc3VtbWFyeSBMb3dlciByaWdodCBjb3JuZXIgb2YgdGhpcyByZWN0LlxuICAgICAqIEBkZXNjIFRoaXMgaXMgYSBjYWxjdWxhdGVkIHZhbHVlIGNyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmtwbGFpbiBSZWN0YW5nbGV8Y29uc3RydWN0b3J9LiBJdCBpcyBgb3JpZ2luYCBvZmZzZXQgYnkgYGV4dGVudGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlc2UgY29vcmRpbmF0ZXMgYWN0dWFsbHkgcG9pbnQgdG8gdGhlIHBpeGVsIG9uZSBiZWxvdyBhbmQgb25lIHRvIHRoZSByaWdodCBvZiB0aGUgcmVjdCdzIGFjdHVhbCBsb3dlciByaWdodCBwaXhlbC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAnY29ybmVyJywgbmV3IFBvaW50KHggKyB3aWR0aCwgeSArIGhlaWdodCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgY2VudGVyXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBzdW1tYXJ5IENlbnRlciBvZiB0aGlzIHJlY3QuXG4gICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGlua3BsYWluIFJlY3RhbmdsZXxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ2NlbnRlcicsIG5ldyBQb2ludCh4ICsgKHdpZHRoIC8gMiksIHkgKyAoaGVpZ2h0IC8gMikpKTtcblxufVxuXG5SZWN0YW5nbGUucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAqIEBzdW1tYXJ5IE1pbmltdW0gdmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgdG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW4ueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAqIEBzdW1tYXJ5IE1pbmltdW0gaG9yaXpvbnRhbCBjb29yZGluYXRlIG9mIHRoaXMgcmVjdC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW4ueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAqIEBzdW1tYXJ5IE1heGltdW0gdmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGlzIHJlY3QgKyAxLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IGJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ybmVyLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBNYXhpbXVtIGhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGlzIHJlY3QgKyAxLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3JuZXIueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAqIEBzdW1tYXJ5IFdpZHRoIG9mIHRoaXMgcmVjdCAoYWx3YXlzIHBvc2l0aXZlKS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW50Lng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBIZWlnaHQgb2YgdGhpcyByZWN0IChhbHdheXMgcG9zaXRpdmUpLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW50Lnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBBcmVhIG9mIHRoaXMgcmVjdC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCBhcmVhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBBIGNvcHkgb2YgdGhpcyByZWN0IGJ1dCB3aXRoIGhvcml6b250YWwgcG9zaXRpb24gcmVzZXQgdG8gZ2l2ZW4gYHhgIGFuZCBubyB3aWR0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIEhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmbGF0dGVuWEF0OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHRoaXMub3JpZ2luLnksIDAsIHRoaXMuZXh0ZW50LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBBIGNvcHkgb2YgdGhpcyByZWN0IGJ1dCB3aXRoIHZlcnRpY2FsIHBvc2l0aW9uIHJlc2V0IHRvIGdpdmVuIGB5YCBhbmQgbm8gaGVpZ2h0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmbGF0dGVuWUF0OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMub3JpZ2luLngsIHksIHRoaXMuZXh0ZW50LngsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBnaXZlbiBgcG9pbnRgIGVudGlyZWx5IGNvbnRhaW5lZCB3aXRoaW4gdGhpcyByZWN0LlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50T3JSZWN0IC0gVGhlIHBvaW50IG9yIHJlY3QgdG8gdGVzdCBmb3IgY29udGFpbm1lbnQuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb250YWluczogZnVuY3Rpb24ocG9pbnRPclJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50T3JSZWN0LndpdGhpbih0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogXyhGb3JtZXJseSBgaXNDb250YWluZWRXaXRoaW5SZWN0YW5nbGVgLilfXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHRoaXNgIHJlY3QgaXMgZW50aXJlbHkgY29udGFpbmVkIHdpdGhpbiBnaXZlbiBgcmVjdGAuXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBSZWN0YW5nbGUgdG8gdGVzdCBhZ2FpbnN0IHRoaXMgcmVjdC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHdpdGhpbjogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcmVjdC5vcmlnaW4ubGVzc1RoYW5PckVxdWFsVG8odGhpcy5vcmlnaW4pICYmXG4gICAgICAgICAgICByZWN0LmNvcm5lci5ncmVhdGVyVGhhbk9yRXF1YWxUbyh0aGlzLmNvcm5lcilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogXyhGb3JtZXJseTogYGluc2V0QnlgLilfXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gVGhhdCBpcyBlbmxhcmdlZC9zaHJ1bmsgYnkgZ2l2ZW4gYHBhZGRpbmdgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nIC0gQW1vdW50IGJ5IHdoaWNoIHRvIGluY3JlYXNlICgrKSBvciBkZWNyZWFzZSAoLSkgdGhpcyByZWN0XG4gICAgICogQHNlZSBUaGUge0BsaW5rIFJlY3RhbmdsZSNzaHJpbmtCeXxzaHJpbmtCeX0gbWV0aG9kLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ3Jvd0J5OiBmdW5jdGlvbihwYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgdGhpcy5vcmlnaW4ueCArIHBhZGRpbmcsXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi55ICsgcGFkZGluZyxcbiAgICAgICAgICAgIHRoaXMuZXh0ZW50LnggLSBwYWRkaW5nIC0gcGFkZGluZyxcbiAgICAgICAgICAgIHRoaXMuZXh0ZW50LnkgLSBwYWRkaW5nIC0gcGFkZGluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoYXQgaXMgZW5sYXJnZWQvc2hydW5rIGJ5IGdpdmVuIGBwYWRkaW5nYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyAtIEFtb3VudCBieSB3aGljaCB0byBkZWNyZWFzZSAoKykgb3IgaW5jcmVhc2UgKC0pIHRoaXMgcmVjdC5cbiAgICAgKiBAc2VlIFRoZSB7QGxpbmsgUmVjdGFuZ2xlI2dyb3dCeXxncm93Qnl9IG1ldGhvZC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNocmlua0J5OiBmdW5jdGlvbihwYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3dCeSgtcGFkZGluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IEJvdW5kaW5nIHJlY3QgdGhhdCBjb250YWlucyBib3RoIHRoaXMgcmVjdCBhbmQgdGhlIGdpdmVuIGByZWN0YC5cbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gdW5pb24gd2l0aCB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB1bmlvbjogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW4ubWluKHJlY3Qub3JpZ2luKSxcbiAgICAgICAgICAgIGNvcm5lciA9IHRoaXMuY29ybmVyLm1heChyZWN0LmNvcm5lciksXG4gICAgICAgICAgICBleHRlbnQgPSBjb3JuZXIubWludXMob3JpZ2luKTtcblxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIG9yaWdpbi54LCBvcmlnaW4ueSxcbiAgICAgICAgICAgIGV4dGVudC54LCBleHRlbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpdGVyYXRlIG92ZXIgYWxsIHBvaW50cyB3aXRoaW4gdGhpcyByZWN0LCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvciBlYWNoLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcil9IGl0ZXJhdGVlIC0gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBwb2ludC5cbiAgICAgKiBCb3VuZCB0byBgY29udGV4dGAgd2hlbiBnaXZlbjsgb3RoZXJ3aXNlIGl0IGlzIGJvdW5kIHRvIHRoaXMgcmVjdC5cbiAgICAgKiBFYWNoIGludm9jYXRpb24gb2YgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuICAgICAqIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0PXRoaXNdIC0gQ29udGV4dCB0byBiaW5kIHRvIGBpdGVyYXRlZWAgKHdoZW4gbm90IGB0aGlzYCkuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmb3JFYWNoOiBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuICAgICAgICBmb3IgKHZhciB4ID0gdGhpcy5vcmlnaW4ueCwgeDIgPSB0aGlzLmNvcm5lci54OyB4IDwgeDI7IHgrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IHRoaXMub3JpZ2luLnksIHkyID0gdGhpcy5jb3JuZXIueTsgeSA8IHkyOyB5KyspIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZS5jYWxsKGNvbnRleHQsIHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IE9uZSBvZjpcbiAgICAgKiAqIF9JZiB0aGlzIHJlY3QgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBgcmVjdGA6X1xuICAgICAqICAgICAgYSBuZXcgcmVjdCByZXByZXNlbnRpbmcgdGhhdCBpbnRlcnNlY3Rpb24uXG4gICAgICogKiBfSWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgYW5kIGBpZk5vbmVBY3Rpb25gIGRlZmluZWQ6X1xuICAgICAqICAgICAgcmVzdWx0IG9mIGNhbGxpbmcgYGlmTm9uZUFjdGlvbmAuXG4gICAgICogKiBfSWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgYW5kIGBpZk5vbmVBY3Rpb25gIHVuZGVmaW5lZDpfXG4gICAgICogICAgICBgbnVsbGAuXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGludGVyc2VjdCB3aXRoIHRoaXMgcmVjdC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFJlY3RhbmdsZSl9IFtpZk5vbmVBY3Rpb25dIC0gV2hlbiBubyBpbnRlcnNlY3Rpb24sIGludm9rZSBhbmQgcmV0dXJuIHJlc3VsdC5cbiAgICAgKiBCb3VuZCB0byBgY29udGV4dGAgd2hlbiBnaXZlbjsgb3RoZXJ3aXNlIGJvdW5kIHRvIHRoaXMgcmVjdC5cbiAgICAgKiBJbnZva2VkIHdpdGggYHJlY3RgIGFzIHNvbGUgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dD10aGlzXSAtIENvbnRleHQgdG8gYmluZCB0byBgaWZOb25lQWN0aW9uYCAod2hlbiBub3QgYHRoaXNgKS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGludGVyc2VjdDogZnVuY3Rpb24ocmVjdCwgaWZOb25lQWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsLFxuICAgICAgICAgICAgb3JpZ2luID0gdGhpcy5vcmlnaW4ubWF4KHJlY3Qub3JpZ2luKSxcbiAgICAgICAgICAgIGNvcm5lciA9IHRoaXMuY29ybmVyLm1pbihyZWN0LmNvcm5lciksXG4gICAgICAgICAgICBleHRlbnQgPSBjb3JuZXIubWludXMob3JpZ2luKTtcblxuICAgICAgICBpZiAoZXh0ZW50LnggPiAwICYmIGV4dGVudC55ID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICBvcmlnaW4ueCwgb3JpZ2luLnksXG4gICAgICAgICAgICAgICAgZXh0ZW50LngsIGV4dGVudC55XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpZk5vbmVBY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGlmTm9uZUFjdGlvbi5jYWxsKGNvbnRleHQgfHwgdGhpcywgcmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiB0aGlzIHJlY3Qgb3ZlcmxhcHMgd2l0aCBnaXZlbiBgcmVjdGAuXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGludGVyc2VjdCB3aXRoIHRoaXMgcmVjdC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGludGVyc2VjdHM6IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY3QuY29ybmVyLnggPiB0aGlzLm9yaWdpbi54ICYmXG4gICAgICAgICAgICByZWN0LmNvcm5lci55ID4gdGhpcy5vcmlnaW4ueSAmJlxuICAgICAgICAgICAgcmVjdC5vcmlnaW4ueCA8IHRoaXMuY29ybmVyLnggJiZcbiAgICAgICAgICAgIHJlY3Qub3JpZ2luLnkgPCB0aGlzLmNvcm5lci55XG4gICAgICAgICk7XG4gICAgfVxufTtcblxuLy8gSW50ZXJmYWNlXG5leHBvcnRzLlBvaW50ID0gUG9pbnQ7XG5leHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIC8vIGEgcmVnZXggc2VhcmNoIHBhdHRlcm4gdGhhdCBtYXRjaGVzIGFsbCB0aGUgcmVzZXJ2ZWQgY2hhcnMgb2YgYSByZWdleCBzZWFyY2ggcGF0dGVyblxuICAgIHJlc2VydmVkID0gLyhbXFwuXFxcXFxcK1xcKlxcP1xcXlxcJFxcKFxcKVxce1xcfVxcPVxcIVxcPFxcPlxcfFxcOlxcW1xcXV0pL2csXG5cbiAgICAvLyByZWdleCB3aWxkY2FyZCBzZWFyY2ggcGF0dGVybnNcbiAgICBSRUdFWFBfV0lMRENBUkQgPSAnLionLFxuICAgIFJFR0VYUF9XSUxEQ0hBUiA9ICcuJyxcbiAgICBSRUdFWFBfV0lMRENBUkRfTUFUQ0hFUiA9ICcoJyArIFJFR0VYUF9XSUxEQ0FSRCArICcpJyxcblxuICAgIC8vIExJS0Ugc2VhcmNoIHBhdHRlcm5zXG4gICAgTElLRV9XSUxEQ0hBUiA9ICdfJyxcbiAgICBMSUtFX1dJTERDQVJEID0gJyUnLFxuXG4gICAgLy8gcmVnZXggc2VhcmNoIHBhdHRlcm5zIHRoYXQgbWF0Y2ggTElLRSBzZWFyY2ggcGF0dGVybnNcbiAgICBSRUdFWFBfTElLRV9QQVRURVJOX01BVENIRVIgPSBuZXcgUmVnRXhwKCcoJyArIFtcbiAgICAgICAgTElLRV9XSUxEQ0hBUixcbiAgICAgICAgTElLRV9XSUxEQ0FSRCxcbiAgICAgICAgJ1xcXFxbXFxcXF4/W14tXFxcXF1dK10nLCAvLyBtYXRjaGVzIGEgTElLRSBzZXQgKHNhbWUgc3ludGF4IGFzIGEgUmVnRXhwIHNldClcbiAgICAgICAgJ1xcXFxbXFxcXF4/W14tXFxcXF1dXFxcXC1bXlxcXFxdXV0nIC8vIG1hdGNoZXMgYSBMSUtFIHJhbmdlIChzYW1lIHN5bnRheCBhcyBhIFJlZ0V4cCByYW5nZSlcbiAgICBdLmpvaW4oJ3wnKSArICcpJywgJ2cnKTtcblxuZnVuY3Rpb24gcmVnRXhwTElLRShwYXR0ZXJuLCBpZ25vcmVDYXNlKSB7XG4gICAgdmFyIGksIHBhcnRzO1xuXG4gICAgLy8gRmluZCBhbGwgTElLRSBwYXR0ZXJuc1xuICAgIHBhcnRzID0gcGF0dGVybi5tYXRjaChSRUdFWFBfTElLRV9QQVRURVJOX01BVENIRVIpO1xuXG4gICAgaWYgKHBhcnRzKSB7XG4gICAgICAgIC8vIFRyYW5zbGF0ZSBmb3VuZCBMSUtFIHBhdHRlcm5zIHRvIHJlZ2V4IHBhdHRlcm5zLCBlc2NhcGVkIGludGVydmVuaW5nIG5vbi1wYXR0ZXJucywgYW5kIGludGVybGVhdmUgdGhlIHR3b1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy8gRXNjYXBlIGxlZnQgYnJhY2tldHMgKHVucGFpcmVkIHJpZ2h0IGJyYWNrZXRzIGFyZSBPSylcbiAgICAgICAgICAgIGlmIChwYXJ0c1tpXVswXSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgcGFydHNbaV0gPSByZWdFeHBMSUtFLnJlc2VydmUocGFydHNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIGVhY2ggZm91bmQgcGF0dGVybiBtYXRjaGFibGUgYnkgZW5jbG9zaW5nIGluIHBhcmVudGhlc2VzXG4gICAgICAgICAgICBwYXJ0c1tpXSA9ICcoJyArIHBhcnRzW2ldICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWF0Y2ggdGhlc2UgcHJlY2lzZSBwYXR0ZXJucyBhZ2FpbiB3aXRoIHRoZWlyIGludGVydmVuaW5nIG5vbi1wYXR0ZXJucyAoaS5lLiwgdGV4dClcbiAgICAgICAgcGFydHMgPSBwYXR0ZXJuLm1hdGNoKG5ldyBSZWdFeHAoXG4gICAgICAgICAgICBSRUdFWFBfV0lMRENBUkRfTUFUQ0hFUiArXG4gICAgICAgICAgICBwYXJ0cy5qb2luKFJFR0VYUF9XSUxEQ0FSRF9NQVRDSEVSKSAgK1xuICAgICAgICAgICAgUkVHRVhQX1dJTERDQVJEX01BVENIRVJcbiAgICAgICAgKSk7XG5cbiAgICAgICAgLy8gRGlzY2FyZCBmaXJzdCBtYXRjaCBvZiBub24tZ2xvYmFsIHNlYXJjaCAod2hpY2ggaXMgdGhlIHdob2xlIHN0cmluZylcbiAgICAgICAgcGFydHMuc2hpZnQoKTtcblxuICAgICAgICAvLyBGb3IgZWFjaCByZS1mb3VuZCBwYXR0ZXJuIHBhcnQsIHRyYW5zbGF0ZSAlIGFuZCBfIHRvIHJlZ2V4IGVxdWl2YWxlbnRcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBMSUtFX1dJTERDQVJEOiBwYXJ0ID0gUkVHRVhQX1dJTERDQVJEOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExJS0VfV0lMRENIQVI6IHBhcnQgPSBSRUdFWFBfV0lMRENIQVI7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHZhciBqID0gcGFydFsxXSA9PT0gJ14nID8gMiA6IDE7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSAnWycgKyByZWdFeHBMSUtFLnJlc2VydmUocGFydC5zdWJzdHIoaiwgcGFydC5sZW5ndGggLSAoaiArIDEpKSkgKyAnXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0c1tpXSA9IHBhcnQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cyA9IFtwYXR0ZXJuXTtcbiAgICB9XG5cbiAgICAvLyBGb3IgZWFjaCBzdXJyb3VuZGluZyB0ZXh0IHBhcnQsIGVzY2FwZSByZXNlcnZlZCByZWdleCBjaGFyc1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwYXJ0c1tpXSA9IHJlZ0V4cExJS0UucmVzZXJ2ZShwYXJ0c1tpXSk7XG4gICAgfVxuXG4gICAgLy8gSm9pbiBhbGwgdGhlIGludGVybGVhdmVkIHBhcnRzXG4gICAgcGFydHMgPSBwYXJ0cy5qb2luKCcnKTtcblxuICAgIC8vIE9wdGltaXplIG9yIGFuY2hvciB0aGUgcGF0dGVybiBhdCBlYWNoIGVuZCBhcyBuZWVkZWRcbiAgICBpZiAocGFydHMuc3Vic3RyKDAsIDIpID09PSBSRUdFWFBfV0lMRENBUkQpIHsgcGFydHMgPSBwYXJ0cy5zdWJzdHIoMik7IH0gZWxzZSB7IHBhcnRzID0gJ14nICsgcGFydHM7IH1cbiAgICBpZiAocGFydHMuc3Vic3RyKC0yLCAyKSA9PT0gUkVHRVhQX1dJTERDQVJEKSB7IHBhcnRzID0gcGFydHMuc3Vic3RyKDAsIHBhcnRzLmxlbmd0aCAtIDIpOyB9IGVsc2UgeyBwYXJ0cyArPSAnJCc7IH1cblxuICAgIC8vIFJldHVybiB0aGUgbmV3IHJlZ2V4XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocGFydHMsIGlnbm9yZUNhc2UgPyAnaScgOiB1bmRlZmluZWQpO1xufVxuXG5yZWdFeHBMSUtFLnJlc2VydmUgPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UocmVzZXJ2ZWQsICdcXFxcJDEnKTtcbn07XG5cbnZhciBjYWNoZSwgc2l6ZTtcblxuLyoqXG4gKiBAc3VtbWFyeSBEZWxldGUgYSBwYXR0ZXJuIGZyb20gdGhlIGNhY2hlOyBvciBjbGVhciB0aGUgd2hvbGUgY2FjaGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhdHRlcm5dIC0gVGhlIExJS0UgcGF0dGVybiB0byByZW1vdmUgZnJvbSB0aGUgY2FjaGUuIEZhaWxzIHNpbGVudGx5IGlmIG5vdCBmb3VuZCBpbiB0aGUgY2FjaGUuIElmIHBhdHRlcm4gb21pdHRlZCwgY2xlYXJzIHdob2xlIGNhY2hlLlxuICovXG4ocmVnRXhwTElLRS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICBpZiAoIXBhdHRlcm4pIHtcbiAgICAgICAgY2FjaGUgPSB7fTtcbiAgICAgICAgc2l6ZSA9IDA7XG4gICAgfSBlbHNlIGlmIChjYWNoZVtwYXR0ZXJuXSkge1xuICAgICAgICBkZWxldGUgY2FjaGVbcGF0dGVybl07XG4gICAgICAgIHNpemUtLTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59KSgpOyAvLyBpbml0IHRoZSBjYWNoZVxuXG5yZWdFeHBMSUtFLmdldENhY2hlU2l6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpemU7IH07XG5cbi8qKlxuICogQHN1bW1hcnkgQ2FjaGVkIHZlcnNpb24gb2YgYHJlZ0V4cExJS0UoKWAuXG4gKiBAZGVzYyBDYWNoZWQgZW50cmllcyBhcmUgc3ViamVjdCB0byBnYXJiYWdlIGNvbGxlY3Rpb24gaWYgYGtlZXBgIGlzIGB1bmRlZmluZWRgIG9yIGBmYWxzZWAgb24gaW5zZXJ0aW9uIG9yIGBmYWxzZWAgb24gbW9zdCByZWNlbnQgcmVmZXJlbmNlLiBHYXJiYWdlIGNvbGxlY3Rpb24gd2lsbCBvY2N1ciBpZmYgYHJlZ0V4cExJS0UuY2FjaGVNYXhgIGlzIGRlZmluZWQgYW5kIGl0IGVxdWFscyB0aGUgbnVtYmVyIG9mIGNhY2hlZCBwYXR0ZXJucy4gVGhlIGdhcmJhZ2UgY29sbGVjdG9yIHNvcnRzIHRoZSBwYXR0ZXJucyBiYXNlZCBvbiBtb3N0IHJlY2VudCByZWZlcmVuY2U7IHRoZSBvbGRlc3QgMTAlIG9mIHRoZSBlbnRyaWVzIGFyZSBkZWxldGVkLiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIG1hbmFnZSB0aGUgY2FjaGUgeW91cnNlbGYgdG8gYSBsaW1pdGVkIGV4dGVudCAoc2VlIHtAbGluayByZWdlRXhwTElLRS5jbGVhckNhY2hlfGNsZWFyQ2FjaGV9KS5cbiAqIEBwYXJhbSBwYXR0ZXJuIC0gdGhlIExJS0UgcGF0dGVybiAodG8gYmUpIGNvbnZlcnRlZCB0byBhIFJlZ0V4cFxuICogQHBhcmFtIFtrZWVwXSAtIElmIGdpdmVuLCBjaGFuZ2VzIHRoZSBrZWVwIHN0YXR1cyBmb3IgdGhpcyBwYXR0ZXJuIGFzIGZvbGxvd3M6XG4gKiAqIGB0cnVlYCBwZXJtYW5lbnRseSBjYWNoZXMgdGhlIHBhdHRlcm4gKG5vdCBzdWJqZWN0IHRvIGdhcmJhZ2UgY29sbGVjdGlvbikgdW50aWwgYGZhbHNlYCBpcyBnaXZlbiBvbiBhIHN1YnNlcXVlbnQgY2FsbFxuICogKiBgZmFsc2VgIGFsbG93cyBnYXJiYWdlIGNvbGxlY3Rpb24gb24gdGhlIGNhY2hlZCBwYXR0ZXJuXG4gKiAqIGB1bmRlZmluZWRgIG5vIGNoYW5nZSB0byBrZWVwIHN0YXR1c1xuICogQHJldHVybnMge1JlZ0V4cH1cbiAqL1xucmVnRXhwTElLRS5jYWNoZWQgPSBmdW5jdGlvbiAoa2VlcCwgcGF0dGVybiwgaWdub3JlQ2FzZSkge1xuICAgIGlmICh0eXBlb2Yga2VlcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWdub3JlQ2FzZSA9IHBhdHRlcm47XG4gICAgICAgIHBhdHRlcm4gPSBrZWVwO1xuICAgICAgICBrZWVwID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuQW5kQ2FzZSA9IHBhdHRlcm4gKyAoaWdub3JlQ2FzZSA/ICdpJyA6ICdjJyksXG4gICAgICAgIGl0ZW0gPSBjYWNoZVtwYXR0ZXJuQW5kQ2FzZV07XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgaXRlbS53aGVuID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGlmIChrZWVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZW0ua2VlcCA9IGtlZXA7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2l6ZSA9PT0gcmVnRXhwTElLRS5jYWNoZU1heCkge1xuICAgICAgICAgICAgdmFyIGFnZSA9IFtdLCBhZ2VzID0gMCwga2V5LCBpO1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gY2FjaGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ua2VlcCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWdlczsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS53aGVuIDwgYWdlW2ldLml0ZW0ud2hlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFnZS5zcGxpY2UoaSwgMCwgeyBrZXk6IGtleSwgaXRlbTogaXRlbSB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWdlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdFeHBMSUtFKHBhdHRlcm4sIGlnbm9yZUNhc2UpOyAvLyBjYWNoZSBpcyBmdWxsIVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IE1hdGguY2VpbChhZ2UubGVuZ3RoIC8gMTApOyAvLyB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCAxXG4gICAgICAgICAgICBzaXplIC09IGk7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2FnZVtpXS5rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0ZW0gPSBjYWNoZVtwYXR0ZXJuQW5kQ2FzZV0gPSB7XG4gICAgICAgICAgICByZWdleDogcmVnRXhwTElLRShwYXR0ZXJuLCBpZ25vcmVDYXNlKSxcbiAgICAgICAgICAgIGtlZXA6IGtlZXAsXG4gICAgICAgICAgICB3aGVuOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgICB9O1xuICAgICAgICBzaXplKys7XG4gICAgfVxuICAgIHJldHVybiBpdGVtLnJlZ2V4O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZWdFeHBMSUtFO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuKGZ1bmN0aW9uIChtb2R1bGUpIHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgICAvLyBUaGlzIGNsb3N1cmUgc3VwcG9ydHMgTm9kZUpTLWxlc3MgY2xpZW50IHNpZGUgaW5jbHVkZXMgd2l0aCA8c2NyaXB0PiB0YWdzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pvbmVpdC9tbm0uXG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3IgUmFuZ2VTZWxlY3Rpb25Nb2RlbFxuICAgICAqXG4gICAgICogQGRlc2MgVGhpcyBvYmplY3QgbW9kZWxzIHNlbGVjdGlvbiBvZiBcImNlbGxzXCIgd2l0aGluIGFuIGFic3RyYWN0IHNpbmdsZS1kaW1lbnNpb25hbCBtYXRyaXguXG4gICAgICpcbiAgICAgKiBEaXNqb2ludCBzZWxlY3Rpb25zIGNhbiBiZSBidWlsdCB3aXRoIGNhbGxzIHRvIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAgICAgKiAqIHtAbGluayBSYW5nZVNlbGVjdGlvbk1vZGVsI3NlbGVjdHxzZWxlY3Qoc3RhcnQsIHN0b3ApfSAtIEFkZCBhIHJhbmdlIHRvIHRoZSBtYXRyaXguXG4gICAgICogKiB7QGxpbmsgUmFuZ2VTZWxlY3Rpb25Nb2RlbCNkZXNlbGVjdHxkZXNlbGVjdChzdGFydCwgc3RvcCl9IC0gUmVtb3ZlIGEgcmFuZ2UgZnJvbSB0aGUgbWF0cml4LlxuICAgICAqXG4gICAgICogVHdvIG1vcmUgbWV0aG9kcyBhcmUgYXZhaWxhYmxlOlxuICAgICAqICogVGVzdCBhIGNlbGwgdG8gc2VlIGlmIGl0IHtAbGluayBSYW5nZVNlbGVjdGlvbk1vZGVsI2lzU2VsZWN0ZWR8aXNTZWxlY3RlZChjZWxsKX1cbiAgICAgKiAqIHtAbGluayBSYW5nZVNlbGVjdGlvbk1vZGVsI2NsZWFyfGNsZWFyKCl9IHRoZSBtYXRyaXhcbiAgICAgKlxuICAgICAqIEludGVybmFsbHksIHRoZSBzZWxlY3Rpb24gaXMgcnVuLWxlbmd0aC1lbmNvZGVkLiBJdCBpcyB0aGVyZWZvcmUgYSBcInNwYXJzZVwiIG1hdHJpeFxuICAgICAqIHdpdGggdW5kZWZpbmVkIGJvdW5kcy4gQSBzaW5nbGUgZGF0YSBwcm9wZXJ0eSBjYWxsZWQgYHNlbGVjdGlvbmAgaXMgYW4gYXJyYXkgdGhhdFxuICAgICAqIGNvbnRhaW5zIGFsbCB0aGUgXCJydW5zXCIgKHJhbmdlcykgb2Ygc2VsZWN0ZWQgY2VsbHMgYWxiZWl0IGluIG5vIHBhcnRpY3VsYXIgb3JkZXIuXG4gICAgICogVGhpcyBwcm9wZXJ0eSBzaG91bGQgbm90IG5vcm1hbGx5IG5lZWQgdG8gYmUgYWNjZXNzZWQgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9iamVjdCBzaG91bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UmFuZ2VTZWxlY3Rpb25Nb2RlbH0gU2VsZiAoaS5lLiwgYHRoaXNgIG9iamVjdCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmFuZ2VTZWxlY3Rpb25Nb2RlbCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIHNlbGVjdGlvblxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuQXJyYXkubnVtYmVyfVxuICAgICAgICAgKiBAc3VtbWFyeSBVbm9yZGVyZWQgbGlzdCBvZiBydW5zLlxuICAgICAgICAgKiBAZGVzYyBBIFwicnVuXCIgaXMgZGVmaW5lZCBhcyBhbiBBcnJheSgyKSB3aGVyZTpcbiAgICAgICAgICogKiBlbGVtZW50IFswXSBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBydW5cbiAgICAgICAgICogKiBlbGVtZW50IFsxXSBpcyB0aGUgZW5kIG9mIHRoZSBydW4gKGluY2x1c2l2ZSkgYW5kIGlzIGFsd2F5cyA+PSBlbGVtZW50IFswXVxuICAgICAgICAgKiBUaGUgb3JkZXIgb2YgdGhlIHJ1bnMgd2l0aGluIGlzIHVuZGVmaW5lZC5cbiAgICAgICAgICogQG1lbWJlck9mIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBbXTtcblxuICAgICAgICAvL3dlIG5lZWQgdG8gYmUgYWJsZSB0byBnbyBiYWNrIGluIHRpbWVcbiAgICAgICAgLy90aGUgc3RhdGVzIGZpZWxkXG4gICAgICAgIHRoaXMuc3RhdGVzID0gW107XG5cbiAgICAgICAgLy9jbG9uZSBhbmQgc3RvcmUgbXkgY3VycmVudCBzdGF0ZVxuICAgICAgICAvL3NvIHdlIGNhbiB1bndpbmQgY2hhbmdlcyBpZiBuZWVkIGJlXG4gICAgICAgIHRoaXMuc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxzID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb3B5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29weSA9IFtdLmNvbmNhdChzZWxzW2ldKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wdXNoKGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IEFkZCBhIGNvbnRpZ3VvdXMgcnVuIG9mIHBvaW50cyB0byB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgKiBAZGVzYyBJbnNlcnQgYSBuZXcgcnVuIGludG8gYHRoaXMuc2VsZWN0aW9uYC5cbiAgICAgICAgICogVGhlIG5ldyBydW4gd2lsbCBiZSBtZXJnZWQgd2l0aCBvdmVybGFwcGluZyBhbmQgYWRqYWNlbnQgcnVucy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHR3byBwYXJhbWV0ZXJzIG1heSBiZSBnaXZlbiBpbiBlaXRoZXIgb3JkZXIuXG4gICAgICAgICAqIFRoZSBzdGFydCBhbmQgc3RvcCBlbGVtZW50cyBpbiB0aGUgcmVzdWx0aW5nIHJ1biB3aWxsIGhvd2V2ZXIgYWx3YXlzIGJlIG9yZGVyZWQuXG4gICAgICAgICAqIChIb3dldmVyLCBub3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBydW5zIHdpdGhpbiBgdGhpcy5zZWxlY3Rpb25gIGlzIGl0c2VsZiBhbHdheXMgdW5vcmRlcmVkLilcbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0IGB0aGlzLnNlbGVjdGlvbmAgaXMgdXBkYXRlZCBpbiBwbGFjZSwgcHJlc2VydmluZyB2YWxpZGl0eSBvZiBhbnkgZXh0ZXJuYWwgcmVmZXJlbmNlcy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gU3RhcnQgb2YgcnVuLiBNYXkgYmUgZ3JlYXRlciB0aGFuIGBzdG9wYC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wPXN0b3BdIC0gRW5kIG9mIHJ1biAoaW5jbHVzaXZlKS4gTWF5IGJlIGxlc3MgdGhhbiBgc3RhcnRgLlxuICAgICAgICAgKiBAcmV0dXJucyB7UmFuZ2VTZWxlY3Rpb25Nb2RlbH0gU2VsZiAoaS5lLiwgYHRoaXNgKSwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdDogZnVuY3Rpb24gKHN0YXJ0LCBzdG9wKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlU3RhdGUoKTtcbiAgICAgICAgICAgIHZhciBydW4gPSBtYWtlUnVuKHN0YXJ0LCBzdG9wKTtcbiAgICAgICAgICAgIHZhciBzcGxpY2VyID0gWzAsIDFdO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoZWFjaCkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwcyhlYWNoLCBydW4pIHx8IGFidXRzKGVhY2gsIHJ1bikpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVuID0gbWVyZ2UoZWFjaCwgcnVuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGxpY2VyLnB1c2goZWFjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzcGxpY2VyLnB1c2gocnVuKTtcbiAgICAgICAgICAgIHNwbGljZXJbMV0gPSB0aGlzLnNlbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zcGxpY2UuYXBwbHkodGhpcy5zZWxlY3Rpb24sIHNwbGljZXIpOyAvLyB1cGRhdGUgaW4gcGxhY2UgdG8gcHJlc2VydmUgZXh0ZXJuYWwgcmVmZXJlbmNlc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlbW92ZSBhIGNvbnRpZ3VvdXMgcnVuIG9mIHBvaW50cyBmcm9tIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAqIEBkZXNjIFRydW5jYXRlIGFuZC9vciByZW1vdmUgcnVuKHMpIGZyb20gYHRoaXMuc2VsZWN0aW9uYC5cbiAgICAgICAgICogUmVtb3ZpbmcgcGFydCBvZiBleGlzdGluZyBydW5zIHdpbGwgKGNvcnJlY3RseSkgc2hvcnRlbiB0aGVtIG9yIGJyZWFrIHRoZW0gaW50byB0d28gZnJhZ21lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgdHdvIHBhcmFtZXRlcnMgbWF5IGJlIGdpdmVuIGluIGVpdGhlciBvcmRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0IGB0aGlzLnNlbGVjdGlvbmAgaXMgdXBkYXRlZCBpbiBwbGFjZSwgcHJlc2VydmluZyB2YWxpZGl0eSBvZiBhbnkgZXh0ZXJuYWwgcmVmZXJlbmNlcy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gU3RhcnQgb2YgcnVuLiBNYXkgYmUgZ3JlYXRlciB0aGFuIGBzdG9wYC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wPXN0b3BdIC0gRW5kIG9mIHJ1biAoaW5jbHVzaXZlKS4gTWF5IGJlIGxlc3MgdGhhbiBgc3RhcnRgLlxuICAgICAgICAgKiBAcmV0dXJucyB7UmFuZ2VTZWxlY3Rpb25Nb2RlbH0gU2VsZiAoaS5lLiwgYHRoaXNgKSwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGRlc2VsZWN0OiBmdW5jdGlvbiAoc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgICAgIHZhciBydW4gPSBtYWtlUnVuKHN0YXJ0LCBzdG9wKTtcbiAgICAgICAgICAgIHZhciBzcGxpY2VyID0gWzAsIDBdO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoZWFjaCkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwcyhlYWNoLCBydW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaWVjZXMgPSBzdWJ0cmFjdChlYWNoLCBydW4pO1xuICAgICAgICAgICAgICAgICAgICBzcGxpY2VyID0gc3BsaWNlci5jb25jYXQocGllY2VzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGxpY2VyLnB1c2goZWFjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzcGxpY2VyWzFdID0gdGhpcy5zZWxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3BsaWNlLmFwcGx5KHRoaXMuc2VsZWN0aW9uLCBzcGxpY2VyKTsgLy8gdXBkYXRlIGluIHBsYWNlIHRvIHByZXNlcnZlIGV4dGVybmFsIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBFbXB0aWVzIGB0aGlzLnNlbGVjdGlvbmAsIGVmZmVjdGl2ZWx5IHJlbW92aW5nIGFsbCBydW5zLlxuICAgICAgICAgKiBAcmV0dXJucyB7UmFuZ2VTZWxlY3Rpb25Nb2RlbH0gU2VsZiAoaS5lLiwgYHRoaXNgKSwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IERldGVybWluZXMgaWYgdGhlIGdpdmVuIGBjZWxsYCBpcyBzZWxlY3RlZC5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgZ2l2ZW4gYGNlbGxgIGlzIHdpdGhpbiBhbnkgb2YgdGhlIHJ1bnMgaW4gYHRoaXMuc2VsZWN0aW9uYC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNlbGwgLSBUaGUgY2VsbCB0byB0ZXN0IGZvciBpbmNsdXNpb24gaW4gdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICogQG1lbWJlck9mIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLnNvbWUoZnVuY3Rpb24gKGVhY2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFjaFswXSA8PSBjZWxsICYmIGNlbGwgPD0gZWFjaFsxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgUmV0dXJuIHRoZSBpbmRleGVzIHRoYXQgYXJlIHNlbGVjdGVkLlxuICAgICAgICAgKiBAZGVzYyBSZXR1cm4gdGhlIGluZGV4ZXMgdGhhdCBhcmUgc2VsZWN0ZWQuXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheS5BcnJheS5udW1iZXJ9XG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGVhY2hbMF07IGkgPD0gZWFjaFsxXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnNvcnQoZnVuY3Rpb24gKGEsIGIpe1xuICAgICAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN1bW1hcnkgUHJlcHMgYHN0YXJ0YCBhbmQgYHN0b3BgIHBhcmFtcyBpbnRvIG9yZGVyIGFycmF5XG4gICAgICogQGZ1bmN0aW9uIG1ha2VSdW5cbiAgICAgKiBAZGVzYyBVdGlsaXR5IGZ1bmN0aW9uIGNhbGxlZCBieSBib3RoIGBzZWxlY3QoKWAgYW5kIGBkZXNlbGVjdCgpYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gc3RhcnQgLSBTdGFydCBvZiBydW4uIGlmIGFycmF5LCBgc3RhcnRgIGFuZCBgc3RvcGAgYXJlIHRha2VuIGZyb20gZmlyc3QgdHdvIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RvcD1zdGFydF0gLSBFbmQgb2YgcnVuIChpbmNsdXNpdmUpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VSdW4oc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHN0YXJ0IGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgICAgICA/IG1ha2VSdW4uYXBwbHkodGhpcywgc3RhcnQpIC8vIGV4dHJhY3QgcGFyYW1zIGZyb20gZ2l2ZW4gYXJyYXlcbiAgICAgICAgICAgICAgICA6IHN0b3AgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gWyBzdGFydCwgc3RhcnQgXSAvLyBzaW5nbGUgcGFyYW0gaXMgYSBydW4gdGhhdCBzdG9wcyB3aGVyZSBpdCBzdGFydHNcbiAgICAgICAgICAgICAgICA6IHN0YXJ0IDw9IHN0b3BcbiAgICAgICAgICAgICAgICA/IFsgc3RhcnQsIHN0b3AgXVxuICAgICAgICAgICAgICAgIDogWyBzdG9wLCBzdGFydCBdIC8vIHJldmVyc2UgZGVzY2VuZGluZyBwYXJhbXMgaW50byBhc2NlbmRpbmcgb3JkZXJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBvdmVybGFwc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIGBydW4xYCBvdmVybGFwcyBgcnVuMmBcbiAgICAgKiBAc3VtbWFyeSBDb21wYXJpc29uIG9wZXJhdG9yIHRoYXQgZGV0ZXJtaW5lcyBpZiBnaXZlbiBydW5zIG92ZXJsYXAgd2l0aCBvbmUgYW5vdGhlci5cbiAgICAgKiBAZGVzYyBCb3RoIHBhcmFtZXRlcnMgYXJlIGFzc3VtZWQgdG8gYmUgX29yZGVyZWRfIGFycmF5cy5cbiAgICAgKlxuICAgICAqIE92ZXJsYXAgaXMgZGVmaW5lZCB0byBpbmNsdWRlIHRoZSBjYXNlIHdoZXJlIG9uZSBydW4gY29tcGxldGVseSBjb250YWlucyB0aGUgb3RoZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdG9yIGlzIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjEgLSBmaXJzdCBydW5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4yIC0gc2Vjb25kIHJ1blxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG92ZXJsYXBzKHJ1bjEsIHJ1bjIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJ1bjFbMF0gPD0gcnVuMlswXSAmJiBydW4yWzBdIDw9IHJ1bjFbMV0gfHwgLy8gcnVuMidzIHN0YXJ0IGlzIHdpdGhpbiBydW4xIE9SLi4uXG4gICAgICAgICAgICBydW4xWzBdIDw9IHJ1bjJbMV0gJiYgcnVuMlsxXSA8PSBydW4xWzFdIHx8IC8vIHJ1bjIncyBzdG9wIGlzIHdpdGhpbiBydW4xIE9SLi4uXG4gICAgICAgICAgICBydW4yWzBdIDwgIHJ1bjFbMF0gJiYgcnVuMVsxXSA8ICBydW4yWzFdICAgIC8vIHJ1bjIgY29tcGxldGVseSBjb250YWlucyBydW4xXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gYWJ1dHNcbiAgICAgKiBAc3VtbWFyeSBDb21wYXJpc29uIG9wZXJhdG9yIHRoYXQgZGV0ZXJtaW5lcyBpZiBnaXZlbiBydW5zIGFyZSBjb25zZWN1dGl2ZSB3aXRoIG9uZSBhbm90aGVyLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIGBydW4xYCBpcyBjb25zZWN1dGl2ZSB3aXRoIGBydW4yYFxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBvcGVyYXRvciBpcyBjb21tdXRhdGl2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4xIC0gZmlyc3QgcnVuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcnVuMiAtIHNlY29uZCBydW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhYnV0cyhydW4xLCBydW4yKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBydW4xWzFdID09PSBydW4yWzBdIC0gMSB8fCAvLyBydW4xJ3MgdG9wIGltbWVkaWF0ZWx5IHByZWNlZGVzIHJ1bjIncyBzdGFydCBPUi4uLlxuICAgICAgICAgICAgcnVuMlsxXSA9PT0gcnVuMVswXSAtIDEgICAgLy8gcnVuMidzIHRvcCBpbW1lZGlhdGVseSBwcmVjZWRlcyBydW4xJ3Mgc3RhcnRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBzdWJ0cmFjdFxuICAgICAqIEBzdW1tYXJ5IE9wZXJhdG9yIHRoYXQgc3VidHJhY3RzIG9uZSBydW4gZnJvbSBhbm90aGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS5BcnJheS5udW1iZXJ9IFRoZSByZW1haW5pbmcgcGllY2VzIG9mIGBtaW51ZW5kYCBhZnRlciByZW1vdmluZyBgc3VidHJhaGVuZGAuXG4gICAgICogQGRlc2MgQm90aCBwYXJhbWV0ZXJzIGFyZSBhc3N1bWVkIHRvIGJlIF9vcmRlcmVkXyBhcnJheXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIF9kb2VzIG5vdCBhc3N1bWVzXyB0aGF0IGBvdmVybGFwKClgIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkIHdpdGggdGhlIHNhbWUgcnVucyBhbmQgaGFzIHJldHVybmVkIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIFJldHVybmVkIGFycmF5IGNvbnRhaW5zIDAsIDEsIG9yIDIgcnVucyB3aGljaCBhcmUgdGhlIHBvcnRpb24ocykgb2YgYG1pbnVlbmRgIHRoYXQgZG8gX25vdF8gaW5jbHVkZSBgc3VidHJhaGVuZGAuXG4gICAgICpcbiAgICAgKiBDYXZlYXQ6IFRoaXMgb3BlcmF0b3IgaXMgKm5vdCogY29tbXV0YXRpdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gbWludWVuZCAtIGEgcnVuIGZyb20gd2hpY2ggdG8gXCJzdWJ0cmFjdFwiIGBzdWJ0cmFoZW5kYFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHN1YnRyYWhlbmQgLSBhIHJ1biB0byBcInN1YnRyYWN0ZWRcIiBmcm9tIGBtaW51ZW5kYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgICAgdmFyIG0wID0gbWludWVuZFswXTtcbiAgICAgICAgdmFyIG0xID0gbWludWVuZFsxXTtcbiAgICAgICAgdmFyIHMwID0gc3VidHJhaGVuZFswXTtcbiAgICAgICAgdmFyIHMxID0gc3VidHJhaGVuZFsxXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmIChzMCA8PSBtMCAmJiBzMSA8IG0xKSB7XG4gICAgICAgICAgICAvL3N1YnRyYWhlbmQgZXh0ZW5kcyBiZWZvcmUgbWludWVuZDogcmV0dXJuIHJlbWFpbmluZyBwaWVjZSBvZiBgbWludWVuZGBcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtzMSArIDEsIG0xXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoczAgPiBtMCAmJiBzMSA+PSBtMSkge1xuICAgICAgICAgICAgLy9zdWJ0cmFoZW5kIGV4dGVuZHMgYWZ0ZXIgbWludWVuZDogcmV0dXJuIHJlbWFpbmluZyBwaWVjZSBvZiBgbWludWVuZGBcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFttMCwgczAgLSAxXSk7XG4gICAgICAgIH0gZWxzZSBpZiAobTAgPCBzMCAmJiBzMSA8IG0xKSB7XG4gICAgICAgICAgICAvL2NvbXBsZXRlbHkgaW5zaWRlOiByZXR1cm4gMiBzbWFsbGVyIHBpZWNlcyByZXN1bHRpbmcgZnJvbSB0aGUgaG9sZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goW20wLCBzMCAtIDFdKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtzMSArIDEsIG0xXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoczEgPCBtMCB8fCBzMCA+IG0xKSB7XG4gICAgICAgICAgICAvLyBjb21wbGV0ZWx5IG91dHNpZGU6IHJldHVybiBgbWludWVuZGAgdW50b3VjaGVkXG4gICAgICAgICAgICByZXN1bHQucHVzaChtaW51ZW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZWxzZSBzdWJ0cmFoZW5kIG11c3QgY29tcGxldGVseSBvdmVybGFwIG1pbnVlbmQgc28gcmV0dXJuIG5vIHBpZWNlc1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG5cbiAgICAvLyBMb2NhbCB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gbWVyZ2VcbiAgICAgKiBAc3VtbWFyeSBPcGVyYXRvciB0aGF0IG1lcmdlcyBnaXZlbiBydW5zLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gQSBzaW5nbGUgbWVyZ2VkIHJ1bi5cbiAgICAgKiBAZGVzYyBCb3RoIHBhcmFtZXRlcnMgYXJlIGFzc3VtZWQgdG8gYmUgX29yZGVyZWRfIGFycmF5cy5cbiAgICAgKlxuICAgICAqIFRoZSBydW5zIGFyZSBhc3N1bWVkIHRvIGJlIG92ZXJsYXBwaW5nIG9yIGFkamFjZW50IHRvIG9uZSBhbm90aGVyLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBvcGVyYXRvciBpcyBjb21tdXRhdGl2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4xIC0gYSBydW4gdG8gbWVyZ2Ugd2l0aCBgcnVuMmBcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4yIC0gYSBydW4gdG8gbWVyZ2Ugd2l0aCBgcnVuMWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZShydW4xLCBydW4yKSB7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihNYXRoLm1pbi5hcHBseShNYXRoLCBydW4xKSwgTWF0aC5taW4uYXBwbHkoTWF0aCwgcnVuMikpO1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgoTWF0aC5tYXguYXBwbHkoTWF0aCwgcnVuMSksIE1hdGgubWF4LmFwcGx5KE1hdGgsIHJ1bjIpKTtcbiAgICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfVxuXG4gICAgLy8gSW50ZXJmYWNlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSYW5nZVNlbGVjdGlvbk1vZGVsO1xufSkoXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlIHx8ICh3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbCA9IHt9KSxcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyB8fCAod2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWwuZXhwb3J0cyA9IHt9KVxuKSB8fCAoXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgfHwgKHdpbmRvdy5SYW5nZVNlbGVjdGlvbk1vZGVsID0gd2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWwuZXhwb3J0cylcbik7XG5cbi8qIEFib3V0IHRoZSBhYm92ZSBJSUZFOlxuICogVGhpcyBmaWxlIGlzIGEgXCJtb2RpZmllZCBub2RlIG1vZHVsZS5cIiBJdCBmdW5jdGlvbnMgYXMgdXN1YWwgaW4gTm9kZS5qcyAqYW5kKiBpcyBhbHNvIHVzYWJsZSBkaXJlY3RseSBpbiB0aGUgYnJvd3Nlci5cbiAqIDEuIE5vZGUuanM6IFRoZSBJSUZFIGlzIHN1cGVyZmx1b3VzIGJ1dCBpbm5vY3VvdXMuXG4gKiAyLiBJbiB0aGUgYnJvd3NlcjogVGhlIElJRkUgY2xvc3VyZSBzZXJ2ZXMgdG8ga2VlcCBpbnRlcm5hbCBkZWNsYXJhdGlvbnMgcHJpdmF0ZS5cbiAqIDIuYS4gSW4gdGhlIGJyb3dzZXIgYXMgYSBnbG9iYWw6IFRoZSBsb2dpYyBpbiB0aGUgYWN0dWFsIHBhcmFtZXRlciBleHByZXNzaW9ucyArIHRoZSBwb3N0LWludm9jYXRpb24gZXhwcmVzc2lvblxuICogd2lsbCBwdXQgeW91ciBBUEkgaW4gYHdpbmRvdy5SYW5nZVNlbGVjdGlvbk1vZGVsYC5cbiAqIDIuYi4gSW4gdGhlIGJyb3dzZXIgYXMgYSBtb2R1bGU6IElmIHlvdSBwcmVkZWZpbmUgYSBgd2luZG93Lm1vZHVsZWAgb2JqZWN0LCB0aGUgcmVzdWx0cyB3aWxsIGJlIGluIGBtb2R1bGUuZXhwb3J0c2AuXG4gKiBUaGUgYm93ZXIgY29tcG9uZW50IGBtbm1gIG1ha2VzIHRoaXMgZWFzeSBhbmQgYWxzbyBwcm92aWRlcyBhIGdsb2JhbCBgcmVxdWlyZSgpYCBmdW5jdGlvbiBmb3IgcmVmZXJlbmNpbmcgeW91ciBtb2R1bGVcbiAqIGZyb20gb3RoZXIgY2xvc3VyZXMuIEluIGVpdGhlciBjYXNlLCB0aGlzIHdvcmtzIHdpdGggYm90aCBOb2RlSnMtc3R5bGUgZXhwb3J0IG1lY2hhbmlzbXMgLS0gYSBzaW5nbGUgQVBJIGFzc2lnbm1lbnQsXG4gKiBgbW9kdWxlLmV4cG9ydHMgPSB5b3VyQVBJYCAqb3IqIGEgc2VyaWVzIG9mIGluZGl2aWR1YWwgcHJvcGVydHkgYXNzaWdubWVudHMsIGBtb2R1bGUuZXhwb3J0cy5wcm9wZXJ0eSA9IHByb3BlcnR5YC5cbiAqXG4gKiBCZWZvcmUgdGhlIElJRkUgcnVucywgdGhlIGFjdHVhbCBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgYXJlIGV4ZWN1dGVkOlxuICogMS4gSWYgYHdpbmRvd2Agb2JqZWN0IHVuZGVmaW5lZCwgd2UncmUgaW4gTm9kZUpzIHNvIGFzc3VtZSB0aGVyZSBpcyBhIGBtb2R1bGVgIG9iamVjdCB3aXRoIGFuIGBleHBvcnRzYCBwcm9wZXJ0eVxuICogMi4gSWYgYHdpbmRvd2Agb2JqZWN0IGRlZmluZWQsIHdlJ3JlIGluIGJyb3dzZXJcbiAqIDIuYS4gSWYgYG1vZHVsZWAgb2JqZWN0IHByZWRlZmluZWQsIHVzZSBpdFxuICogMi5iLiBJZiBgbW9kdWxlYCBvYmplY3QgdW5kZWZpbmVkLCBjcmVhdGUgYSBgUmFuZ2VTZWxlY3Rpb25Nb2RlbGAgb2JqZWN0XG4gKlxuICogQWZ0ZXIgdGhlIElJRkUgcmV0dXJuczpcbiAqIEJlY2F1c2UgaXQgYWx3YXlzIHJldHVybnMgdW5kZWZpbmVkLCB0aGUgZXhwcmVzc2lvbiBhZnRlciB0aGUgfHwgd2lsbCBleGVjdXRlOlxuICogMS4gSWYgYHdpbmRvd2Agb2JqZWN0IHVuZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBOb2RlSnMgc28gd2UncmUgZG9uZVxuICogMi4gSWYgYHdpbmRvd2Agb2JqZWN0IGRlZmluZWQsIHRoZW4gd2UncmUgaW4gYnJvd3NlclxuICogMi5hLiBJZiBgbW9kdWxlYCBvYmplY3QgcHJlZGVmaW5lZCwgd2UncmUgZG9uZTsgcmVzdWx0cyBhcmUgaW4gYG1vdWR1bGUuZXhwb3J0c2BcbiAqIDIuYi4gSWYgYG1vZHVsZWAgb2JqZWN0IHVuZGVmaW5lZCwgcmVkZWZpbmVgUmFuZ2VTZWxlY3Rpb25Nb2RlbGAgdG8gYmUgdGhlIGBSYW5nZVNlbGVjdGlvbk1vZGVsLmV4cG9ydHNgIG9iamVjdFxuICovXG4iLCIvLyB0ZW1wbGV4IG5vZGUgbW9kdWxlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L3RlbXBsZXhcblxuLyogZXNsaW50LWVudiBub2RlICovXG5cbi8qKlxuICogTWVyZ2VzIHZhbHVlcyBvZiBleGVjdXRpb24gY29udGV4dCBwcm9wZXJ0aWVzIG5hbWVkIGluIHRlbXBsYXRlIGJ5IHtwcm9wMX0sXG4gKiB7cHJvcDJ9LCBldGMuLCBvciBhbnkgamF2YXNjcmlwdCBleHByZXNzaW9uIGluY29ycG9yYXRpbmcgc3VjaCBwcm9wIG5hbWVzLlxuICogVGhlIGNvbnRleHQgYWx3YXlzIGluY2x1ZGVzIHRoZSBnbG9iYWwgb2JqZWN0LiBJbiBhZGRpdGlvbiB5b3UgY2FuIHNwZWNpZnkgYSBzaW5nbGVcbiAqIGNvbnRleHQgb3IgYW4gYXJyYXkgb2YgY29udGV4dHMgdG8gc2VhcmNoIChpbiB0aGUgb3JkZXIgZ2l2ZW4pIGJlZm9yZSBmaW5hbGx5XG4gKiBzZWFyY2hpbmcgdGhlIGdsb2JhbCBjb250ZXh0LlxuICpcbiAqIE1lcmdlIGV4cHJlc3Npb25zIGNvbnNpc3Rpbmcgb2Ygc2ltcGxlIG51bWVyaWMgdGVybXMsIHN1Y2ggYXMgezB9LCB7MX0sIGV0Yy4sIGRlcmVmXG4gKiB0aGUgZmlyc3QgY29udGV4dCBnaXZlbiwgd2hpY2ggaXMgYXNzdW1lZCB0byBiZSBhbiBhcnJheS4gQXMgYSBjb252ZW5pZW5jZSBmZWF0dXJlLFxuICogaWYgYWRkaXRpb25hbCBhcmdzIGFyZSBnaXZlbiBhZnRlciBgdGVtcGxhdGVgLCBgYXJndW1lbnRzYCBpcyB1bnNoaWZ0ZWQgb250byB0aGUgY29udGV4dFxuICogYXJyYXksIHRodXMgbWFraW5nIGZpcnN0IGFkZGl0aW9uYWwgYXJnIGF2YWlsYWJsZSBhcyB7MX0sIHNlY29uZCBhcyB7Mn0sIGV0Yy4sIGFzIGluXG4gKiBgdGVtcGxleCgnSGVsbG8sIHsxfSEnLCAnV29ybGQnKWAuICh7MH0gaXMgdGhlIHRlbXBsYXRlIHNvIGNvbnNpZGVyIHRoaXMgdG8gYmUgMS1iYXNlZC4pXG4gKlxuICogSWYgeW91IHByZWZlciBzb21ldGhpbmcgb3RoZXIgdGhhbiBicmFjZXMsIHJlZGVmaW5lIGB0ZW1wbGV4LnJlZ2V4cGAuXG4gKlxuICogU2VlIHRlc3RzIGZvciBleGFtcGxlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBbYXJnc11cbiAqL1xuZnVuY3Rpb24gdGVtcGxleCh0ZW1wbGF0ZSkge1xuICAgIHZhciBjb250ZXh0cyA9IHRoaXMgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMgOiBbdGhpc107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7IGNvbnRleHRzLnVuc2hpZnQoYXJndW1lbnRzKTsgfVxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKHRlbXBsZXgucmVnZXhwLCB0ZW1wbGV4Lm1lcmdlci5iaW5kKGNvbnRleHRzKSk7XG59XG5cbnRlbXBsZXgucmVnZXhwID0gL1xceyguKj8pXFx9L2c7XG5cbnRlbXBsZXgud2l0aCA9IGZ1bmN0aW9uIChpLCBzKSB7XG4gICAgcmV0dXJuICd3aXRoKHRoaXNbJyArIGkgKyAnXSl7JyArIHMgKyAnfSc7XG59O1xuXG50ZW1wbGV4LmNhY2hlID0gW107XG5cbnRlbXBsZXguZGVyZWYgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCEodGhpcy5sZW5ndGggaW4gdGVtcGxleC5jYWNoZSkpIHtcbiAgICAgICAgdmFyIGNvZGUgPSAncmV0dXJuIGV2YWwoZXhwciknO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29kZSA9IHRlbXBsZXgud2l0aChpLCBjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBsZXguY2FjaGVbdGhpcy5sZW5ndGhdID0gZXZhbCgnKGZ1bmN0aW9uKGV4cHIpeycgKyBjb2RlICsgJ30pJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuICAgIH1cbiAgICByZXR1cm4gdGVtcGxleC5jYWNoZVt0aGlzLmxlbmd0aF0uY2FsbCh0aGlzLCBrZXkpO1xufTtcblxudGVtcGxleC5tZXJnZXIgPSBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuICAgIC8vIEFkdmFuY2VkIGZlYXR1cmVzOiBDb250ZXh0IGNhbiBiZSBhIGxpc3Qgb2YgY29udGV4dHMgd2hpY2ggYXJlIHNlYXJjaGVkIGluIG9yZGVyLlxuICAgIHZhciByZXBsYWNlbWVudDtcblxuICAgIHRyeSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gaXNOYU4oa2V5KSA/IHRlbXBsZXguZGVyZWYuY2FsbCh0aGlzLCBrZXkpIDogdGhpc1swXVtrZXldO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSAneycgKyBrZXkgKyAnfSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcGxhY2VtZW50O1xufTtcblxuLy8gdGhpcyBpbnRlcmZhY2UgY29uc2lzdHMgc29sZWx5IG9mIHRoZSB0ZW1wbGV4IGZ1bmN0aW9uIChhbmQgaXQncyBwcm9wZXJ0aWVzKVxubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGV4O1xuIiwiLy8gQ3JlYXRlZCBieSBKb25hdGhhbiBFaXRlbiBvbiAxLzcvMTYuXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBWZXJ5IGZhc3QgYXJyYXkgdGVzdC5cbiAqIEZvciBjcm9zcy1mcmFtZSBzY3JpcHRpbmc7IHVzZSBgY3Jvc3NGcmFtZXNJc0FycmF5YCBpbnN0ZWFkLlxuICogQHBhcmFtIHsqfSBhcnIgLSBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudW5zdHJ1bmdpZnkuaXNBcnJheSA9IGZ1bmN0aW9uKGFycikgeyByZXR1cm4gYXJyLmNvbnN0cnVjdG9yID09PSBBcnJheTsgfTtcblxuLyoqXG4gKiBAc3VtbWFyeSBXYWxrIGEgaGllcmFyY2hpY2FsIG9iamVjdCBhcyBKU09OLnN0cmluZ2lmeSBkb2VzIGJ1dCB3aXRob3V0IHNlcmlhbGl6aW5nLlxuICpcbiAqIEBkZXNjIFVzYWdlOlxuICogKiB2YXIgbXlEaXN0aWxsZWRPYmplY3QgPSB1bnN0cnVuZ2lmeS5jYWxsKG15T2JqZWN0KTtcbiAqICogdmFyIG15RGlzdGlsbGVkT2JqZWN0ID0gbXlBcGkuZ2V0U3RhdGUoKTsgLy8gd2hlcmUgbXlBcGkucHJvdG90eXBlLmdldFN0YXRlID0gdW5zdHJ1bmdpZnlcbiAqXG4gKiBSZXN1bHQgZXF1aXZhbGVudCB0byBgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzKSlgLlxuICpcbiAqID4gRG8gbm90IHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGdldCBhIEpTT04gc3RyaW5nOyB1c2UgYEpTT04uc3RyaW5naWZ5KHRoaXMpYCBpbnN0ZWFkLlxuICpcbiAqIEB0aGlzIHsqfG9iamVjdHwqW119IC0gT2JqZWN0IHRvIHdhbGs7IHR5cGljYWxseSBhbiBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5udWxsRWxlbWVudHM9PWZhbHNlXSAtIFByZXNlcnZlIHVuZGVmaW5lZCBhcnJheSBlbGVtZW50cyBhcyBgbnVsbGBzLlxuICogVXNlIHRoaXMgd2hlbiBwcmVjaXNlIGluZGV4IG1hdHRlcnMgKG5vdCBtZXJlbHkgdGhlIG9yZGVyIG9mIHRoZSBlbGVtZW50cykuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5udWxsUHJvcGVydGllcz09ZmFsc2VdIC0gUHJlc2VydmUgdW5kZWZpbmVkIG9iamVjdCBwcm9wZXJ0aWVzIGFzIGBudWxsYHMuXG4gKlxuICogQHJldHVybnMge29iamVjdH0gLSBEaXN0aWxsZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiB1bnN0cnVuZ2lmeShvcHRpb25zKSB7XG4gICAgdmFyIGNsb25lLCBwcmVzZXJ2ZSxcbiAgICAgICAgb2JqZWN0ID0gKHR5cGVvZiB0aGlzLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLnRvSlNPTigpIDogdGhpcztcblxuICAgIGlmICh1bnN0cnVuZ2lmeS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgY2xvbmUgPSBbXTtcbiAgICAgICAgcHJlc2VydmUgPSBvcHRpb25zICYmIG9wdGlvbnMubnVsbEVsZW1lbnRzO1xuICAgICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHVuc3RydW5naWZ5LmNhbGwob2JqKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUucHVzaChudWxsKTsgLy8gdW5kZWZpbmVkIG5vdCBhIHZhbGlkIEpTT04gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY2xvbmUgPSB7fTtcbiAgICAgICAgcHJlc2VydmUgPSBvcHRpb25zICYmIG9wdGlvbnMubnVsbFByb3BlcnRpZXM7XG4gICAgICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuc3RydW5naWZ5LmNhbGwob2JqZWN0W2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjbG9uZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVba2V5XSA9IG51bGw7IC8vIHVuZGVmaW5lZCBub3QgYSB2YWxpZCBKU09OIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb25lID0gb2JqZWN0O1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbn1cblxuLyoqXG4gKiBWZXJ5IHNsb3cgYXJyYXkgdGVzdC4gU3VpdGFibGUgZm9yIGNyb3NzLWZyYW1lIHNjcmlwdGluZy5cbiAqXG4gKiBTdWdnZXN0aW9uOiBJZiB5b3UgbmVlZCB0aGlzIGFuZCBoYXZlIGpRdWVyeSBsb2FkZWQsIHVzZSBgalF1ZXJ5LmlzQXJyYXlgIGluc3RlYWQgd2hpY2ggaXMgcmVhc29uYWJseSBmYXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gYXJyIC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnVuc3RydW5naWZ5LmNyb3NzRnJhbWVzSXNBcnJheSA9IGZ1bmN0aW9uKGFycikgeyByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09PSBhcnJTdHJpbmc7IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZywgYXJyU3RyaW5nID0gJ1tvYmplY3QgQXJyYXldJztcblxubW9kdWxlLmV4cG9ydHMgPSB1bnN0cnVuZ2lmeTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtbWUnKTtcbnZhciBkZXByZWNhdGVkID0gcmVxdWlyZSgnLi9saWIvZGVwcmVjYXRlZCcpO1xuZXh0ZW5kLmRlYnVnID0gdHJ1ZTtcblxudmFyIEZpbkJhciA9IHJlcXVpcmUoJ2ZpbmJhcnMnKTtcbnZhciBDYW52YXMgPSByZXF1aXJlKCdmaW5jYW52YXMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3JlY3Rhbmd1bGFyJykuUG9pbnQ7XG52YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKS5SZWN0YW5nbGU7XG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xudmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi9saWIvUmVuZGVyZXInKTtcbnZhciBTZWxlY3Rpb25Nb2RlbCA9IHJlcXVpcmUoJy4vbGliL1NlbGVjdGlvbk1vZGVsJyk7XG52YXIgYWRkU3R5bGVzaGVldCA9IHJlcXVpcmUoJy4uL2Nzcy9zdHlsZXNoZWV0cycpO1xudmFyIFRhYmxlRGlhbG9nID0gcmVxdWlyZSgnLi9saWIvVGFibGVEaWFsb2cnKTtcbnZhciBGb3JtYXR0ZXJzID0gcmVxdWlyZSgnLi9saWIvRm9ybWF0dGVycycpO1xuXG52YXIgdGhlbWVJbml0aWFsaXplZCA9IGZhbHNlLFxuICAgIHBvbHltZXJUaGVtZSA9IE9iamVjdC5jcmVhdGUoZGVmYXVsdHMpLFxuICAgIGdsb2JhbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKHBvbHltZXJUaGVtZSk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fSBkaXYgLSBDU1Mgc2VsZWN0b3Igb3IgRWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGJlaGF2aW9yTmFtZSAtIG5hbWUgb2YgYSBiZWhhdmlvciBjb25zdHJ1Y3RvciBmcm9tIC4vYmVoYXZpb3JzXG4gKiBAcGFyYW0ge29iamVjdH0gW21hcmdpbl0gLSBvcHRpb25hbCBjYW52YXMgbWFyZ2luc1xuICogQHBhcmFtIHtzdHJpbmd9IFttYXJnaW4udG9wXVxuICogQHBhcmFtIHtzdHJpbmd9IFttYXJnaW4ucmlnaHQ9Jy0yMDBweCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW21hcmdpbi5ib3R0b21dXG4gKiBAcGFyYW0ge3N0cmluZ30gW21hcmdpbi5sZWZ0XVxuICovXG5mdW5jdGlvbiBIeXBlcmdyaWQoZGl2LCBiZWhhdmlvckZhY3RvcnksIG1hcmdpbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuZGl2ID0gKHR5cGVvZiBkaXYgPT09ICdzdHJpbmcnKSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZGl2KSA6IGRpdjtcblxuICAgIGFkZFN0eWxlc2hlZXQoJ2dyaWQnKTtcblxuICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb24gPSBbMCwgMF07XG5cbiAgICB0aGlzLmxuZlByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGdsb2JhbFByb3BlcnRpZXMpO1xuXG4gICAgdGhpcy5pc1dlYmtpdCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd3ZWJraXQnKSA+IC0xO1xuICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwgPSBuZXcgU2VsZWN0aW9uTW9kZWwodGhpcyk7XG4gICAgdGhpcy5sb2NhbENlbGxFZGl0b3JzID0ge307XG4gICAgdGhpcy5jZWxsRWRpdG9ycyA9IE9iamVjdC5jcmVhdGUodGhpcy5sb2NhbENlbGxFZGl0b3JzKTtcbiAgICB0aGlzLnJlbmRlck92ZXJyaWRlc0NhY2hlID0ge307XG4gICAgdGhpcy5iZWhhdmlvciA9IGJlaGF2aW9yRmFjdG9yeSh0aGlzKTtcblxuICAgIC8vcHJldmVudCB0aGUgZGVmYXVsdCBjb250ZXh0IG1lbnUgZm9yIGFwcGVhcmluZ1xuICAgIHRoaXMuZGl2Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXJNb3VzZURvd24oKTtcbiAgICB0aGlzLmRyYWdFeHRlbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5udW1Sb3dzID0gMDtcbiAgICB0aGlzLm51bUNvbHVtbnMgPSAwO1xuXG4gICAgLy9pbnN0YWxsIGFueSBwbHVnaW5zXG4gICAgdGhpcy5wbHVnaW5zRG8oZnVuY3Rpb24oZWFjaCkge1xuICAgICAgICBpZiAoZWFjaC5pbnN0YWxsT24pIHtcbiAgICAgICAgICAgIGVhY2guaW5zdGFsbE9uKHNlbGYpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtYXJnaW4gPSBtYXJnaW4gfHwge307XG4gICAgbWFyZ2luLnRvcCA9IG1hcmdpbi50b3AgfHwgMDtcbiAgICBtYXJnaW4ucmlnaHQgPSBtYXJnaW4ucmlnaHQgfHwgJy0yMDBweCc7XG4gICAgbWFyZ2luLmJvdHRvbSA9IG1hcmdpbi5ib3R0b20gfHwgMDtcbiAgICBtYXJnaW4ubGVmdCA9IG1hcmdpbi5sZWZ0IHx8IDA7XG5cbiAgICAvL2luaXRpYWxpemUgb3VyIHZhcmlvdXMgcGllY2VzXG4gICAgaWYgKCF0aGVtZUluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoZW1lSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBidWlsZFBvbHltZXJUaGVtZSgpO1xuICAgIH1cbiAgICB0aGlzLmluaXRSZW5kZXJlcigpO1xuICAgIHRoaXMuaW5pdENhbnZhcyhtYXJnaW4pO1xuICAgIHRoaXMuaW5pdFNjcm9sbGJhcnMoKTtcbiAgICB0aGlzLmluaXRMb2NhbENlbGxFZGl0b3JzKCk7XG5cbiAgICAvL1JlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIHRoZSBjb3B5IGV2ZW50IHNvIHdlIGNhbiBjb3B5IG91ciBzZWxlY3RlZCByZWdpb24gdG8gdGhlIHBhc3RlYnVmZmVyIGlmIGNvbmRpdGlvbnMgYXJlIHJpZ2h0LlxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY29weScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBzZWxmLmNoZWNrQ2xpcGJvYXJkQ29weShldnQpO1xuICAgIH0pO1xuICAgIHRoaXMuZ2V0Q2FudmFzKCkucmVzaXplKCk7XG5cbiAgICB0aGlzLmRpYWxvZyA9IG5ldyBUYWJsZURpYWxvZyh0aGlzKTtcbiAgICAvL3RoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG59XG5cbkh5cGVyZ3JpZC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IEh5cGVyZ3JpZC5wcm90b3R5cGUuY29uc3RydWN0b3IsXG5cbiAgICBkZXByZWNhdGVkOiBkZXByZWNhdGVkLFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIG51bGwgb2JqZWN0IGJlaGF2aW9yIHNlcnZlcyBhcyBhIHBsYWNlIGhvbGRlci5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgYmVoYXZpb3I6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgcmVzdWxhbn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGlzV2Via2l0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIGFuIGluaXRpYWwgbW91c2Vkb3duIGNsaWNrLCBlaXRoZXIgZm9yIGVkaXRpbmcgYSBjZWxsIG9yIGZvciBkcmFnZ2luZyBhIHNlbGVjdGlvbi5cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtb3VzZURvd246IFtdLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVudCBmcm9tIHRoZSBtb3VzZWRvd24gcG9pbnQgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBkcmFnRXh0ZW50OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQSBmbG9hdCB2YWx1ZSBiZXR3ZWVuIDAuMCAtIDEuMCBvZiB0aGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2U2Nyb2xsVmFsdWU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBIGZsb2F0IHZhbHVlIGJldHdlZW4gMC4wIC0gMS4wIG9mIHRoZSBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgaFNjcm9sbFZhbHVlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyfSByZWN0YW5ndWxhciAtIE5hbWVzcGFjZSBmb3IgUG9pbnQgYW5kIFJlY3RhbmdsZSBcImNsYXNzZXNcIiAoY29uc3RydWN0b3JzKS5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlY3Rhbmd1bGFyOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbH0gc2VsZWN0aW9uTW9kZWwgLSBBIFtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbF0obW9kdWxlLS5fc2VsZWN0aW9uLW1vZGVsLmh0bWwpIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2VsZWN0aW9uTW9kZWw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Zpbi1oeXBlcmdyaWQtY2VsbC1lZGl0b3J9IGNlbGxFZGl0b3IgLSBUaGUgY3VycmVudCBpbnN0YW5jZSBvZiBbZmluLWh5cGVyZ3JpZC1jZWxsLWVkaXRvcl0obW9kdWxlLWNlbGwtZWRpdG9yc19iYXNlLmh0bWwpLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgY2VsbEVkaXRvcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7ZmluLXZhbXBpcmUtYmFyfSBzYkhTY3JvbGxlciAtIEFuIGluc3RhbmNlIG9mIFtmaW4tdmFtcGlyZS1iYXJdKGh0dHA6Ly9kYXRhbWFkaWMuZ2l0aHViLmlvL2Zpbi12YW1waXJlLWJhci9jb21wb25lbnRzL2Zpbi12YW1waXJlLWJhci8pLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JIU2Nyb2xsZXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Zpbi12YW1waXJlLWJhcn0gc2JWU2Nyb2xsZXIgLSBBbiBpbnN0YW5jZSBvZiBbZmluLXZhbXBpcmUtYmFyXShodHRwOi8vZGF0YW1hZGljLmdpdGh1Yi5pby9maW4tdmFtcGlyZS1iYXIvY29tcG9uZW50cy9maW4tdmFtcGlyZS1iYXIvKS5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiVlNjcm9sbGVyOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIHZhbHVlIG9mIHNiVlNjcm9sbFZhbC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JQcmV2VlNjcm9sbFZhbHVlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIHZhbHVlIG9mIHNiSFNjcm9sbFZhbHVlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYlByZXZIU2Nyb2xsVmFsdWU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FjaGUgb2Ygc2luZ2xldG9uIGNlbGxFZGl0b3JzLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjZWxsRWRpdG9yczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGlzIHRoZSBzaG9ydCB0ZXJtIG1lbW9yeSBvZiB3aGF0IGNvbHVtbiBJIG1pZ2h0IGJlIGRyYWdnaW5nIGFyb3VuZFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIHJlbmRlck92ZXJyaWRlc0NhY2hlOiB7fSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCBob3ZlcmVkIGNlbGwuXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgaG92ZXJDZWxsOiBudWxsLFxuXG4gICAgc2Nyb2xsaW5nTm93OiBmYWxzZSxcblxuICAgIGxhc3RFZGdlU2VsZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICBjbGVhciBvdXQgdGhlIExSVSBjYWNoZSBvZiB0ZXh0IHdpZHRoc1xuICAgICAqL1xuICAgIHNldEF0dHJpYnV0ZTogZnVuY3Rpb24oYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgY2xlYXIgb3V0IGFsbCBzdGF0ZSBhbmQgZGF0YSBvZiB0aGUgZ3JpZFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvbiA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5sbmZQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShnbG9iYWxQcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbCA9IG5ldyBTZWxlY3Rpb25Nb2RlbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jZWxsRWRpdG9ycyA9IE9iamVjdC5jcmVhdGUodGhpcy5sb2NhbENlbGxFZGl0b3JzKTtcbiAgICAgICAgdGhpcy5yZW5kZXJPdmVycmlkZXNDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmNsZWFyTW91c2VEb3duKCk7XG4gICAgICAgIHRoaXMuZHJhZ0V4dGVudCA9IG5ldyBQb2ludCgwLCAwKTtcblxuICAgICAgICB0aGlzLm51bVJvd3MgPSAwO1xuICAgICAgICB0aGlzLm51bUNvbHVtbnMgPSAwO1xuXG4gICAgICAgIHRoaXMudlNjcm9sbFZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5oU2Nyb2xsVmFsdWUgPSAwO1xuXG4gICAgICAgIHRoaXMuY2VsbEVkaXRvciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5zYlByZXZWU2Nyb2xsVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnNiUHJldkhTY3JvbGxWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5ob3ZlckNlbGwgPSBudWxsO1xuICAgICAgICB0aGlzLnNjcm9sbGluZ05vdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RFZGdlU2VsZWN0aW9uID0gWzAsIDBdO1xuXG4gICAgICAgIHRoaXMuYmVoYXZpb3IucmVzZXQoKTtcbiAgICAgICAgdGhpcy5nZXRSZW5kZXJlcigpLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkucmVzaXplKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8vcmVzZXRUZXh0V2lkdGhDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gICAgdGV4dFdpZHRoQ2FjaGUgPSBuZXcgTFJVQ2FjaGUoMjAwMCk7XG4gICAgLy99LFxuXG4gICAgZ2V0UHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBfZ2V0UHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxuZlByb3BlcnRpZXM7XG4gICAgfSxcblxuICAgIGNvbXB1dGVDZWxsc0JvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICAgICAgICByZW5kZXJlci5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0Q2VsbEVkaXRvcjogZnVuY3Rpb24oY2VsbEVkaXRvcikge1xuICAgICAgICB0aGlzLmxvY2FsQ2VsbEVkaXRvcnNbY2VsbEVkaXRvci4kJENMQVNTX05BTUUudG9Mb3dlckNhc2UoKV0gPSBjZWxsRWRpdG9yO1xuICAgICAgICBjZWxsRWRpdG9yLmdyaWQgPSB0aGlzO1xuICAgIH0sXG5cbiAgICBpbml0TG9jYWxDZWxsRWRpdG9yczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNlbGxFZGl0b3JzID0gW1xuICAgICAgICAgICAgJ1RleHRmaWVsZCcsXG4gICAgICAgICAgICAnQ2hvaWNlJyxcbiAgICAgICAgICAgIC8vJ0NvbWJvJyxcbiAgICAgICAgICAgICdDb2xvcicsXG4gICAgICAgICAgICAnRGF0ZScsXG4gICAgICAgICAgICAnU2xpZGVyJyxcbiAgICAgICAgICAgICdTcGlubmVyJyxcbiAgICAgICAgICAgICdGaWx0ZXInXG4gICAgICAgIF07XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBjZWxsRWRpdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHNlbGYuaW5pdENlbGxFZGl0b3IobmV3IEh5cGVyZ3JpZC5jZWxsRWRpdG9yc1tuYW1lXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubG9jYWxDZWxsRWRpdG9ycy5pbnQgPSB0aGlzLmxvY2FsQ2VsbEVkaXRvcnMuc3Bpbm5lcjtcbiAgICAgICAgdGhpcy5sb2NhbENlbGxFZGl0b3JzLmZsb2F0ID0gdGhpcy5sb2NhbENlbGxFZGl0b3JzLnNwaW5uZXI7XG4gICAgICAgIHRoaXMubG9jYWxDZWxsRWRpdG9ycy5kYXRlID0gdGhpcy5sb2NhbENlbGxFZGl0b3JzLmRhdGU7XG4gICAgICAgIHRoaXMubG9jYWxDZWxsRWRpdG9ycy5zdHJpbmcgPSB0aGlzLmxvY2FsQ2VsbEVkaXRvcnMuZXh0ZmllbGQ7XG4gICAgfSxcblxuICAgIHRvZ2dsZUNvbHVtblBpY2tlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IudG9nZ2xlQ29sdW1uUGlja2VyKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBwb2ludGVyIGlzIG92ZXIgdGhlIGdpdmVuIGNlbGwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgaXNIb3ZlcmVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5nZXRIb3ZlckNlbGwoKTtcbiAgICAgICAgcmV0dXJuIHAgJiYgcC54ID09PSB4ICYmIHAueSA9PT0geTtcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJGb3JtYXR0ZXI6IGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgRm9ybWF0dGVyc1tuYW1lXSA9IGZ1bmM7XG4gICAgfSxcblxuICAgIGdldEZvcm1hdHRlcjogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gRm9ybWF0dGVyc1t0eXBlXTtcbiAgICAgICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRm9ybWF0dGVycy5kZWZhdWx0O1xuICAgIH0sXG5cbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24odHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZ2V0Rm9ybWF0dGVyKHR5cGUpO1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyBib29sZWFufSBUaGUgcG9pbnRlciBpcyBob3ZlcmluZyBvdmVyIHRoZSBnaXZlbiBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgaXNDb2x1bW5Ib3ZlcmVkOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5nZXRIb3ZlckNlbGwoKTtcbiAgICAgICAgcmV0dXJuIHAgJiYgcC54ID09PSB4O1xuICAgIH0sXG5cbiAgICBpc1Jvd1Jlc2l6ZWFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Jvd1Jlc2l6ZScpO1xuICAgIH0sXG5cbiAgICBpc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgcG9pbnRlciBpcyBob3ZlcmluZyBvdmVyIHRoZSByb3cgYHlgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNlbGwgY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICBpc1Jvd0hvdmVyZWQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmdldEhvdmVyQ2VsbCgpO1xuICAgICAgICByZXR1cm4gcCAmJiBwLnkgPT09IHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1BvaW50fSBUaGUgY2VsbCBvdmVyIHdoaWNoIHRoZSBjdXJzb3IgaXMgaG92ZXJpbmcuXG4gICAgICovXG4gICAgZ2V0SG92ZXJDZWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG92ZXJDZWxsO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBjZWxsIHVuZGVyIHRoZSBjdXJzb3IuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKi9cbiAgICBzZXRIb3ZlckNlbGw6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXMuaG92ZXJDZWxsO1xuICAgICAgICB2YXIgbmV3UG9pbnQgPSBuZXcgUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIGlmIChtZSAmJiBtZS5lcXVhbHMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3ZlckNlbGwgPSBuZXdQb2ludDtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljT25DZWxsRW50ZXJFdmVudChuZXdQb2ludCk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFtbWVuZCBwcm9wZXJ0aWVzIGZvciBhbGwgaHlwZXJncmlkcyBpbiB0aGlzIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBBIHNpbXBsZSBwcm9wZXJ0aWVzIGhhc2guXG4gICAgICovXG4gICAgYWRkR2xvYmFsUHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICAvL3dlIGNoZWNrIGZvciBleGlzdGVuY2UgdG8gYXZvaWQgcmFjZSBjb25kaXRpb24gaW4gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgaWYgKCFnbG9iYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYWRkR2xvYmFsUHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEdsb2JhbFByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFtbWVuZCBwcm9wZXJ0aWVzIGZvciBhbGwgaHlwZXJncmlkcyBpbiB0aGlzIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBBIHNpbXBsZSBwcm9wZXJ0aWVzIGhhc2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkR2xvYmFsUHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICBfKHByb3BlcnRpZXMpLmVhY2goZnVuY3Rpb24ocHJvcGVydHksIGtleSkge1xuICAgICAgICAgICAgZ2xvYmFsUHJvcGVydGllc1trZXldID0gcHJvcGVydHk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFV0aWxpdHkgZnVuY3Rpb24gdG8gcHVzaCBvdXQgcHJvcGVydGllcyBpZiB3ZSBjaGFuZ2UgdGhlbS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllcyAtIEFuIG9iamVjdCBvZiB2YXJpb3VzIGtleSB2YWx1ZSBwYWlycy5cbiAgICAgKi9cblxuICAgIHJlZnJlc2hQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignZmluLWNhbnZhcycpO1xuICAgICAgICAvL3RoaXMuY2FudmFzID0gbmV3IENhbnZhcyh0aGlzLmRpdkNhbnZhcywgdGhpcy5yZW5kZXJlcik7IC8vVE9ETzogRG8gd2UgcmVhbGx5IG5lZWQgdG8gYmUgcmVjcmVhdGluZyBpdCBoZXJlP1xuICAgICAgICB0aGlzLmNoZWNrU2Nyb2xsYmFyVmlzaWJpbGl0eSgpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmRlZmF1bHRSb3dIZWlnaHQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5pc0NvbHVtbkF1dG9zaXppbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5iZWhhdmlvci5hdXRvc2l6ZUFsbENvbHVtbnMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFtbWVuZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGh5cGVyZ3JpZCBvbmx5LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb3JlUHJvcGVydGllcyAtIEEgc2ltcGxlIHByb3BlcnRpZXMgaGFzaC5cbiAgICAgKi9cbiAgICBhZGRQcm9wZXJ0aWVzOiBmdW5jdGlvbihtb3JlUHJvcGVydGllcykge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICBhZGREZWVwUHJvcGVydGllcyhwcm9wZXJ0aWVzLCBtb3JlUHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMucmVmcmVzaFByb3BlcnRpZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgc3RhdGUgb2JqZWN0IGZvciByZW1lbWJlcmluZyBvdXIgc3RhdGUuXG4gICAgICogQHNlZSBbTWVtZW50byBwYXR0ZXJuXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lbWVudG9fcGF0dGVybilcbiAgICAgKi9cbiAgICBnZXRQcml2YXRlU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHN0YXRlIG9iamVjdCB0byByZXR1cm4gdG8gdGhlIGdpdmVuIHVzZXIgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSBBIG1lbWVudG8gb2JqZWN0LlxuICAgICAqIEBzZWUgW01lbWVudG8gcGF0dGVybl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZW1lbnRvX3BhdHRlcm4pXG4gICAgICovXG4gICAgc2V0U3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmJlaGF2aW9yQ2hhbmdlZCgpO1xuICAgICAgICAgICAgc2VsZi5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllcygpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFN0YXRlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBpbml0aWFsIG1vdXNlIHBvc2l0aW9uIG9uIGEgbW91c2UgZG93biBldmVudCBmb3IgY2VsbCBlZGl0aW5nIG9yIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRNb3VzZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGFzdCA9IHRoaXMubW91c2VEb3duLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duW2xhc3RdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlbW92ZSB0aGUgbGFzdCBpdGVtIGZyb20gdGhlIG1vdXNlIGRvd24gc3RhY2suXG4gICAgICovXG4gICAgcG9wTW91c2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VEb3duLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZURvd24ubGVuZ3RoID0gdGhpcy5tb3VzZURvd24ubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEVtcHR5IG91dCB0aGUgbW91c2UgZG93biBzdGFjay5cbiAgICAgKi9cbiAgICBjbGVhck1vdXNlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gW25ldyBQb2ludCgtMSwgLTEpXTtcbiAgICAgICAgdGhpcy5kcmFnRXh0ZW50ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgc2V0IHRoZSBtb3VzZSBwb2ludCB0aGF0IGluaXRhdGVkIGEgY2VsbCBlZGl0IG9yIGRyYWcgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICAgICAqL1xuICAgIHNldE1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdGhpcy5tb3VzZURvd24ucHVzaChwb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1BvaW50fSBUaGUgZXh0ZW50IHBvaW50IG9mIHRoZSBjdXJyZW50IGRyYWcgc2VsZWN0aW9uIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBnZXREcmFnRXh0ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0V4dGVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZXRzIHRoZSBleHRlbnQgcG9pbnQgb2YgdGhlIGN1cnJlbnQgZHJhZyBzZWxlY3Rpb24gb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gICAgICovXG4gICAgc2V0RHJhZ0V4dGVudDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdGhpcy5kcmFnRXh0ZW50ID0gcG9pbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgSXRlcmF0ZSBvdmVyIHRoZSBwbHVnaW5zIGludm9raW5nIHRoZSBnaXZlbiBmdW5jdGlvbiB3aXRoIGVhY2guXG4gICAgICogQHRvZG8gV2UgbmVlZCBhIG5ldyBwbHVnaW4gbWVjaGFuaXNtIVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIG9uIGFsbCB0aGUgcGx1Z2lucy5cbiAgICAgKi9cbiAgICBwbHVnaW5zRG86IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgLy9UT0RPOiBXZSBuZWVkIGEgbmV3IHBsdWdpbiBtZWNoYW5pc20hXG4gICAgICAgIC8vdmFyIHVzZXJQbHVnaW5zID0gdGhpcy5jaGlsZHJlbi5hcnJheSgpO1xuICAgICAgICAvL3ZhciBwbHVnaW5zVGFnID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2Zpbi1wbHVnaW5zJyk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vdmFyIHBsdWdpbnMgPSB1c2VyUGx1Z2lucztcbiAgICAgICAgLy9pZiAocGx1Z2luc1RhZykge1xuICAgICAgICAvLyAgICB2YXIgc3lzdGVtUGx1Z2lucyA9IHBsdWdpbnNUYWcuY2hpbGRyZW4uYXJyYXkoKTtcbiAgICAgICAgLy8gICAgcGx1Z2lucyA9IHN5c3RlbVBsdWdpbnMuY29uY2F0KHBsdWdpbnMpO1xuICAgICAgICAvL31cbiAgICAgICAgLy9cbiAgICAgICAgLy9wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgIC8vICAgIGZ1bmMocGx1Z2luKTtcbiAgICAgICAgLy99KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgQ2VsbFByb3ZpZGVyIGlzIGFjY2Vzc2VkIHRocm91Z2ggSHlwZXJncmlkIGJlY2F1c2UgSHlwZXJncmlkIGlzIHRoZSBtZWRpYXRvciBhbmQgc2hvdWxkIGhhdmUgdWx0aW1hdGUgY29udHJvbCBvbiB3aGVyZSBpdCBjb21lcyBmcm9tLiBUaGUgZGVmYXVsdCBpcyB0byBkZWxlZ2F0ZSB0aHJvdWdoIHRoZSBiZWhhdmlvciBvYmplY3QuXG4gICAgICogQHJldHVybnMge2Zpbi1oeXBlcmdyaWQtY2VsbC1wcm92aWRlcn1cbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvdmlkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0aGlzLmJlaGF2aW9yLmdldENlbGxQcm92aWRlcigpO1xuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBmdW5jdGlvbiBpcyBhIGNhbGxiYWNrIGZyb20gdGhlIEh5cGVyZ3JpZFJlbmRlcmVyIHN1Yi1jb21wb25lbnQuIEl0IGlzIGNhbGxlZCBhZnRlciBlYWNoIHBhaW50IG9mIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGVSZW5kZXJlZFNpemVzKCk7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5ncmlkUmVuZGVyZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrQ29sdW1uQXV0b3NpemluZygpO1xuICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNHcmlkUmVuZGVyZWRFdmVudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBncmlkIGhhcyBqdXN0IGJlZW4gcmVuZGVyZWQsIG1ha2Ugc3VyZSB0aGUgY29sdW1uIHdpZHRocyBhcmUgb3B0aW1hbC5cbiAgICAgKi9cbiAgICBjaGVja0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmJlaGF2aW9yO1xuICAgICAgICBiZWhhdmlvci5hdXRvU2l6ZVJvd051bWJlckNvbHVtbigpO1xuICAgICAgICBpZiAodGhpcy5pc0NvbHVtbkF1dG9zaXppbmcoKSkge1xuICAgICAgICAgICAgYmVoYXZpb3IuY2hlY2tDb2x1bW5BdXRvc2l6aW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBOb3RpZnkgdGhlIEdyaWRCZWhhdmlvciBob3cgbWFueSByb3dzIGFuZCBjb2x1bW5zIHdlIGp1c3QgcmVuZGVyZWQuXG4gICAgICovXG4gICAgdXBkYXRlUmVuZGVyZWRTaXplczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vYWRkIG9uZSB0byBlYWNoIG9mIHRoZXNlIHZhbHVlcyBhcyB3ZSB3YW50IGFsc28gdG8gaW5jbHVkZVxuICAgICAgICAvL3RoZSBjb2x1bW5zIGFuZCByb3dzIHRoYXQgYXJlIHBhcnRpYWxseSB2aXNpYmxlXG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0UmVuZGVyZWRDb2x1bW5Db3VudCh0aGlzLmdldFZpc2libGVDb2x1bW5zKCkgKyAxKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRSZW5kZXJlZFJvd0NvdW50KHRoaXMuZ2V0VmlzaWJsZVJvd3MoKSArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IENvbmRpdGlvbmFsbHkgY29weSB0byBjbGlwYm9hcmQuXG4gICAgICogQGRlc2MgSWYgd2UgaGF2ZSBmb2N1cywgY29weSBvdXIgY3VycmVudCBzZWxlY3Rpb24gZGF0YSB0byB0aGUgc3lzdGVtIGNsaXBib2FyZC5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBjb3B5IHN5c3RlbSBldmVudC5cbiAgICAgKi9cbiAgICBjaGVja0NsaXBib2FyZENvcHk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgY3N2RGF0YSA9IHRoaXMuZ2V0U2VsZWN0aW9uQXNUU1YoKTtcbiAgICAgICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIGNzdkRhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdlIGhhdmUgYW55IHNlbGVjdGlvbnMuXG4gICAgICovXG4gICAgaGFzU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyB3ZXJlIG5vdCBmdWxseSBpbml0aWFsaXplZCB5ZXRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5oYXNTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGFiIHNlcGFyYXRlZCB2YWx1ZSBzdHJpbmcgZnJvbSB0aGUgc2VsZWN0aW9uIGFuZCBvdXIgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25Bc1RTVjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzbSA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIGlmIChzbS5oYXNTZWxlY3Rpb25zKCkpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbnMgPSBzZWxlY3Rpb25zW3NlbGVjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXRyaXhTZWxlY3Rpb25Bc1RTVihzZWxlY3Rpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChzbS5oYXNSb3dTZWxlY3Rpb25zKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1hdHJpeFNlbGVjdGlvbkFzVFNWKHRoaXMuZ2V0Um93U2VsZWN0aW9uTWF0cml4KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNtLmhhc0NvbHVtblNlbGVjdGlvbnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF0cml4U2VsZWN0aW9uQXNUU1YodGhpcy5nZXRDb2x1bW5TZWxlY3Rpb25NYXRyaXgoKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TWF0cml4U2VsZWN0aW9uQXNUU1Y6IGZ1bmN0aW9uKHNlbGVjdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIC8vb25seSB1c2UgdGhlIGRhdGEgZnJvbSB0aGUgbGFzdCBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzZWxlY3Rpb25zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzZWxlY3Rpb25zWzBdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhcmVhID0gd2lkdGggKiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgbGFzdCA9IHdpZHRoIC0gMTtcblxuICAgICAgICAgICAgLy9kaXNhbGxvdyBpZiBzZWxlY3Rpb24gaXMgdG9vIGJpZ1xuICAgICAgICAgICAgaWYgKGFyZWEgPiAyMDAwMCkge1xuICAgICAgICAgICAgICAgIGFsZXJ0KCdzZWxlY3Rpb24gc2l6ZSBpcyB0b28gYmlnIHRvIGNvcHkgdG8gdGhlIHBhc3RlIGJ1ZmZlcicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IGhlaWdodDsgaCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCB3aWR0aDsgdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzZWxlY3Rpb25zW3ddW2hdICsgKHcgPCBsYXN0ID8gJ1xcdCcgOiAnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2UgaGF2ZSBmb2N1cy5cbiAgICAgKi9cbiAgICBoYXNGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENhbnZhcygpLmhhc0ZvY3VzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgQ2xlYXIgYWxsIHRoZSBzZWxlY3Rpb25zLlxuICAgICAqL1xuICAgIGNsZWFyU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb250Q2xlYXJSb3dzID0gdGhpcy5pc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhcihkb250Q2xlYXJSb3dzKTtcbiAgICAgICAgdGhpcy5jbGVhck1vdXNlRG93bigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIENsZWFyIHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRvbnRDbGVhclJvd3MgPSB0aGlzLmlzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbihkb250Q2xlYXJSb3dzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBDbGVhciB0aGUgbW9zdCByZWNlbnQgY29sdW1uIHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIENsZWFyIHRoZSBtb3N0IHJlY2VudCByb3cgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb24oKTsgLy8gY29tbWVudGVkIG9mZiBhcyBwZXIgR1JJRC0xMTJcbiAgICB9LFxuXG4gICAgY2xlYXJSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyUm93U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuZGF0YU1vZGVsLmNsZWFyU2VsZWN0ZWREYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2VsZWN0IGdpdmVuIHJlZ2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ggLSBvcmlnaW4geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeVxuICAgICAqL1xuICAgIHNlbGVjdDogZnVuY3Rpb24ob3gsIG95LCBleCwgZXkpIHtcbiAgICAgICAgaWYgKG94IDwgMCB8fCBveSA8IDApIHtcbiAgICAgICAgICAgIC8vd2UgZG9uJ3Qgc2VsZWN0IG5lZ2F0aXZlIGFyZWFcbiAgICAgICAgICAgIC8vYWxzbyB0aGlzIG1lYW5zIHRoZXJlIGlzIG5vIG9yaWdpbiBtb3VzZSBkb3duIGZvciBhIHNlbGVjdGlvbiByZWN0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5zZWxlY3Qob3gsIG95LCBleCwgZXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBHaXZlbiBwb2ludCBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjb2x1bW4gaXMgc2VsZWN0ZWQgYW55d2hlcmUgaW4gdGhlIGVudGlyZSB0YWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sIC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluUm93OiBmdW5jdGlvbihjb2wpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbk1vZGVsID0gdGhpcy5zZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBzZWxlY3Rpb25Nb2RlbC5pc0NlbGxTZWxlY3RlZEluUm93KGNvbCk7XG4gICAgICAgIHJldHVybiBpc1NlbGVjdGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gcm93IGlzIHNlbGVjdGVkIGFueXdoZXJlIGluIHRoZSBlbnRpcmUgdGFibGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdyAtIFRoZSByb3cgaW5kZXguXG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbjogZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25Nb2RlbCA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHZhciBpc1NlbGVjdGVkID0gc2VsZWN0aW9uTW9kZWwuaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbihyb3cpO1xuICAgICAgICByZXR1cm4gaXNTZWxlY3RlZDtcbiAgICB9LFxuXG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBgLnNlbGVjdGlvbk1vZGVsYCBwcm9wZXJ0eSBpbnN0ZWFkLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1NlbGVjdGlvbk1vZGVsfSBUaGUgc2VsZWN0aW9uIG1vZGVsLlxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbk1vZGVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnc2VsZWN0aW9uTW9kZWwnLCB7IHNpbmNlOiAnMC4yJyB9KTtcbiAgICB9LFxuXG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBgLmJlaGF2aW9yYCBwcm9wZXJ0eSBpbnN0ZWFkLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0JlaGF2aW9yfSBUaGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKi9cbiAgICBnZXRCZWhhdmlvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2JlaGF2aW9yJywgeyBzaW5jZTogJzAuMicgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBCZWhhdmlvciAobW9kZWwpIG9iamVjdCBmb3IgdGhpcyBncmlkIGNvbnRyb2wuXG4gICAgICogQGRlc2MgVGhpcyBjYW4gYmUgZG9uZSBkeW5hbWljYWxseS5cbiAgICAgKiBAcGFyYW0ge0JlaGF2aW9yfSBiZWhhdmlvciAtIFRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqL1xuICAgIHNldEJlaGF2aW9yOiBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgICAgICBiZWhhdmlvci5jaGFuZ2VkID0gdGhpcy5iZWhhdmlvckNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgYmVoYXZpb3Iuc2hhcGVDaGFuZ2VkID0gdGhpcy5iZWhhdmlvclNoYXBlQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICBiZWhhdmlvci5zdGF0ZUNoYW5nZWQgPSB0aGlzLmJlaGF2aW9yU3RhdGVDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IgPSBiZWhhdmlvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJJ3ZlIGJlZW4gbm90aWZpZWQgdGhhdCB0aGUgYmVoYXZpb3IgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgYmVoYXZpb3JDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubnVtQ29sdW1ucyAhPT0gdGhpcy5nZXRDb2x1bW5Db3VudCgpIHx8IHRoaXMubnVtUm93cyAhPT0gdGhpcy5nZXRSb3dDb3VudCgpKSB7XG4gICAgICAgICAgICB0aGlzLm51bUNvbHVtbnMgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgICAgICB0aGlzLm51bVJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yU2hhcGVDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gTXkgYm91bmRzLlxuICAgICAqL1xuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyICYmIHJlbmRlcmVyLmdldEJvdW5kcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB2YWx1ZSBvZiBhIGxuZiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gQSBsb29rLWFuZC1mZWVsIGtleS5cbiAgICAgKi9cbiAgICByZXNvbHZlUHJvcGVydHk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgcHJvcCA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHsgcHJvcCA9IHByb3Bba2V5cy5zaGlmdCgpXTsgfVxuICAgICAgICByZXR1cm4gcHJvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZ3JpZCBkYXRhIGhhdmUgY2hhbmdlZC4gWW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgYmVoYXZpb3JTaGFwZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGdyaWQgZGF0YSBoYXZlIGNoYW5nZWQuIFlvdSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqL1xuICAgIGJlaGF2aW9yU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRSZW5kZXJlcigpLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgcmVwYWludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgncmVwYWludEltbWVkaWF0ZWx5Jyk7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBpZiAobm93ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLnBhaW50Tm93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZXBhaW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBQYWludCBpbW1lZGlhdGVseSBpbiB0aGlzIG1pY3JvdGFzay5cbiAgICAgKi9cbiAgICBwYWludE5vdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgICBjYW52YXMucGFpbnROb3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSW4gSGlEUEkgbW9kZSAoaGFzIGFuIGF0dHJpYnV0ZSBhcyBzdWNoKS5cbiAgICAgKi9cbiAgICB1c2VIaURQSTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgndXNlSGlEUEknKSAhPT0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgSW5pdGlhbGl6ZSBkcmF3aW5nIHN1cmZhY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0Q2FudmFzOiBmdW5jdGlvbihtYXJnaW4pIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRpdkNhbnZhcyA9IHRoaXMuZGl2Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKGRpdkNhbnZhcyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbmV3IENhbnZhcyhkaXZDYW52YXMsIHRoaXMucmVuZGVyZXIpO1xuXG4gICAgICAgIHZhciBzdHlsZSA9IGRpdkNhbnZhcy5zdHlsZTtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBzdHlsZS50b3AgPSBtYXJnaW4udG9wO1xuICAgICAgICBzdHlsZS5yaWdodCA9IG1hcmdpbi5yaWdodDtcbiAgICAgICAgc3R5bGUuYm90dG9tID0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgc3R5bGUubGVmdCA9IG1hcmdpbi5sZWZ0O1xuXG4gICAgICAgIHRoaXMuY2FudmFzLnJlc2l6ZU5vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5yZXNpemVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGU7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlTW91c2VNb3ZlKG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9zZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQua2V5cyA9IGUuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIHNlbGYubW91c2VEb3duU3RhdGUgPSBtb3VzZUV2ZW50O1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZU1vdXNlRG93bihtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY01vdXNlRG93bkV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgc2VsZi5yZXBhaW50KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1jbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIC8vc2VsZi5zdG9wRWRpdGluZygpO1xuICAgICAgICAvLyAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgIC8vICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgIC8vICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZTtcbiAgICAgICAgLy8gICAgIHNlbGYuZmlyZVN5bnRoZXRpY0NsaWNrRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgIC8vIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1tb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0U2Nyb2xsaW5nTm93KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9zZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZU1vdXNlVXAobW91c2VFdmVudCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5tb3VzZURvd25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0J1dHRvblByZXNzZWRFdmVudChzZWxmLm1vdXNlRG93blN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYubW91c2VEb3duU3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljTW91c2VVcEV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtZGJsY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljRG91YmxlQ2xpY2tFdmVudChtb3VzZUV2ZW50LCBlKTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVEb3VibGVDbGljayhtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLXRhcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vc2VsZi5zdG9wRWRpdGluZygpO1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgdGFwRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgdGFwRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAgICAgdGFwRXZlbnQua2V5cyA9IGUuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICBzZWxmLmZpcmVTeW50aGV0aWNDbGlja0V2ZW50KHRhcEV2ZW50KTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVUYXAodGFwRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtZHJhZycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVNb3VzZURyYWcobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1rZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdlZGl0T25LZXlkb3duJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhciA9IGUuZGV0YWlsLmNoYXIsXG4gICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZUNoYXIsIGlzRGVsZXRlQ2hhciwgY3VycmVudENlbGwsIGVkaXRvcjtcblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuaXNFZGl0aW5nKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhciA9PT0gJ0YyJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGlzVmlzaWJsZUNoYXIgPSBjaGFyLmxlbmd0aCA9PT0gMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc0RlbGV0ZUNoYXIgPSBjaGFyID09PSAnREVMRVRFJyB8fCBjaGFyID09PSAnQkFDS1NQQUNFJylcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2VsbCA9IHNlbGYuc2VsZWN0aW9uTW9kZWwuZ2V0TGFzdFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwc2V1ZG9FdmVudCA9IHsgZ3JpZENlbGw6IGN1cnJlbnRDZWxsLm9yaWdpbiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yID0gc2VsZi5vbkVkaXRvckFjdGl2YXRlKHBzZXVkb0V2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZGl0b3IgaW5zdGFuY2VvZiBIeXBlcmdyaWQuY2VsbEVkaXRvcnMuU2ltcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmlzaWJsZUNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmlucHV0LnZhbHVlID0gY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzRGVsZXRlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kZXRhaWwucHJpbWl0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0tleWRvd25FdmVudChlKTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVLZXlEb3duKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMta2V5dXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmZpcmVTeW50aGV0aWNLZXl1cEV2ZW50KGUpO1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZUtleVVwKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtdHJhY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBlLmRldGFpbC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhwcmltRXZlbnQuZHkpID4gTWF0aC5hYnMocHJpbUV2ZW50LmR4KSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmltRXZlbnQueURpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxWQnkoLTIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJpbUV2ZW50LnlEaXJlY3Rpb24gPCAtMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbFZCeSgyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwcmltRXZlbnQueERpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxIQnkoLTEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJpbUV2ZW50LnhEaXJlY3Rpb24gPCAtMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbEhCeSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1ob2xkcHVsc2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZygnaG9sZHB1bHNlJyk7XG4gICAgICAgIC8vICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgLy8gICAgICAgICByZXR1cm47XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgLy8gICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgLy8gICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAvLyAgICAgc2VsZi5kZWxlZ2F0ZUhvbGRQdWxzZShtb3VzZUV2ZW50KTtcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLXdoZWVsbW92ZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlLmRldGFpbC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVXaGVlbE1vdmVkKG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtbW91c2VvdXQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlLmRldGFpbC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVNb3VzZUV4aXQobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1jb250ZXh0LW1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlLmRldGFpbC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVDb250ZXh0TWVudShtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kaXYucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuXG4gICAgfSxcblxuICAgIGNvbnZlcnRWaWV3UG9pbnRUb0RhdGFQb2ludDogZnVuY3Rpb24odmlld1BvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmNvbnZlcnRWaWV3UG9pbnRUb0RhdGFQb2ludCh2aWV3UG9pbnQpO1xuICAgIH0sXG5cbiAgICBjb252ZXJ0RGF0YVBvaW50VG9WaWV3UG9pbnQ6IGZ1bmN0aW9uKGRhdGFQb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5jb252ZXJ0RGF0YVBvaW50VG9WaWV3UG9pbnQoZGF0YVBvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHdlIGFyZSBpbnRlcmVzdGVkIGluLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBhZGRGaW5FdmVudExpc3RlbmVyOiBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignLmFkZEZpbkV2ZW50TGlzdGVuZXIoKSBtZXRob2QgaXMgZGVwcmVjYXRlZCBhcyBvZiB2MC4yLiBVc2UgLmFkZEV2ZW50TGlzdGVuZXIoKSBpbnN0ZWFkLiAoV2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuKScpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2V0IGZvciBgc2Nyb2xsaW5nTm93YCBmaWVsZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSXROb3cgLSBUaGUgdHlwZSBvZiBldmVudCB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAgKi9cbiAgICBzZXRTY3JvbGxpbmdOb3c6IGZ1bmN0aW9uKGlzSXROb3cpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxpbmdOb3cgPSBpc0l0Tm93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgYHNjcm9sbGluZ05vd2AgZmllbGQuXG4gICAgICovXG4gICAgaXNTY3JvbGxpbmdOb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxpbmdOb3c7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gZGl2aWRlciB1bmRlciB0aGUgbW91c2UgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gVGhlIGV2ZW50IHRvIGludGVyb2dhdGUuXG4gICAgICovXG4gICAgb3ZlckNvbHVtbkRpdmlkZXI6IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIHggPSBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS54O1xuICAgICAgICB2YXIgd2hpY2hDb2wgPSB0aGlzLmdldFJlbmRlcmVyKCkub3ZlckNvbHVtbkRpdmlkZXIoeCk7XG4gICAgICAgIHJldHVybiB3aGljaENvbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIHJvdyBkaXZpZGVyIHVuZGVyIHRoZSBtb3VzZSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBUaGUgZXZlbnQgdG8gaW50ZXJvZ2F0ZS5cbiAgICAgKi9cbiAgICBvdmVyUm93RGl2aWRlcjogZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgICAgICB2YXIgeSA9IG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnk7XG4gICAgICAgIHZhciB3aGljaCA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5vdmVyUm93RGl2aWRlcih5KTtcbiAgICAgICAgcmV0dXJuIHdoaWNoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN3aXRjaCB0aGUgY3Vyc29yIGZvciB0aGUgZ3JpZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3Vyc29yTmFtZSAtIEEgd2VsbCBrbm93IGN1cnNvciBuYW1lLlxuICAgICAqIEBzZWUgW2N1cnNvciBuYW1lc10oaHR0cDovL3d3dy5qYXZhc2NyaXB0ZXIubmV0L2ZhcS9zdHlsZXNjLmh0bSlcbiAgICAgKi9cbiAgICBiZUN1cnNvcjogZnVuY3Rpb24oY3Vyc29yTmFtZSkge1xuICAgICAgICBpZiAoIWN1cnNvck5hbWUpIHtcbiAgICAgICAgICAgIGN1cnNvck5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXYuc3R5bGUuY3Vyc29yID0gY3Vyc29yTmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSB0aGUgd2hlZWwgbW92ZWQgZXZlbnQgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZVdoZWVsTW92ZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25XaGVlbE1vdmVkKHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBNb3VzZUV4aXQgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VFeGl0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmhhbmRsZU1vdXNlRXhpdCh0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgTW91c2VFeGl0IHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZUNvbnRleHRNZW51OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgIHRoaXMuIGJlaGF2aW9yLm9uQ29udGV4dE1lbnUodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIE1vdXNlTW92ZSB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VNb3ZlOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbk1vdXNlTW92ZSh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIG1vdXNlZG93biB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VEb3duOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5oYW5kbGVNb3VzZURvd24odGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBtb3VzZXVwIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVNb3VzZVVwOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbk1vdXNlVXAodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSB0YXAgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZVRhcDogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25UYXAodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBtb3VzZURyYWcgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlRHJhZzogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25Nb3VzZURyYWcodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBXZSd2ZSBiZWVuIGRvdWJsZWNsaWNrZWQgb24uIERlbGVnYXRlIHRocm91Z2ggdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZURvdWJsZUNsaWNrOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbkRvdWJsZUNsaWNrKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgaG9sZHB1bHNlIHRocm91Z2ggdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZUhvbGRQdWxzZTogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25Ib2xkUHVsc2UodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG5hbWUgYW5kIGNhbGwgaXQgb24gc2VsZi5cbiAgICAgKiBAZGVzYyBUaGlzIHNob3VsZCBhbHNvIGJlIGRlbGVnYXRlZCB0aHJvdWdoIEJlaGF2aW9yIGtlZXBpbmcgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaGVyZSB0aG91Z2guXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlS2V5RG93bjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbktleURvd24odGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEdlbmVyYXRlIGEgZnVuY3Rpb24gbmFtZSBhbmQgY2FsbCBpdCBvbiBzZWxmLlxuICAgICAqIEBkZXNjIFRoaXMgc2hvdWxkIGFsc28gYmUgZGVsZWdhdGVkIHRocm91Z2ggQmVoYXZpb3Iga2VlcGluZyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBoZXJlIHRob3VnaC5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVLZXlVcDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbktleVVwKHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTaHV0IGRvd24gdGhlIGN1cnJlbnQgY2VsbCBlZGl0b3IuXG4gICAgICovXG4gICAgc3RvcEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yICYmIHRoaXMuaXNFZGl0aW5nKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBhIGNlbGwgZWRpdG9yLlxuICAgICAqIEBkZXNjIFRoaXMgaXMgdHlwaWNhbGx5IGNhbGxlZCBmcm9tIHdpdGhpbiBhIGNlbGwtZWRpdG9yJ3MgYGluc3RhbGxPbmAgbWV0aG9kLCB3aGVuIGl0IGlzIGJlaW5nIGluaXRpYWxpemVkIGFzIGEgcGx1Z2luLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlhcyAtIFRoZSBuYW1lL2lkIG9mIHRoZSBjZWxsIGVkaXRvci5cbiAgICAgKiBAcGFyYW0ge2Zpbi1oeXBlcmdyaWQtY2VsbC1lZGl0b3ItYmFzZX0gY2VsbEVkaXRvciAtIHNlZSBbZmluLWh5cGVyZ3JpZC1jZWxsLWVkaXRvci1iYXNlXShtb2R1bGUtY2VsbC1lZGl0b3JzX2Jhc2UuaHRtbClcbiAgICAgKi9cbiAgICByZWdpc3RlckNlbGxFZGl0b3I6IGZ1bmN0aW9uKGFsaWFzLCBjZWxsRWRpdG9yKSB7XG4gICAgICAgIHRoaXMuY2VsbEVkaXRvcnNbYWxpYXNdID0gY2VsbEVkaXRvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBUaGUgcGl4ZWwgY29vcmRpbmF0ZXMgb2YganVzdCB0aGUgY2VudGVyICdtYWluXCIgZGF0YSBhcmVhLlxuICAgICAqL1xuICAgIGdldERhdGFCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sRE5ESGFja1dpZHRoID0gMjAwOyAvL3RoaXMgd2FzIGEgaGFjayB0byBoZWxwIHdpdGggY29sdW1uIGRuZCwgbmVlZCB0byBmYWN0b3IgdGhpcyBpbnRvIGEgc2hhcmVkIHZhcmlhYmxlXG4gICAgICAgIHZhciBiID0gdGhpcy5jYW52YXMuYm91bmRzO1xuXG4gICAgICAgIC8vdmFyIHggPSB0aGlzLmdldFJvd051bWJlcnNXaWR0aCgpO1xuICAgICAgICAvLyB2YXIgeSA9IGJlaGF2aW9yLmdldEZpeGVkUm93c0hlaWdodCgpICsgMjtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFJlY3RhbmdsZSgwLCAwLCBiLm9yaWdpbi54ICsgYi5leHRlbnQueCAtIGNvbEROREhhY2tXaWR0aCwgYi5vcmlnaW4ueSArIGIuZXh0ZW50LnkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRSb3dOdW1iZXJzV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Nob3dSb3dOdW1iZXJzKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0Um93TnVtYmVyc1dpZHRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtDYW52YXN9IE91ciBmaW4tY2FudmFzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBPcGVuIHRoZSBnaXZlbiBjZWxsLWVkaXRvciBhdCB0aGUgcHJvdmlkZWQgbW9kZWwgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNlbGxFZGl0b3IgLSBUaGUgc3BlY2lmaWMgY2VsbCBlZGl0b3IgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNvb3JkaW5hdGVzIC0gVGhlIHBpeGVsIGxvY2FpdG9uIG9mIHRoZSBjZWxsIHRvIGVkaXQgYXQuXG4gICAgICovXG4gICAgZWRpdEF0OiBmdW5jdGlvbihjZWxsRWRpdG9yLCBlZGl0UG9pbnQpIHtcblxuICAgICAgICB0aGlzLmNlbGxFZGl0b3IgPSBjZWxsRWRpdG9yO1xuXG4gICAgICAgIGlmIChlZGl0UG9pbnQueCA+PSAwICYmIGVkaXRQb2ludC55ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TW91c2VEb3duKGVkaXRQb2ludCk7XG4gICAgICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQobmV3IFBvaW50KDAsIDApKTtcbiAgICAgICAgICAgIGNlbGxFZGl0b3IuYmVnaW5FZGl0QXQoZWRpdFBvaW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtib29sYW59IFZpc2libGUuXG4gICAgICovXG4gICAgaXNDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmlzQ29sdW1uVmlzaWJsZShjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiByb3cgaXMgZnVsbHkgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEByZXR1cm4ge2Jvb2xhbn0gVmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFSb3dWaXNpYmxlOiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmlzUm93VmlzaWJsZShyb3dJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjZWxsIGlzIGZ1bGx5IGlzIHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IERhdGEgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFWaXNpYmxlOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgcm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEYXRhUm93VmlzaWJsZShyb3dJbmRleCkgJiYgdGhpcy5pc0NvbHVtblZpc2libGUoY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBpbiB0aGUgYG9mZnNldFhgIGRpcmVjdGlvbiBpZiBjb2x1bW4gaW5kZXggYGNvbEluZGV4YCBpcyBub3QgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXggLSBUaGUgY29sdW1uIGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gVGhlIGRpcmVjdGlvbiBhbmQgbWFnbml0dWRlIHRvIHNjcm9sbCBpZiB3ZSBuZWVkIHRvLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbHVtbiBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIGluc3VyZU1vZGVsQ29sSXNWaXNpYmxlOiBmdW5jdGlvbihjb2xJbmRleCwgb2Zmc2V0WCkge1xuICAgICAgICB2YXIgbWF4Q29scyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDEsIC8vIC0xIGV4Y2x1ZGVzIHBhcnRpYWxseSB2aXNpYmxlIGNvbHVtbnNcbiAgICAgICAgICAgIGluZGV4VG9DaGVjayA9IGNvbEluZGV4ICsgKG9mZnNldFggPiAwKSxcbiAgICAgICAgICAgIHZpc2libGUgPSAhdGhpcy5pc0NvbHVtblZpc2libGUoaW5kZXhUb0NoZWNrKSB8fCBjb2xJbmRleCA9PT0gbWF4Q29scztcblxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgLy90aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIHRoZSBsZWZ0bW9zdCBjb2x1bW5cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnkob2Zmc2V0WCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgaW4gdGhlIG9mZnNldFkgZGlyZWN0aW9uIGlmIGNvbHVtbiBpbmRleCBjIGlzIG5vdCB2aXNpYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFRoZSBjb2x1bW4gaW5kZXggaW4gcXVlc3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBUaGUgZGlyZWN0aW9uIGFuZCBtYWduaXR1ZGUgdG8gc2Nyb2xsIGlmIHdlIG5lZWQgdG8uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUm93IGlzIHZpc2libGUuXG4gICAgICovXG4gICAgaW5zdXJlTW9kZWxSb3dJc1Zpc2libGU6IGZ1bmN0aW9uKHJvd0luZGV4LCBvZmZzZXRZKSB7XG4gICAgICAgIHZhciBtYXhSb3dzID0gdGhpcy5nZXRSb3dDb3VudCgpIC0gMSwgLy8gLTEgZXhjbHVkZXMgcGFydGlhbGx5IHZpc2libGUgcm93c1xuICAgICAgICAgICAgaW5kZXhUb0NoZWNrID0gcm93SW5kZXggKyAob2Zmc2V0WSA+IDApLFxuICAgICAgICAgICAgdmlzaWJsZSA9ICF0aGlzLmlzRGF0YVJvd1Zpc2libGUoaW5kZXhUb0NoZWNrKSB8fCByb3dJbmRleCA9PT0gbWF4Um93cztcblxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgLy90aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIHRoZSB0b3Btb3N0IHJvd1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCeSgwLCBvZmZzZXRZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbGx5IGJ5IHRoZSBwcm92aWRlZCBvZmZzZXRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gU2Nyb2xsIGluIHRoZSB4IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSBTY3JvbGwgaW4gdGhlIHkgZGlyZWN0aW9uIHRoaXMgbXVjaC5cbiAgICAgKi9cbiAgICBzY3JvbGxCeTogZnVuY3Rpb24ob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICB0aGlzLnNjcm9sbEhCeShvZmZzZXRYKTtcbiAgICAgICAgdGhpcy5zY3JvbGxWQnkob2Zmc2V0WSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIHZlcnRpY2FsbHkgYnkgdGhlIHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIFNjcm9sbCBpbiB0aGUgeSBkaXJlY3Rpb24gdGhpcyBtdWNoLlxuICAgICAqL1xuICAgIHNjcm9sbFZCeTogZnVuY3Rpb24ob2Zmc2V0WSkge1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5zYlZTY3JvbGxlci5yYW5nZS5tYXg7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZ2V0VlNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMCwgb2xkVmFsdWUgKyBvZmZzZXRZKSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VlNjcm9sbFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBob3Jpem9udGFsbHkgYnkgdGhlIHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIFNjcm9sbCBpbiB0aGUgeCBkaXJlY3Rpb24gdGhpcyBtdWNoLlxuICAgICAqL1xuICAgIHNjcm9sbEhCeTogZnVuY3Rpb24ob2Zmc2V0WCkge1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5zYkhTY3JvbGxlci5yYW5nZS5tYXg7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMCwgb2xkVmFsdWUgKyBvZmZzZXRYKSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEFuc3dlciB3aGljaCBkYXRhIGNlbGwgaXMgdW5kZXIgYSBwaXhlbCB2YWx1ZSBtb3VzZSBwb2ludC5cbiAgICAgKiBAcGFyYW0ge21vdXNlUG9pbnR9IG1vdXNlIC0gVGhlIG1vdXNlIHBvaW50IHRvIGludGVycm9nYXRlLlxuICAgICAqL1xuXG4gICAgZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBUaGUgcGl4ZWwgYmFzZWQgYm91bmRzIHJlY3RhbmdsZSBnaXZlbiBhIGRhdGEgY2VsbCBwb2ludC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBtb3VzZS5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEJvdW5kc09mQ2VsbDogZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRCb3VuZHNPZkNlbGwoY2VsbCk7XG5cbiAgICAgICAgLy93ZSBuZWVkIHRvIGNvbnZlcnQgdGhpcyB0byBhIHByb3BlciByZWN0YW5nbGVcbiAgICAgICAgdmFyIG5ld0JvdW5kcyA9IG5ldyBSZWN0YW5nbGUoYi54LCBiLnksIGIud2lkdGgsIGIuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG5ld0JvdW5kcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIGlzIGNhbGxlZCBieSB0aGUgZmluLWNhbnZhcyB3aGVuIGEgcmVzaXplIG9jY3Vycy5cbiAgICAgKi9cbiAgICByZXNpemVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEEgY2xpY2sgZXZlbnQgb2NjdXJlZC5cbiAgICAgKiBAZGVzYyBEZXRlcm1pbmUgdGhlIGNlbGwgYW5kIGRlbGVnYXRlIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQgdG8gaW50ZXJyb2dhdGUuXG4gICAgICovXG4gICAgY2VsbENsaWNrZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsID0gZXZlbnQuZ3JpZENlbGw7XG5cbiAgICAgICAgLy9jbGljayBvY2N1cnJlZCBpbiBiYWNrZ3JvdW5kIGFyZWFcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY2VsbC54IDw9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAmJlxuICAgICAgICAgICAgY2VsbC55IDw9IHRoaXMuZ2V0Um93Q291bnQoKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBob3ZlcmVkID0gdGhpcy5nZXRIb3ZlckNlbGwoKSxcbiAgICAgICAgICAgICAgICB4ID0gaG92ZXJlZC54LFxuICAgICAgICAgICAgICAgIHkgPSBob3ZlcmVkLnk7XG5cbiAgICAgICAgICAgIC8vIGlmICh4ID49IDApIHtcbiAgICAgICAgICAgIC8vICAgICB4ID0gYmVoYXZpb3IudHJhbnNsYXRlQ29sdW1uSW5kZXgoeCArIHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCkpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICBpZiAoeSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgeSArPSB0aGlzLmdldFZTY3JvbGxWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLmNlbGxDbGlja2VkKG5ldyBQb2ludCh4LCB5KSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBjb2x1bW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRvdGFscyByb3cgaW5kZXggbG9jYWwgdG8gdGhlIHRvdGFscyBhcmVhXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZWFzPVsndG9wJywgJ2JvdHRvbSddXSAtIG1heSBpbmNsdWRlIGAndG9wJ2AgYW5kL29yIGAnYm90dG9tJ2BcbiAgICAgKi9cbiAgICBzZXRUb3RhbHNWYWx1ZU5vdGlmaWNhdGlvbjogZnVuY3Rpb24oeCwgeSwgdmFsdWUsIGFyZWFzKSB7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY1NldFRvdGFsc1ZhbHVlKHgsIHksIHZhbHVlLCBhcmVhcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBjb2x1bW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRvdGFscyByb3cgaW5kZXggbG9jYWwgdG8gdGhlIHRvdGFscyBhcmVhXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZWFzPVsndG9wJywgJ2JvdHRvbSddXSAtIG1heSBpbmNsdWRlIGAndG9wJ2AgYW5kL29yIGAnYm90dG9tJ2BcbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljU2V0VG90YWxzVmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlLCBhcmVhcykge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLXNldC10b3RhbHMtdmFsdWUnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGFyZWFzOiBhcmVhc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleVVwRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwga2V5RXZlbnQpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1lZGl0b3Ita2V5dXAnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXRDb250cm9sLFxuICAgICAgICAgICAgICAgIGtleUV2ZW50OiBrZXlFdmVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleURvd25FdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBrZXlFdmVudCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWVkaXRvci1rZXlkb3duJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29udHJvbCxcbiAgICAgICAgICAgICAgICBrZXlFdmVudDoga2V5RXZlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNFZGl0b3JLZXlQcmVzc0V2ZW50OiBmdW5jdGlvbihpbnB1dENvbnRyb2wsIGtleUV2ZW50KSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tZWRpdG9yLWtleXByZXNzJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29udHJvbCxcbiAgICAgICAgICAgICAgICBrZXlFdmVudDoga2V5RXZlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNFZGl0b3JEYXRhQ2hhbmdlRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tZWRpdG9yLWRhdGEtY2hhbmdlJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29udHJvbCxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tcm93LXNlbGVjdGlvbi1jaGFuZ2VkYCBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tcm93LXNlbGVjdGlvbi1jaGFuZ2VkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChzZWxlY3Rpb25FdmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNDb2x1bW5TZWxlY3Rpb25DaGFuZ2VkRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jb2x1bW4tc2VsZWN0aW9uLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoc2VsZWN0aW9uRXZlbnQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBkaXNwYXRjaCBhIGBmaW4tc2VsZWN0aW9uLWNoYW5nZWRgIGV2ZW50LlxuICAgICAqL1xuICAgIHNlbGVjdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRSb3dzID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tc2VsZWN0aW9uLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICByb3dzOiBzZWxlY3RlZFJvd3MsXG4gICAgICAgICAgICAgICAgY29sdW1uczogdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoc2VsZWN0aW9uRXZlbnQpO1xuICAgIH0sXG5cblxuICAgIGdldFJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjLCBjb2x1bW4sIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dJbmRleGVzID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgIG51bUNvbHMgPSB0aGlzLmdldENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgICBmdW5jdGlvbiBzZXRWYWx1ZShzZWxlY3RlZFJvd0luZGV4LCByKSB7XG4gICAgICAgICAgICBjb2x1bW5bcl0gPSB2YWxPckZ1bmMoc2VsZi5nZXRWYWx1ZShjLCBzZWxlY3RlZFJvd0luZGV4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGMgPSAwOyBjIDwgbnVtQ29sczsgYysrKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSBuZXcgQXJyYXkoc2VsZWN0ZWRSb3dJbmRleGVzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXN1bHRbdGhpcy5nZXRGaWVsZChjKV0gPSBjb2x1bW47XG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMuZm9yRWFjaChzZXRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRSb3dTZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYywgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgbnVtQ29scyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShudW1Db2xzKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRWYWx1ZShzZWxlY3RlZFJvd0luZGV4LCByKSB7XG4gICAgICAgICAgICByZXN1bHRbY11bcl0gPSB2YWxPckZ1bmMoc2VsZi5nZXRWYWx1ZShjLCBzZWxlY3RlZFJvd0luZGV4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGMgPSAwOyBjIDwgbnVtQ29sczsgYysrKSB7XG4gICAgICAgICAgICByZXN1bHRbY10gPSBuZXcgQXJyYXkoc2VsZWN0ZWRSb3dJbmRleGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMuZm9yRWFjaChnZXRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5TZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRDb2x1bW5JbmRleGVzID0gdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICAgICAgdmFyIG51bVJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoc2VsZWN0ZWRDb2x1bW5JbmRleGVzLmxlbmd0aCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZWN0ZWRDb2x1bW5JbmRleGVzLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0ZWRDb2x1bW5JbmRleCwgYykge1xuICAgICAgICAgICAgcmVzdWx0W2NdID0gbmV3IEFycmF5KG51bVJvd3MpO1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBudW1Sb3dzOyByKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY11bcl0gPSB2YWxPckZ1bmMoc2VsZi5nZXRWYWx1ZShzZWxlY3RlZENvbHVtbkluZGV4LCByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRDb2x1bW5JbmRleGVzID0gdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICB2YXIgcm93Q291bnQgPSB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZWN0ZWRDb2x1bW5JbmRleGVzLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0ZWRDb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gICAgICAgICAgICByZXN1bHRbc2VsZi5nZXRGaWVsZChzZWxlY3RlZENvbHVtbkluZGV4KV0gPSBjb2x1bW47XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5bcl0gPSB2YWxPckZ1bmMoc2VsZi5nZXRWYWx1ZShzZWxlY3RlZENvbHVtbkluZGV4LCByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoc2VsZWN0aW9ucy5sZW5ndGgpO1xuICAgICAgICBzZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uUmVjdCwgaSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gc2VsZi5fZ2V0U2VsZWN0aW9uKHNlbGVjdGlvblJlY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2dldFNlbGVjdGlvbjogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICByZWN0ID0gbm9ybWFsaXplUmVjdChyZWN0KTtcbiAgICAgICAgdmFyIGNvbENvdW50ID0gcmVjdC5leHRlbnQueCArIDE7XG4gICAgICAgIHZhciByb3dDb3VudCA9IHJlY3QuZXh0ZW50LnkgKyAxO1xuICAgICAgICB2YXIgb3ggPSByZWN0Lm9yaWdpbi54O1xuICAgICAgICB2YXIgb3kgPSByZWN0Lm9yaWdpbi55O1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciByO1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbENvdW50OyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBuZXcgQXJyYXkocm93Q291bnQpO1xuICAgICAgICAgICAgcmVzdWx0W3RoaXMuZ2V0RmllbGQoYyArIG94KV0gPSBjb2x1bW47XG4gICAgICAgICAgICBmb3IgKHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgICAgICAgICAgIGNvbHVtbltyXSA9IHZhbE9yRnVuYyh0aGlzLmdldFZhbHVlKG94ICsgYywgb3kgKyByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHNlbGVjdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgc2VsZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGlvblJlY3QsIGkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGYuX2dldFNlbGVjdGlvbk1hdHJpeChzZWxlY3Rpb25SZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9nZXRTZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gICAgICAgIHZhciBjb2xDb3VudCA9IHJlY3QuZXh0ZW50LnggKyAxO1xuICAgICAgICB2YXIgcm93Q291bnQgPSByZWN0LmV4dGVudC55ICsgMTtcbiAgICAgICAgdmFyIG94ID0gcmVjdC5vcmlnaW4ueDtcbiAgICAgICAgdmFyIG95ID0gcmVjdC5vcmlnaW4ueTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbENvdW50OyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBuZXcgQXJyYXkocm93Q291bnQpO1xuICAgICAgICAgICAgcmVzdWx0W2NdID0gY29sdW1uO1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uW3JdID0gdmFsT3JGdW5jKHRoaXMuZ2V0VmFsdWUob3ggKyBjLCBveSArIHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1jb250ZXh0LW1lbnVgIGV2ZW50XG4gICAgICogQHBhcmFtIHtrZXlFdmVudH0gZXZlbnQgLSBUaGUgY2FudmFzIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNDb250ZXh0TWVudUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuZ3JpZENlbGwgPSB0aGlzLmNvbnZlcnRWaWV3UG9pbnRUb0RhdGFQb2ludChlLmdyaWRDZWxsKTtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tY29udGV4dC1tZW51Jywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGUuZ3JpZENlbGwsXG4gICAgICAgICAgICAgICAgbW91c2VQb2ludDogZS5tb3VzZVBvaW50LFxuICAgICAgICAgICAgICAgIHZpZXdQb2ludDogZS52aWV3UG9pbnQsXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlRXZlbnQ6IGUucHJpbWl0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY01vdXNlVXBFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1tb3VzZXVwJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGUuZ3JpZENlbGwsXG4gICAgICAgICAgICAgICAgbW91c2VQb2ludDogZS5tb3VzZVBvaW50LFxuICAgICAgICAgICAgICAgIHZpZXdQb2ludDogZS52aWV3UG9pbnQsXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlRXZlbnQ6IGUucHJpbWl0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY01vdXNlRG93bkV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tbW91c2Vkb3duJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGUuZ3JpZENlbGwsXG4gICAgICAgICAgICAgICAgbW91c2VQb2ludDogZS5tb3VzZVBvaW50LFxuICAgICAgICAgICAgICAgIHZpZXdQb2ludDogZS52aWV3UG9pbnQsXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlRXZlbnQ6IGUucHJpbWl0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9LFxuXG4gICAgaXNWaWV3YWJsZUJ1dHRvbjogZnVuY3Rpb24oYywgcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmlzVmlld2FibGVCdXR0b24oYywgcik7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNCdXR0b25QcmVzc2VkRXZlbnQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgZGF0YUNlbGwgPSBldnQuZGF0YUNlbGw7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2dC5ncmlkQ2VsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3YWJsZUJ1dHRvbihkYXRhQ2VsbC54LCBkYXRhQ2VsbC55KSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tYnV0dG9uLXByZXNzZWQnLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRDZWxsOiBncmlkQ2VsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1rZXlkb3duYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge2tleUV2ZW50fSBldmVudCAtIFRoZSBjYW52YXMgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0tleWRvd25FdmVudDogZnVuY3Rpb24oa2V5RXZlbnQpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1rZXlkb3duJywge1xuICAgICAgICAgICAgZGV0YWlsOiBrZXlFdmVudC5kZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4ta2V5dXBgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7a2V5RXZlbnR9IGV2ZW50IC0gVGhlIGNhbnZhcyBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljS2V5dXBFdmVudDogZnVuY3Rpb24oa2V5RXZlbnQpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1rZXl1cCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoga2V5RXZlbnQuZGV0YWlsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljRmlsdGVyQXBwbGllZEV2ZW50OiBmdW5jdGlvbihkZXRhaWxzKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWZpbHRlci1hcHBsaWVkJywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY2VsbC1lbnRlcmAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjZWxsIGluIHdoaWNoIHRoZSBjbGljayBldmVudCBvY2N1cnJlZC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIHN5c3RlbSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljT25DZWxsRW50ZXJFdmVudDogZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWNlbGwtZW50ZXInLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0dyb3Vwc0NoYW5nZWRFdmVudDogZnVuY3Rpb24oZ3JvdXBzKSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSB7XG4gICAgICAgICAgICBncm91cHM6IGdyb3VwcyxcbiAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBncmlkOiB0aGlzXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tZ3JvdXBzLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1jZWxsLWV4aXRgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIGNlbGwgaW4gd2hpY2ggdGhlIGNsaWNrIGV2ZW50IG9jY3VyZWQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBzeXN0ZW0gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY09uQ2VsbEV4aXRFdmVudDogZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWNlbGwtZXhpdCcsIHtcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWNlbGwtY2xpY2tgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIGNlbGwgaW4gd2hpY2ggdGhlIGNsaWNrIGV2ZW50IG9jY3VyZWQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBzeXN0ZW0gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0NsaWNrRXZlbnQ6IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIGNlbGwgPSBtb3VzZUV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICBtb3VzZVBvaW50OiBtb3VzZUV2ZW50Lm1vdXNlUG9pbnQsXG4gICAgICAgICAgICBrZXlzOiBtb3VzZUV2ZW50LmtleXMsXG4gICAgICAgICAgICBwcmltaXRpdmVFdmVudDogbW91c2VFdmVudCxcbiAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBncmlkOiB0aGlzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuZW5oYW5jZURvdWJsZUNsaWNrRXZlbnQoZGV0YWlsKTtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jbGljaycsIHtcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWRvdWJsZS1jbGlja2AgZXZlbnQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBzeXN0ZW0gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0RvdWJsZUNsaWNrRXZlbnQ6IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgICAgICB2YXIgY2VsbCA9IG1vdXNlRXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciBkZXRhaWwgPSB7XG4gICAgICAgICAgICBncmlkQ2VsbDogY2VsbCxcbiAgICAgICAgICAgIG1vdXNlUG9pbnQ6IG1vdXNlRXZlbnQubW91c2VQb2ludCxcbiAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBncmlkOiB0aGlzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuZW5oYW5jZURvdWJsZUNsaWNrRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tZG91YmxlLWNsaWNrJywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuY2VsbERvdWJsZUNsaWNrZWQoY2VsbCwgbW91c2VFdmVudCk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIHJlbmRlcmVkIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNHcmlkUmVuZGVyZWRFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWdyaWQtcmVuZGVyZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBzY3JvbGwgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBTaG91bGQgYmUgZWl0aGVyIGBmaW4tc2Nyb2xsLXhgIG9yIGBmaW4tc2Nyb2xsLXlgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvbGRWYWx1ZSAtIFRoZSBvbGQgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIGZpcmVTY3JvbGxFdmVudDogZnVuY3Rpb24odHlwZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCh0eXBlLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSB2ZXJ0aWNhbCBzY3JvbGwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1ZhbHVlIC0gVGhlIG5ldyBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgc2V0VlNjcm9sbFZhbHVlOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5zYlZTY3JvbGxlci5yYW5nZS5tYXg7XG4gICAgICAgIHkgPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KDAsIHkpKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoeSAhPT0gdGhpcy52U2Nyb2xsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuX3NldFNjcm9sbFBvc2l0aW9uWSh5KTtcbiAgICAgICAgICAgIHZhciBvbGRZID0gdGhpcy52U2Nyb2xsVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnZTY3JvbGxWYWx1ZSA9IHk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBzZWxmLnNiVlJhbmdlQWRhcHRlci5zdWJqZWN0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZVNjcm9sbEV2ZW50KCdmaW4tc2Nyb2xsLXknLCBvbGRZLCB5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmVydGljYWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIGdldFZTY3JvbGxWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZTY3JvbGxWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIGhvcml6b250YWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIHNldEhTY3JvbGxWYWx1ZTogZnVuY3Rpb24oeCkge1xuICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgdmFyIG1heCA9IHRoaXMuc2JIU2Nyb2xsZXIucmFuZ2UubWF4O1xuICAgICAgICB4ID0gTWF0aC5taW4obWF4LCBNYXRoLm1heCgwLCB4KSk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHggIT09IHRoaXMuaFNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLl9zZXRTY3JvbGxQb3NpdGlvblgoeCk7XG4gICAgICAgICAgICB2YXIgb2xkWCA9IHRoaXMuaFNjcm9sbFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oU2Nyb2xsVmFsdWUgPSB4O1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy9zZWxmLnNiSFJhbmdlQWRhcHRlci5zdWJqZWN0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZVNjcm9sbEV2ZW50KCdmaW4tc2Nyb2xsLXgnLCBvbGRYLCB4KTtcbiAgICAgICAgICAgICAgICBzZWxmLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIFRoZSB2ZXJ0aWNhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0SFNjcm9sbFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFNjcm9sbFZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcXVlc3QgaW5wdXQgZm9jdXMuXG4gICAgICovXG4gICAgdGFrZUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFZGl0aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkudGFrZUZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXF1ZXN0IGZvY3VzIGZvciBvdXIgY2VsbCBlZGl0b3IuXG4gICAgICovXG4gICAgZWRpdG9yVGFrZUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbEVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbEVkaXRvci50YWtlRm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXZSBoYXZlIGEgY3VycmVudGx5IGFjdGl2ZSBjZWxsIGVkaXRvci5cbiAgICAgKi9cbiAgICBpc0VkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsRWRpdG9yICYmIHRoaXMuY2VsbEVkaXRvci5pc0VkaXRpbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgSW5pdGlhbGl6ZSB0aGUgc2Nyb2xsIGJhcnMuXG4gICAgICovXG4gICAgaW5pdFNjcm9sbGJhcnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgaG9yekJhciA9IG5ldyBGaW5CYXIoe1xuICAgICAgICAgICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIG9uY2hhbmdlOiBzZWxmLnNldEhTY3JvbGxWYWx1ZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnQ6IHRoaXMuZGl2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB2ZXJ0QmFyID0gbmV3IEZpbkJhcih7XG4gICAgICAgICAgICBvcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICAgICAgICAgIG9uY2hhbmdlOiBzZWxmLnNldFZTY3JvbGxWYWx1ZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgcGFnaW5nOiB7XG4gICAgICAgICAgICAgICAgdXA6IHNlbGYucGFnZVVwLmJpbmQoc2VsZiksXG4gICAgICAgICAgICAgICAgZG93bjogc2VsZi5wYWdlRG93bi5iaW5kKHNlbGYpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIgPSBob3J6QmFyO1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyID0gdmVydEJhcjtcblxuICAgICAgICB2YXIgaFByZWZpeCA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdoU2Nyb2xsYmFyQ2xhc3NQcmVmaXgnKTtcbiAgICAgICAgdmFyIHZQcmVmaXggPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgndlNjcm9sbGJhckNsYXNzUHJlZml4Jyk7XG5cbiAgICAgICAgaWYgKGhQcmVmaXggJiYgaFByZWZpeCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuY2xhc3NQcmVmaXggPSBoUHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZQcmVmaXggJiYgdlByZWZpeCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIuY2xhc3NQcmVmaXggPSB2UHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoaG9yekJhci5iYXIpO1xuICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZCh2ZXJ0QmFyLmJhcik7XG5cbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGxiYXJzKCk7XG5cbiAgICB9LFxuXG4gICAgcmVzaXplU2Nyb2xsYmFyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuc2hvcnRlbkJ5KHRoaXMuc2JWU2Nyb2xsZXIpLnJlc2l6ZSgpO1xuICAgICAgICAvL3RoaXMuc2JWU2Nyb2xsZXIuc2hvcnRlbkJ5KHRoaXMuc2JIU2Nyb2xsZXIpO1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNjcm9sbCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLCB3ZSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqL1xuICAgIHNldFZTY3JvbGxiYXJWYWx1ZXM6IGZ1bmN0aW9uKG1heCkge1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLnJhbmdlID0ge1xuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2V0SFNjcm9sbGJhclZhbHVlczogZnVuY3Rpb24obWF4KSB7XG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIucmFuZ2UgPSB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IG1heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLmhTY3JvbGxWYWx1ZSA9PT0gdGhpcy5zYlByZXZIU2Nyb2xsVmFsdWUgJiYgdGhpcy52U2Nyb2xsVmFsdWUgPT09IHRoaXMuc2JQcmV2VlNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNiUHJldkhTY3JvbGxWYWx1ZSA9IHRoaXMuaFNjcm9sbFZhbHVlO1xuICAgICAgICB0aGlzLnNiUHJldlZTY3JvbGxWYWx1ZSA9IHRoaXMudlNjcm9sbFZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5zY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgR2V0IGRhdGEgdmFsdWUgYXQgZ2l2ZW4gY2VsbC5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRWYWx1ZSh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgYSBkYXRhIHZhbHVlIGludG8gdGhlIGJlaGF2aW9yIChtb2RlbCkgYXQgdGhlIGdpdmVuIHBvaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5BbGlnbm1lbnQ6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1uQWxpZ25tZW50KGMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBkYXRhIGRpbWVuc2lvbnMgaGF2ZSBjaGFuZ2VkLCBvciBvdXIgcGl4ZWwgYm91bmRyaWVzIGhhdmUgY2hhbmdlZC5cbiAgICAgKiBBZGp1c3QgdGhlIHNjcm9sbGJhciBwcm9wZXJ0aWVzIGFzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBzeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IHRoaXMuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBudW1Db2x1bW5zID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Nyb2xsYWJsZUhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSB0aGlzLmJlaGF2aW9yLmdldEZpeGVkUm93c01heEhlaWdodCgpIC0gMTU7IC8vNXB4IHBhZGRpbmcgYXQgYm90dG9tIGFuZCByaWdodCBzaWRlXG4gICAgICAgIHZhciBzY3JvbGxhYmxlV2lkdGggPSAoYm91bmRzLndpZHRoIC0gMjAwKSAtIHRoaXMuYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGgoKSAtIDE1O1xuXG4gICAgICAgIHZhciBsYXN0UGFnZUNvbHVtbkNvdW50ID0gMDtcbiAgICAgICAgdmFyIGNvbHVtbnNXaWR0aCA9IDA7XG4gICAgICAgIGZvciAoOyBsYXN0UGFnZUNvbHVtbkNvdW50IDwgbnVtQ29sdW1uczsgbGFzdFBhZ2VDb2x1bW5Db3VudCsrKSB7XG4gICAgICAgICAgICB2YXIgZWFjaFdpZHRoID0gdGhpcy5nZXRDb2x1bW5XaWR0aChudW1Db2x1bW5zIC0gbGFzdFBhZ2VDb2x1bW5Db3VudCAtIDEpO1xuICAgICAgICAgICAgY29sdW1uc1dpZHRoID0gY29sdW1uc1dpZHRoICsgZWFjaFdpZHRoO1xuICAgICAgICAgICAgaWYgKGNvbHVtbnNXaWR0aCA+IHNjcm9sbGFibGVXaWR0aCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RQYWdlUm93Q291bnQgPSAwO1xuICAgICAgICB2YXIgcm93c0hlaWdodCA9IDA7XG4gICAgICAgIGZvciAoOyBsYXN0UGFnZVJvd0NvdW50IDwgbnVtUm93czsgbGFzdFBhZ2VSb3dDb3VudCsrKSB7XG4gICAgICAgICAgICB2YXIgZWFjaEhlaWdodCA9IHRoaXMuZ2V0Um93SGVpZ2h0KG51bVJvd3MgLSBsYXN0UGFnZVJvd0NvdW50IC0gMSk7XG4gICAgICAgICAgICByb3dzSGVpZ2h0ID0gcm93c0hlaWdodCArIGVhY2hIZWlnaHQ7XG4gICAgICAgICAgICBpZiAocm93c0hlaWdodCA+IHNjcm9sbGFibGVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoTWF4ID0gTWF0aC5tYXgoMCwgbnVtQ29sdW1ucyAtIG51bUZpeGVkQ29sdW1ucyAtIGxhc3RQYWdlQ29sdW1uQ291bnQpO1xuICAgICAgICB0aGlzLnNldEhTY3JvbGxiYXJWYWx1ZXMoaE1heCk7XG5cbiAgICAgICAgdmFyIHZNYXggPSAxICsgTWF0aC5tYXgoMCwgbnVtUm93cyAtIG51bUZpeGVkUm93cyAtIGxhc3RQYWdlUm93Q291bnQpO1xuICAgICAgICB0aGlzLnNldFZTY3JvbGxiYXJWYWx1ZXModk1heCk7XG5cbiAgICAgICAgdGhpcy5zZXRIU2Nyb2xsVmFsdWUoTWF0aC5taW4odGhpcy5nZXRIU2Nyb2xsVmFsdWUoKSwgaE1heCkpO1xuICAgICAgICB0aGlzLnNldFZTY3JvbGxWYWx1ZShNYXRoLm1pbih0aGlzLmdldFZTY3JvbGxWYWx1ZSgpLCB2TWF4KSk7XG5cbiAgICAgICAgLy90aGlzLmdldENhbnZhcygpLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcblxuICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbGJhcnMoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIE5vdGUgdGhhdCBcInZpZXdhYmxlIHJvd3NcIiBpbmNsdWRlcyBhbnkgcGFydGlhbGx5IHZpZXdhYmxlIHJvd3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiB2aWV3YWJsZSByb3dzLlxuICAgICAqL1xuICAgIGdldFZpc2libGVSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRWaXNpYmxlUm93cygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIE5vdGUgdGhhdCBcInZpZXdhYmxlIGNvbHVtbnNcIiBpbmNsdWRlcyBhbnkgcGFydGlhbGx5IHZpZXdhYmxlIGNvbHVtbnMuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiB2aWV3YWJsZSBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRWaXNpYmxlQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEluaXRpYWxpemUgdGhlIHJlbmRlcmVyIHN1Yi1jb21wb25lbnQuXG4gICAgICovXG4gICAgaW5pdFJlbmRlcmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcih0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IHN1Yi1jb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIFRoZSB1bnRyYW5zbGF0ZWQgY29sdW1uIGluZGV4LlxuICAgICAqL1xuICAgIGdldENvbHVtbldpZHRoOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIFRoZSB1bnRyYW5zbGF0ZWQgY29sdW1uIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5XaWR0aCAtIFRoZSB3aWR0aCBpbiBwaXhlbHMuXG4gICAgICovXG4gICAgc2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uKGNvbHVtbkluZGV4LCBjb2x1bW5XaWR0aCkge1xuICAgICAgICB0aGlzLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0Q29sdW1uV2lkdGgoY29sdW1uSW5kZXgsIGNvbHVtbldpZHRoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uRWRnZTogZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRDb2x1bW5FZGdlKGMsIHRoaXMuZ2V0UmVuZGVyZXIoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHRvdGFsIHdpZHRoIG9mIGFsbCB0aGUgZml4ZWQgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbnNXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEZpeGVkQ29sdW1uc1dpZHRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgZ2l2ZW4gcm93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIHVudHJhbnNsYXRlZCBmaXhlZCBjb2x1bW4gaW5kZXguXG4gICAgICovXG4gICAgZ2V0Um93SGVpZ2h0OiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRSb3dIZWlnaHQocm93SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiByb3cuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIHJvdyBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SGVpZ2h0IC0gVGhlIHdpZHRoIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBzZXRSb3dIZWlnaHQ6IGZ1bmN0aW9uKHJvd0luZGV4LCByb3dIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldFJvd0hlaWdodChyb3dJbmRleCwgcm93SGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdG90YWwgZml4ZWQgcm93cyBoZWlnaHRcbiAgICAgKi9cbiAgICBnZXRGaXhlZFJvd3NIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZFJvd3NIZWlnaHQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgcm93cy5cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiB1bmZpbHRlcmVkIHJvd3MuXG4gICAgICovXG4gICAgZ2V0VW5maWx0ZXJlZFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0VW5maWx0ZXJlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgVGhlIHRvcCBsZWZ0IGFyZWEgaGFzIGJlZW4gY2xpY2tlZCBvblxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICB0b3BMZWZ0Q2xpY2tlZDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci50b3BMZWZ0Q2xpY2tlZCh0aGlzLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQSBmaXhlZCByb3cgaGFzIGJlZW4gY2xpY2tlZC5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGRldGFpbHMuXG4gICAgICovXG4gICAgcm93SGVhZGVyQ2xpY2tlZDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5yb3dIZWFkZXJDbGlja2VkKHRoaXMsIG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBBIGZpeGVkIGNvbHVtbiBoYXMgYmVlbiBjbGlja2VkLlxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJDbGlja2VkOiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmNvbHVtbkhlYWRlckNsaWNrZWQodGhpcywgbW91c2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFuIGVkaXQgZXZlbnQgaGFzIG9jY3VycmVkLiBBY3RpdmF0ZSB0aGUgZWRpdG9yIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQuZ3JpZENlbGwueCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LmdyaWRDZWxsLnkgLSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtldmVudC5wcmltaXRpdmVFdmVudC50eXBlXVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Q2VsbEVkaXRvcn0gVGhlIGVkaXRvciBvYmplY3Qgb3IgYHVuZGVmaW5lZGAgaWYgbm8gZWRpdG9yIG9yIGVkaXRvciBhbHJlYWR5IG9wZW4uXG4gICAgICovXG4gICAgb25FZGl0b3JBY3RpdmF0ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gZXZlbnQuZ3JpZENlbGw7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNFZGl0YWJsZSgpIHx8IHRoaXMuaXNGaWx0ZXJSb3cocG9pbnQueSkpIHtcbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICBpc0RibENsaWNrID0gcHJpbUV2ZW50ICYmIHByaW1FdmVudC50eXBlID09PSAnZmluLWNhbnZhcy1kYmxjbGljaycsXG4gICAgICAgICAgICAgICAgZWRpdG9yID0gdGhpcy5nZXRDZWxsRWRpdG9yQXQocG9pbnQueCwgcG9pbnQueSwgaXNEYmxDbGljayksXG4gICAgICAgICAgICAgICAgZWRpdG9yUG9pbnQgPSBlZGl0b3IuZ2V0RWRpdG9yUG9pbnQoKSxcbiAgICAgICAgICAgICAgICBzYW1lQ2VsbCA9IHBvaW50LmVxdWFscyhlZGl0b3JQb2ludCksXG4gICAgICAgICAgICAgICAgZWRpdG9yQWxyZWFkeU9wZW4gPSBzYW1lQ2VsbCAmJiBlZGl0b3IuaXNFZGl0aW5nO1xuXG4gICAgICAgICAgICBpZiAoZWRpdG9yQWxyZWFkeU9wZW4pIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRWRpdGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTsgLy9vdGhlciBlZGl0b3IgaXMgb3BlbiwgY2xvc2UgaXQgZmlyc3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0QXQoZWRpdG9yLCBwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWRpdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgY2VsbCBlZGl0b3IuXG4gICAgICogQGRlc2MgRGVsZWdhdGVzIHRvIHRoZSBiZWhhdmlvci5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2VsbCBlZGl0b3IgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7eH0geCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHt5fSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0RibENsaWNrIC0gV2hlbiBjYWxsZWQgZnJvbSBgb25FZGl0b3JBY3RpdmF0ZWAsIGluZGljYXRlcyBpZiBldmVudCB3YXMgYSBkb3VibGUtY2xpY2suXG4gICAgICovXG4gICAgZ2V0Q2VsbEVkaXRvckF0OiBmdW5jdGlvbih4LCB5LCBpc0RibENsaWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLl9nZXRDZWxsRWRpdG9yQXQoeCwgeSwgaXNEYmxDbGljayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgVG9nZ2xlIEhpRFBJIHN1cHBvcnQuXG4gICAgICogQGRlc2MgSGlEUEkgc3VwcG9ydCBpcyBub3cgKm9uKiBieSBkZWZhdWx0LlxuICAgICAqID4gVGhlcmUgdXNlZCB0byBiZSBhIGJ1ZyBpbiBDaHJvbWUgdGhhdCBjYXVzZWQgc2V2ZXJlIHNsb3cgZG93biBvbiBiaXQgYmxpdCBvZiBsYXJnZSBpbWFnZXMsIHNvIHRoaXMgSGlEUEkgbmVlZGVkIHRvIGJlIG9wdGlvbmFsLlxuICAgICAqL1xuICAgIHRvZ2dsZUhpRFBJOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlSGlEUEkoKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2hpZHBpJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGlkcGknLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbnZhcy5yZXNpemUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUZSBIaURQSSByYXRpby5cbiAgICAgKi9cbiAgICBnZXRIaURQSTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAmJiB0aGlzLnVzZUhpRFBJKCkpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgICAgIHZhciBiYWNraW5nU3RvcmVSYXRpbyA9IGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgICAgICAgICAgdmFyIHJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICAgICAgICAgICAgcmV0dXJuIHJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGdpdmVuIChyZWNlbnRseSByZW5kZXJlZCkgY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleCAtIFRoZSBjb2x1bW4gaW5kZXguXG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRXaWR0aDogZnVuY3Rpb24oY29sSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0UmVuZGVyZWRXaWR0aChjb2xJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgZ2l2ZW4gKHJlY2VudGx5IHJlbmRlcmVkKSByb3cuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVHRoZSByb3cgaW5kZXguXG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRIZWlnaHQ6IGZ1bmN0aW9uKHJvd0luZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFJlbmRlcmVkSGVpZ2h0KHJvd0luZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Q2VsbEVkaXRvcn0gVGhlIGNlbGwgZWRpdG9yIGF0IGFsaWFzIFwibmFtZVwiIChhIHN1Yi1jb21wb25lbnQpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG4gICAgcmVzb2x2ZUNlbGxFZGl0b3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbEVkaXRvcnNbbmFtZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVXBkYXRlIHRoZSBjdXJzb3IgdW5kZXIgdGhlIGhvdmVyIGNlbGwuXG4gICAgICovXG4gICAgdXBkYXRlQ3Vyc29yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuYmVoYXZpb3IuZ2V0Q3Vyc29yQXQoLTEsIC0xKTtcbiAgICAgICAgdmFyIGhvdmVyQ2VsbCA9IHRoaXMuZ2V0SG92ZXJDZWxsKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGhvdmVyQ2VsbCAmJlxuICAgICAgICAgICAgaG92ZXJDZWxsLnggPiAtMSAmJlxuICAgICAgICAgICAgaG92ZXJDZWxsLnkgPiAtMVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB4ID0gaG92ZXJDZWxsLnggKyB0aGlzLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICAgICAgY3Vyc29yID0gdGhpcy5iZWhhdmlvci5nZXRDdXJzb3JBdCh4LCBob3ZlckNlbGwueSArIHRoaXMuZ2V0VlNjcm9sbFZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVDdXJzb3IoY3Vyc29yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXBhaW50IHRoZSBnaXZlbiBjZWxsLlxuICAgICAqIEBwYXJhbSB7eH0geCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHt5fSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgcmVwYWludENlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdGhpcy5nZXRSZW5kZXJlcigpLnJlcGFpbnRDZWxsKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgdXNlciBpcyBjdXJyZW50bHkgZHJhZ2dpbmcgYSBjb2x1bW4gdG8gcmVvcmRlciBpdC5cbiAgICAgKi9cbiAgICBpc0RyYWdnaW5nQ29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNjcm9sbCB1cCBvbmUgZnVsbCBwYWdlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcGFnZVVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJvd051bSA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRQYWdlVXBSb3coKTtcbiAgICAgICAgdGhpcy5zZXRWU2Nyb2xsVmFsdWUocm93TnVtKTtcbiAgICAgICAgcmV0dXJuIHJvd051bTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTY3JvbGwgZG93biBvbmUgZnVsbCBwYWdlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcGFnZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm93TnVtID0gdGhpcy5nZXRSZW5kZXJlcigpLmdldFBhZ2VEb3duUm93KCk7XG4gICAgICAgIHRoaXMuc2V0VlNjcm9sbFZhbHVlKHJvd051bSk7XG4gICAgICAgIHJldHVybiByb3dOdW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgTm90IHlldCBpbXBsZW1lbnRlZC5cbiAgICAgKi9cbiAgICBwYWdlTGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwYWdlIGxlZnQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBOb3QgeWV0IGltcGxlbWVudGVkLlxuICAgICAqL1xuICAgIHBhZ2VSaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwYWdlIHJpZ2h0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfSBPYmplY3RzIHdpdGggdGhlIHZhbHVlcyB0aGF0IHdlcmUganVzdCByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBhc3N1bWVzIG9uZSByb3cgb2YgaGVhZGVyc1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmJlaGF2aW9yLFxuICAgICAgICAgICAgcmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKCksXG4gICAgICAgICAgICBjb2xDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgIHJvd0NvdW50ID0gcmVuZGVyZXIuZ2V0VmlzaWJsZVJvd3MoKSxcbiAgICAgICAgICAgIGhlYWRlcnMgPSBuZXcgQXJyYXkoY29sQ291bnQpLFxuICAgICAgICAgICAgcmVzdWx0cyA9IG5ldyBBcnJheShyb3dDb3VudCksXG4gICAgICAgICAgICByb3c7XG5cbiAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlciwgYykge1xuICAgICAgICAgICAgaGVhZGVyc1tjXSA9IGJlaGF2aW9yLmdldENvbHVtbklkKGMsIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24ocmVzdWx0LCByKSB7XG4gICAgICAgICAgICByb3cgPSByZXN1bHRzW3JdID0ge1xuICAgICAgICAgICAgICAgIGhpZXJhcmNoeTogYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5WYWx1ZSgwLCByKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgYykge1xuICAgICAgICAgICAgICAgIHJvd1tmaWVsZF0gPSBiZWhhdmlvci5nZXRWYWx1ZShjLCByKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50bHkgc2VsZWN0aW9uIHJvdy5cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxzID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5iZWhhdmlvcixcbiAgICAgICAgICAgICAgICBjb2xDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgICAgICB0b3BSb3cgPSBzZWxzWzBdLm9yaWdpbi55LFxuICAgICAgICAgICAgICAgIHJvdyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy9oaWVyYXJjaHk6IGJlaGF2aW9yLmdldEZpeGVkQ29sdW1uVmFsdWUoMCwgdG9wUm93KVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHJvd1tiZWhhdmlvci5nZXRDb2x1bW5JZChjLCAwKV0gPSBiZWhhdmlvci5nZXRWYWx1ZShjLCB0b3BSb3cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpcmVSZXF1ZXN0Q2VsbEVkaXQ6IGZ1bmN0aW9uKGNlbGwsIHZhbHVlKSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tcmVxdWVzdC1jZWxsLWVkaXQnLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpOyAvL0kgd2Fzbid0IGNhbmNlbGxlZFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgZmluLWJlZm9yZS1jZWxsLWVkaXQgZXZlbnQuXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSB4LHkgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gVGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICovXG4gICAgZmlyZUJlZm9yZUNlbGxFZGl0OiBmdW5jdGlvbihjZWxsLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGNvbnRyb2wpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1iZWZvcmUtY2VsbC1lZGl0Jywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICBpbnB1dDogY29udHJvbCxcbiAgICAgICAgICAgICAgICByb3c6IHRoaXMuZ2V0Um93KGNlbGwueSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwcm9jZWVkID0gdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHByb2NlZWQ7IC8vSSB3YXNuJ3QgY2FuY2VsbGVkXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1JlbmRlcmVyfSBzdWItY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSB4LHkgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlIC0gVGhlIG9sZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWUgLSBUaGUgbmV3IHZhbHVlLlxuICAgICAqL1xuICAgIGZpcmVBZnRlckNlbGxFZGl0OiBmdW5jdGlvbihjZWxsLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGNvbnRyb2wpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1hZnRlci1jZWxsLWVkaXQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGNvbnRyb2wsXG4gICAgICAgICAgICAgICAgcm93OiB0aGlzLmdldFJvdyhjZWxsLnkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEF1dG9zaXplIHRoZSBjb2x1bW4gYXQgY29sSW5kZXggZm9yIGJlc3QgZml0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleCAtIFRoZSBjb2x1bW4gaW5kZXggdG8gbW9kaWZ5IGF0XG4gICAgICovXG4gICAgYXV0b3NpemVDb2x1bW46IGZ1bmN0aW9uKGNvbEluZGV4KSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmJlaGF2aW9yLmdldENvbHVtbihjb2xJbmRleCk7XG4gICAgICAgIGNvbHVtbi5jaGVja0NvbHVtbkF1dG9zaXppbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRW5hYmxlL2Rpc2FibGUgaWYgdGhpcyBjb21wb25lbnQgY2FuIHJlY2VpdmUgdGhlIGZvY3VzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gLSBjYW5SZWNlaXZlRm9jdXNcbiAgICAgKi9cbiAgICBzZXRGb2N1c2FibGU6IGZ1bmN0aW9uKGNhblJlY2VpdmVGb2N1cykge1xuICAgICAgICB0aGlzLmdldENhbnZhcygpLnNldEZvY3VzYWJsZShjYW5SZWNlaXZlRm9jdXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29sdW1ucyB0aGF0IHdlcmUganVzdCByZW5kZXJlZFxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmdldFZpc2libGVDb2x1bW5zQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3MgdGhhdCB3ZXJlIGp1c3QgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93c0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRWaXNpYmxlUm93c0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgdXBkYXRlIHRoZSBzaXplIG9mIHRoZSBncmlkXG4gICAgICpcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICB1cGRhdGVTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuY2hlY2tzaXplKCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTdG9wIHRoZSBnbG9iYWwgcmVwYWludGluZyBmbGFnIHRocmVhZC5cbiAgICAgKi9cbiAgICBzdG9wUGFpbnRUaHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5zdG9wUGFpbnRUaHJlYWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTdG9wIHRoZSBnbG9iYWwgcmVzaXplIGNoZWNrIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHN0b3BSZXNpemVUaHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5zdG9wUmVzaXplVGhyZWFkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVzdGFydCB0aGUgZ2xvYmFsIHJlc2l6ZSBjaGVjayBmbGFnIHRocmVhZC5cbiAgICAgKi9cbiAgICByZXN0YXJ0UmVzaXplVGhyZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMucmVzdGFydFJlc2l6ZVRocmVhZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlc3RhcnQgdGhlIGdsb2JhbCByZXBhaW50aW5nIGNoZWNrIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHJlc3RhcnRQYWludFRocmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlc3RhcnRQYWludFRocmVhZCgpO1xuICAgIH0sXG5cbiAgICBzd2FwQ29sdW1uczogZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zd2FwQ29sdW1ucyhzb3VyY2UsIHRhcmdldCk7XG4gICAgfSxcblxuICAgIGVuZERyYWdDb2x1bW5Ob3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmVuZERyYWdDb2x1bW5Ob3RpZmljYXRpb24oKTtcbiAgICB9LFxuXG4gICAgZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbnNNYXhXaWR0aCgpO1xuICAgIH0sXG5cbiAgICBpc01vdXNlRG93bkluSGVhZGVyQXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW1IZWFkZXJDb2x1bW5zID0gdGhpcy5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtSGVhZGVyUm93cyA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIG1vdXNlRG93biA9IHRoaXMuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHJldHVybiBtb3VzZURvd24ueCA8IG51bUhlYWRlckNvbHVtbnMgfHwgbW91c2VEb3duLnkgPCBudW1IZWFkZXJSb3dzO1xuICAgIH0sXG5cbiAgICBpc0hlYWRlcldyYXBwaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdoZWFkZXJUZXh0V3JhcHBpbmcnKTtcbiAgICB9LFxuXG4gICAgX2dldEJvdW5kc09mQ2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLl9nZXRCb3VuZHNPZkNlbGwoeCwgeSk7XG4gICAgfSxcblxuICAgIGdldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldENvbHVtblByb3BlcnRpZXMoY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICBzZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgcHJvcGVydGllcykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldENvbHVtblByb3BlcnRpZXMoY29sdW1uSW5kZXgsIHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IubW92ZVNpbmdsZVNlbGVjdCh0aGlzLCB4LCB5KTtcbiAgICB9LFxuXG4gICAgc2VsZWN0Q2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHgsIHksIDAsIDApO1xuICAgIH0sXG5cbiAgICBnZXRIZWFkZXJDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIHRvZ2dsZVNvcnQ6IGZ1bmN0aW9uKHgsIGtleXMpIHtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmJlaGF2aW9yO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGJlaGF2aW9yLnRvZ2dsZVNvcnQoeCwga2V5cyk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuc3luY2hyb25pemVTY3JvbGxpbmdCb3VuZHJpZXMoKTtcbiAgICAgICAgICAgIC8vc2VsZi5iZWhhdmlvckNoYW5nZWQoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzQ29sdW1uQXV0b3NpemluZygpKSB7XG4gICAgICAgICAgICAgICAgYmVoYXZpb3IuYXV0b3NpemVBbGxDb2x1bW5zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJlcGFpbnQoKTtcbiAgICAgICAgfSwgMTApO1xuICAgIH0sXG5cbiAgICB0b2dnbGVTZWxlY3RDb2x1bW46IGZ1bmN0aW9uKHgsIGtleXMpIHtcbiAgICAgICAga2V5cyA9IGtleXMgfHwgW107XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHZhciBhbHJlYWR5U2VsZWN0ZWQgPSBtb2RlbC5pc0NvbHVtblNlbGVjdGVkKHgpO1xuICAgICAgICB2YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpID4gLTE7XG4gICAgICAgIHZhciBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSA+IC0xO1xuICAgICAgICBpZiAoIWhhc0NUUkwgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgICAgICBtb2RlbC5jbGVhcigpO1xuICAgICAgICAgICAgaWYgKCFhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5zZWxlY3RDb2x1bW4oeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ1RSTCkge1xuICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGVzZWxlY3RDb2x1bW4oeCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0Q29sdW1uKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNTSElGVCkge1xuICAgICAgICAgICAgICAgIG1vZGVsLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0Q29sdW1uKHRoaXMubGFzdEVkZ2VTZWxlY3Rpb25bMF0sIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxyZWFkeVNlbGVjdGVkICYmICFoYXNTSElGVCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvblswXSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0NvbHVtblNlbGVjdGlvbkNoYW5nZWRFdmVudCgpO1xuICAgIH0sXG5cbiAgICB0b2dnbGVTZWxlY3RSb3c6IGZ1bmN0aW9uKHksIGtleXMpIHtcbiAgICAgICAgLy93ZSBjYW4gc2VsZWN0IHRoZSB0b3RhbHMgcm93cyBpZiB0aGV5IGV4aXN0LCBidXQgbm90IHJvd3MgYWJvdmUgdGhhdFxuICAgICAgICBpZiAoeSA+IHRoaXMuZ2V0RmlsdGVyUm93SW5kZXgoKSkge1xuICAgICAgICAgICAga2V5cyA9IGtleXMgfHwgW107XG5cbiAgICAgICAgICAgIHZhciBzbSA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgICAgICB2YXIgYWxyZWFkeVNlbGVjdGVkID0gc20uaXNSb3dTZWxlY3RlZCh5KTtcbiAgICAgICAgICAgIHZhciBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSA+PSAwO1xuXG4gICAgICAgICAgICBpZiAoYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgc20uZGVzZWxlY3RSb3coeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2luZ2xlU2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgc20uc2VsZWN0Um93KHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgICAgICBzbS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHNtLnNlbGVjdFJvdyh0aGlzLmxhc3RFZGdlU2VsZWN0aW9uWzFdLCB5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFhbHJlYWR5U2VsZWN0ZWQgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvblsxXSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXNDaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zID0gdGhpcy5pc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMoKSxcbiAgICAgICAgICAgIGlzU2luZ2xlUm93U2VsZWN0aW9uTW9kZSA9IHRoaXMuaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlKCksXG4gICAgICAgICAgICBoYXNDVFJMID0gdGhpcy5tb3VzZURvd25TdGF0ZS5wcmltaXRpdmVFdmVudC5kZXRhaWwucHJpbWl0aXZlRXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICBpc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMgJiYgaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlIHx8XG4gICAgICAgICAgICAgICAgIWlzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucyAmJiAoIWhhc0NUUkwgfHwgaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyUm93U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBzZWxlY3RWaWV3cG9ydENlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKCk7XG4gICAgICAgIHZhciByZWFsWCA9IHJlbmRlcmVyLmdldFZpc2libGVDb2x1bW5zKClbeF07XG4gICAgICAgIHZhciByZWFsWSA9IHJlbmRlcmVyLmdldFZpc2libGVSb3dzKClbeV07XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0KHJlYWxYLCByZWFsWSArIGhlYWRlclJvd0NvdW50LCAwLCAwKTtcbiAgICAgICAgdGhpcy5zZXRNb3VzZURvd24odGhpcy5uZXdQb2ludChyZWFsWCwgcmVhbFkgKyBoZWFkZXJSb3dDb3VudCkpO1xuICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQodGhpcy5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RUb1ZpZXdwb3J0Q2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoc2VsZWN0aW9ucyAmJiBzZWxlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpO1xuICAgICAgICAgICAgdmFyIHJlYWxYID0gcmVuZGVyZXIuZ2V0VmlzaWJsZUNvbHVtbnMoKVt4XTtcbiAgICAgICAgICAgIHZhciByZWFsWSA9IHJlbmRlcmVyLmdldFZpc2libGVSb3dzKClbeV0gKyBoZWFkZXJSb3dDb3VudDtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzZWxlY3Rpb25zWzBdO1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHNlbGVjdGlvbi5vcmlnaW47XG4gICAgICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQodGhpcy5uZXdQb2ludChyZWFsWCAtIG9yaWdpbi54LCByZWFsWSAtIG9yaWdpbi55KSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIHJlYWxYIC0gb3JpZ2luLngsIHJlYWxZIC0gb3JpZ2luLnkpO1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0RmluYWxDZWxsT2ZDdXJyZW50Um93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldENvbHVtbkNvdW50KCkgLSAxO1xuICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKClbMF07XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCeSh0aGlzLmdldENvbHVtbkNvdW50KCksIDApO1xuICAgICAgICB0aGlzLnNlbGVjdCh4LCB5ICsgaGVhZGVyUm93Q291bnQsIDAsIDApO1xuICAgICAgICB0aGlzLnNldE1vdXNlRG93bih0aGlzLm5ld1BvaW50KHgsIHkgKyBoZWFkZXJSb3dDb3VudCkpO1xuICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQodGhpcy5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RUb0ZpbmFsQ2VsbE9mQ3VycmVudFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25zICYmIHNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1swXTtcbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSBzZWxlY3Rpb24ub3JpZ2luO1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQ7XG4gICAgICAgICAgICB2YXIgY29sdW1uQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJ5KGNvbHVtbkNvdW50LCAwKTtcblxuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgY29sdW1uQ291bnQgLSBvcmlnaW4ueCAtIDEsIGV4dGVudC55KTtcblxuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0Rmlyc3RDZWxsT2ZDdXJyZW50Um93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKClbMF07XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRIU2Nyb2xsVmFsdWUoMCk7XG4gICAgICAgIHRoaXMuc2VsZWN0KHgsIHkgKyBoZWFkZXJSb3dDb3VudCwgMCwgMCk7XG4gICAgICAgIHRoaXMuc2V0TW91c2VEb3duKHRoaXMubmV3UG9pbnQoeCwgeSArIGhlYWRlclJvd0NvdW50KSk7XG4gICAgICAgIHRoaXMuc2V0RHJhZ0V4dGVudCh0aGlzLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNlbGVjdFRvRmlyc3RDZWxsT2ZDdXJyZW50Um93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbnMgJiYgc2VsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzZWxlY3Rpb25zWzBdO1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHNlbGVjdGlvbi5vcmlnaW47XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gc2VsZWN0aW9uLmV4dGVudDtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIC1vcmlnaW4ueCwgZXh0ZW50LnkpO1xuICAgICAgICAgICAgdGhpcy5zZXRIU2Nyb2xsVmFsdWUoMCk7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWxlY3RGaW5hbENlbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdENlbGwodGhpcy5nZXRDb2x1bW5Db3VudCgpIC0gMSwgdGhpcy5nZXRSb3dDb3VudCgpIC0gMSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsQnkodGhpcy5nZXRDb2x1bW5Db3VudCgpLCB0aGlzLmdldFJvd0NvdW50KCkpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0VG9GaW5hbENlbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoc2VsZWN0aW9ucyAmJiBzZWxlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbMF07XG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gc2VsZWN0aW9uLm9yaWdpbjtcbiAgICAgICAgICAgIHZhciBjb2x1bW5Db3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgY29sdW1uQ291bnQgLSBvcmlnaW4ueCAtIDEsIHJvd0NvdW50IC0gb3JpZ2luLnkgLSAxKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnkoY29sdW1uQ291bnQsIHJvd0NvdW50KTtcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGlzU2hvd1Jvd051bWJlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Nob3dSb3dOdW1iZXJzJyk7XG4gICAgfSxcbiAgICBpc0VkaXRhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdlZGl0YWJsZScpID09PSB0cnVlO1xuICAgIH0sXG4gICAgaXNTaG93RmlsdGVyUm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdzaG93RmlsdGVyUm93Jyk7XG4gICAgfSxcbiAgICBpc1Nob3dIZWFkZXJSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Nob3dIZWFkZXJSb3cnKTtcbiAgICB9LFxuICAgIGdldEhlYWRlclJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICB9LFxuICAgIGlzRmlsdGVyUm93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB5ID09PSB0aGlzLmdldEZpbHRlclJvd0luZGV4KCk7XG4gICAgfSxcbiAgICBnZXRGaWx0ZXJSb3dJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc1Nob3dGaWx0ZXJSb3coKSA/IC0xIDogdGhpcy5pc1Nob3dIZWFkZXJSb3coKSA/IDEgOiAwO1xuICAgIH0sXG4gICAgc2V0R3JvdXBzOiBmdW5jdGlvbihhcnJheU9mQ29sdW1uSW5kZXhlcykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldEdyb3VwcyhhcnJheU9mQ29sdW1uSW5kZXhlcyk7XG4gICAgfSxcbiAgICBoYXNIaWVyYXJjaHlDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5oYXNIaWVyYXJjaHlDb2x1bW4oKTtcbiAgICB9LFxuICAgIGlzSGllcmFyY2h5Q29sdW1uOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0hpZXJhcmNoeUNvbHVtbigpICYmIHggPT09IDA7XG4gICAgfSxcbiAgICBjaGVja1Njcm9sbGJhclZpc2liaWxpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB2YXIgaG92ZXJDbGFzc092ZXIgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsYmFySG92ZXJPdmVyJyk7XG4gICAgICAgIC8vIHZhciBob3ZlckNsYXNzT2ZmID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGJhckhvdmVyT2ZmJyk7XG5cbiAgICAgICAgLy8gaWYgKGhvdmVyQ2xhc3NPZmYgPT09ICd2aXNpYmxlJykge1xuICAgICAgICAvLyAgICAgdGhpcy5zYkhTY3JvbGxlci5jbGFzc0xpc3QucmVtb3ZlKGhvdmVyQ2xhc3NPdmVyKTtcbiAgICAgICAgLy8gICAgIHRoaXMuc2JWU2Nyb2xsZXIuY2xhc3NMaXN0LnJlbW92ZShob3ZlckNsYXNzT2ZmKTtcbiAgICAgICAgLy8gICAgIHRoaXMuc2JIU2Nyb2xsZXIuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAvLyAgICAgdGhpcy5zYlZTY3JvbGxlci5jbGFzc0xpc3QuYWRkKCd2aXNpYmxlJyk7XG4gICAgICAgIC8vIH1cbiAgICB9LFxuICAgIGlzQ29sdW1uT3JSb3dTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzQ29sdW1uT3JSb3dTZWxlY3RlZCgpO1xuICAgIH0sXG4gICAgc2VsZWN0Q29sdW1uOiBmdW5jdGlvbih4MSwgeDIpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5zZWxlY3RDb2x1bW4oeDEsIHgyKTtcbiAgICB9LFxuICAgIHNlbGVjdFJvdzogZnVuY3Rpb24oeTEsIHkyKSB7XG4gICAgICAgIHZhciBzbSA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHZhciBzZWxlY3Rpb25FZGdlID0gdGhpcy5nZXRGaWx0ZXJSb3dJbmRleCgpICsgMTtcblxuICAgICAgICBpZiAodGhpcy5zaW5nbGVTZWxlY3QoKSkge1xuICAgICAgICAgICAgeTEgPSB5MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG11bHRpcGxlIHJvdyBzZWxlY3Rpb25cbiAgICAgICAgICAgIHkyID0geTIgfHwgeTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHkxLCB5Mik7XG4gICAgICAgIGlmIChtaW4gPj0gc2VsZWN0aW9uRWRnZSkge1xuICAgICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHkxLCB5Mik7XG4gICAgICAgICAgICBzbS5zZWxlY3RSb3cobWluLCBtYXgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpc1Jvd051bWJlckF1dG9zaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Jvd051bWJlckF1dG9zaXppbmcnKTtcbiAgICB9LFxuICAgIGlzUm93U2VsZWN0ZWQ6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuaXNSb3dTZWxlY3RlZChyKTtcbiAgICB9LFxuICAgIGlzQ29sdW1uU2VsZWN0ZWQ6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuaXNDb2x1bW5TZWxlY3RlZChjKTtcbiAgICB9LFxuICAgIGxvb2t1cEZlYXR1cmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5sb29rdXBGZWF0dXJlKGtleSk7XG4gICAgfSxcbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Um93KHkpO1xuICAgIH0sXG4gICAgZ2V0RmllbGROYW1lOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaWVsZE5hbWUoaW5kZXgpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5JbmRleDogZnVuY3Rpb24oZmllbGROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldENvbHVtbkluZGV4KGZpZWxkTmFtZSk7XG4gICAgfSxcbiAgICBpc0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2NlbGxTZWxlY3Rpb24nKSA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIGlzUm93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdyb3dTZWxlY3Rpb24nKSA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIGlzQ29sdW1uU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdjb2x1bW5TZWxlY3Rpb24nKSA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIGdldENvbXB1dGVkUm93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldENvbXB1dGVkUm93KHkpO1xuICAgIH0sXG4gICAgaXNDb2x1bW5BdXRvc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdjb2x1bW5BdXRvc2l6aW5nJykgPT09IHRydWU7XG4gICAgfSxcbiAgICBnZXRHbG9iYWxGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRHbG9iYWxGaWx0ZXIoKTtcbiAgICB9LFxuICAgIHNldEdsb2JhbEZpbHRlcjogZnVuY3Rpb24oZmlsdGVyT3JPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0R2xvYmFsRmlsdGVyKGZpbHRlck9yT3B0aW9ucyk7XG4gICAgfSxcbiAgICBzZWxlY3RSb3dzRnJvbUNlbGxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucygpKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCxcbiAgICAgICAgICAgICAgICBoYXNDVFJMID0gdGhpcy5tb3VzZURvd25TdGF0ZS5wcmltaXRpdmVFdmVudC5kZXRhaWwucHJpbWl0aXZlRXZlbnQuY3RybEtleTtcblxuICAgICAgICAgICAgaWYgKGhhc0NUUkwgJiYgIXRoaXMuaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnNlbGVjdFJvd3NGcm9tQ2VsbHMoMCwgaGFzQ1RSTCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChsYXN0ID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRMYXN0U2VsZWN0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RSb3cobnVsbCwgbGFzdC5jb3JuZXIueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJSb3dTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0Q29sdW1uc0Zyb21DZWxsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0Q29sdW1uc0Zyb21DZWxscygpO1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0ZWRSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgfSxcbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICB9LFxuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcbiAgICBnZXRMYXN0U2VsZWN0aW9uVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldExhc3RTZWxlY3Rpb25UeXBlKCk7XG4gICAgfSxcbiAgICBpc0NlbGxTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc0NlbGxTZWxlY3RlZCh4LCB5KTtcbiAgICB9LFxuICAgIGlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlKHgsIHkpO1xuICAgIH0sXG4gICAgc2VsZWN0QWxsUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0QWxsUm93cygpO1xuICAgIH0sXG4gICAgYXJlQWxsUm93c1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuYXJlQWxsUm93c1NlbGVjdGVkKCk7XG4gICAgfSxcbiAgICB0b2dnbGVTZWxlY3RBbGxSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJlQWxsUm93c1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0QWxsUm93cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG4gICAgZ2V0RmllbGQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0RmllbGQoeCk7XG4gICAgfSxcbiAgICBpc1NpbmdsZVJvd1NlbGVjdGlvbk1vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3NpbmdsZVJvd1NlbGVjdGlvbk1vZGUnKTtcbiAgICB9LFxuICAgIG5ld1BvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgfSxcbiAgICBuZXdSZWN0YW5nbGU6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBnZXRGb3JtYXR0ZWRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB5ID0geSArIHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIGZvcm1hdFR5cGUgPSB0aGlzLmdldENvbHVtblByb3BlcnRpZXMoeCkuZm9ybWF0O1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKHgsIHkpO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gdGhpcy5nZXRGb3JtYXR0ZXIoZm9ybWF0VHlwZSk7XG4gICAgICAgIHZhciBzdHJpbmcgPSBmb3JtYXR0ZXIodmFsdWUpO1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHN1bW1hcnkgVXBkYXRlIGRlZXAgcHJvcGVydGllcyB3aXRoIG5ldyB2YWx1ZXMuXG4gKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIGlzIGEgcmVjdXJzaXZlIHByb3BlcnR5IHNldHRlciB3aGljaCB1cGRhdGVzIGEgZGVlcCBwcm9wZXJ0eSBpbiBhIGRlc3RpbmF0aW9uIG9iamVjdCB3aXRoIHRoZSB2YWx1ZSBvZiBhIGNvbmdydWVudCBwcm9wZXJ0eSBpbiBhIHNvdXJjZSBvYmplY3QuXG4gKlxuICogPiBUZXJtaW5vbG9neTogQSBkZWVwIHByb3BlcnR5IGlzIGEgXCJ0ZXJtaW5hbCBub2RlXCIgKHByaW1pdGl2ZSB2YWx1ZSkgbmVzdGVkIGF0IHNvbWUgZGVwdGggKGkuZS4sIGRlcHRoID4gMSkgaW5zaWRlIGEgY29tcGxleCBvYmplY3QgKGFuIG9iamVjdCBjb250YWluaW5nIG5lc3RlZCBvYmplY3RzKS4gQSBjb25ncnVlbnQgcHJvcGVydHkgaXMgYSBwcm9wZXJ0eSBpbiBhbm90aGVyIG9iamVjdCB3aXRoIHRoZSBzYW1lIG5hbWUgYW5kIGF0IHRoZSBzYW1lIGxldmVsIG9mIG5lc3RpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBzaW1wbGUgYW5kIGVsZWdhbnQuIEkgcmVjb21tZW5kIHlvdSBzdHVkeSB0aGUgY29kZSwgd2hpY2ggbm9uZXRoZWxlc3MgaW1wbGllcyBhbGwgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAqIElmIHRoZSBkZWVwIHByb3BlcnR5IGlzIF9ub3RfIGZvdW5kIGluIGBkZXN0aW5hdGlvbmAsIGl0IHdpbGwgYmUgY3JlYXRlZC5cbiAqICogSWYgdGhlIGRlZXAgcHJvcGVydHkgaXMgZm91bmQgaW4gYGRlc3RpbmF0aW9uYCBfYW5kXyBpcyBhIHByaW1pdGl2ZSB0eXBlLCBpdCB3aWxsIGJlIG1vZGlmaWVkIChvdmVyd3JpdHRlbiB3aXRoIHRoZSB2YWx1ZSBmcm9tIGBzb3VyY2VgKS5cbiAqICogSWYgdGhlIGRlZXAgcHJvcGVydHkgaXMgZm91bmQgaW4gYGRlc3RpbmF0aW9uYCBfYnV0XyBpcyBub3QgYSBwcmltaXRpdmUgdHlwZSAoaS5lLiwgaXMgYSBuZXN0ZWQgb2JqZWN0KSwgaXQgd2lsbCBfYWxzb18gYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgKHByaW1pdGl2ZSkgdmFsdWUgZnJvbSBgc291cmNlYC5cbiAqICogSWYgdGhlIG5lc3RlZCBvYmplY3QgdGhlIGRlZXAgcHJvcGVydHkgaW5oYWJpdHMgaW4gYHNvdXJjZWAgaXMgbm90IGZvdW5kIGluIGBkZXN0aW5hdGlvbmAsIGl0IHdpbGwgYmUgY3JlYXRlZC5cbiAqICogSWYgdGhlIG5lc3RlZCBvYmplY3QgdGhlIGRlZXAgcHJvcGVydHkgaW5oYWJpdHMgaW4gYHNvdXJjZWAgaXMgZm91bmQgaW4gYGRlc3RpbmF0aW9uYCBidXQgaXMgbm90IGluIGZhY3QgYW4gb2JqZWN0IChpLmUuLCBpdCBpcyBhIHByaW1pdGl2ZSB2YWx1ZSksIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCBhIHJlZmVyZW5jZSB0byB0aGF0IG9iamVjdC5cbiAqICogSWYgdGhlIHByaW1pdGl2ZSB2YWx1ZSBpcyBgdW5kZWZpbmVkYCwgdGhlIGRlc3RpbmF0aW9uIHByb3BlcnR5IGlzIGRlbGV0ZWQuXG4gKiAqIGBzb3VyY2VgIG1heSBjb250YWluIG11bHRpcGxlIHByb3BlcnRpZXMgdG8gdXBkYXRlLlxuICpcbiAqIFRoYXQgb25lIHJ1bGUgaXMgc2ltcGx5IHRoaXM6IElmIGJvdGggdGhlIHNvdXJjZSBfYW5kXyB0aGUgZGVzdGluYXRpb24gcHJvcGVydGllcyBhcmUgb2JqZWN0cywgdGhlbiByZWN1cnNlOyBlbHNlIG92ZXJ3cml0ZSB0aGUgZGVzdGluYXRpb24gcHJvcGVydHkgd2l0aCB0aGUgc291cmNlIHByb3BlcnR5LlxuICpcbiAqID4gQ2F2ZWF0OiBUaGlzIGlzIF9ub3RfIGVxdWl2YWxlbnQgdG8gYSBkZWVwIGV4dGVuZCBmdW5jdGlvbi4gV2hpbGUgYm90aCBhIGRlZXAgZXh0ZW5kIGFuZCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmVjdXJzZSBvdmVyIGEgY29tcGxleCBvYmplY3QsIHRoZXkgYXJlIGZ1bmRhbWVudGFsbHkgZGlmZmVyZW50OiBBIGRlZXAgZXh0ZW5kIGNsb25lcyB0aGUgbmVzdGVkIG9iamVjdHMgYXMgaXQgZmluZHMgdGhlbTsgdGhpcyBmdW5jdGlvbiBtZXJlbHkgdXBkYXRlcyB0aGVtIChvciBjcmVhdGVzIHRoZW0gd2hlcmUgdGhleSBkb24ndCBleGlzdCkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRlc3RpbmF0aW9uIC0gQW4gb2JqZWN0IHRvIHVwZGF0ZSB3aXRoIG5ldyBvciBtb2RpZmllZCBwcm9wZXJ0eSB2YWx1ZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgLSBBIGNvbmdydWVudCBvYmplY3QgY29udGluYWx5IChvbmx5KSB0aGUgbmV3IG9yIG1vZGlmaWVkIHByb3BlcnR5IHZhbHVlcy5cbiAqIEByZXR1cm5zIHtvYmplY3R9IEFsd2F5cyByZXR1cm5zIGBkZXN0aW5hdGlvbmAuXG4gKi9cbmZ1bmN0aW9uIGFkZERlZXBQcm9wZXJ0aWVzKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICBfKHNvdXJjZSkuZWFjaChmdW5jdGlvbihwcm9wZXJ0eSwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25ba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb3BlcnR5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYWRkRGVlcFByb3BlcnRpZXMoZGVzdGluYXRpb25ba2V5XSwgcHJvcGVydHkpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkZXN0aW5hdGlvbltrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHByb3BlcnR5O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICB2YXIgbyA9IHJlY3Qub3JpZ2luO1xuICAgIHZhciBjID0gcmVjdC5jb3JuZXI7XG5cbiAgICB2YXIgb3ggPSBNYXRoLm1pbihvLngsIGMueCk7XG4gICAgdmFyIG95ID0gTWF0aC5taW4oby55LCBjLnkpO1xuXG4gICAgdmFyIGN4ID0gTWF0aC5tYXgoby54LCBjLngpO1xuICAgIHZhciBjeSA9IE1hdGgubWF4KG8ueSwgYy55KTtcblxuICAgIHZhciByZXN1bHQgPSBuZXcgUmVjdGFuZ2xlKG94LCBveSwgY3ggLSBveCwgY3kgLSBveSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBidWlsZFBvbHltZXJUaGVtZSgpIHtcbiAgICBjbGVhck9iamVjdFByb3BlcnRpZXMocG9seW1lclRoZW1lKTtcbiAgICB2YXIgcGIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwYXBlci1idXR0b24nKTtcblxuICAgIHBiLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgcGIuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGIpO1xuICAgIHZhciBwID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGIpO1xuXG4gICAgdmFyIHNlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gICAgc2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdoZXJvJywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzZWN0aW9uKTtcblxuICAgIHZhciBoID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCcpKTtcbiAgICB2YXIgaGIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sLCBib2R5JykpO1xuICAgIHZhciBzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc2VjdGlvbik7XG5cbiAgICBwb2x5bWVyVGhlbWUuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yID0gcC5jb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUucm93SGVhZGVyQmFja2dyb3VuZENvbG9yID0gcC5jb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUudG9wTGVmdEJhY2tncm91bmRDb2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLmxpbmVDb2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgcG9seW1lclRoZW1lLmJhY2tncm91bmRDb2xvcjIgPSBoYi5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICBwb2x5bWVyVGhlbWUuY29sb3IgPSBoLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5mb250RmFtaWx5ID0gaC5mb250RmFtaWx5O1xuICAgIHBvbHltZXJUaGVtZS5iYWNrZ3JvdW5kQ29sb3IgPSBzLmJhY2tncm91bmRDb2xvcjtcblxuICAgIHBiLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgcGIuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnknLCB0cnVlKTtcbiAgICBwYi5zZXRBdHRyaWJ1dGUoJ3JhaXNlZCcsIHRydWUpO1xuICAgIHAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYik7XG5cbiAgICBwb2x5bWVyVGhlbWUuY29sdW1uSGVhZGVyQ29sb3IgPSBwLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5yb3dIZWFkZXJDb2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLnRvcExlZnRDb2xvciA9IHAuY29sb3I7XG5cblxuICAgIHBvbHltZXJUaGVtZS5iYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSBwLmJhY2tncm91bmRDb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUuZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gcC5jb2xvcjtcblxuICAgIHBiLnNldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5JywgZmFsc2UpO1xuICAgIHBiLnNldEF0dHJpYnV0ZSgnd2FybmluZycsIHRydWUpO1xuXG4gICAgcG9seW1lclRoZW1lLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSBwLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5maXhlZENvbHVtbkJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgLy9jaGVjayBpZiB0aGVyZSBpcyBhY3R1YWxseSBhIHRoZW1lIGxvYWRlZCBpZiBub3QsIGNsZWFyIG91dCBhbGwgYm9ndXMgdmFsdWVzXG4gICAgLy9mcm9tIG15IGNhY2hlXG4gICAgaWYgKHBvbHltZXJUaGVtZS5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPT09ICdyZ2JhKDAsIDAsIDAsIDApJyB8fFxuICAgICAgICBwb2x5bWVyVGhlbWUubGluZUNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIGNsZWFyT2JqZWN0UHJvcGVydGllcyhwb2x5bWVyVGhlbWUpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocGIpO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2VjdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNsZWFyT2JqZWN0UHJvcGVydGllcyhvYmopIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2YWxPckZ1bmModmYpIHtcbiAgICB2YXIgcmVzdWx0ID0gKHR5cGVvZiB2ZilbMF0gPT09ICdmJyA/IHZmKCkgOiB2ZjtcbiAgICByZXR1cm4gcmVzdWx0IHx8IHJlc3VsdCA9PT0gMCA/IHJlc3VsdCA6ICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEh5cGVyZ3JpZDtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vbGliL0Jhc2UnKTtcblxudmFyIENvbHVtbiA9IHJlcXVpcmUoJy4vQ29sdW1uJyk7XG52YXIgQ2VsbFByb3ZpZGVyID0gcmVxdWlyZSgnLi4vbGliL0NlbGxQcm92aWRlcicpO1xuXG52YXIgbm9FeHBvcnRQcm9wZXJ0aWVzID0gW1xuICAgICdjb2x1bW5IZWFkZXInLFxuICAgICdjb2x1bW5IZWFkZXJDb2x1bW5TZWxlY3Rpb24nLFxuICAgICdmaWx0ZXJQcm9wZXJ0aWVzJyxcbiAgICAncm93SGVhZGVyJyxcbiAgICAncm93SGVhZGVyUm93U2VsZWN0aW9uJyxcbiAgICAncm93TnVtYmVyc1Byb3BlcnRpZXMnLFxuICAgICd0cmVlQ29sdW1uUHJvcGVydGllcycsXG4gICAgJ3RyZWVDb2x1bW5Qcm9wZXJ0aWVzQ29sdW1uU2VsZWN0aW9uJyxcbl07XG5cbnZhciBpc051bGwgPSB7XG4gICAgaXNOdWxsOiB0cnVlXG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFic3RyYWN0XG4gKiBAZGVzYyBBIHNvcnQgb2YgXCJtb2RlbCsrLlwiIEl0IGNvbnRhaW5zIGFsbCBjb2RlL2RhdGEgdGhhdCdzIG5lY2Vzc2FyeSBmb3IgZWFzaWx5IGltcGxlbWVudGluZyBhIHZpcnR1YWwgZGF0YSBzb3VyY2UgYW5kIGl0cyBtYW5pcHVsYXRpb24vYW5hbHl0aWNzLlxuICpcbiAqL1xudmFyIEJlaGF2aW9yID0gQmFzZS5leHRlbmQoJ0JlaGF2aW9yJywge1xuXG4gICAgLyoqXG4gICAgICogQGRlc2MgdGhpcyBpcyB0aGUgY2FsbGJhY2sgZm9yIHRoZSBwbHVnaW4gcGF0dGVybiBvZiBuZXN0ZWQgdGFnc1xuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQpIHsgLy9mb3JtZXJseSBpbnN0YWxsT25cbiAgICAgICAgdGhpcy5zZXRHcmlkKGdyaWQpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVGZWF0dXJlQ2hhaW4oZ3JpZCk7XG5cbiAgICAgICAgdGhpcy5jZWxsUHJvdmlkZXIgPSB0aGlzLmNyZWF0ZUNlbGxQcm92aWRlcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVkQ29sdW1uQ291bnQgPSAzMDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZFJvd0NvdW50ID0gNjA7XG4gICAgICAgIHRoaXMuZGF0YVVwZGF0ZXMgPSB7fTsgLy9mb3Igb3ZlcnJpZGluZyB3aXRoIGVkaXQgdmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBjcmVhdGUgdGhlIGZlYXR1cmUgY2hhaW4gLSB0aGlzIGlzIHRoZSBbY2hhaW4gb2YgcmVzcG9uc2liaWxpdHldKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/Q2hhaW5PZlJlc3BvbnNpYmlsaXR5UGF0dGVybikgcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplRmVhdHVyZUNoYWluOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5mZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKEZlYXR1cmVDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgc2VsZi5zZXROZXh0RmVhdHVyZShuZXcgRmVhdHVyZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgIH0sXG5cbiAgICBmZWF0dXJlczogW10sIC8vIGluIGNhc2UgaW1wbGVtZW50aW5nIGNsYXNzIGhhcyBubyBmZWF0dXJlcyBUT0RPOiBXaWxsIHRoaXMgZXZlciBoYXBwZW4/XG5cbiAgICAvKipcbiAgICAgKiBtZW1lbnRvIGZvciB0aGUgdXNlciBjb25maWd1cmVkIHZpc3VhbCBwcm9wZXJ0aWVzIG9mIHRoZSB0YWJsZVxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRhYmxlU3RhdGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SHlwZXJncmlkfVxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBncmlkOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogbGlzdCBvZiBkZWZhdWx0IGNlbGwgZWRpdG9yIG5hbWVzXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlZGl0b3JUeXBlczogW1xuICAgICAgICAnY2hvaWNlJyxcbiAgICAgICAgJ3RleHRmaWVsZCcsXG4gICAgICAgICdjb2xvcicsXG4gICAgICAgICdzbGlkZXInLFxuICAgICAgICAnc3Bpbm5lcicsXG4gICAgICAgICdkYXRlJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyIGNoYWluIG9mIGNvbW1hbmRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmZWF0dXJlQ2hhaW46IG51bGwsXG5cbiAgICBkYXRhTW9kZWw6IG51bGwsXG4gICAgYmFzZU1vZGVsOiBudWxsLFxuXG4gICAgc2Nyb2xsUG9zaXRpb25YOiAwLFxuICAgIHNjcm9sbFBvc2l0aW9uWTogMCxcblxuICAgIGZlYXR1cmVNYXA6IHt9LFxuICAgIGFsbENvbHVtbnM6IFtdLFxuICAgIGNvbHVtbnM6IFtdLFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNlbGxQcm92aWRlciA9IHRoaXMuY3JlYXRlQ2VsbFByb3ZpZGVyKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZWRDb2x1bW5Db3VudCA9IDMwO1xuICAgICAgICB0aGlzLnJlbmRlcmVkUm93Q291bnQgPSA2MDtcbiAgICAgICAgdGhpcy5kYXRhVXBkYXRlcyA9IHt9OyAvL2ZvciBvdmVycmlkaW5nIHdpdGggZWRpdCB2YWx1ZXM7XG4gICAgICAgIHRoaXMuY2xlYXJDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5yZXNldCgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgY2xlYXJDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMuYWxsQ29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLmNvbHVtbnNbLTFdID0gdGhpcy5uZXdDb2x1bW4oLTEsICcnKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zWy0yXSA9IHRoaXMubmV3Q29sdW1uKC0yLCAnVHJlZScpO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnNbLTFdID0gdGhpcy5jb2x1bW5zWy0xXTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zWy0yXSA9IHRoaXMuY29sdW1uc1stMl07XG4gICAgfSxcblxuICAgIGdldENvbHVtbjogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zW3hdO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5JZDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW4oeCkubGFiZWw7XG4gICAgfSxcblxuICAgIG5ld0NvbHVtbjogZnVuY3Rpb24oaW5kZXgsIGxhYmVsKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5jcmVhdGVDb2x1bW5Qcm9wZXJ0aWVzKCk7XG4gICAgICAgIHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCkuY29sdW1uUHJvcGVydGllc1tpbmRleF0gPSBwcm9wZXJ0aWVzO1xuICAgICAgICByZXR1cm4gbmV3IENvbHVtbih0aGlzLCBpbmRleCwgbGFiZWwpO1xuICAgIH0sXG5cbiAgICBhZGRDb2x1bW46IGZ1bmN0aW9uKGluZGV4LCBsYWJlbCkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5uZXdDb2x1bW4oaW5kZXgsIGxhYmVsKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9LFxuXG4gICAgY3JlYXRlQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vY29uY3JldGUgaW1wbGVtZW50YXRpb24gaGVyZVxuICAgIH0sXG5cbiAgICBjcmVhdGVDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUodGFibGVTdGF0ZSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5yb3dOdW1iZXJzUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcywge1xuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3BlcnRpZXMucm93SGVhZGVyID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckZvbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93SGVhZGVyRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5jb2x1bW5IZWFkZXIgPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnZGVmYXVsdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckZvbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5jb2x1bW5IZWFkZXJDb2x1bW5TZWxlY3Rpb24gPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMuY29sdW1uSGVhZGVyLCB7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5yb3dIZWFkZXJSb3dTZWxlY3Rpb24gPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMucm93SGVhZGVyLCB7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFJvd1NlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRSb3dTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZFJvd1NlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRSb3dTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5maWx0ZXJQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckZvbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjZWxsQm9yZGVyU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQ2VsbEJvcmRlclN0eWxlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckNlbGxCb3JkZXJTdHlsZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjZWxsQm9yZGVyVGhpY2tuZXNzOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckNlbGxCb3JkZXJUaGlja25lc3M7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyQ2VsbEJvcmRlclRoaWNrbmVzcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy50cmVlQ29sdW1uUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcywge1xuICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uRm9udDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVDb2x1bW5Gb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnRyZWVDb2x1bW5Qcm9wZXJ0aWVzQ29sdW1uU2VsZWN0aW9uID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLnRyZWVDb2x1bW5Qcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgY29sID0gdGhpcy5nZXRDb2x1bW4oeCk7XG4gICAgICAgIGlmICghY29sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2RlZmF1bHRDb2x1bW5XaWR0aCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IGNvbC5nZXRXaWR0aCgpO1xuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIHNldENvbHVtbldpZHRoOiBmdW5jdGlvbih4LCB3aWR0aCkge1xuICAgICAgICB0aGlzLmdldENvbHVtbih4KS5zZXRXaWR0aCh3aWR0aCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgYC5kYXRhTW9kZWxgIHByb3BlcnR5IGluc3RlYWQuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtIeXBlcmdyaWR9IFRoZSBoeXBlcmdyaWQgdG8gd2hpY2ggdGhpcyBiZWhhdmlvciBpcyBhdHRhY2hlZC5cbiAgICAgKi9cbiAgICBnZXREYXRhTW9kZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdkYXRhTW9kZWwnLCB7IHNpbmNlOiAnMC4yLjEnIH0pO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsUmVuZGVyZXI6IGZ1bmN0aW9uKGNvbmZpZywgeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW4oeCkuZ2V0Q2VsbFJlbmRlcmVyKGNvbmZpZywgeSk7XG4gICAgfSxcblxuICAgIGFwcGx5QW5hbHl0aWNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gdG8gZW1wdHkgYW4gb2JqZWN0IG9mIGl0cyBtZW1iZXJzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gZW1wdHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBvcnRQcm9wc11cbiAgICAgKiAqIGB1bmRlZmluZWRgIChvbWl0dGVkKSAtIGRlbGV0ZSAqYWxsKiBwcm9wZXJ0aWVzXG4gICAgICogKiAqKmZhbHN5KiogLSBkZWxldGUgKm9ubHkqIHRoZSBleHBvcnQgcHJvcGVydGllc1xuICAgICAqICogKip0cnV0aHkqKiAtIGRlbGV0ZSBhbGwgcHJvcGVydGllcyAqZXhjZXB0KiB0aGUgZXhwb3J0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBjbGVhck9iamVjdFByb3BlcnRpZXM6IGZ1bmN0aW9uKG9iaiwgZXhwb3J0UHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0UHJvcHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAhZXhwb3J0UHJvcHMgJiYgbm9FeHBvcnRQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydFByb3BzICYmIG5vRXhwb3J0UHJvcGVydGllcy5pbmRleE9mKGtleSkgPCAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXR0ZXIgZm9yIGEgW01lbWVudG9dKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/TWVtZW50b1BhdHRlcm4pIE9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0UHJpdmF0ZVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhYmxlU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudGFibGVTdGF0ZSA9IHRoaXMuZ2V0RGVmYXVsdFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGFibGVTdGF0ZTtcbiAgICB9LFxuXG4gICAgLy90aGlzIGlzIGVmZmVjdGl2ZWx5IGEgY2xvbmUsIHdpdGggY2VydGFpbiB0aGluZ3MgcmVtb3ZlZC4uLi5cbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmdldFByaXZhdGVTdGF0ZSgpKSk7XG4gICAgICAgIHRoaXMuY2xlYXJPYmplY3RQcm9wZXJ0aWVzKGNvcHkuY29sdW1uUHJvcGVydGllcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjbGVhciBhbGwgdGFibGUgc3RhdGVcbiAgICAgKi9cbiAgICBjbGVhclN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50YWJsZVN0YXRlID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge29iamVjdH0gTmV3bHkgY3JlYXRlZCBkZWZhdWx0IGVtcHR5IHRhYmxlc3RhdGUuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhYmxlUHJvcGVydGllcyA9IHRoaXMuZ3JpZC5fZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB2YXIgc3RhdGUgPSBPYmplY3QuY3JlYXRlKHRhYmxlUHJvcGVydGllcyk7XG5cbiAgICAgICAgXyhzdGF0ZSkuZXh0ZW5kT3duKHtcbiAgICAgICAgICAgIHJvd0hlaWdodHM6IHt9LFxuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgY29sdW1uUHJvcGVydGllczogW11cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVzdG9yZSB0aGlzIHRhYmxlIHRvIGEgcHJldmlvdXMgc3RhdGUuXG4gICAgICogU2VlIHRoZSBbbWVtZW50byBwYXR0ZXJuXShodHRwOi8vYzIuY29tL2NnaS93aWtpP01lbWVudG9QYXR0ZXJuKS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWVtZW50byAtIGFuIGVuY2Fwc3VsYXRlZCByZXByZXNlbnRhdGlvbiBvZiB0YWJsZSBzdGF0ZVxuICAgICAqL1xuICAgIHNldFN0YXRlOiBmdW5jdGlvbihtZW1lbnRvKSB7XG5cbiAgICAgICAgLy93ZSBkb24ndCB3YW50IHRvIGNsb2JiZXIgdGhlIGNvbHVtbiBwcm9wZXJ0aWVzIGNvbXBsZXRlbHlcbiAgICAgICAgaWYgKCFtZW1lbnRvLmNvbHVtbkluZGV4ZXMpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpO1xuICAgICAgICAgICAgbWVtZW50by5jb2x1bW5JbmRleGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1lbWVudG8uY29sdW1uSW5kZXhlc1tpXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbFByb3BlcnRpZXMgPSBtZW1lbnRvLmNvbHVtblByb3BlcnRpZXM7XG4gICAgICAgIGRlbGV0ZSBtZW1lbnRvLmNvbHVtblByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMudGFibGVTdGF0ZSA9IG51bGw7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29sdW1ucygpO1xuICAgICAgICB0aGlzLnNldENvbHVtbk9yZGVyKG1lbWVudG8uY29sdW1uSW5kZXhlcyk7XG4gICAgICAgIF8oc3RhdGUpLmV4dGVuZE93bihtZW1lbnRvKTtcbiAgICAgICAgdGhpcy5zZXRBbGxDb2x1bW5Qcm9wZXJ0aWVzKGNvbFByb3BlcnRpZXMpO1xuICAgICAgICBtZW1lbnRvLmNvbHVtblByb3BlcnRpZXMgPSBjb2xQcm9wZXJ0aWVzO1xuICAgICAgICAvL21lbWVudG8uY29sdW1uUHJvcGVydGllcyA9IGNvbFByb3BlcnRpZXM7XG5cbiAgICAgICAgLy8gdGhpcy5kYXRhTW9kZWwuc2V0U3RhdGUobWVtZW50byk7XG4gICAgICAgIC8vIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyAgICAgc2VsZi5hcHBseVNvcnRzKCk7XG4gICAgICAgIC8vICAgICBzZWxmLmNoYW5nZWQoKTtcbiAgICAgICAgLy8gICAgIHNlbGYuc3RhdGVDaGFuZ2VkKCk7XG4gICAgICAgIC8vIH0pO1xuXG4gICAgICAgIC8vanVzdCB0byBiZSBjbG9zZS8gaXQncyBlYXNpZXIgb24gdGhlIGV5ZXNcbiAgICAgICAgdGhpcy5zZXRDb2x1bW5XaWR0aCgtMSwgMjQuMTkzMzU5Mzc1KTtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuYXBwbHlTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBzZXRBbGxDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKS5jb2x1bW5Qcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgdGhpcy5jbGVhck9iamVjdFByb3BlcnRpZXMoY3VycmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgXyhjdXJyZW50KS5leHRlbmRPd24ocHJvcGVydGllc1tpXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0Q29sdW1uT3JkZXI6IGZ1bmN0aW9uKGluZGV4ZXMpIHtcbiAgICAgICAgaWYgKCFpbmRleGVzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbnMubGVuZ3RoID0gaW5kZXhlcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zW2ldID0gdGhpcy5hbGxDb2x1bW5zW2luZGV4ZXNbaV1dO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFwcGx5U29ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2lmIEkgaGF2ZSBzb3J0cywgYXBwbHkgdGhlbSBub3cvL1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZmV0Y2ggdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IGtleVxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgb2YgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBhIHByb3BlcnR5IG5hbWVcbiAgICAgKi9cbiAgICByZXNvbHZlUHJvcGVydHk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eShrZXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgQSBzcGVjaWZpYyBjZWxsIHdhcyBjbGlja2VkOyB5b3UndmUgYmVlbiBub3RpZmllZC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gcG9pbnQgb2YgY2VsbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIGFsbCBldmVudCBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGNlbGxDbGlja2VkOiBmdW5jdGlvbihjZWxsLCBldmVudCkge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5jZWxsQ2xpY2tlZChjZWxsLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBIHNwZWNpZmljIGNlbGwgd2FzIGxlIGRvdWJsZS1jbGlja2VkOyB5b3UndmUgYmVlbiBub3RpZmllZC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gcG9pbnQgb2YgY2VsbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIGFsbCBldmVudCBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGNlbGxEb3VibGVDbGlja2VkOiBmdW5jdGlvbihjZWxsLCBldmVudCkge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhZGQgbmV4dEZlYXR1cmUgdG8gbWUgSWYgSSBkb24ndCBoYXZlIGEgbmV4dCBub2RlLCBvdGhlcndpc2UgcGFzcyBpdCBhbG9uZ1xuICAgICAqIEBwYXJhbSB7RmVhdHVyZX1cbiAgICAgKi9cbiAgICBzZXROZXh0RmVhdHVyZTogZnVuY3Rpb24obmV4dEZlYXR1cmUpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlTWFwW25leHRGZWF0dXJlLiQkQ0xBU1NfTkFNRV0gPSBuZXh0RmVhdHVyZTtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5zZXROZXh0KG5leHRGZWF0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluID0gbmV4dEZlYXR1cmU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbG9va3VwRmVhdHVyZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVNYXBba2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldHRlciBmb3IgdGhlIGNlbGwgcHJvdmlkZXJcbiAgICAgKiBAcmV0dXJuIHtDZWxsUHJvdmlkZXJ9XG4gICAgICovXG4gICAgZ2V0Q2VsbFByb3ZpZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbFByb3ZpZGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0dGVyIGZvciB0aGUgaHlwZXJncmlkXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBzZXRHcmlkOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsID0gdGhpcy5kYXRhTW9kZWwgfHwgdGhpcy5nZXREZWZhdWx0RGF0YU1vZGVsKCk7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldEdyaWQoZ3JpZCk7XG4gICAgICAgIGdyaWQuc2V0QmVoYXZpb3IodGhpcyk7XG4gICAgICAgIHRoaXMuY2xlYXJDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgYC5ncmlkYCBwcm9wZXJ0eSBpbnN0ZWFkLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7SHlwZXJncmlkfSBUaGUgaHlwZXJncmlkIHRvIHdoaWNoIHRoaXMgYmVoYXZpb3IgaXMgYXR0YWNoZWQuXG4gICAgICogQHBhcmFtIHt0eXBlfSB2YXJuYW1lIC0gZGVzY3JpcHRvblxuICAgICAqL1xuICAgIGdldEdyaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdncmlkJywgeyBzaW5jZTogJzAuMicgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gYW5kIHN1YnN0aXR1dGUgeW91ciBvd24gY2VsbCBwcm92aWRlci5cbiAgICAgKiBAcmV0dXJuIHtDZWxsUHJvdmlkZXJ9XG4gICAgICovXG4gICAgY3JlYXRlQ2VsbFByb3ZpZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsUHJvdmlkZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEZpcnN0IGNoZWNrIHRvIHNlZSBpZiBzb21ldGhpbmcgd2FzIG92ZXJyaWRkZW4uXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIGF0IGB4LHlgIGZvciB0aGUgdG9wIGxlZnQgc2VjdGlvbiBvZiB0aGUgaHlwZXJncmlkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRDb2x1bW4oeCk7XG4gICAgICAgIHJldHVybiBjb2x1bW4gJiYgY29sdW1uLmdldFZhbHVlKHkpO1xuICAgIH0sXG5cbiAgICBnZXRVbmZpbHRlcmVkVmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uKHgpO1xuICAgICAgICByZXR1cm4gY29sdW1uICYmIGNvbHVtbi5nZXRVbmZpbHRlcmVkVmFsdWUoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGRhdGEgYXQgcG9pbnQgeCwgeSB3aXRoIHZhbHVlXG4gICAgICogQHJldHVybiBUaGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0geSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHVzZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRDb2x1bW4oeCk7XG4gICAgICAgIHJldHVybiBjb2x1bW4gJiYgY29sdW1uLnNldFZhbHVlKHksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YVZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRWYWx1ZSh4LCB5KTtcbiAgICB9LFxuXG4gICAgc2V0RGF0YVZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRWYWx1ZSh4LCB5LCB2YWx1ZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgRmlyc3QgY2hlY2tzIHRvIHNlZSBpZiBzb21ldGhpbmcgd2FzIG92ZXJyaWRkZW4uXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIGF0IHgseSBmb3IgdGhlIHRvcCBsZWZ0IHNlY3Rpb24gb2YgdGhlIGh5cGVyZ3JpZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0geSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ2V0Q2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uKHgpLmdldENlbGxQcm9wZXJ0aWVzKHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBkYXRhIGF0IHBvaW50IHgsIHkgd2l0aCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gdXNlXG4gICAgICovXG4gICAgc2V0Q2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLmdldENvbHVtbih4KTtcbiAgICAgICAgaWYgKGNvbCkge1xuICAgICAgICAgICAgY29sLnNldENlbGxQcm9wZXJ0aWVzKHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBoeXBlcmdyaWQuXG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0Um93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgZ2V0VW5maWx0ZXJlZFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFVuZmlsdGVyZWRSb3dDb3VudCgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGhlaWdodCBpbiBwaXhlbHMgb2YgdGhlIGZpeGVkIHJvd3MgYXJlYSAgb2YgdGhlIGh5cGVyZ3JpZC5cbiAgICAgKi9cbiAgICBnZXRGaXhlZFJvd3NIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmdldEZpeGVkUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsICsgdGhpcy5nZXRSb3dIZWlnaHQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy92YXIgZm9vdGVySGVpZ2h0ID0gdGhpcy5nZXREZWZhdWx0Um93SGVpZ2h0KCk7XG4gICAgICAgIC8vdG90YWwgPSB0b3RhbCArIChmb290ZXJIZWlnaHQgKiB0aGlzLmdldEZvb3RlclJvd0NvdW50KCkpO1xuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZWlnaHQgaW4gcGl4ZWxzIG9mIGEgc3BlY2lmaWMgcm93IGluIHRoZSBoeXBlcmdyaWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd051bSAtIHJvdyBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldFJvd0hlaWdodDogZnVuY3Rpb24ocm93TnVtKSB7XG4gICAgICAgIHZhciByb3dIZWlnaHRzID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKS5yb3dIZWlnaHRzO1xuICAgICAgICByZXR1cm4gcm93SGVpZ2h0cyAmJiByb3dIZWlnaHRzW3Jvd051bV0gfHwgdGhpcy5nZXREZWZhdWx0Um93SGVpZ2h0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgdmFsdWUgaXMgbGF6aWx5IGluaXRpYWxpemVkIGFuZCBjb21lcyBmcm9tIHRoZSBwcm9wZXJ0aWVzIG1lY2hhbmlzbSBmb3IgJ2BkZWZhdWx0Um93SGVpZ2h0YCcsIHdoaWNoIHNob3VsZCBiZSB+MjBweC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IGhlaWdodCBpbiBwaXhlbHMuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFJvd0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5kZWZhdWx0Um93SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRSb3dIZWlnaHQgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZGVmYXVsdFJvd0hlaWdodCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRSb3dIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHBpeGVsIGhlaWdodCBvZiBhIHNwZWNpZmljIHJvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dOdW0gLSB0aGUgcm93IGluZGV4IG9mIGludGVyZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHBpeGVsIGhlaWdodFxuICAgICAqL1xuICAgIHNldFJvd0hlaWdodDogZnVuY3Rpb24ocm93TnVtLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB0YWJsZVN0YXRlLnJvd0hlaWdodHNbcm93TnVtXSA9IE1hdGgubWF4KDUsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIHdpbGwgYWxsb3cgJ2Zsb2F0aW5nJyBmaXhlZCByb3dzLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gaGVpZ2h0IG9mIHRoZSBmaXhlZCByb3dzIGFyZWEgaW4gdGhlIGh5cGVyZ3JpZC5cbiAgICAgKi9cbiAgICBnZXRGaXhlZFJvd3NNYXhIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaXhlZFJvd3NIZWlnaHQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBmaXhlZCBjb2x1bW4gYXJlYSBpbiB0aGUgaHlwZXJncmlkLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uc1dpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuaXNTaG93Um93TnVtYmVycygpKSB7XG4gICAgICAgICAgICB0b3RhbCA9IHRoaXMuZ2V0Q29sdW1uV2lkdGgoLTEpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdG90YWwgPSB0b3RhbCArIHRoaXMuZ2V0Q29sdW1uV2lkdGgoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBleGlzdHMgdG8gc3VwcG9ydCBcImZsb2F0aW5nXCIgY29sdW1ucy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0b3RhbCB3aWR0aCBvZiB0aGUgZml4ZWQgY29sdW1ucyBhcmVhLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uc01heFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rml4ZWRDb2x1bW5zV2lkdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIHZlcnRpY2FsIGRpbWVuc2lvbiBhbmQgbm90aWZ5IGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSBuZXcgeSB2YWx1ZVxuICAgICAqL1xuICAgIF9zZXRTY3JvbGxQb3NpdGlvblk6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxQb3NpdGlvblkoeSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gaG9yaXpvbnRhbCBkaW1lbnNpb24gYW5kIG5vdGlmeSBsaXN0ZW5lcnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgbmV3IHggdmFsdWVcbiAgICAgKi9cbiAgICBfc2V0U2Nyb2xsUG9zaXRpb25YOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsUG9zaXRpb25YKHgpO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMganVzdCByZW5kZXJlZCwgaW5jbHVkaW5nIHBhcnRpYWxseSByZW5kZXJlZCBjb2x1bW5zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIGhvdyBtYW55IGNvbHVtbnMgd2VyZSBqdXN0IHJlbmRlcmVkXG4gICAgICovXG4gICAgc2V0UmVuZGVyZWRDb2x1bW5Db3VudDogZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbkNvdW50ID0gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIG51bWJlciBvZiByb3dzIGp1c3QgcmVuZGVyZWQsIGluY2x1ZGluZyBwYXJ0aWFsbHkgcmVuZGVyZWQgcm93cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBob3cgbWFueSByb3dzIHdlcmUganVzdCByZW5kZXJlZFxuICAgICAqL1xuICAgIHNldFJlbmRlcmVkUm93Q291bnQ6IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWRSb3dDb3VudCA9IGNvdW50O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZml4ZWQgcm93IGFyZWEgaGFzIGJlZW4gY2xpY2tlZCwgbWFzc2FnZSB0aGUgZGV0YWlscyBhbmQgY2FsbCB0aGUgcmVhbCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBfZml4ZWRSb3dDbGlja2VkOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICB2YXIgeCA9IHRoaXMudHJhbnNsYXRlQ29sdW1uSW5kZXgodGhpcy5nZXRTY3JvbGxQb3NpdGlvblgoKSArIG1vdXNlLmdyaWRDZWxsLnggLSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKSk7XG4gICAgICAgIHZhciB0cmFuc2xhdGVkUG9pbnQgPSB0aGlzLmdyaWQubmV3UG9pbnQoeCwgbW91c2UuZ3JpZENlbGwueSk7XG4gICAgICAgIG1vdXNlLmdyaWRDZWxsID0gdHJhbnNsYXRlZFBvaW50O1xuICAgICAgICB0aGlzLmZpeGVkUm93Q2xpY2tlZChncmlkLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZml4ZWQgY29sdW1uIGFyZWEgaGFzIGJlZW4gY2xpY2tlZCwgbWFzc2FnZSB0aGUgZGV0YWlscyBhbmQgY2FsbCB0aGUgcmVhbCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBfZml4ZWRDb2x1bW5DbGlja2VkOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICB2YXIgdHJhbnNsYXRlZFBvaW50ID0gdGhpcy5ncmlkLm5ld1BvaW50KG1vdXNlLmdyaWRDZWxsLngsIHRoaXMuZ2V0U2Nyb2xsUG9zaXRpb25ZKCkgKyBtb3VzZS5ncmlkQ2VsbC55IC0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCkpO1xuICAgICAgICBtb3VzZS5ncmlkQ2VsbCA9IHRyYW5zbGF0ZWRQb2ludDtcbiAgICAgICAgdGhpcy5maXhlZENvbHVtbkNsaWNrZWQoZ3JpZCwgbW91c2UpO1xuICAgIH0sXG5cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbihncmlkLCB4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4ubW92ZVNpbmdsZVNlbGVjdChncmlkLCB4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBzZXR0aW5nIHRoZSBjdXJzb3IgdXAgdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHNldEN1cnNvcjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBncmlkLnVwZGF0ZUN1cnNvcigpO1xuICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSBtb3ZlIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgdGFwIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uVGFwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlVGFwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyB0YXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Db250ZXh0TWVudTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIHByb2NlZWQgPSBncmlkLmZpcmVTeW50aGV0aWNDb250ZXh0TWVudUV2ZW50KGV2ZW50KTtcbiAgICAgICAgaWYgKHByb2NlZWQgJiYgdGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUNvbnRleHRNZW51KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyB3aGVlbCBtb3ZlZCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbldoZWVsTW92ZWQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlV2hlZWxNb3ZlZChncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgdXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Nb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIGRyYWcgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Nb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBrZXkgZG93biB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbktleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcga2V5IHVwIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uS2V5VXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlS2V5VXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIGRvdWJsZSBjbGljayB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbkRvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBob2xkIHB1bHNlIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uSG9sZFB1bHNlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUhvbGRQdWxzZShncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgZG91YmxlIGNsaWNrIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIHRvZ2dsZUNvbHVtblBpY2tlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaWFsb2cgPSB0aGlzLmdyaWQuZGlhbG9nO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChkaWFsb2cuaXNPcGVuKCkpIHtcbiAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWlsZENvbHVtblBpY2tlcihkaWFsb2cub3ZlcmxheSk7XG4gICAgICAgICAgICBkaWFsb2cub25DbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlRnJvbUNvbHVtblBpY2tlcihkaWFsb2cub3ZlcmxheSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGlhbG9nLm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgZG93biB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSBleGl0IHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRXhpdDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVNb3VzZUV4aXQoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgcmVwbGFjZWQgYnkgdGhlIGdyaWQgb24gaW5pdGlhbGl6YXRpb24gYW5kIHNlcnZlcyBhcyB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBjaGFuZ2VkOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgcmVwbGFjZWQgYnkgdGhlIGdyaWQgb24gaW5pdGlhbGl6YXRpb24gYW5kIHNlcnZlcyBhcyB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBzaGFwZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIHJlLW9yZGVyIGNvbHVtbnMuXG4gICAgICovXG4gICAgaXNDb2x1bW5SZW9yZGVyYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcHJvcGVydGllcyBmb3IgYSBzcGVjaWZpYyBjb2x1bW4uIFRoZXNlIGFyZSB1c2VkIGlmIG5vIGNlbGwgcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7aW5kZXh9IGNvbHVtbkluZGV4IC0gdGhlIGNvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLmNvbHVtbnNbY29sdW1uSW5kZXhdO1xuICAgICAgICBpZiAoIWNvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGNvbC5nZXRQcm9wZXJ0aWVzKCk7IC8vVE9ETzogcmV0dXJucyBgbnVsbGAgb24gSHlwZXJncmlkLnJlc2V0KCk7XG4gICAgICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIGlzTnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9LFxuXG4gICAgc2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oY29sdW1uSW5kZXgsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIGNvbHVtblByb3BlcnRpZXMgPSB0aGlzLmFsbENvbHVtbnNbY29sdW1uSW5kZXhdLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgXyhjb2x1bW5Qcm9wZXJ0aWVzKS5leHRlbmRPd24ocHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgZmllbGQgYXQgYGNvbEluZGV4YC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXggLSB0aGUgY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0RmllbGQ6IGZ1bmN0aW9uKGNvbEluZGV4KSB7XG4gICAgICAgIHJldHVybiBjb2xJbmRleCA9PT0gLTEgPyAndHJlZScgOiB0aGlzLmdldENvbHVtbihjb2xJbmRleCkuZ2V0RmllbGQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbHVtbiBoZWFkaW5nIGF0IGBjb2xJbmRleCcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gdGhlIGNvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldEhlYWRlcjogZnVuY3Rpb24oY29sSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGNvbEluZGV4ID09PSAtMSA/ICdUcmVlJyA6IHRoaXMuZ2V0Q29sdW1uKGNvbEluZGV4KS5nZXRIZWFkZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBjb2x1bW4gZWRpdG9yIHBvc3QgY2xvc2luZzsgcmVidWlsZCB0aGUgY29sdW1uIG9yZGVyIGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IC0gbGlzdCBvZiBjb2x1bW4gb2JqZWN0cyBmcm9tIHRoZSBjb2x1bW4gZWRpdG9yXG4gICAgICovXG4gICAgc2V0Q29sdW1uRGVzY3JpcHRvcnM6IGZ1bmN0aW9uKGxpc3RzKSB7XG4gICAgICAgIC8vYXNzdW1lcyB0aGVyZSBpcyBvbmUgcm93Li4uLlxuICAgICAgICB2YXIgdmlzaWJsZSA9IGxpc3RzLnZpc2libGU7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcblxuICAgICAgICB2YXIgY29sdW1uQ291bnQgPSB2aXNpYmxlLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2godmlzaWJsZVtpXS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGVTdGF0ZS5jb2x1bW5JbmRleGVzID0gaW5kZXhlcztcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gQWxsIHRoZSBjdXJyZW50bHkgaGlkZGVuIGNvbHVtbiBoZWFkZXIgbGFiZWxzLlxuICAgICAqL1xuICAgIGdldEhpZGRlbkNvbHVtbkRlc2NyaXB0b3JzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgaW5kZXhlcyA9IHRhYmxlU3RhdGUuY29sdW1uSW5kZXhlcztcbiAgICAgICAgdmFyIGxhYmVscyA9IFtdO1xuICAgICAgICB2YXIgY29sdW1uQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGluZGV4ZXMuaW5kZXhPZihpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsYWJlbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5nZXRIZWFkZXIoaSksXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0aGlzLmdldEZpZWxkKGkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhpZGUgY29sdW1ucyB0aGF0IGFyZSBzcGVjaWZpZWQgYnkgdGhlaXIgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5T2ZJbmRleGVzIC0gYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgdG8gaGlkZVxuICAgICAqL1xuICAgIGhpZGVDb2x1bW5zOiBmdW5jdGlvbihhcnJheU9mSW5kZXhlcykge1xuICAgICAgICB2YXIgdGFibGVTdGF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgICAgIHZhciBvcmRlciA9IHRhYmxlU3RhdGUuY29sdW1uSW5kZXhlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mSW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVhY2ggPSBhcnJheU9mSW5kZXhlc1tpXTtcbiAgICAgICAgICAgIGlmIChvcmRlci5pbmRleE9mKGVhY2gpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG9yZGVyLnNwbGljZShvcmRlci5pbmRleE9mKGVhY2gpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7aW50ZWdlcn0gVGhlIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcml2YXRlU3RhdGUoKS5maXhlZENvbHVtbkNvdW50IHx8IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSB0aGUgaW50ZWdlciBjb3VudCBvZiBob3cgbWFueSBjb2x1bW5zIHRvIGJlIGZpeGVkXG4gICAgICovXG4gICAgc2V0Rml4ZWRDb2x1bW5Db3VudDogZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLmdldFByaXZhdGVTdGF0ZSgpLmZpeGVkQ29sdW1uQ291bnQgPSBuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7aW50ZWdlcn0gVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudGFibGVTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHVzZXJzU2l6ZSA9IHRoaXMudGFibGVTdGF0ZS5maXhlZFJvd0NvdW50IHx8IDA7XG4gICAgICAgIHJldHVybiBoZWFkZXJzICsgdXNlcnNTaXplO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBudW1iZXIgb2YgZml4ZWQgcm93cywgd2hpY2ggaW5jbHVkZXMgKHRvcCB0byBib3R0b20gb3JkZXIpOlxuICAgICAqIDEuIFRoZSBoZWFkZXIgcm93c1xuICAgICAqICAgIDEuIFRoZSBoZWFkZXIgbGFiZWxzIHJvdyAob3B0aW9uYWwpXG4gICAgICogICAgMi4gVGhlIGZpbHRlciByb3cgKG9wdGlvbmFsKVxuICAgICAqICAgIDMuIFRoZSB0b3AgdG90YWwgcm93cyAoMCBvciBtb3JlKVxuICAgICAqIDIuIFRoZSBub24tc2Nyb2xsaW5nIHJvd3MgKGV4dGVybmFsbHkgY2FsbGVkIFwidGhlIGZpeGVkIHJvd3NcIilcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFN1bSBvZiB0aGUgYWJvdmUgb3IgMCBpZiBub25lIG9mIHRoZSBhYm92ZSBhcmUgaW4gdXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSBUaGUgbnVtYmVyIG9mIHJvd3MuXG4gICAgICovXG4gICAgc2V0Rml4ZWRSb3dDb3VudDogZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLnRhYmxlU3RhdGUuZml4ZWRSb3dDb3VudCA9IG47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgaGVhZGVyIHJvd3MuXG4gICAgICogQSBwb3J0aW9uIG9mIHRoZSBudW1iZXIgcmV0dXJuZWQgYnkge0BsaW5rIEJlaGF2aW9yI2dldEZpeGVkUm93Q291bnQoKXxnZXRGaXhlZFJvd0NvdW50KCl9LlxuICAgICAqIChUaGUgcmVtYWluaW5nIF9maXhlZCByb3dzXyBhcmUgdGhlIF90b3AgdG90YWxzXyByb3dzLilcbiAgICAgKi9cbiAgICBnZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmdyaWQuaXNTaG93SGVhZGVyUm93KCkgPyAxIDogMDtcbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuZ3JpZC5pc1Nob3dGaWx0ZXJSb3coKSA/IDEgOiAwO1xuICAgICAgICB2YXIgdG90YWxzID0gdGhpcy5nZXRUb3BUb3RhbHMoKS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBoZWFkZXIgKyBmaWx0ZXIgKyB0b3RhbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZm9vdGVyIHJvd3MsIGNvbnNpc3RpbmcgZW50aXJlbHkgb2YgMCBvciBtb3JlIF9ib3R0b20gdG90YWxzXyByb3dzLlxuICAgICAqL1xuICAgIGdldEZvb3RlclJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm90dG9tVG90YWxzKCkubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBnZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0VG9wVG90YWxzKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBudW1iZXIgb2YgaGVhZGVyIHJvd3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSBUaGUgbnVtYmVyIG9mIF9maXhlZCByb3dzXyB0byByZXNlcnZlIGFzIGhlYWRlciByb3dzLlxuICAgICAqIChUaGUgcmVtYWluaW5nIF9maXhlZCByb3dzXyBhcmUgdGhlIF90b3AgdG90YWxzXyByb3dzLilcbiAgICAgKi9cbiAgICBzZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLnRhYmxlU3RhdGUuaGVhZGVyUm93Q291bnQgPSBuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnaGVhZGVyQ29sdW1uQ291bnQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MuXG4gICAgICovXG4gICAgc2V0SGVhZGVyQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKG51bWJlck9mSGVhZGVyQ29sdW1ucykge1xuICAgICAgICB0aGlzLnRhYmxlU3RhdGUuaGVhZGVyQ29sdW1uQ291bnQgPSBudW1iZXJPZkhlYWRlckNvbHVtbnM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgYnVpbGQgYW5kIG9wZW4gdGhlIGVkaXRvciB3aXRoaW4gdGhlIGNvbnRhaW5lciBkaXYgYXJndW1lbnRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHByZXZlbnRzIGVkaXRvciBmcm9tIG9wZW5pbmdcbiAgICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSBkaXYgLSB0aGUgY29udGFpbmluZyBkaXYgZWxlbWVudFxuICAgICAqL1xuICAgIGJ1aWxkQ29sdW1uUGlja2VyOiBmdW5jdGlvbihkaXYpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIHZhciBoaWRkZW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaW4taHlwZXJncmlkLWRuZC1saXN0Jyk7XG4gICAgICAgIHZhciB2aXNpYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmluLWh5cGVyZ3JpZC1kbmQtbGlzdCcpO1xuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChoaWRkZW4pO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodmlzaWJsZSk7XG5cbiAgICAgICAgdGhpcy5iZUNvbHVtblN0eWxlKGhpZGRlbi5zdHlsZSk7XG4gICAgICAgIGhpZGRlbi50aXRsZSA9ICdoaWRkZW4gY29sdW1ucyc7XG4gICAgICAgIGhpZGRlbi5saXN0ID0gdGhpcy5nZXRIaWRkZW5Db2x1bW5EZXNjcmlwdG9ycygpO1xuXG4gICAgICAgIHRoaXMuYmVDb2x1bW5TdHlsZSh2aXNpYmxlLnN0eWxlKTtcbiAgICAgICAgdmlzaWJsZS5zdHlsZS5sZWZ0ID0gJzUwJSc7XG4gICAgICAgIHZpc2libGUudGl0bGUgPSAndmlzaWJsZSBjb2x1bW5zJztcbiAgICAgICAgdmlzaWJsZS5saXN0ID0gdGhpcy5nZXRDb2x1bW5EZXNjcmlwdG9ycygpO1xuXG4gICAgICAgIGRpdi5saXN0cyA9IHtcbiAgICAgICAgICAgIGhpZGRlbjogaGlkZGVuLmxpc3QsXG4gICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmxlLmxpc3RcbiAgICAgICAgfTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhlIGVkaXRvciBpcyByZXF1ZXN0aW5nIGNsb3NlOyBkZWFsIHdpdGggdGhlIGVkaXRzXG4gICAgICogQHJldHVybiBgdHJ1ZWBcbiAgICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSBkaXYgLSB0aGUgY29udGFpbmluZyBkaXYgZWxlbWVudFxuICAgICAqL1xuICAgIHVwZGF0ZUZyb21Db2x1bW5QaWNrZXI6IGZ1bmN0aW9uKGRpdikge1xuICAgICAgICB2YXIgbGlzdHMgPSBkaXYubGlzdHM7XG4gICAgICAgIHRoaXMuc2V0Q29sdW1uRGVzY3JpcHRvcnMobGlzdHMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGEgZG5kIGNvbHVtbiBoYXMganVzdCBiZWVuIGRyb3BwZWQsIHdlJ3ZlIGJlZW4gbm90aWZpZWRcbiAgICAgKi9cbiAgICBlbmREcmFnQ29sdW1uTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGJpbmQgY29sdW1uIGVkaXRvciBhcHByb3ByaWF0ZSBjc3MgdmFsdWVzIHRvIGFyZyBzdHlsZVxuICAgICAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGUgLSB0aGUgc3R5bGUgb2JqZWN0IHRvIGVuaGFuY2VcbiAgICAgKi9cbiAgICBiZUNvbHVtblN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICBzdHlsZS50b3AgPSAnNSUnO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHN0eWxlLndpZHRoID0gJzUwJSc7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgc3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVsbH0gdGhlIGN1cnNvciBhdCBhIHNwZWNpZmljIHgseSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ2V0Q3Vyc29yQXQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0b3RhbCBudW1iZXIgb2YgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29sdW1uIGFsaWdubWVudCBhdCBjb2x1bW4gYHhgOiBgJ2xlZnQnYCwgYCdjZW50ZXInYCAsIG9yIGAncmlnaHQnYFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGNvbHVtbiBpbmRleCBvZiBpbnRlcmVzdC5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5BbGlnbm1lbnQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgUXVpZXRseSBzZXQgdGhlIGhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIG5ldyBwb3NpdGlvbiBpbiBwaXhlbHMuXG4gICAgICovXG4gICAgc2V0U2Nyb2xsUG9zaXRpb25YOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb25YID0geDtcbiAgICB9LFxuXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb25YOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUG9zaXRpb25YO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgUXVpZXRseSBzZXQgdGhlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBuZXcgcG9zaXRpb24gaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHNldFNjcm9sbFBvc2l0aW9uWTogZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uWSA9IHk7XG4gICAgfSxcblxuICAgIGdldFNjcm9sbFBvc2l0aW9uWTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFBvc2l0aW9uWTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge2NlbGxFZGl0b3J9IFRoZSBjZWxsIGVkaXRvciBmb3IgdGhlIGNlbGwgYXQgY2VsbCBjb29yZGluYXRlcyBgeCx5YFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgY2VsbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNlbGwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGJsQ2xpY2sgLSBXaGVuIGNhbGxlZCBmcm9tIGBvbkVkaXRvckFjdGl2YXRlYCwgaW5kaWNhdGVzIGlmIGV2ZW50IHdhcyBhIGRvdWJsZS1jbGljay5cbiAgICAgKi9cbiAgICBfZ2V0Q2VsbEVkaXRvckF0OiBmdW5jdGlvbih4LCB5LCBpc0RibENsaWNrKSB7XG4gICAgICAgIHZhciBlZGl0b3IsXG4gICAgICAgICAgICBpc0ZpbHRlclJvdyA9IHRoaXMuZ3JpZC5pc0ZpbHRlclJvdyh5KTtcblxuICAgICAgICBpZiAoIWlzRmlsdGVyUm93KSB7XG4gICAgICAgICAgICBlZGl0b3IgPSB0aGlzLmdldENvbHVtbih4KS5nZXRDZWxsRWRpdG9yQXQoeCwgeSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRGJsQ2xpY2spIHtcbiAgICAgICAgICAgIC8vIGZpbHRlciByb3cgc2luZ2xlIGNsaWNrIGp1c3QgZ2V0cyB0ZXh0IGVkaXRvclxuICAgICAgICAgICAgZWRpdG9yID0gdGhpcy5ncmlkLmNlbGxFZGl0b3JzLnRleHRmaWVsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRDb2x1bW4oeCk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGlzRmlsdGVyUm93ID8gY29sdW1uLmdldEZpbHRlclR5cGUoKSA6IGNvbHVtbi5nZXRUeXBlKCk7XG4gICAgICAgICAgICBlZGl0b3IgPSB0aGlzLmdyaWQucmVzb2x2ZUNlbGxFZGl0b3IodHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWRpdG9yO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5pc0ZpbHRlclJvdyh5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5jZWxsRWRpdG9ycy50ZXh0ZmllbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldENlbGxFZGl0b3JBdCh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlzXG4gICAgICovXG4gICAgdG9nZ2xlU29ydDogZnVuY3Rpb24oeCwga2V5cykge1xuICAgICAgICB0aGlzLmdldENvbHVtbih4KS50b2dnbGVTb3J0KGtleXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHdlIHNob3VsZCBoaWdobGlnaHQgb24gaG92ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ29sdW1uSG92ZXJlZCAtIHRoZSBjb2x1bW4gaXMgaG92ZXJlZCBvciBub3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUm93SG92ZXJlZCAtIHRoZSByb3cgaXMgaG92ZXJlZCBvciBub3RcbiAgICAgKi9cbiAgICBoaWdobGlnaHRDZWxsT25Ib3ZlcjogZnVuY3Rpb24oaXNDb2x1bW5Ib3ZlcmVkLCBpc1Jvd0hvdmVyZWQpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29sdW1uSG92ZXJlZCAmJiBpc1Jvd0hvdmVyZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIGNlbGwgb2NjdXJzXG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbFByb3BlcnRpZXNQcmVQYWludE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oY2VsbFByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0Um93KGNlbGxQcm9wZXJ0aWVzLnkpO1xuICAgICAgICB2YXIgY29sdW1uSWQgPSB0aGlzLmdldEhlYWRlcihjZWxsUHJvcGVydGllcy54KTtcbiAgICAgICAgY2VsbFByb3BlcnRpZXMucm93ID0gcm93O1xuICAgICAgICBjZWxsUHJvcGVydGllcy5jb2x1bW5JZCA9IGNvbHVtbklkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyBhIGhvb2sgYW5kIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFpbnRpbmcgb2YgYSBmaXhlZCByb3cgY2VsbCBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXIuUG9pbnR9IGNlbGxcbiAgICAgKi9cbiAgICBjZWxsRml4ZWRSb3dQcmVQYWludE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIGZpeGVkIGNvbHVtbiBjZWxsIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH0gY2VsbFxuICAgICAqL1xuICAgIGNlbGxGaXhlZENvbHVtblByZVBhaW50Tm90aWZpY2F0aW9uOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgYSBob29rIGFuZCBpcyBjYWxsZWQganVzdCBiZWZvcmUgdGhlIHBhaW50aW5nIG9mIGEgdG9wIGxlZnQgY2VsbCBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXIuUG9pbnR9IGNlbGxcbiAgICAgKi9cbiAgICBjZWxsVG9wTGVmdFByZVBhaW50Tm90aWZpY2F0aW9uOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gZW5oYW5jZSB0aGUgZG91YmxlIGNsaWNrIGV2ZW50IGp1c3QgYmVmb3JlIGl0J3MgYnJvYWRjYXN0IHRvIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIGV2ZW50IHRvIGVuaGFuY2VcbiAgICAgKi9cbiAgICBlbmhhbmNlRG91YmxlQ2xpY2tFdmVudDogZnVuY3Rpb24oZXZlbnQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHN3YXAgc3JjIGFuZCB0YXIgY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmMgLSBjb2x1bW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyIC0gY29sdW1uIGluZGV4XG4gICAgICovXG4gICAgc3dhcENvbHVtbnM6IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy5jb2x1bW5zO1xuICAgICAgICB2YXIgdG1wID0gY29sdW1uc1tzb3VyY2VdO1xuICAgICAgICBjb2x1bW5zW3NvdXJjZV0gPSBjb2x1bW5zW3RhcmdldF07XG4gICAgICAgIGNvbHVtbnNbdGFyZ2V0XSA9IHRtcDtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkVkZ2U6IGZ1bmN0aW9uKGMsIHJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRDb2x1bW5FZGdlKGMsIHJlbmRlcmVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gY29sdW1uIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0b3RhbHMgcm93IGluZGV4IGxvY2FsIHRvIHRoZSB0b3RhbHMgYXJlYVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFthcmVhcz1bJ3RvcCcsICdib3R0b20nXV0gLSBtYXkgaW5jbHVkZSBgJ3RvcCdgIGFuZC9vciBgJ2JvdHRvbSdgXG4gICAgICovXG4gICAgc2V0VG90YWxzVmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlLCBhcmVhcykge1xuICAgICAgICB0aGlzLmdyaWQuc2V0VG90YWxzVmFsdWVOb3RpZmljYXRpb24oeCwgeSwgdmFsdWUsIGFyZWFzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIG9iamVjdCBhdCB5IGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHJvdyBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0Um93KHkpO1xuICAgIH0sXG5cbiAgICBjb252ZXJ0Vmlld1BvaW50VG9EYXRhUG9pbnQ6IGZ1bmN0aW9uKHZpZXdQb2ludCkge1xuICAgICAgICB2YXIgbmV3WCA9IHRoaXMuZ2V0Q29sdW1uKHZpZXdQb2ludC54KS5pbmRleDtcbiAgICAgICAgdmFyIG5ld1BvaW50ID0gdGhpcy5ncmlkLm5ld1BvaW50KG5ld1gsIHZpZXdQb2ludC55KTtcbiAgICAgICAgcmV0dXJuIG5ld1BvaW50O1xuICAgIH0sXG5cbiAgICBzZXRHcm91cHM6IGZ1bmN0aW9uKGFycmF5T2ZDb2x1bW5JbmRleGVzKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldEdyb3VwcyhhcnJheU9mQ29sdW1uSW5kZXhlcyk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29sdW1ucygpO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgc2V0QWdncmVnYXRlczogZnVuY3Rpb24obWFwT2ZLZXlzVG9GdW5jdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRBZ2dyZWdhdGVzKG1hcE9mS2V5c1RvRnVuY3Rpb25zKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmNoYW5nZWQoKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9LFxuXG4gICAgaGFzSGllcmFyY2h5Q29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBnZXRSb3dDb250ZXh0RnVuY3Rpb246IGZ1bmN0aW9uKHNlbGVjdGVkUm93cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uTWF0cml4RnVuY3Rpb246IGZ1bmN0aW9uKHNlbGVjdGVkUm93cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0RmllbGROYW1lOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZHMoKVtpbmRleF07XG4gICAgfSxcblxuICAgIGdldENvbHVtbkluZGV4OiBmdW5jdGlvbihmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRzKCkuaW5kZXhPZihmaWVsZE5hbWUpO1xuICAgIH0sXG5cbiAgICBnZXRDb21wdXRlZFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0Q29tcHV0ZWRSb3coeSk7XG4gICAgfSxcblxuICAgIGF1dG9zaXplQWxsQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgY2hlY2tDb2x1bW5BdXRvc2l6aW5nOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICBmb3JjZSA9IGZvcmNlID09PSB0cnVlO1xuICAgICAgICB0aGlzLmF1dG9TaXplUm93TnVtYmVyQ29sdW1uKCk7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1uc1stMl0uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKGZvcmNlKTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICBjb2x1bW4uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKGZvcmNlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGF1dG9TaXplUm93TnVtYmVyQ29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5pc1Jvd051bWJlckF1dG9zaXppbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5hbGxDb2x1bW5zWy0xXS5jaGVja0NvbHVtbkF1dG9zaXppbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0R2xvYmFsRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEdsb2JhbEZpbHRlcigpO1xuICAgIH0sXG5cbiAgICBzZXRHbG9iYWxGaWx0ZXI6IGZ1bmN0aW9uKGZpbHRlck9yT3B0aW9ucykge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRHbG9iYWxGaWx0ZXIoZmlsdGVyT3JPcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0ZWRSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0ZWRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpO1xuICAgIH0sXG5cbiAgICBnZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldERhdGEoKTtcbiAgICB9LFxuXG4gICAgZ2V0RmlsdGVyZWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEZpbHRlcmVkRGF0YSgpO1xuICAgIH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWhhdmlvcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xuXG5mdW5jdGlvbiBDb2x1bW4oYmVoYXZpb3IsIGluZGV4LCBsYWJlbCkge1xuICAgIHRoaXMuYmVoYXZpb3IgPSBiZWhhdmlvcjtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IGJlaGF2aW9yLmRhdGFNb2RlbDtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xufVxuXG5Db2x1bW4ucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb2x1bW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgZ2V0VW5maWx0ZXJlZFZhbHVlOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRVbmZpbHRlcmVkVmFsdWUodGhpcy5pbmRleCwgeSk7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRWYWx1ZSh0aGlzLmluZGV4LCB5KTtcbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5zZXRWYWx1ZSh0aGlzLmluZGV4LCB5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXMgJiYgcHJvcGVydGllcy53aWR0aCB8fCB0aGlzLmJlaGF2aW9yLnJlc29sdmVQcm9wZXJ0eSgnZGVmYXVsdENvbHVtbldpZHRoJyk7XG4gICAgfSxcblxuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICB0aGlzLmdldFByb3BlcnRpZXMoKS53aWR0aCA9IE1hdGgubWF4KDUsIHdpZHRoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q2VsbFJlbmRlcmVyOiBmdW5jdGlvbihjb25maWcsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldENlbGxSZW5kZXJlcihjb25maWcsIHRoaXMuaW5kZXgsIHkpO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRQcml2YXRlU3RhdGUoKS5jZWxsUHJvcGVydGllc1t0aGlzLmluZGV4ICsgJywnICsgeV07XG4gICAgfSxcblxuICAgIHNldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmdldFByaXZhdGVTdGF0ZSgpLmNlbGxQcm9wZXJ0aWVzW3RoaXMuaW5kZXggKyAnLCcgKyB5XSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBjaGVja0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHZhciBhLCBiLCBkO1xuICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgYSA9IHByb3BlcnRpZXMud2lkdGg7XG4gICAgICAgICAgICBiID0gcHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCB8fCBhO1xuICAgICAgICAgICAgZCA9IHByb3BlcnRpZXMuY29sdW1uQXV0b3NpemVkICYmICFmb3JjZTtcbiAgICAgICAgICAgIGlmIChhICE9PSBiIHx8ICFkKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy53aWR0aCA9ICFkID8gYiA6IE1hdGgubWF4KGEsIGIpO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuY29sdW1uQXV0b3NpemVkID0gIWlzTmFOKHByb3BlcnRpZXMud2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldENlbGxUeXBlOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoeSk7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlT2YodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuXG4gICAgZ2V0RmlsdGVyVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHZhciBwcm9wcyA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICAvLyB2YXIgdHlwZSA9IHByb3BzLmZpbHRlclR5cGU7XG4gICAgICAgIC8vIGlmICghdHlwZSkge1xuICAgICAgICAvLyAgICAgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpO1xuICAgICAgICAvLyAgICAgaWYgKHR5cGUgIT09ICd1bmtub3duJykge1xuICAgICAgICAvLyAgICAgICAgIHByb3BzLnR5cGUgPSB0eXBlO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHJldHVybiB0eXBlO1xuICAgICAgICByZXR1cm4gJ2ZpbHRlcic7XG4gICAgfSxcblxuICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgdmFyIHR5cGUgPSBwcm9wcy50eXBlO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLmNvbXB1dGVDb2x1bW5UeXBlKCk7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfSxcblxuICAgIGNvbXB1dGVDb2x1bW5UeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5iZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5iZWhhdmlvci5nZXRSb3dDb3VudCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKGhlYWRlclJvd0NvdW50KTtcbiAgICAgICAgdmFyIGVhY2hUeXBlID0gdGhpcy50eXBlT2YodmFsdWUpO1xuICAgICAgICBpZiAoIWVhY2hUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlT2YodmFsdWUpO1xuICAgICAgICB2YXIgaXNOdW1iZXIgPSAoKHR5cGVvZiB2YWx1ZSkgPT09ICdudW1iZXInKTtcbiAgICAgICAgZm9yICh2YXIgeSA9IGhlYWRlclJvd0NvdW50OyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSh5KTtcbiAgICAgICAgICAgIGVhY2hUeXBlID0gdGhpcy50eXBlT2YodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09IGVhY2hUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyICYmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2Zsb2F0JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ21peGVkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfSxcblxuICAgIHR5cGVPZjogZnVuY3Rpb24oc29tZXRoaW5nKSB7XG4gICAgICAgIHZhciB0eXBlT2YgPSB0eXBlb2Ygc29tZXRoaW5nO1xuICAgICAgICBzd2l0Y2ggKHR5cGVPZikge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc29tZXRoaW5nLmNvbnN0cnVjdG9yLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNvbWV0aGluZykgPT09IHNvbWV0aGluZyA/ICdpbnQnIDogJ2Zsb2F0JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVPZjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0UHJpdmF0ZVN0YXRlKCkuY29sdW1uUHJvcGVydGllc1t0aGlzLmluZGV4XTtcbiAgICB9LFxuXG4gICAgc2V0UHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuYmVoYXZpb3IuZ2V0UHJpdmF0ZVN0YXRlKCkuY29sdW1uUHJvcGVydGllc1t0aGlzLmluZGV4XTtcbiAgICAgICAgdGhpcy5jbGVhck9iamVjdFByb3BlcnRpZXMoY3VycmVudCwgZmFsc2UpO1xuICAgICAgICBfKGN1cnJlbnQpLmV4dGVuZE93bihwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlU29ydDogZnVuY3Rpb24oa2V5cykge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC50b2dnbGVTb3J0KHRoaXMuaW5kZXgsIGtleXMpO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldENlbGxFZGl0b3JBdCh0aGlzLmluZGV4LCB5KTtcbiAgICB9LFxuXG4gICAgZ2V0SGVhZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gICAgfSxcblxuICAgIGdldEZpZWxkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEZpZWxkcygpW3RoaXMuaW5kZXhdO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGlzdERyYWdvbiA9IHJlcXVpcmUoJ2xpc3QtZHJhZ29uJyk7XG5cbnZhciBMb2NhbCA9IHJlcXVpcmUoJy4vTG9jYWwnKTtcbnZhciBEYXRhTW9kZWxKU09OID0gcmVxdWlyZSgnLi4vZGF0YU1vZGVscy9KU09OJyk7XG52YXIgZmVhdHVyZXMgPSByZXF1aXJlKCcuLi9mZWF0dXJlcycpO1xudmFyIGFkZFN0eWxlc2hlZXQgPSByZXF1aXJlKCcuLi8uLi9jc3Mvc3R5bGVzaGVldHMnKTtcbi8vdmFyIGFnZ3JlZ2F0aW9ucyA9IHJlcXVpcmUoJ2h5cGVyLWFuYWx5dGljcycpLnV0aWwuYWdncmVnYXRpb25zO1xudmFyIGFnZ3JlZ2F0aW9ucyA9IHJlcXVpcmUoJy4uL2xvY2FsX25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MnKS51dGlsLmFnZ3JlZ2F0aW9ucztcbi8vdmFyIGFnZ3JlZ2F0aW9ucyA9IHJlcXVpcmUoJy4uL2xvY2FsX25vZGVfbW9kdWxlcy9maW5hbmFseXRpY3MnKS5hZ2dyZWdhdGlvbnM7XG5cbi8qKlxuICogQG5hbWUgYmVoYXZpb3JzLkpTT05cbiAqIEBkZXNjID4gU2FtZSBwYXJhbWV0ZXJzIGFzIHtAbGluayBiZWhhdmlvcnMuQmVoYXZpb3IjaW5pdGlhbGl6ZXxpbml0aWFsaXplfSwgd2hpY2ggaXMgY2FsbGVkIGJ5IHRoaXMgY29uc3RydWN0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEpTT04gPSBMb2NhbC5leHRlbmQoJ2JlaGF2aW9ycy5KU09OJywge1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ29uc3RydWN0b3IgbG9naWMsIGNhbGxlZCBfYWZ0ZXJfe0BsaW5rIEJlaGF2aW9yI2luaXRpYWxpemV8QmVoYXZpb3IuaW5pdGlhbGl6ZSgpfS5cbiAgICAgKiBAZGVzYyBUaGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCB1cG9uIGluc3RhbnRpYXRpb24gb2YgdGhpcyBjbGFzcyBvciBvZiBhbnkgY2xhc3MgdGhhdCBleHRlbmRzIGZyb20gdGhpcyBjbGFzcy5cbiAgICAgKiA+IEFsbCBgaW5pdGlhbGl6ZSgpYCBtZXRob2RzIGluIHRoZSBpbmhlcml0YW5jZSBjaGFpbiBhcmUgY2FsbGVkLCBpbiB0dXJuLCBlYWNoIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciwgYmVnaW5uaW5nIHdpdGggdGhhdCBvZiB0aGUgbW9zdCBcInNlbmlvclwiIGNsYXNzIHRocm91Z2ggdGhhdCBvZiB0aGUgY2xhc3Mgb2YgdGhlIG5ldyBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkIC0gdGhlIGh5cGVyZ3JpZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGRhdGFSb3dzIC0gYXJyYXkgb2YgdW5pZm9ybSBkYXRhIG9iamVjdHNcbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgZGF0YVJvd3MpIHtcbiAgICAgICAgdGhpcy5zZXREYXRhKGRhdGFSb3dzKTtcbiAgICB9LFxuXG4gICAgZmVhdHVyZXM6IFtcbiAgICAgICAgZmVhdHVyZXMuQ2VsbFNlbGVjdGlvbixcbiAgICAgICAgZmVhdHVyZXMuS2V5UGFnaW5nLFxuICAgICAgICBmZWF0dXJlcy5Db2x1bW5QaWNrZXIsXG4gICAgICAgIGZlYXR1cmVzLkNvbHVtblJlc2l6aW5nLFxuICAgICAgICBmZWF0dXJlcy5Sb3dSZXNpemluZyxcbiAgICAgICAgZmVhdHVyZXMuRmlsdGVycyxcbiAgICAgICAgZmVhdHVyZXMuUm93U2VsZWN0aW9uLFxuICAgICAgICBmZWF0dXJlcy5Db2x1bW5TZWxlY3Rpb24sXG4gICAgICAgIGZlYXR1cmVzLkNvbHVtbk1vdmluZyxcbiAgICAgICAgZmVhdHVyZXMuQ29sdW1uU29ydGluZyxcbiAgICAgICAgZmVhdHVyZXMuQ2VsbEVkaXRpbmcsXG4gICAgICAgIGZlYXR1cmVzLkNlbGxDbGljayxcbiAgICAgICAgZmVhdHVyZXMuT25Ib3ZlclxuICAgIF0sXG5cbiAgICBhZ2dyZWdhdGlvbnM6IGFnZ3JlZ2F0aW9ucyxcblxuICAgIGNyZWF0ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YU1vZGVsID0gdGhpcy5kYXRhTW9kZWw7XG4gICAgICAgIHZhciBjb2x1bW5Db3VudCA9IGRhdGFNb2RlbC5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgaGVhZGVycyA9IGRhdGFNb2RlbC5nZXRIZWFkZXJzKCk7XG4gICAgICAgIHZhciBmaWVsZHMgPSBkYXRhTW9kZWwuZ2V0RmllbGRzKCk7XG4gICAgICAgIHRoaXMuY2xlYXJDb2x1bW5zKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IGhlYWRlcnNbaV07XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5hZGRDb2x1bW4oaSwgaGVhZGVyKTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gY29sdW1uLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuY29tcGxleEZpbHRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0RGVmYXVsdERhdGFNb2RlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YU1vZGVsSlNPTih0aGlzLmdyaWQpO1xuICAgIH0sXG5cbiAgICBhcHBseUFuYWx5dGljczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBoZWFkZXIgbGFiZWxzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGhlYWRlckxhYmVscyAtIFRoZSBoZWFkZXIgbGFiZWxzLlxuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlckxhYmVscykge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRIZWFkZXJzKGhlYWRlckxhYmVscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGhlYWRlciBsYWJlbHMuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRIZWFkZXJzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBmaWVsZHMgYXJyYXkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyAtIFRoZSBmaWVsZCBuYW1lcy5cbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkTmFtZXMpIHtcbiAgICAgICAgLy93ZXJlIGRlZmluaW5nIHRoZSBjb2x1bW5zIGJhc2VkIG9uIGZpZWxkIG5hbWVzLi4uLlxuICAgICAgICAvL3dlIG11c3QgcmVidWlsZCB0aGUgY29sdW1uIGRlZmluaXRpb25zXG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldEZpZWxkcyhmaWVsZE5hbWVzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBmaWVsZCBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEZpZWxkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCB0aGUgZGF0YSBmaWVsZC5cbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSBvYmplY3RzIC0gQW4gYXJyYXkgb2YgdW5pZm9ybSBvYmplY3RzLCBlYWNoIGJlaW5nIGEgcm93IGluIHRoZSBncmlkLlxuICAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uKGRhdGFSb3dzKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldERhdGEoZGF0YVJvd3MpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5ncmlkLmlzQ29sdW1uQXV0b3NpemluZygpKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXV0b3NpemVBbGxDb2x1bW5zKCk7XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgc2VsZi5jaGFuZ2VkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYWxsQ29sdW1uc1stMV0uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSB0b3AgdG90YWxzLlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gdG90YWxSb3dzIC0gYXJyYXkgb2Ygcm93cyAoYXJyYXlzKSBvZiB0b3RhbHNcbiAgICAgKi9cbiAgICBzZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKHRvdGFsUm93cykge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRUb3BUb3RhbHModG90YWxSb3dzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSB0b3AgdG90YWxzLlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fVxuICAgICAqL1xuICAgIGdldFRvcFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRUb3BUb3RhbHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBib3R0b20gdG90YWxzLlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gdG90YWxSb3dzIC0gYXJyYXkgb2Ygcm93cyAoYXJyYXlzKSBvZiB0b3RhbHNcbiAgICAgKi9cbiAgICBzZXRCb3R0b21Ub3RhbHM6IGZ1bmN0aW9uKHRvdGFsUm93cykge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRCb3R0b21Ub3RhbHModG90YWxSb3dzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBib3R0b20gdG90YWxzLlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fVxuICAgICAqL1xuICAgIGdldEJvdHRvbVRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRCb3R0b21Ub3RhbHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBCdWlsZCB0aGUgZmllbGRzIGFuZCBoZWFkZXJzIGZyb20gdGhlIHN1cHBsaWVkIGNvbHVtbiBkZWZpbml0aW9ucy5cbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogbXlKc29uQmVoYXZpb3Iuc2V0Q29sdW1ucyhbXG4gICAgICogICAgIHsgdGl0bGU6ICdTdG9jayBOYW1lJywgZmllbGQ6ICdzaG9ydF9kZXNjcmlwdGlvbicgfSxcbiAgICAgKiAgICAgeyB0aXRsZTogJ1N0YXR1cycsIGZpZWxkOiAndHJhZGluZ19waGFzZScgfSxcbiAgICAgKiAgICAgeyB0aXRsZTogJ1JlZmVyZW5jZSBQcmljZScsIGZpZWxkOiAncmVmZXJlbmNlX3ByaWNlJyB9XG4gICAgICogXSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29sdW1uRGVmaW5pdGlvbnMgLSBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggZmllbGRzICd0aXRsZScsIGFuZCAnZmllbGQnXG4gICAgICovXG4gICAgc2V0Q29sdW1uczogZnVuY3Rpb24oY29sdW1uRGVmaW5pdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0Q29sdW1ucyhjb2x1bW5EZWZpbml0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gRW5oYW5jZSB0aGUgZG91YmxlLWNsaWNrIGV2ZW50IGp1c3QgYmVmb3JlIGl0J3MgYnJvYWRjYXN0IHRvIGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBldmVudFxuICAgICAqL1xuICAgIGVuaGFuY2VEb3VibGVDbGlja0V2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5yb3cgPSB0aGlzLmdldFJvdyhldmVudC5ncmlkQ2VsbC55KTtcbiAgICB9LFxuXG4gICAgc2V0RGF0YVByb3ZpZGVyOiBmdW5jdGlvbihkYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0RGF0YVByb3ZpZGVyKGRhdGFQcm92aWRlcik7XG4gICAgfSxcblxuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5oYXNIaWVyYXJjaHlDb2x1bW4oKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uQWxpZ25tZW50OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ID09PSAwICYmIHRoaXMuaGFzSGllcmFyY2h5Q29sdW1uKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Um93U2VsZWN0aW9uTWF0cml4OiBmdW5jdGlvbihzZWxlY3RlZFJvd3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFJvd1NlbGVjdGlvbk1hdHJpeChzZWxlY3RlZFJvd3MpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5TZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKHNlbGVjdGVkQ29sdW1ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0Q29sdW1uU2VsZWN0aW9uTWF0cml4KHNlbGVjdGVkQ29sdW1ucyk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oc2VsZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0U2VsZWN0aW9uTWF0cml4KHNlbGVjdGlvbnMpO1xuICAgIH0sXG5cbiAgICBnZXRSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRSb3dzID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFJvd1NlbGVjdGlvbihzZWxlY3RlZFJvd3MpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRDb2x1bW5zID0gdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldENvbHVtblNlbGVjdGlvbihzZWxlY3RlZENvbHVtbnMpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0U2VsZWN0aW9uKHNlbGVjdGlvbnMpO1xuICAgIH0sXG5cbiAgICBidWlsZENvbHVtblBpY2tlcjogZnVuY3Rpb24oZGl2KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0NvbHVtblJlb3JkZXJhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50OiBkaXZcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ3JvdXBzID0geyBtb2RlbHM6IHRoaXMuZ2V0R3JvdXBzKCksIHRpdGxlOiAnR3JvdXBzJyB9LFxuICAgICAgICAgICAgYXZhaWxhYmxlR3JvdXBzID0geyBtb2RlbHM6IHRoaXMuZ2V0QXZhaWxhYmxlR3JvdXBzKCksIHRpdGxlOiAnQXZhaWxhYmxlIEdyb3VwcycgfSxcbiAgICAgICAgICAgIGhpZGRlbkNvbHVtbnMgPSB7IG1vZGVsczogdGhpcy5nZXRIaWRkZW5Db2x1bW5zKCksIHRpdGxlOiAnSGlkZGVuIENvbHVtbnMnIH0sXG4gICAgICAgICAgICB2aXNpYmxlQ29sdW1ucyA9IHsgbW9kZWxzOiB0aGlzLmdldFZpc2libGVDb2x1bW5zKCksIHRpdGxlOiAnVmlzaWJsZSBDb2x1bW5zJ30sXG4gICAgICAgICAgICBncm91cExpc3RzID0gbmV3IExpc3REcmFnb24oW2dyb3VwcywgYXZhaWxhYmxlR3JvdXBzXSwgbGlzdE9wdGlvbnMpLFxuICAgICAgICAgICAgY29sdW1uTGlzdHMgPSBuZXcgTGlzdERyYWdvbihbaGlkZGVuQ29sdW1ucywgdmlzaWJsZUNvbHVtbnNdLCBsaXN0T3B0aW9ucyksXG4gICAgICAgICAgICBsaXN0U2V0cyA9IFtncm91cExpc3RzLCBjb2x1bW5MaXN0c107XG5cbiAgICAgICAgYWRkU3R5bGVzaGVldCgnbGlzdC1kcmFnb24nLCBkaXYpO1xuXG4gICAgICAgIGxpc3RTZXRzLmZvckVhY2goZnVuY3Rpb24obGlzdFNldCkge1xuICAgICAgICAgICAgbGlzdFNldC5tb2RlbExpc3RzLmZvckVhY2goZnVuY3Rpb24obGlzdCkge1xuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChsaXN0LmNvbnRhaW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9hdHRhY2ggZm9yIGxhdGVyIHJldHJpZXZhbFxuICAgICAgICBkaXYubGlzdHMgPSB7XG4gICAgICAgICAgICBncm91cDogZ3JvdXBzLm1vZGVscyxcbiAgICAgICAgICAgIGF2YWlsYWJsZUdyb3VwczogYXZhaWxhYmxlR3JvdXBzLm1vZGVscyxcbiAgICAgICAgICAgIGhpZGRlbjogaGlkZGVuQ29sdW1ucy5tb2RlbHMsXG4gICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmxlQ29sdW1ucy5tb2RlbHNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldEdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRHcm91cHMoKTtcbiAgICB9LFxuICAgIGdldEF2YWlsYWJsZUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRBdmFpbGFibGVHcm91cHMoKTtcbiAgICB9LFxuICAgIGdldEhpZGRlbkNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0SGlkZGVuQ29sdW1ucygpO1xuICAgIH0sXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0VmlzaWJsZUNvbHVtbnMoKTtcbiAgICB9LFxuICAgIHNldENvbHVtbkRlc2NyaXB0b3JzOiBmdW5jdGlvbihsaXN0cykge1xuICAgICAgICAvL2Fzc3VtZXMgdGhlcmUgaXMgb25lIHJvdy4uLi5cbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLmNvbHVtbnNbMF07XG4gICAgICAgIHRoaXMuY29sdW1ucy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAodHJlZSAmJiB0cmVlLmxhYmVsID09PSAnVHJlZScpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKHRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdHMudmlzaWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2gobGlzdHMudmlzaWJsZVtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXBCeXMgPSBsaXN0cy5ncm91cC5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRHcm91cHMoZ3JvdXBCeXMpO1xuXG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gLXRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNlbGVjdGlvbnMubWFwKGZ1bmN0aW9uKGVhY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBlYWNoICsgb2Zmc2V0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0ZWRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy92YXIgTGlzdERyYWdvbiA9IHJlcXVpcmUoJ2xpc3QtZHJhZ29uJyk7XG5cbnZhciBCZWhhdmlvciA9IHJlcXVpcmUoJy4vQmVoYXZpb3InKTtcbi8vdmFyIERhdGFNb2RlbEpTT04gPSByZXF1aXJlKCcuLi9kYXRhTW9kZWxzL0pTT04nKTtcbi8vdmFyIGZlYXR1cmVzID0gcmVxdWlyZSgnLi4vZmVhdHVyZXMnKTtcbi8vdmFyIGFkZFN0eWxlc2hlZXQgPSByZXF1aXJlKCcuLi9zdHlsZXNoZWV0cycpO1xuLy8vL3ZhciBhZ2dyZWdhdGlvbnMgPSByZXF1aXJlKCdoeXBlci1hbmFseXRpY3MnKS51dGlsLmFnZ3JlZ2F0aW9ucztcbi8vLy92YXIgYWdncmVnYXRpb25zID0gcmVxdWlyZSgnLi4vbG9jYWxfbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcycpLnV0aWwuYWdncmVnYXRpb25zO1xuLy92YXIgYWdncmVnYXRpb25zID0gcmVxdWlyZSgnLi4vbG9jYWxfbm9kZV9tb2R1bGVzL2ZpbmFuYWx5dGljcycpLmFnZ3JlZ2F0aW9ucztcblxuLyoqXG4gKiBAbmFtZSBiZWhhdmlvcnMuTG9jYWxcbiAqIEBkZXNjID4gU2FtZSBwYXJhbWV0ZXJzIGFzIHtAbGluayBiZWhhdmlvcnMuQmVoYXZpb3IjaW5pdGlhbGl6ZXxpbml0aWFsaXplfSwgd2hpY2ggaXMgY2FsbGVkIGJ5IHRoaXMgY29uc3RydWN0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIExvY2FsID0gQmVoYXZpb3IuZXh0ZW5kKCdMb2NhbCcsIHtcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9jYWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCZWhhdmlvciA9IHJlcXVpcmUoJy4vQmVoYXZpb3InKTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9LFxuICAgIG4wMHAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBOdWxsID0gQmVoYXZpb3IuZXh0ZW5kKCdOdWxsJywge1xuXG4gICAgLy9pbml0YWxpemU6IGZ1bmN0aW9uKGdyaWQsIGNvbXBvbmVudCkge30sXG5cbiAgICBzZXRTY3JvbGxQb3NpdGlvblk6IG5vb3AsXG4gICAgc2V0U2Nyb2xsUG9zaXRpb25YOiBub29wLFxuICAgIGdldENvbHVtbkNvdW50OiBuMDBwLFxuICAgIGdldEZpeGVkQ29sdW1uQ291bnQ6IG4wMHAsXG4gICAgZ2V0Rml4ZWRDb2x1bW5zV2lkdGg6IG4wMHAsXG4gICAgZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGg6IG4wMHAsXG4gICAgc2V0UmVuZGVyZWRXaWR0aDogbjAwcCxcbiAgICBnZXRSb3dDb3VudDogbjAwcCxcbiAgICBnZXRGaXhlZFJvd0NvdW50OiBuMDBwLFxuICAgIGdldEZpeGVkUm93c0hlaWdodDogbjAwcCxcbiAgICBnZXRGaXhlZFJvd3NNYXhIZWlnaHQ6IG4wMHAsXG4gICAgc2V0UmVuZGVyZWRIZWlnaHQ6IG4wMHAsXG4gICAgZ2V0Q2VsbFByb3ZpZGVyOiBub29wLFxuICAgIGNsaWNrOiBub29wLFxuICAgIGRvdWJsZUNsaWNrOiBub29wXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBCZWhhdmlvcjogcmVxdWlyZSgnLi9CZWhhdmlvcicpLCAvLyBhYnN0cmFjdCBiYXNlIGNsYXNzXG4gICAgSlNPTjogcmVxdWlyZSgnLi9KU09OJyksXG4gICAgTnVsbDogcmVxdWlyZSgnLi9OdWxsJylcbn07IiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG11c3RhY2hlID0gcmVxdWlyZSgnbXVzdGFjaGUnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vbGliL0Jhc2UnKTtcblxudmFyIGV4dHJhY3QgPSAvXFwvXFwqXFxzKihbXl0rPylcXHMrXFwqXFwvLzsgLy8gZmluZHMgdGhlIHN0cmluZyBpbnNpZGUgdGhlIC8qIC4uLiAqLzsgdGhlIChncm91cCkgZXhjbHVkZXMgdGhlIHdoaXRlc3BhY2VcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENlbGxFZGl0b3IgPSBCYXNlLmV4dGVuZCgnQ2VsbEVkaXRvcicsIHtcblxuICAgIC8qKlxuICAgICAqIGFtIEkgY3VycmVudGx5IGVkaXRpbmcgKGkuZS4sIGJldHdlZW4gY2FsbHMgdG8gYGJlZ2luRWRpdEF0YCBhbmQgZWl0aGVyIGBzdG9wRWRpdGluZ2Agb3IgYGNhbmNlbEVkaXRpbmdgKVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgaXNFZGl0aW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBwb2ludCB0aGF0IEkgYW0gZWRpdGluZyBhdCByaWdodCBub3dcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGVkaXRvclBvaW50OiB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAtMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpZiB0cnVlLCBjaGVjayB0aGF0IHRoZSBlZGl0b3IgaXMgaW4gdGhlIHJpZ2h0IGxvY2F0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjaGVja0VkaXRvclBvc2l0aW9uRmxhZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBteSBpbnN0YW5jZSBvZiBoeXBlcmdyaWRcbiAgICAgKiBAdHlwZSB7SHlwZXJncmlkfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBncmlkOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogdGhlIHZhbHVlIGJlZm9yZSBlZGl0aW5nXG4gICAgICogQHR5cGUge3R5cGV9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxWYWx1ZTogbnVsbCxcblxuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgYC5ncmlkLmJlaGF2aW9yYCBwcm9wZXJ0eSBpbnN0ZWFkLlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtCZWhhdmlvcn0gVGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICovXG4gICAgZ2V0QmVoYXZpb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdncmlkLmJlaGF2aW9yJywgeyBzaW5jZTogJzAuMicgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoaXMgZnVuY3Rpb24gaXMgYSBjYWxsYmFjayBmcm9tIHRoZSBmaW4taHlwZXJncmlkLiAgIEl0IGlzIGNhbGxlZCBhZnRlciBlYWNoIHBhaW50IG9mIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jaGVja0VkaXRvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzY3JvbGwgdmFsdWVzIGhhdmUgY2hhbmdlZCwgd2UndmUgYmVlbiBub3RpZmllZFxuICAgICAqL1xuICAgIHNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0Q2hlY2tFZGl0b3JQb3NpdGlvbkZsYWcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdHVybiBvbiBjaGVja0VkaXRvclBvc2l0aW9uRmxhZyBib29sZWFuIGZpZWxkXG4gICAgICovXG4gICAgc2V0Q2hlY2tFZGl0b3JQb3NpdGlvbkZsYWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoZWNrRWRpdG9yUG9zaXRpb25GbGFnID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgYmVnaW4gZWRpdGluZyBhdCBsb2NhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gdGhlIGxvY2F0aW9uIHRvIHN0YXJ0IGVkaXRpbmcgYXRcbiAgICAgKi9cbiAgICBiZWdpbkVkaXRBdDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdGhpcy5lZGl0b3JQb2ludCA9IHBvaW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBwdXQgdmFsdWUgaW50byBvdXIgZWRpdG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIC0gd2hhdGV2ZXIgdmFsdWUgd2Ugd2FudCB0byBlZGl0XG4gICAgICovXG4gICAgc2V0RWRpdG9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybnMgdGhlIHBvaW50IGF0IHdoaWNoIHdlIGFyZSBjdXJyZW50bHkgZWRpdGluZ1xuICAgICAqIEByZXR1cm5zIHtQb2ludH1cbiAgICAgKi9cbiAgICBnZXRFZGl0b3JQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvclBvaW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIGN1cnJlbnQgZWRpdG9yIGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSB0aGUgZGF0YSBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCBlZGl0b3JcbiAgICAgKi9cbiAgICBzZXRFZGl0b3JQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdGhpcy5lZGl0b3JQb2ludCA9IHBvaW50O1xuICAgICAgICB0aGlzLm1vZGVsUG9pbnQgPSB0aGlzLmdyaWQuY29udmVydFZpZXdQb2ludFRvRGF0YVBvaW50KHBvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGlzcGxheSB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgc2hvd0VkaXRvcjogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhpZGUgdGhlIGVkaXRvclxuICAgICAqL1xuICAgIGhpZGVFZGl0b3I6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzdG9wIGVkaXRpbmdcbiAgICAgKi9cbiAgICBzdG9wRWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvY2VlZCA9IHRoaXMuZ3JpZC5maXJlU3ludGhldGljRWRpdG9yRGF0YUNoYW5nZUV2ZW50KHRoaXMsIHRoaXMuaW5pdGlhbFZhbHVlLCB0aGlzLmdldEVkaXRvclZhbHVlLCB0aGlzKTtcbiAgICAgICAgaWYgKCFwcm9jZWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zYXZlRWRpdG9yVmFsdWUoKTtcbiAgICAgICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRlRWRpdG9yKCk7XG4gICAgfSxcblxuICAgIGNhbmNlbEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRlRWRpdG9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNhdmUgdGhlIG5ldyB2YWx1ZSBpbnRvIHRoZSBiZWhhdmlvcihtb2RlbClcbiAgICAgKi9cbiAgICBzYXZlRWRpdG9yVmFsdWU6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGN1cnJlbnQgZWRpdG9yJ3MgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRFZGl0b3JWYWx1ZTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJlcXVlc3QgZm9jdXNcbiAgICAgKi9cbiAgICB0YWtlRm9jdXM6IGZ1bmN0aW9uKCkge30sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNoZWNrIHRoYXQgdGhlIGVkaXRvciBpcyBpbiB0aGUgY29ycmVjdCBsb2NhdGlvbiwgYW5kIGlzIHNob3dpbmcvaGlkZGVuIGFwcHJvcHJpYXRlbHlcbiAgICAgKi9cbiAgICBjaGVja0VkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgfSxcblxuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgYC5ncmlkYCBwcm9wZXJ0eSBpbnN0ZWFkLiAqL1xuICAgIGdldEdyaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdncmlkJywgeyBzaW5jZTogJzAuMicgfSk7XG4gICAgfSxcblxuICAgIHRlbXBsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLypcblxuICAgICAgICAgKi9cbiAgICB9LFxuXG4gICAgZ2V0SFRNTDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUudG9TdHJpbmcoKS5tYXRjaChleHRyYWN0KVsxXTtcbiAgICAgICAgcmV0dXJuIG11c3RhY2hlLnJlbmRlcih0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgfSxcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbEVkaXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNpbXBsZSA9IHJlcXVpcmUoJy4vU2ltcGxlJyk7XG52YXIgTWFwID0gcmVxdWlyZSgnLi4vbGliL01hcHB5Jyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDaG9pY2UgPSBTaW1wbGUuZXh0ZW5kKCdDaG9pY2UnLCB7XG5cbiAgICAvKipcbiAgICAgKiB0aGUgbGlzdCBvZiBpdGVtcyB0byBwaWNrIGZyb21cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQG1lbWJlck9mIENob2ljZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpdGVtczogWydhJywgJ2InLCAnYyddLFxuXG4gICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKlxuICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJlZGl0b3JcIj5cbiAgICAgICAgICAgICAgICAgICAge3sjaXRlbXN9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInt7Ln19XCI+e3sufX08L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAge3svaXRlbXN9fVxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgKi9cbiAgICB9LFxuXG4gICAgYXV0b3BvcHVsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yO1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmdldEVkaXRvclBvaW50KCk7XG4gICAgICAgIHZhciBjb2xQcm9wcyA9IHRoaXMuZ3JpZC5nZXRDb2x1bW5Qcm9wZXJ0aWVzKHBvaW50LngpO1xuICAgICAgICBpZiAoIWNvbFByb3BzLmF1dG9wb3B1bGF0ZUVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXJDb3VudCA9IHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgcm93Q291bnQgPSB0aGlzLmdyaWQuZ2V0VW5maWx0ZXJlZFJvd0NvdW50KCkgLSBoZWFkZXJDb3VudDtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHBvaW50Lng7XG4gICAgICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgICAgICAgdmFyIGVhY2ggPSBiZWhhdmlvci5nZXRVbmZpbHRlcmVkVmFsdWUoY29sdW1uLCByKTtcbiAgICAgICAgICAgIG1hcC5zZXQoZWFjaCwgZWFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlcyA9IG1hcC52YWx1ZXM7XG4gICAgICAgIHZhbHVlcy5zb3J0KCk7XG5cbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwICYmIHZhbHVlc1swXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YWx1ZXMudW5zaGlmdCgnJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEl0ZW1zKHZhbHVlcyk7XG4gICAgfSxcblxuICAgIC8vbm8gZXZlbnRzIGFyZSBmaXJlZCB3aGlsZSB0aGUgZHJvcGRvd24gaXMgb3BlblxuICAgIC8vc2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvbTR0bmR0dTQvNi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDaG9pY2UucHJvdG90eXBlXG4gICAgICovXG4gICAgc2hvd0VkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5pbnB1dC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnNob3dEcm9wZG93bihzZWxmLmlucHV0KTtcbiAgICAgICAgfSwgNTApO1xuICAgIH0sXG5cbiAgICBwcmVTaG93RWRpdG9yTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5hdXRvcG9wdWxhdGUoKTtcbiAgICAgICAgdGhpcy5zZXRFZGl0b3JWYWx1ZSh0aGlzLmluaXRpYWxWYWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDaG9pY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGl0ZW1zXG4gICAgICovXG4gICAgc2V0SXRlbXM6IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDaG9pY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZUlucHV0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIFNpbXBsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZUlucHV0LmFwcGx5KHRoaXMsIFtpbnB1dF0pO1xuICAgICAgICBpbnB1dC5vbmNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5zdG9wRWRpdGluZygpO1xuICAgICAgICB9O1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hvaWNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2ltcGxlID0gcmVxdWlyZSgnLi9TaW1wbGUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENvbG9yID0gU2ltcGxlLmV4dGVuZCgnQ29sb3InLCB7XG5cbiAgICB0ZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XCJlZGl0b3JcIiB0eXBlPVwiY29sb3JcIj5cbiAgICAgICAgKi9cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNpbXBsZSA9IHJlcXVpcmUoJy4vU2ltcGxlJyk7XG52YXIgRm9ybWF0dGVycyA9IHJlcXVpcmUoJy4uL2xpYi9Gb3JtYXR0ZXJzJyk7XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZShpbnB1dCkge1xuICB2YXIgcGFydHMgPSBpbnB1dC5tYXRjaCgvKFxcZCspL2cpO1xuICAvLyBuZXcgRGF0ZSh5ZWFyLCBtb250aCBbLCBkYXRlIFssIGhvdXJzWywgbWludXRlc1ssIHNlY29uZHNbLCBtc11dXV1dKVxuICByZXR1cm4gbmV3IHdpbmRvdy5EYXRlKHBhcnRzWzBdLCBwYXJ0c1sxXSAtIDEsIHBhcnRzWzJdKTsgLy8gbW9udGhzIGFyZSAwLWJhc2VkXG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRlID0gU2ltcGxlLmV4dGVuZCgnRGF0ZScsIHtcblxuICAgIHRlbXBsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cImVkaXRvclwiIHR5cGU9XCJkYXRlXCI+XG4gICAgICAgICovXG4gICAgfSxcblxuICAgIHNldEVkaXRvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnRGF0ZScpIHtcbiAgICAgICAgICAgIHZhbHVlID0gRm9ybWF0dGVycy5kYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldElucHV0KCkudmFsdWUgPSB2YWx1ZSArICcnO1xuICAgIH0sXG5cbiAgICBnZXRFZGl0b3JWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0SW5wdXQoKS52YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZURhdGUodmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0ZTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRmlsdGVyID0gQ2VsbEVkaXRvci5leHRlbmQoJ0ZpbHRlcicsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgc3R5bGUgPSBkYXRhLnN0eWxlO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHN0eWxlLnRvcCA9IHN0eWxlLmJvdHRvbSA9ICc0NHB4JztcbiAgICAgICAgc3R5bGUucmlnaHQgPSBzdHlsZS5sZWZ0ID0gJzFlbSc7XG4gICAgICAgIHN0eWxlLm92ZXJmbG93WSA9ICdzY3JvbGwnO1xuXG4gICAgICAgIHZhciB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgICAgIGRhdGEuYXBwZW5kQ2hpbGQodGFibGUpO1xuXG4gICAgICAgIHN0eWxlID0gdGFibGUuc3R5bGU7XG4gICAgICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgICAgIHZhciB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgIHZhciB0ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRyKTtcbiAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGQpO1xuXG5cbiAgICAgICAgdGhpcy50aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRpdGxlLmlubmVySFRNTCA9ICdGaWx0ZXIgRWRpdG9yJztcblxuICAgICAgICB0aGlzLmRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIHRoaXMuY29udGVudCA9IHRkO1xuICAgICAgICB0aGlzLmJ1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBzdHlsZSA9IHRoaXMuZGlhbG9nLnN0eWxlO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHN0eWxlLnRvcCA9IHN0eWxlLmxlZnQgPSBzdHlsZS5yaWdodCA9IHN0eWxlLmJvdHRvbSA9IDA7XG4gICAgICAgIHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcblxuICAgICAgICBzdHlsZSA9IHRoaXMudGl0bGUuc3R5bGU7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgc3R5bGUudG9wID0gc3R5bGUubGVmdCA9IHN0eWxlLnJpZ2h0ID0gMDtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gJzQ0cHgnO1xuICAgICAgICBzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XG4gICAgICAgIHN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBzdHlsZS5wYWRkaW5nID0gJzExcHgnO1xuXG4gICAgICAgIHN0eWxlID0gdGhpcy5idXR0b25zLnN0eWxlO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBzdHlsZS5yaWdodCA9IHN0eWxlLmJvdHRvbSA9IDA7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9ICc0NHB4JztcbiAgICAgICAgc3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xuICAgICAgICBzdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgc3R5bGUucGFkZGluZyA9ICc4cHgnO1xuXG4gICAgICAgIHRoaXMuZGlhbG9nLmFwcGVuZENoaWxkKHRoaXMudGl0bGUpO1xuICAgICAgICB0aGlzLmRpYWxvZy5hcHBlbmRDaGlsZChkYXRhKTtcbiAgICAgICAgdGhpcy5kaWFsb2cuYXBwZW5kQ2hpbGQodGhpcy5idXR0b25zKTtcblxuICAgICAgICB0aGlzLm9rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHRoaXMub2suc3R5bGUuYm9yZGVyUmFkaXVzID0gJzhweCc7XG4gICAgICAgIHRoaXMub2suc3R5bGUud2lkdGggPSAnNS41ZW0nO1xuXG4gICAgICAgIHRoaXMuY2FuY2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuY2FuY2VsLnN0eWxlLm1hcmdpbkxlZnQgPSAnMmVtJztcbiAgICAgICAgdGhpcy5jYW5jZWwuc3R5bGUuYm9yZGVyUmFkaXVzID0gJzhweCc7XG4gICAgICAgIHRoaXMuY2FuY2VsLnN0eWxlLndpZHRoID0gJzUuNWVtJztcblxuICAgICAgICB0aGlzLmRlbGV0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICB0aGlzLmRlbGV0ZS5zdHlsZS5tYXJnaW5MZWZ0ID0gJzJlbSc7XG4gICAgICAgIHRoaXMuZGVsZXRlLnN0eWxlLmJvcmRlclJhZGl1cyA9ICc4cHgnO1xuICAgICAgICB0aGlzLmRlbGV0ZS5zdHlsZS53aWR0aCA9ICc1LjVlbSc7XG5cbiAgICAgICAgdGhpcy5yZXNldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICB0aGlzLnJlc2V0LnN0eWxlLm1hcmdpbkxlZnQgPSAnMmVtJztcbiAgICAgICAgdGhpcy5yZXNldC5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnOHB4JztcbiAgICAgICAgdGhpcy5yZXNldC5zdHlsZS53aWR0aCA9ICc1LjVlbSc7XG5cbiAgICAgICAgdGhpcy5vay5pbm5lckhUTUwgPSAnb2snO1xuICAgICAgICB0aGlzLmNhbmNlbC5pbm5lckhUTUwgPSAnY2FuY2VsJztcbiAgICAgICAgdGhpcy5kZWxldGUuaW5uZXJIVE1MID0gJ2RlbGV0ZSc7XG4gICAgICAgIHRoaXMucmVzZXQuaW5uZXJIVE1MID0gJ3Jlc2V0JztcblxuICAgICAgICB0aGlzLmJ1dHRvbnMuYXBwZW5kQ2hpbGQodGhpcy5vayk7XG4gICAgICAgIHRoaXMuYnV0dG9ucy5hcHBlbmRDaGlsZCh0aGlzLnJlc2V0KTtcbiAgICAgICAgdGhpcy5idXR0b25zLmFwcGVuZENoaWxkKHRoaXMuZGVsZXRlKTtcbiAgICAgICAgdGhpcy5idXR0b25zLmFwcGVuZENoaWxkKHRoaXMuY2FuY2VsKTtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMub2sub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5va1ByZXNzZWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYW5jZWwub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5jYW5jZWxQcmVzc2VkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZGVsZXRlUHJlc3NlZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc2V0Lm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucmVzZXRQcmVzc2VkKCk7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHRlYXJEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb250ZW50LmlubmVySFRNTCA9ICcnO1xuICAgIH0sXG5cbiAgICBva1ByZXNzZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5ncmlkLmRpYWxvZztcbiAgICAgICAgZGlhbG9nLm9uT2tQcmVzc2VkKCk7XG4gICAgfSxcblxuICAgIGNhbmNlbFByZXNzZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5ncmlkLmRpYWxvZztcbiAgICAgICAgZGlhbG9nLm9uQ2FuY2VsUHJlc3NlZCgpO1xuICAgIH0sXG5cbiAgICBkZWxldGVQcmVzc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpYWxvZyA9IHRoaXMuZ3JpZC5kaWFsb2c7XG4gICAgICAgIGRpYWxvZy5vbkRlbGV0ZVByZXNzZWQoKTtcbiAgICB9LFxuXG4gICAgcmVzZXRQcmVzc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpYWxvZyA9IHRoaXMuZ3JpZC5kaWFsb2c7XG4gICAgICAgIGRpYWxvZy5vblJlc2V0UHJlc3NlZCgpO1xuICAgIH0sXG5cbiAgICBiZWdpbkVkaXRBdDogZnVuY3Rpb24oZWRpdG9yUG9pbnQpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yO1xuICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5ncmlkLmRpYWxvZztcblxuICAgICAgICB2YXIgY29sdW1uSW5kZXggPSBlZGl0b3JQb2ludC54O1xuICAgICAgICAvL3ZhciB0aXRsZSA9IGJlaGF2aW9yLmdldENvbHVtbklkKGNvbHVtbkluZGV4KTtcbiAgICAgICAgLy92YXIgZmllbGQgPSBiZWhhdmlvci5nZXRGaWVsZChjb2x1bW5JbmRleCk7XG4gICAgICAgIC8vdmFyIHR5cGUgPSBiZWhhdmlvci5nZXRDb2x1bW4oY29sdW1uSW5kZXgpLmdldFR5cGUoKTtcblxuICAgICAgICB0aGlzLnRpdGxlLmlubmVySFRNTCA9ICdNYW5hZ2UgRmlsdGVycyc7XG4gICAgICAgIHZhciBmaWx0ZXIgPSBiZWhhdmlvci5nZXRHbG9iYWxGaWx0ZXIoKTtcbiAgICAgICAgLy92YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChkaWFsb2cuaXNPcGVuKCkpIHtcbiAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBkaWFsb2cuY2xlYXIoKTtcbiAgICAgICAgICAgIGRpYWxvZy5vdmVybGF5LmFwcGVuZENoaWxkKHRoaXMuZGlhbG9nKTtcblxuICAgICAgICAgICAgZmlsdGVyLmluaXRpYWxpemVEaWFsb2coKTtcblxuICAgICAgICAgICAgZGlhbG9nLm9uT2tQcmVzc2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlci5vbk9rICYmIGZpbHRlci5vbk9rKCkpIHsgLy8gb25PSygpIHRydXRoeSByZXN1bHQgbWVhbnMgYWJvcnQ7IGZhbHN5IG1lYW5zIHByb2NlZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnRlYXJEb3duKCk7XG4gICAgICAgICAgICAgICAgLy9iZWhhdmlvci5zZXRDb21wbGV4RmlsdGVyKGNvbHVtbkluZGV4LCB7XG4gICAgICAgICAgICAgICAgLy8gICAgLy90eXBlOiBmaWx0ZXIuYWxpYXMsXG4gICAgICAgICAgICAgICAgLy8gICAgc3RhdGU6IGZpbHRlci5nZXRTdGF0ZSgpXG4gICAgICAgICAgICAgICAgLy99KTtcbiAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBiZWhhdmlvci5hcHBseUFuYWx5dGljcygpO1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRpYWxvZy5vbkNhbmNlbFByZXNzZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLm9uQ2FuY2VsICYmIGZpbHRlci5vbkNhbmNlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi50ZWFyRG93bigpO1xuICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGZpbHRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRpYWxvZy5vbkRlbGV0ZVByZXNzZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLm9uRGVsZXRlICYmIGZpbHRlci5vbkRlbGV0ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi50ZWFyRG93bigpO1xuICAgICAgICAgICAgICAgIC8vYmVoYXZpb3Iuc2V0Q29tcGxleEZpbHRlcihjb2x1bW5JbmRleCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBiZWhhdmlvci5hcHBseUFuYWx5dGljcygpO1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRpYWxvZy5vblJlc2V0UHJlc3NlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIub25SZXNldCAmJiBmaWx0ZXIub25SZXNldCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi50ZWFyRG93bigpO1xuICAgICAgICAgICAgICAgIGZpbHRlci5pbml0aWFsaXplRGlhbG9nKGRpYWxvZyk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlci5vblNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLm9uU2hvdyhzZWxmLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjZWxsQm91bmRzID0gdGhpcy5ncmlkLl9nZXRCb3VuZHNPZkNlbGwoY29sdW1uSW5kZXgsIGVkaXRvclBvaW50LnkpO1xuXG4gICAgICAgICAgICAvL2hhY2sgdG8gYWNjb21vZGF0ZSBib290c3RyYXAgbWFyZ2luIGlzc3Vlcy4uLlxuICAgICAgICAgICAgdmFyIHhPZmZzZXQgPVxuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLmRpdkNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICAgICAgY2VsbEJvdW5kcy54ID0gY2VsbEJvdW5kcy54IC0geE9mZnNldDtcbiAgICAgICAgICAgIGRpYWxvZy5vcGVuRnJvbShjZWxsQm91bmRzKTtcblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLm9uU2hvdykge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIub25TaG93KHNlbGYuY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZGlhbG9nLmdldEFuaW1hdGlvblRpbWUoKSArIDEwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsRWRpdG9yID0gcmVxdWlyZSgnLi9DZWxsRWRpdG9yLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTaW1wbGUgPSBDZWxsRWRpdG9yLmV4dGVuZCgnU2ltcGxlJywge1xuXG4gICAgLyoqXG4gICAgICogbXkgbWFpbiBpbnB1dCBjb250cm9sXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGlucHV0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNpbXBsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lZGl0b3JQb2ludCA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHNwZWNpYWxLZXl1cHM6IHtcbiAgICAgICAgLy8weDA4OiAnY2xlYXJTdG9wRWRpdGluZycsIC8vIGJhY2tzcGFjZVxuICAgICAgICAweDA5OiAnc3RvcEVkaXRpbmcnLCAvLyB0YWJcbiAgICAgICAgMHgwZDogJ3N0b3BFZGl0aW5nJywgLy8gcmV0dXJuL2VudGVyXG4gICAgICAgIDB4MWI6ICdjYW5jZWxFZGl0aW5nJyAvLyBlc2NhcGVcbiAgICB9LFxuXG4gICAga2V5dXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHZhciBzcGVjaWFsS2V5dXAgPSB0aGlzLnNwZWNpYWxLZXl1cHNbZS5rZXlDb2RlXTtcblxuICAgICAgICAgICAgaWYgKHNwZWNpYWxLZXl1cCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzW3NwZWNpYWxLZXl1cF0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC50YWtlRm9jdXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ncmlkLmZpcmVTeW50aGV0aWNFZGl0b3JLZXlVcEV2ZW50KHRoaXMsIGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTaW1wbGUucHJvdG90eXBlXG4gICAgICogQGRlc2MgIHRoZSBmdW5jdGlvbiB0byBvdmVycmlkZSBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICAgKi9cbiAgICBpbml0aWFsaXplSW5wdXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmtleXVwLmJpbmQodGhpcykpO1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgc2VsZi5ncmlkLmZpcmVTeW50aGV0aWNFZGl0b3JLZXlEb3duRXZlbnQoc2VsZiwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHNlbGYuZ3JpZC5maXJlU3ludGhldGljRWRpdG9yS2V5UHJlc3NFdmVudChzZWxmLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0Lm9uYmx1ciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHNlbGYuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgICBzZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgICBzZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIC8vIH0pO1xuXG4gICAgICAgIGlucHV0LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgaW5wdXQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgaW5wdXQuc3R5bGUuYm9yZGVyID0gJ3NvbGlkIDJweCBibGFjayc7XG4gICAgICAgIGlucHV0LnN0eWxlLm91dGxpbmUgPSAwO1xuICAgICAgICBpbnB1dC5zdHlsZS5wYWRkaW5nID0gMDtcbiAgICAgICAgaW5wdXQuc3R5bGUuYm94U2hhZG93ID0gJ3doaXRlIDBweCAwcHggMXB4IDFweCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTaW1wbGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlIGN1cnJlbnQgZWRpdG9yJ3MgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRFZGl0b3JWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0SW5wdXQoKS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNhdmUgdGhlIG5ldyB2YWx1ZSBpbnRvIHRoZSBiZWhhdmlvcihtb2RlbClcbiAgICAgKi9cbiAgICBzZXRFZGl0b3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRJbnB1dCgpLnZhbHVlID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGNsZWFyU3RvcEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldEVkaXRvclZhbHVlKCcnKTtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgIH0sXG5cbiAgICBjYW5jZWxFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0SW5wdXQoKS52YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZUVkaXRvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRpc3BsYXkgdGhlIGVkaXRvclxuICAgICAqL1xuICAgIHNob3dFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldElucHV0KCkuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhpZGUgdGhlIGVkaXRvclxuICAgICAqL1xuICAgIGhpZGVFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldElucHV0KCkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVxdWVzdCBmb2N1cyBmb3IgbXkgaW5wdXQgY29udHJvbC5cbiAgICAgKiBAZGVzYyBTZWUgR1JJRC05NSBcIlNjcm9sbGJhciBtb3ZlcyBpbndhcmRcIiBmb3IgaXNzdWUgYW5kIHdvcmstYXJvdW5kIGV4cGxhbmF0aW9uLlxuICAgICAqIEBtZW1iZXJPZiBTaW1wbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgdGFrZUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybVdhcyA9IHNlbGYuaW5wdXQuc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICAgICAgc2VsZi5pbnB1dC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsMCknOyAvLyB3b3JrLWFyb3VuZDogbW92ZSB0byB1cHBlciBsZWZ0XG5cbiAgICAgICAgICAgIHNlbGYuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgICAgIHNlbGYuaW5wdXQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtV2FzO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNpbXBsZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZWxlY3QgZXZlcnl0aGluZ1xuICAgICAqL1xuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNpbXBsZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBob3cgbXVjaCBzaG91bGQgSSBvZmZzZXQgbXkgYm91bmRzIGZyb20gMCwwXG4gICAgICovXG4gICAgb3JpZ2luT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNpbXBsZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIGJvdW5kcyBvZiBteSBpbnB1dCBjb250cm9sXG4gICAgICogQHBhcmFtIHtyZWN0YW5nbGV9IHJlY3RhbmdsZSAtIHRoZSBib3VuZHMgdG8gbW92ZSB0b1xuICAgICAqL1xuICAgIHNldEJvdW5kczogZnVuY3Rpb24oY2VsbEJvdW5kcykge1xuICAgICAgICB2YXIgb3JpZ2luT2Zmc2V0ID0gdGhpcy5vcmlnaW5PZmZzZXQoKTtcbiAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gJ3RyYW5zbGF0ZSgnXG4gICAgICAgICAgICArIChjZWxsQm91bmRzLnggLSAxICsgb3JpZ2luT2Zmc2V0WzBdKSArICdweCwnXG4gICAgICAgICAgICArIChjZWxsQm91bmRzLnkgLSAxICsgb3JpZ2luT2Zmc2V0WzFdKSArICdweCknO1xuXG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXQoKTtcblxuICAgICAgICBpbnB1dC5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG5cbiAgICAgICAgaW5wdXQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNsYXRpb247XG4gICAgICAgIGlucHV0LnN0eWxlLk1velRyYW5zZm9ybSA9IHRyYW5zbGF0aW9uO1xuICAgICAgICBpbnB1dC5zdHlsZS5tc1RyYW5zZm9ybSA9IHRyYW5zbGF0aW9uO1xuICAgICAgICBpbnB1dC5zdHlsZS5PVHJhbnNmb3JtID0gdHJhbnNsYXRpb247XG5cbiAgICAgICAgLy8gVE9ETzogT2J2aW91c2x5IHRoaXMgd2FzIGNoYW5nZWQgYXQgc29tZSBwb2ludCBmcm9tIGxlZnQsdG9wIHRvIHRybmFzZm9ybTp0cmFuc2xhdGlvbi4gV29uZGVyaW5nIHdoeSB0aGlzIHdhcyBuZWNlc3NhcnkuLi4/XG5cbiAgICAgICAgLy8gaW5wdXQuc3R5bGUubGVmdCA9IGNlbGxCb3VuZHMueCArIG9yaWdpbk9mZnNldFswXSArICdweCc7XG4gICAgICAgIC8vIGlucHV0LnN0eWxlLnRvcCA9IGNlbGxCb3VuZHMueSArIG9yaWdpbk9mZnNldFsxXSArICdweCc7XG5cbiAgICAgICAgaW5wdXQuc3R5bGUud2lkdGggPSAoY2VsbEJvdW5kcy53aWR0aCArIDIpICsgJ3B4JztcbiAgICAgICAgaW5wdXQuc3R5bGUuaGVpZ2h0ID0gKGNlbGxCb3VuZHMuaGVpZ2h0ICsgMikgKyAncHgnO1xuICAgICAgICAvL3ZhciB4T2Zmc2V0ID0gdGhpcy5ncmlkLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIH0sXG5cbiAgICBzYXZlRWRpdG9yVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmdldEVkaXRvclBvaW50KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0RWRpdG9yVmFsdWUoKS50cmltKCk7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlID09PSB0aGlzLmluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvL2RhdGEgZGlkbid0IGNoYW5nZSBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlRmxvYXQodGhpcy5pbml0aWFsVmFsdWUpID09PSB0aGlzLmluaXRpYWxWYWx1ZSkgeyAvLyBJJ20gYSBudW1iZXJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRpbnVlZCA9IHRoaXMuZ3JpZC5maXJlQmVmb3JlQ2VsbEVkaXQocG9pbnQsIHRoaXMuaW5pdGlhbFZhbHVlLCB2YWx1ZSwgdGhpcyk7XG4gICAgICAgIGlmICghY29udGludWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLnNldFZhbHVlKHBvaW50LngsIHBvaW50LnksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5ncmlkLmZpcmVBZnRlckNlbGxFZGl0KHBvaW50LCB0aGlzLmluaXRpYWxWYWx1ZSwgdmFsdWUsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBtb3ZlIHRoZSBlZGl0b3IgdG8gdGhlIGN1cnJlbnQgZWRpdG9yIHBvaW50XG4gICAgICovXG4gICAgX21vdmVFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWRpdG9yUG9pbnQgPSB0aGlzLmdldEVkaXRvclBvaW50KCk7XG4gICAgICAgIHZhciBjZWxsQm91bmRzID0gdGhpcy5ncmlkLl9nZXRCb3VuZHNPZkNlbGwoZWRpdG9yUG9pbnQueCwgZWRpdG9yUG9pbnQueSk7XG5cbiAgICAgICAgLy9oYWNrIHRvIGFjY29tbW9kYXRlIGJvb3RzdHJhcCBtYXJnaW4gaXNzdWVzLi4uXG4gICAgICAgIHZhciB4T2Zmc2V0ID1cbiAgICAgICAgICAgIHRoaXMuZ3JpZC5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG4gICAgICAgICAgICB0aGlzLmdyaWQuZGl2Q2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGNlbGxCb3VuZHMueCA9IGNlbGxCb3VuZHMueCAtIHhPZmZzZXQ7XG5cbiAgICAgICAgdGhpcy5zZXRCb3VuZHMoY2VsbEJvdW5kcyk7XG4gICAgfSxcblxuICAgIG1vdmVFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9tb3ZlRWRpdG9yKCk7XG4gICAgICAgIHRoaXMudGFrZUZvY3VzKCk7XG4gICAgfSxcblxuICAgIGJlZ2luRWRpdEF0OiBmdW5jdGlvbihwb2ludCkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0FkZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzQWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hFZGl0b3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RWRpdG9yUG9pbnQocG9pbnQpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdyaWQuYmVoYXZpb3IuZ2V0VmFsdWUocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzFdOyAvL2l0J3MgYSBuZXN0ZWQgb2JqZWN0XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2NlZWQgPSB0aGlzLmdyaWQuZmlyZVJlcXVlc3RDZWxsRWRpdChwb2ludCwgdmFsdWUpO1xuICAgICAgICBpZiAoIXByb2NlZWQpIHtcbiAgICAgICAgICAgIC8vd2Ugd2VyZSBjYW5jZWxsZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0Q2hlY2tFZGl0b3JQb3NpdGlvbkZsYWcoKTtcbiAgICAgICAgdGhpcy5jaGVja0VkaXRvcigpO1xuICAgIH0sXG5cbiAgICBjaGVja0VkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWRpdG9yUG9pbnQgPSB0aGlzLmdldEVkaXRvclBvaW50KCk7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuaXNEYXRhVmlzaWJsZShlZGl0b3JQb2ludC54LCBlZGl0b3JQb2ludC55KSkge1xuICAgICAgICAgICAgdGhpcy5wcmVTaG93RWRpdG9yTm90aWZpY2F0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaEVkaXRvcigpO1xuICAgICAgICAgICAgdGhpcy5tb3ZlRWRpdG9yKCk7XG4gICAgICAgICAgICB0aGlzLnNob3dFZGl0b3IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUVkaXRvcigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGF0dGFjaEVkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXQoKSxcbiAgICAgICAgICAgIGRpdiA9IHRoaXMuZ3JpZC5kaXYsXG4gICAgICAgICAgICByZWZlcmVuY2VOb2RlID0gZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJy5maW5iYXItaG9yaXpvbnRhbCwgLmZpbmJhci12ZXJ0aWNhbCcpO1xuXG4gICAgICAgIGRpdi5pbnNlcnRCZWZvcmUoaW5wdXQsIHJlZmVyZW5jZU5vZGUubGVuZ3RoID8gcmVmZXJlbmNlTm9kZVswXSA6IG51bGwpO1xuICAgIH0sXG5cbiAgICBwcmVTaG93RWRpdG9yTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRFZGl0b3JWYWx1ZSh0aGlzLmluaXRpYWxWYWx1ZSk7XG4gICAgfSxcblxuICAgIGdldElucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5nZXREZWZhdWx0SW5wdXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dDtcbiAgICB9LFxuXG4gICAgZ2V0RGVmYXVsdElucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGhpcy5nZXRIVE1MKCk7XG4gICAgICAgIHZhciBpbnB1dCA9IGRpdi5maXJzdENoaWxkO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVJbnB1dChpbnB1dCk7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9LFxuXG4gICAgdXBkYXRlVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvbGRHdXkgPSB0aGlzLmdldElucHV0KCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBvbGRHdXkucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIG5ld0d1eSA9IHRoaXMuZ2V0RGVmYXVsdElucHV0KCk7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBuZXdHdXk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobmV3R3V5LCBvbGRHdXkpO1xuICAgIH0sXG5cbiAgICBzaG93RHJvcGRvd246IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50O1xuICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgICAgICBldmVudC5pbml0TW91c2VFdmVudCgnbW91c2Vkb3duJywgdHJ1ZSwgdHJ1ZSwgd2luZG93KTtcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTaW1wbGUgPSByZXF1aXJlKCcuL1NpbXBsZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU2xpZGVyID0gU2ltcGxlLmV4dGVuZCgnU2xpZGVyJywge1xuXG4gICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKlxuICAgICAgICAgICAgPGlucHV0IGlkPVwiZWRpdG9yXCIgdHlwZT1cInJhbmdlXCI+XG4gICAgICAgICovXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbGlkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTaW1wbGUgPSByZXF1aXJlKCcuL1NpbXBsZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU3Bpbm5lciA9IFNpbXBsZS5leHRlbmQoJ1NwaW5uZXInLCB7XG5cbiAgICB0ZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XCJlZGl0b3JcIiB0eXBlPVwibnVtYmVyXCI+XG4gICAgICAgICovXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGlubmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2ltcGxlID0gcmVxdWlyZSgnLi9TaW1wbGUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFRleHRmaWVsZCA9IFNpbXBsZS5leHRlbmQoJ1RleHRmaWVsZCcsIHtcblxuICAgIHRlbXBsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cImVkaXRvclwiPlxuICAgICAgICAqL1xuICAgIH0sXG5cbiAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKDAsIHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgc3BlY2lhbEtleXVwczoge1xuICAgICAgICAweDA5OiAnc3RvcEVkaXRpbmcnLCAvLyB0YWJcbiAgICAgICAgMHgwZDogJ3N0b3BFZGl0aW5nJywgLy8gcmV0dXJuL2VudGVyXG4gICAgICAgIDB4MWI6ICdjYW5jZWxFZGl0aW5nJyAvLyBlc2NhcGVcbiAgICB9LFxuXG4gICAga2V5dXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIFNpbXBsZS5wcm90b3R5cGUua2V5dXAuY2FsbCh0aGlzLCBlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZC5pc0ZpbHRlclJvdyh0aGlzLmdldEVkaXRvclBvaW50KCkueSkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGtleXVwLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGtleXVwKCkge1xuICAgIHRoaXMuc2F2ZUVkaXRvclZhbHVlKCk7XG4gICAgdGhpcy5fbW92ZUVkaXRvcigpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRmaWVsZDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ2VsbEVkaXRvcjogcmVxdWlyZSgnLi9DZWxsRWRpdG9yJyksIC8vIGFic3RyYWN0IGJhc2UgY2xhc3NcbiAgICBUZXh0ZmllbGQ6IHJlcXVpcmUoJy4vVGV4dGZpZWxkJyksXG4gICAgQ2hvaWNlOiByZXF1aXJlKCcuL0Nob2ljZScpLFxuICAgIC8vQ29tYm86IHJlcXVpcmUoJy4vQ29tYm8nKSxcbiAgICBDb2xvcjogcmVxdWlyZSgnLi9Db2xvcicpLFxuICAgIERhdGU6IHJlcXVpcmUoJy4vRGF0ZScpLFxuICAgIFNpbXBsZTogcmVxdWlyZSgnLi9TaW1wbGUnKSxcbiAgICBTbGlkZXI6IHJlcXVpcmUoJy4vU2xpZGVyJyksXG4gICAgU3Bpbm5lcjogcmVxdWlyZSgnLi9TcGlubmVyJyksXG4gICAgRmlsdGVyOiByZXF1aXJlKCcuL0ZpbHRlcicpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL2xpYi9CYXNlJyk7XG5cbnZhciBBID0gJ0EnLmNoYXJDb2RlQXQoMCk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhTW9kZWwgPSBCYXNlLmV4dGVuZCgnRGF0YU1vZGVsJywge1xuXG4gICAgbmV4dDogbnVsbCxcblxuICAgIGdyaWQ6IG51bGwsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuc2V0R3JpZChncmlkKTtcbiAgICB9LFxuXG4gICAgc2V0R3JpZDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgIH0sXG5cbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIGAuZ3JpZGAgcHJvcGVydHkgaW5zdGVhZC4gKi9cbiAgICBnZXRHcmlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ3JpZCcsIHsgc2luY2U6ICcwLjInIH0pO1xuICAgIH0sXG5cbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIGAuZ3JpZC5iZWhhdmlvcmAgcHJvcGVydHkgaW5zdGVhZC4gKi9cbiAgICBnZXRCZWhhdmlvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dyaWQuYmVoYXZpb3InLCB7IHNpbmNlOiAnMC4yJyB9KTtcbiAgICB9LFxuXG4gICAgY2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ3JpZC5iZWhhdmlvci5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIGdldFByaXZhdGVTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgfSxcblxuICAgIGFwcGx5U3RhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgfSxcblxuICAgIGFscGhhRm9yOiBmdW5jdGlvbihpKSB7XG4gICAgICAgIC8vIE5hbWUgdGhlIGNvbHVtbiBoZWFkZXJzIGluIEEsIC4uLCBBQSwgQUIsIEFDLCAuLiwgQVogZm9ybWF0XG4gICAgICAgIC8vIHF1b3RpZW50L3JlbWFpbmRlclxuICAgICAgICAvL3ZhciBxdW8gPSBNYXRoLmZsb29yKGNvbC8yNyk7XG4gICAgICAgIHZhciBxdW8gPSBNYXRoLmZsb29yKGkgLyAyNik7XG4gICAgICAgIHZhciByZW0gPSBpICUgMjY7XG4gICAgICAgIHZhciBjb2RlID0gJyc7XG4gICAgICAgIGlmIChxdW8gPiAwKSB7XG4gICAgICAgICAgICBjb2RlICs9IHRoaXMuYWxwaGEocXVvIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZSArPSB0aGlzLmFscGhhKHJlbSk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH0sXG5cbiAgICBhbHBoYTogZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBICsgaSk7XG4gICAgfSxcblxuICAgIGdldENlbGxFZGl0b3JBdDogZnVuY3Rpb24oeCwgeSkge1xuICAgIH0sXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFNb2RlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy92YXIgYW5hbHl0aWNzID0gcmVxdWlyZSgnaHlwZXItYW5hbHl0aWNzJyk7XG52YXIgYW5hbHl0aWNzID0gcmVxdWlyZSgnLi4vbG9jYWxfbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcycpO1xuLy92YXIgYW5hbHl0aWNzID0gcmVxdWlyZSgnLi4vbG9jYWxfbm9kZV9tb2R1bGVzL2ZpbmFuYWx5dGljcycpO1xudmFyIERhdGFNb2RlbCA9IHJlcXVpcmUoJy4vRGF0YU1vZGVsJyk7XG52YXIgaW1hZ2VzID0gcmVxdWlyZSgnLi4vLi4vaW1hZ2VzJyk7XG52YXIgQ3VzdG9tRmlsdGVyID0gcmVxdWlyZSgnLi4vbGliL0N1c3RvbUZpbHRlcicpO1xuXG52YXIgVVBXQVJEU19CTEFDS19BUlJPVyA9ICdcXHUyNWIyJywgLy8gYWthICfilrInXG4gICAgRE9XTldBUkRTX0JMQUNLX0FSUk9XID0gJ1xcdTI1YmMnOyAvLyBha2EgJ+KWvCdcblxudmFyIG51bGxEYXRhU291cmNlID0ge1xuICAgIGlzTnVsbE9iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgZ2V0QWdncmVnYXRlVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgaGFzQWdncmVnYXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGhhc0dyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGdldFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQG5hbWUgZGF0YU1vZGVscy5KU09OXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEpTT04gPSBEYXRhTW9kZWwuZXh0ZW5kKCdkYXRhTW9kZWxzLkpTT04nLCB7XG5cbiAgICAvL251bGwgb2JqZWN0IHBhdHRlcm4gZm9yIHRoZSBzb3VyY2Ugb2JqZWN0XG4gICAgc291cmNlOiBudWxsRGF0YVNvdXJjZSxcblxuICAgIHByZWdsb2JhbGZpbHRlcjogbnVsbERhdGFTb3VyY2UsXG5cbiAgICBwcmVzb3J0ZXI6IG51bGxEYXRhU291cmNlLFxuICAgIGFuYWx5dGljczogbnVsbERhdGFTb3VyY2UsXG4gICAgcG9zdGdsb2JhbGZpbHRlcjogbnVsbERhdGFTb3VyY2UsXG4gICAgcG9zdHNvcnRlcjogbnVsbERhdGFTb3VyY2UsXG5cbiAgICB0b3BUb3RhbHM6IFtdLFxuICAgIGJvdHRvbVRvdGFsczogW10sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGEgPSBbXTtcbiAgICB9LFxuXG4gICAgY2xlYXJTZWxlY3RlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0YS5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0FnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmFseXRpY3MuaGFzQWdncmVnYXRlcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0dyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuYWx5dGljcy5oYXNHcm91cHMoKTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YVNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc3Rzb3J0ZXI7IC8vdGhpcy5oYXNBZ2dyZWdhdGVzKCkgPyB0aGlzLmFuYWx5dGljcyA6IHRoaXMucHJlc29ydGVyO1xuICAgIH0sXG5cbiAgICBnZXRHbG9iYWxGaWx0ZXJEYXRhU291cmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdGdsb2JhbGZpbHRlcjsgLy90aGlzLmhhc0FnZ3JlZ2F0ZXMoKSA/IHRoaXMucG9zdGZpbHRlciA6IHRoaXMucHJlZmlsdGVyO1xuICAgIH0sXG5cbiAgICBnZXRTb3J0RGF0YVNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc3Rzb3J0ZXI7IC8vdGhpcy5oYXNBZ2dyZWdhdGVzKCkgPyB0aGlzLnBvc3Rzb3J0ZXIgOiB0aGlzLnByZXNvcnRlcjtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5kYXRhO1xuICAgIH0sXG5cbiAgICBnZXRGaWx0ZXJlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZHMgPSB0aGlzLmdldERhdGFTb3VyY2UoKTtcbiAgICAgICAgdmFyIGNvdW50ID0gZHMuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY291bnQ7IHkrKykge1xuICAgICAgICAgICAgcmVzdWx0W3ldID0gZHMuZ2V0Um93KHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBoYXNIaWVyYXJjaHlDb2x1bW4gPSB0aGlzLmhhc0hpZXJhcmNoeUNvbHVtbigpO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAoaGFzSGllcmFyY2h5Q29sdW1uKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSkge1xuICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5IDwgaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRIZWFkZXJSb3dWYWx1ZSh4LCB5KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAoaGFzSGllcmFyY2h5Q29sdW1uKSB7XG4gICAgICAgIC8vICAgICB5ICs9IDE7XG4gICAgICAgIC8vIH1cbiAgICAgICAgdmFsdWUgPSB0aGlzLmdldERhdGFTb3VyY2UoKS5nZXRWYWx1ZSh4LCB5IC0gaGVhZGVyUm93Q291bnQpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIG5lZ2F0aXZlIHZhbHVlcyByZWZlciB0byBfYm90dG9tIHRvdGFsc18gcm93c1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldEhlYWRlclJvd1ZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEhlYWRlcnMoKVtNYXRoLm1heCh4LCAwKV07XG4gICAgICAgIH0gZWxzZSBpZiAoeSA8IDApIHsgLy8gYm90dG9tIHRvdGFscyByb3dzXG4gICAgICAgICAgICB2YXIgYm90dG9tVG90YWxzID0gdGhpcy5nZXRCb3R0b21Ub3RhbHMoKTtcbiAgICAgICAgICAgIHZhbHVlID0gYm90dG9tVG90YWxzW2JvdHRvbVRvdGFscy5sZW5ndGggKyB5XVt4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpc0ZpbHRlclJvdyA9IHRoaXMuZ3JpZC5pc1Nob3dGaWx0ZXJSb3coKSxcbiAgICAgICAgICAgICAgICBpc0hlYWRlclJvdyA9IHRoaXMuZ3JpZC5pc1Nob3dIZWFkZXJSb3coKSxcbiAgICAgICAgICAgICAgICB0b3BUb3RhbHNPZmZzZXQgPSAoaXNGaWx0ZXJSb3cgPyAxIDogMCkgKyAoaXNIZWFkZXJSb3cgPyAxIDogMCk7XG4gICAgICAgICAgICBpZiAoeSA+PSB0b3BUb3RhbHNPZmZzZXQpIHsgLy8gdG9wIHRvdGFscyByb3dzXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldFRvcFRvdGFscygpW3kgLSB0b3BUb3RhbHNPZmZzZXRdW3hdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0hlYWRlclJvdyAmJiB5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEhlYWRlcnMoKVt4XTtcbiAgICAgICAgICAgICAgICB2YXIgc29ydFN0cmluZyA9IHRoaXMuZ2V0U29ydEltYWdlRm9yQ29sdW1uKHgpO1xuICAgICAgICAgICAgICAgIGlmIChzb3J0U3RyaW5nKSB7IHZhbHVlID0gc29ydFN0cmluZyArIHZhbHVlOyB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBtdXN0IGJlIGZpbHRlciByb3dcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5nZXRHbG9iYWxGaWx0ZXIoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpbHRlciA/IGZpbHRlci5nZXRDb2x1bW5GaWx0ZXJTdGF0ZSh0aGlzLmdldEZpZWxkcygpW3hdKSA6ICcnO1xuICAgICAgICAgICAgICAgIHZhciBpY29uID0gaW1hZ2VzLmZpbHRlcih2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbbnVsbCwgdmFsdWUsIGljb25dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHZhciBoYXNIaWVyYXJjaHlDb2x1bW4gPSB0aGlzLmhhc0hpZXJhcmNoeUNvbHVtbigpO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgaWYgKGhhc0hpZXJhcmNoeUNvbHVtbikge1xuICAgICAgICAgICAgaWYgKHggPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNBZ2dyZWdhdGVzKCkpIHtcbiAgICAgICAgICAgIHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA8IGhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldEhlYWRlclJvd1ZhbHVlKHgsIHksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RGF0YVNvdXJjZSgpLnNldFZhbHVlKHgsIHkgLSBoZWFkZXJSb3dDb3VudCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXRIZWFkZXJSb3dWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRIZWFkZXIoeCwgeSk7IC8vIHkgaXMgcmVhbGx5IHRoZSB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIHZhciBpc0ZpbHRlclJvdyA9IHRoaXMuZ3JpZC5pc1Nob3dGaWx0ZXJSb3coKTtcbiAgICAgICAgdmFyIGlzSGVhZGVyUm93ID0gdGhpcy5ncmlkLmlzU2hvd0hlYWRlclJvdygpO1xuICAgICAgICB2YXIgaXNCb3RoID0gaXNGaWx0ZXJSb3cgJiYgaXNIZWFkZXJSb3c7XG4gICAgICAgIHZhciB0b3BUb3RhbHNPZmZzZXQgPSAoaXNGaWx0ZXJSb3cgPyAxIDogMCkgKyAoaXNIZWFkZXJSb3cgPyAxIDogMCk7XG4gICAgICAgIGlmICh5ID49IHRvcFRvdGFsc09mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5nZXRUb3BUb3RhbHMoKVt5IC0gdG9wVG90YWxzT2Zmc2V0XVt4XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGNhbid0IGNoYW5nZSB0aGUgcm93IG51bWJlcnNcbiAgICAgICAgfSBlbHNlIGlmIChpc0JvdGgpIHtcbiAgICAgICAgICAgIGlmICh5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldEhlYWRlcih4LCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmlsdGVyKHgsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0ZpbHRlclJvdykge1xuICAgICAgICAgICAgdGhpcy5zZXRGaWx0ZXIoeCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldEhlYWRlcih4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKHgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmdldEdsb2JhbEZpbHRlcigpLFxuICAgICAgICAgICAgY29sdW1uTmFtZSA9IHRoaXMuZ2V0RmllbGRzKClbeF07XG5cbiAgICAgICAgZmlsdGVyLnNldENvbHVtbkZpbHRlclN0YXRlKGNvbHVtbk5hbWUsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbEluZGV4KSB7XG4gICAgICAgIC8vYWNjZXNzIGRpcmVjdGx5IGJlY2F1c2Ugd2Ugd2FudCBpdCBvcmRlcmVkXG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdyaWQuYmVoYXZpb3IuYWxsQ29sdW1uc1tjb2xJbmRleF07XG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4uZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaG93VHJlZSA9IHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Nob3dUcmVlQ29sdW1uJykgPT09IHRydWU7XG4gICAgICAgIHZhciBoYXNBZ2dyZWdhdGVzID0gdGhpcy5oYXNBZ2dyZWdhdGVzKCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSAoaGFzQWdncmVnYXRlcyAmJiAhc2hvd1RyZWUpID8gLTEgOiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5hbmFseXRpY3MuZ2V0Q29sdW1uQ291bnQoKSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXREYXRhU291cmNlKCkuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgY291bnQgKz0gdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuYWx5dGljcy5nZXRIZWFkZXJzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVyc1xuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5nZXREYXRhU291cmNlKCkuc2V0SGVhZGVycyhoZWFkZXJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZHNcbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICB0aGlzLmdldERhdGFTb3VyY2UoKS5zZXRGaWVsZHMoZmllbGRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YVNvdXJjZSgpLmdldEZpZWxkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGRhdGFSb3dzXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oZGF0YVJvd3MpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBuZXcgYW5hbHl0aWNzLkpTRGF0YVNvdXJjZShkYXRhUm93cyk7XG4gICAgICAgIC8vdGhpcy5wcmVnbG9iYWxmaWx0ZXIgPSBuZXcgYW5hbHl0aWNzLkRhdGFTb3VyY2VHbG9iYWxGaWx0ZXIodGhpcy5zb3VyY2UpO1xuICAgICAgICAvL3RoaXMucHJlc29ydGVyID0gbmV3IGFuYWx5dGljcy5EYXRhU291cmNlU29ydGVyQ29tcG9zaXRlKHRoaXMucHJlZmlsdGVyKTtcblxuICAgICAgICB0aGlzLmFuYWx5dGljcyA9IG5ldyBhbmFseXRpY3MuRGF0YVNvdXJjZUFnZ3JlZ2F0b3IodGhpcy5zb3VyY2UpO1xuXG4gICAgICAgIHRoaXMucG9zdGdsb2JhbGZpbHRlciA9IG5ldyBhbmFseXRpY3MuRGF0YVNvdXJjZUdsb2JhbEZpbHRlcih0aGlzLmFuYWx5dGljcyk7XG4gICAgICAgIHRoaXMucG9zdHNvcnRlciA9IG5ldyBhbmFseXRpY3MuRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSh0aGlzLnBvc3RnbG9iYWxmaWx0ZXIpO1xuXG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSB0b3RhbFJvd3NcbiAgICAgKi9cbiAgICBzZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKHRvdGFsUm93cykge1xuICAgICAgICB0aGlzLnRvcFRvdGFscyA9IHRvdGFsUm93cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fVxuICAgICAqL1xuICAgIGdldFRvcFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSA/IHRoaXMuZ2V0RGF0YVNvdXJjZSgpLmdldEdyYW5kVG90YWxzKCkgOiB0aGlzLnRvcFRvdGFscztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gdG90YWxSb3dzXG4gICAgICovXG4gICAgc2V0Qm90dG9tVG90YWxzOiBmdW5jdGlvbih0b3RhbFJvd3MpIHtcbiAgICAgICAgdGhpcy5ib3R0b21Ub3RhbHMgPSB0b3RhbFJvd3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn1cbiAgICAgKi9cbiAgICBnZXRCb3R0b21Ub3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNBZ2dyZWdhdGVzKCkgPyB0aGlzLmdldERhdGFTb3VyY2UoKS5nZXRHcmFuZFRvdGFscygpIDogdGhpcy5ib3R0b21Ub3RhbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGdyb3Vwc1xuICAgICAqL1xuICAgIHNldEdyb3VwczogZnVuY3Rpb24oZ3JvdXBzKSB7XG4gICAgICAgIHRoaXMuYW5hbHl0aWNzLnNldEdyb3VwQnlzKGdyb3Vwcyk7XG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcbiAgICAgICAgdGhpcy5ncmlkLmZpcmVTeW50aGV0aWNHcm91cHNDaGFuZ2VkRXZlbnQodGhpcy5nZXRHcm91cHMoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5nZXRIZWFkZXJzKCkuc2xpY2UoMCk7XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpLnNsaWNlKDApO1xuICAgICAgICB2YXIgZ3JvdXBCeXMgPSB0aGlzLmFuYWx5dGljcy5ncm91cEJ5cztcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQnlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBoZWFkZXJzW2dyb3VwQnlzW2ldXTtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogZ3JvdXBCeXNbaV0sXG4gICAgICAgICAgICAgICAgbGFiZWw6IGZpZWxkLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEF2YWlsYWJsZUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5zb3VyY2UuZ2V0SGVhZGVycygpLnNsaWNlKDApO1xuICAgICAgICB2YXIgZ3JvdXBCeXMgPSB0aGlzLmFuYWx5dGljcy5ncm91cEJ5cztcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChncm91cEJ5cy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGhlYWRlcnNbaV07XG4gICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZ3JpZC5iZWhhdmlvci5jb2x1bW5zO1xuICAgICAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcihmdW5jdGlvbihlYWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZWFjaC5sYWJlbCAhPT0gJ1RyZWUnO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRIaWRkZW5Db2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZpc2libGUgPSB0aGlzLmdyaWQuYmVoYXZpb3IuY29sdW1ucztcbiAgICAgICAgdmFyIGFsbCA9IHRoaXMuZ3JpZC5iZWhhdmlvci5hbGxDb2x1bW5zO1xuICAgICAgICB2YXIgaGlkZGVuID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmlzaWJsZS5pbmRleE9mKGFsbFtpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuLnB1c2goYWxsW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoaWRkZW4uc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5sYWJlbCA8IGIubGFiZWw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGlkZGVuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBhZ2dyZWdhdGlvbnNcbiAgICAgKi9cbiAgICBzZXRBZ2dyZWdhdGVzOiBmdW5jdGlvbihhZ2dyZWdhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5xdWlldGx5U2V0QWdncmVnYXRlcyhhZ2dyZWdhdGlvbnMpO1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0aW9uc1xuICAgICAqL1xuICAgIHF1aWV0bHlTZXRBZ2dyZWdhdGVzOiBmdW5jdGlvbihhZ2dyZWdhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hbmFseXRpY3Muc2V0QWdncmVnYXRlcyhhZ2dyZWdhdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaG93VHJlZSA9IHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Nob3dUcmVlQ29sdW1uJykgPT09IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSAmJiB0aGlzLmhhc0dyb3VwcygpICYmIHNob3dUcmVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5QW5hbHl0aWNzOiBmdW5jdGlvbihkb250QXBwbHlHcm91cEJ5c0FuZEFnZ3JlZ2F0aW9ucykge1xuICAgICAgICBzZWxlY3RlZERhdGFSb3dzQmFja2luZ1NlbGVjdGVkR3JpZFJvd3MuY2FsbCh0aGlzKTtcblxuICAgICAgICBpZiAoIWRvbnRBcHBseUdyb3VwQnlzQW5kQWdncmVnYXRpb25zKSB7XG4gICAgICAgICAgICBhcHBseUdyb3VwQnlzQW5kQWdncmVnYXRpb25zLmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBseUZpbHRlcnMuY2FsbCh0aGlzKTtcblxuICAgICAgICBhcHBseVNvcnRzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgcmVzZWxlY3RHcmlkUm93c0JhY2tlZEJ5U2VsZWN0ZWREYXRhUm93cy5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleFxuICAgICAqIEBwYXJhbSBrZXlzXG4gICAgICovXG4gICAgdG9nZ2xlU29ydDogZnVuY3Rpb24oY29sSW5kZXgsIGtleXMpIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRTb3J0U3RhdGUoY29sSW5kZXgsIGtleXMpO1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5c1xuICAgICAqL1xuICAgIGluY3JlbWVudFNvcnRTdGF0ZTogZnVuY3Rpb24oY29sSW5kZXgsIGtleXMpIHtcbiAgICAgICAgY29sSW5kZXgrKzsgLy9oYWNrIHRvIGdldCBhcm91bmQgMCBpbmRleFxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpID4gLTE7XG4gICAgICAgIHN0YXRlLnNvcnRzID0gc3RhdGUuc29ydHMgfHwgW107XG4gICAgICAgIHZhciBhbHJlYWR5ID0gc3RhdGUuc29ydHMuaW5kZXhPZihjb2xJbmRleCk7XG4gICAgICAgIGlmIChhbHJlYWR5ID09PSAtMSkge1xuICAgICAgICAgICAgYWxyZWFkeSA9IHN0YXRlLnNvcnRzLmluZGV4T2YoLTEgKiBjb2xJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFscmVhZHkgPiAtMSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNvcnRzW2FscmVhZHldID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnNvcnRzW2FscmVhZHldID0gLTEgKiBzdGF0ZS5zb3J0c1thbHJlYWR5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuc29ydHMuc3BsaWNlKGFscmVhZHksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhhc0NUUkwgfHwgc3RhdGUuc29ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5zb3J0cy51bnNoaWZ0KGNvbEluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLnNvcnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBzdGF0ZS5zb3J0cy51bnNoaWZ0KGNvbEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuc29ydHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgc3RhdGUuc29ydHMubGVuZ3RoID0gMztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqIEBwYXJhbSByZXR1cm5Bc1N0cmluZ1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFNvcnRJbWFnZUZvckNvbHVtbjogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgdmFyIHVwID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNvcnRzID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKS5zb3J0cztcbiAgICAgICAgaWYgKCFzb3J0cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gc29ydHMuaW5kZXhPZihpbmRleCk7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gc29ydHMuaW5kZXhPZigtMSAqIGluZGV4KTtcbiAgICAgICAgICAgIHVwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmsgPSBzb3J0cy5sZW5ndGggLSBwb3NpdGlvbjtcbiAgICAgICAgdmFyIGFycm93ID0gdXAgPyBVUFdBUkRTX0JMQUNLX0FSUk9XIDogRE9XTldBUkRTX0JMQUNLX0FSUk9XO1xuICAgICAgICByZXR1cm4gcmFuayArIGFycm93ICsgJyAnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBjZWxsXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgY2VsbENsaWNrZWQ6IGZ1bmN0aW9uKGNlbGwsIGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNBZ2dyZWdhdGVzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuZ3JpZENlbGwueCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyB0aGlzIHdhc24ndCBhIGNsaWNrIG9uIHRoZSBoaWVyYXJjaHkgY29sdW1uXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciB5ID0gZXZlbnQuZ3JpZENlbGwueSAtIGhlYWRlclJvd0NvdW50O1xuICAgICAgICB0aGlzLmdldERhdGFTb3VyY2UoKS5jbGljayh5KTtcbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcyh0cnVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgaWYgKHkgPCBoZWFkZXJSb3dDb3VudCAmJiAhdGhpcy5oYXNBZ2dyZWdhdGVzKCkpIHtcbiAgICAgICAgICAgIHZhciB0b3BUb3RhbHMgPSB0aGlzLmdldFRvcFRvdGFscygpO1xuICAgICAgICAgICAgcmV0dXJuIHRvcFRvdGFsc1t5IC0gKGhlYWRlclJvd0NvdW50IC0gdG9wVG90YWxzLmxlbmd0aCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFTb3VyY2UoKS5nZXRSb3coeSAtIGhlYWRlclJvd0NvdW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgYnVpbGRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIGNvbENvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgZmllbGRzID0gW10uY29uY2F0KHRoaXMuZ2V0RmllbGRzKCkpO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmICh0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnRyZWUgPSB0aGlzLmdldFZhbHVlKC0yLCB5KTtcbiAgICAgICAgICAgIGZpZWxkcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ZpZWxkc1tpXV0gPSB0aGlzLmdldFZhbHVlKGksIHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldENvbXB1dGVkUm93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciByY2YgPSB0aGlzLmdldFJvd0NvbnRleHRGdW5jdGlvbihbeV0pO1xuICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5nZXRGaWVsZHMoKTtcbiAgICAgICAgdmFyIHJvdyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgcm93W2ZpZWxkXSA9IHJjZihmaWVsZClbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGROYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZUJ5RmllbGQ6IGZ1bmN0aW9uKGZpZWxkTmFtZSwgeSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEZpZWxkcygpLmluZGV4T2YoZmllbGROYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQWdncmVnYXRlcygpKSB7XG4gICAgICAgICAgICB5ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YVNvdXJjZSgpLmdldFZhbHVlKGluZGV4LCB5KTtcbiAgICB9LFxuXG4gICAgZ2V0R2xvYmFsRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsRmlsdGVyRGF0YVNvdXJjZSgpLmdldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZXxGaWx0ZXJUcmVlT3B0aW9uc09iamVjdH0gW2ZpbHRlck9yT3B0aW9uc10gLSBPbmUgb2Y6XG4gICAgICogKiBgRmlsdGVyVHJlZWAgLSBhbiBleGlzdGluZyBmaWx0ZXItdHJlZVxuICAgICAqICogYEZpbHRlclRyZWVPcHRpb25zT2JqZWN0YCAtIGFuIG9wdGlvbnMgb2JqZWN0IGZvciB0aGUgY3JlYXRpb24gb2YgYSBuZXcgZmlsdGVyLXRyZWVcbiAgICAgKiAqIGZhbHN5IChvbWl0dGVkKSAtIFR1cm5zIG9mZiBmaWx0ZXJpbmcuXG4gICAgICovXG4gICAgc2V0R2xvYmFsRmlsdGVyOiBmdW5jdGlvbihmaWx0ZXJPck9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRhdGFTb3VyY2UgPSB0aGlzLmdldEdsb2JhbEZpbHRlckRhdGFTb3VyY2UoKTtcblxuICAgICAgICBpZiAoIWZpbHRlck9yT3B0aW9ucykge1xuICAgICAgICAgICAgZGF0YVNvdXJjZS5jbGVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZpbHRlcjtcblxuICAgICAgICAgICAgaWYgKGZpbHRlck9yT3B0aW9ucyBpbnN0YW5jZW9mIEN1c3RvbUZpbHRlcikge1xuICAgICAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlck9yT3B0aW9ucztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyID0gbmV3IEN1c3RvbUZpbHRlcihmaWx0ZXJPck9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgKGp1c3QgZm9yIHRlc3RpbmcpOlxuICAgICAgICAgICAgICAgIGlmIChmYWxzZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuY2hpbGRyZW5bMV0uYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogJ3RvdGFsX251bWJlcl9vZl9wZXRzX293bmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJz0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpdGVyYWw6ICczJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29sdW1uRmlsdGVyJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaWx0ZXIuaW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhU291cmNlLnNldChmaWx0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVudHJhbnNsYXRlZFhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdW50cmFuc2xhdGVkWVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0Q2VsbFJlbmRlcmVyOiBmdW5jdGlvbihjb25maWcsIHgsIHksIHVudHJhbnNsYXRlZFgsIHVudHJhbnNsYXRlZFkpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyO1xuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0aGlzLmdyaWQuZ2V0Q2VsbFByb3ZpZGVyKCk7XG5cbiAgICAgICAgY29uZmlnLnggPSB4O1xuICAgICAgICBjb25maWcueSA9IHk7XG4gICAgICAgIGNvbmZpZy51bnRyYW5zbGF0ZWRYID0gdW50cmFuc2xhdGVkWDtcbiAgICAgICAgY29uZmlnLnVudHJhbnNsYXRlZFkgPSB1bnRyYW5zbGF0ZWRZO1xuXG4gICAgICAgIHJlbmRlcmVyID0gcHJvdmlkZXIuZ2V0Q2VsbChjb25maWcpO1xuICAgICAgICByZW5kZXJlci5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldERhdGEoW10pO1xuICAgIH0sXG5cbiAgICBnZXRVbmZpbHRlcmVkVmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmdldFZhbHVlKHgsIHkpO1xuICAgIH0sXG5cbiAgICBnZXRVbmZpbHRlcmVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZ2V0Um93Q291bnQoKTtcbiAgICB9LFxuXG59KTtcblxuLy8gTE9DQUwgTUVUSE9EUyAtLSB0byBiZSBjYWxsZWQgd2l0aCBgLmNhbGwodGhpc2BcblxuLyoqXG4gKiBBY2N1bXVsYXRlIGFjdHVhbCBkYXRhIHJvdyBvYmplY3RzIGJhY2tpbmcgY3VycmVudCBncmlkIHJvdyBzZWxlY3Rpb25zLlxuICogVGhpcyBjYWxsIHNob3VsZCBiZSBwYWlyZWQgd2l0aCBhIHN1YnNlcXVlbnQgY2FsbCB0byBgcmVzZWxlY3RHcmlkUm93c0JhY2tlZEJ5U2VsZWN0ZWREYXRhUm93c2AuXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gc2VsZWN0ZWREYXRhUm93c0JhY2tpbmdTZWxlY3RlZEdyaWRSb3dzKCkge1xuICAgIHZhciBzZWxlY3RlZERhdGEgPSB0aGlzLnNlbGVjdGVkRGF0YSxcbiAgICAgICAgaGFzUm93U2VsZWN0aW9ucyA9IHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5oYXNSb3dTZWxlY3Rpb25zKCksXG4gICAgICAgIG5lZWRGaWx0ZXJlZERhdGFMaXN0ID0gc2VsZWN0ZWREYXRhLmxlbmd0aCB8fCBoYXNSb3dTZWxlY3Rpb25zO1xuXG4gICAgaWYgKG5lZWRGaWx0ZXJlZERhdGFMaXN0KSB7XG4gICAgICAgIHZhciBmaWx0ZXJlZERhdGEgPSB0aGlzLmdldEZpbHRlcmVkRGF0YSgpO1xuICAgIH1cblxuICAgIC8vIFNURVAgMTogUmVtb3ZlIGFueSBmaWx0ZXJlZCBkYXRhIHJvd3MgZnJvbSB0aGUgcmVjZW50bHkgc2VsZWN0ZWQgbGlzdC5cbiAgICBzZWxlY3RlZERhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhUm93LCBpbmRleCkge1xuICAgICAgICBpZiAoZmlsdGVyZWREYXRhLmluZGV4T2YoZGF0YVJvdykgPj0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGVkRGF0YVtpbmRleF07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNURVAgMjogQWNjdW11bGF0ZSB0aGUgZGF0YSByb3dzIGJhY2tpbmcgYW55IGN1cnJlbnRseSBzZWxlY3RlZCBncmlkIHJvd3MgaW4gYHRoaXMuc2VsZWN0ZWREYXRhYC5cbiAgICBpZiAoaGFzUm93U2VsZWN0aW9ucykgeyAvLyBhbnkgY3VycmVudCBncmlkIHJvdyBzZWxlY3Rpb25zP1xuICAgICAgICB0aGlzLmdyaWQuZ2V0U2VsZWN0ZWRSb3dzKCkuZm9yRWFjaChmdW5jdGlvbihzZWxlY3RlZFJvd0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YVJvdyA9IGZpbHRlcmVkRGF0YVtzZWxlY3RlZFJvd0luZGV4XTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZERhdGEuaW5kZXhPZihkYXRhUm93KSA8IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZERhdGEucHVzaChkYXRhUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlLWVzdGFibGlzaCBncmlkIHJvdyBzZWxlY3Rpb25zIGJhc2VkIG9uIGFjdHVhbCBkYXRhIHJvdyBvYmplY3RzIGFjY3VtdWxhdGVkIGJ5IGBzZWxlY3RlZERhdGFSb3dzQmFja2luZ1NlbGVjdGVkR3JpZFJvd3NgIHdoaWNoIHNob3VsZCBiZSBjYWxsZWQgZmlyc3QuXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gcmVzZWxlY3RHcmlkUm93c0JhY2tlZEJ5U2VsZWN0ZWREYXRhUm93cygpIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZERhdGEubGVuZ3RoKSB7IC8vIGFueSBkYXRhIHJvdyBvYmplY3RzIGFkZGVkIGZyb20gcHJldmlvdXMgZ3JpZCByb3cgc2VsZWN0aW9ucz9cbiAgICAgICAgdmFyIHNlbGVjdGlvbk1vZGVsID0gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvdW50KCksXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGEgPSB0aGlzLmdldEZpbHRlcmVkRGF0YSgpO1xuXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsLmNsZWFyUm93U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhUm93KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBmaWx0ZXJlZERhdGEuaW5kZXhPZihkYXRhUm93KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwuc2VsZWN0Um93KG9mZnNldCArIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICovXG5mdW5jdGlvbiBhcHBseUdyb3VwQnlzQW5kQWdncmVnYXRpb25zKCkge1xuICAgIGlmICh0aGlzLmFuYWx5dGljcy5hZ2dyZWdhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnF1aWV0bHlTZXRBZ2dyZWdhdGVzKHt9KTtcbiAgICB9XG4gICAgdGhpcy5hbmFseXRpY3MuYXBwbHkoKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gYXBwbHlGaWx0ZXJzKCkge1xuICAgIHRoaXMuZ2V0R2xvYmFsRmlsdGVyRGF0YVNvdXJjZSgpLmFwcGx5KCk7XG5cbiAgICB2YXIgZGV0YWlscyA9IFtdO1xuXG4gICAgLy8gVE9ETzogcmV0dXJuIHNvbWV0aGluZyB1c2VmdWwuLi5cbiAgICAvLyB3YXMgcHJldmlvdXNseSByZXR1cm5pbmcsIGZvciBlYWNoIGNvbHVtbiBpbiB0aGlzLmdldFZpc2libGVDb2x1bW5zKCk6XG4gICAgLy8gWyB7IGNvbHVtbjogY29sdW1uLmxhYmVsLCBmb3JtYXQ6ICdjb21wbGV4JyBvciBjb2x1bW4uZ2V0UHJvcGVydGllcygpLmZvcm1hdCB9LCAuLi4gXVxuXG5cbiAgICB0aGlzLmdyaWQuZmlyZVN5bnRoZXRpY0ZpbHRlckFwcGxpZWRFdmVudCh7XG4gICAgICAgIGRldGFpbHM6IGRldGFpbHNcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gYXBwbHlTb3J0cygpIHtcbiAgICB2YXIgc29ydGluZ1NvdXJjZSA9IHRoaXMuZ2V0U29ydERhdGFTb3VyY2UoKTtcbiAgICB2YXIgc29ydHMgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpLnNvcnRzO1xuICAgIHZhciBncm91cE9mZnNldCA9IHRoaXMuaGFzQWdncmVnYXRlcygpID8gMSA6IDA7XG4gICAgaWYgKCFzb3J0cyB8fCBzb3J0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc29ydGluZ1NvdXJjZS5jbGVhclNvcnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbEluZGV4ID0gTWF0aC5hYnMoc29ydHNbaV0pIC0gMTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gc29ydHNbaV0gPCAwID8gLTEgOiAxO1xuICAgICAgICAgICAgc29ydGluZ1NvdXJjZS5zb3J0T24oY29sSW5kZXggLSBncm91cE9mZnNldCwgdHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc29ydGluZ1NvdXJjZS5hcHBseVNvcnRzKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMUlVDYWNoZSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpO1xuXG52YXIgcmVuZGVyQ2VsbEVycm9yID0gcmVxdWlyZSgnLi9saWIvcmVuZGVyQ2VsbEVycm9yJyk7XG5cbi8qKlxuICogVGhpcyBtb2R1bGUgbGlzdHMgdGhlIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgc2V0IG9uIGEge0BsaW5rIEh5cGVyZ3JpZH0gYWxvbmcgd2l0aCB0aGVpciBkZWZhdWx0IHZhbHVlcy5cbiAqIEVkaXQgdGhpcyBmaWxlIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAqIEBtb2R1bGUgZGVmYXVsdHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIC8vdGhlc2UgYXJlIGZvciB0aGUgdGhlbWVcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGZvbnQgZm9yIGRhdGEgY2VsbHMuXG4gICAgICogQGRlZmF1bHQgJzEzcHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnXG4gICAgICogQHR5cGUge2Nzc0ZvbnR9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZm9udDogJzEzcHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBjb2xvciBmb3IgZGF0YSBjZWxscy5cbiAgICAgKiBAZGVmYXVsdCAncmdiKDI1LCAyNSwgMjUpJ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBmb3IgZGF0YSBjZWxscy5cbiAgICAgKiBAZGVmYXVsdCAncmdiKDI0MSwgMjQxLCAyNDEpJ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiKDI0MSwgMjQxLCAyNDEpJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgc3R5bGUgZm9yIHNlbGVjdGVkIGNlbGwocykuXG4gICAgICogQGRlZmF1bHQgJ2JvbGQnXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDogJ2JvbGQgMTNweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBGb250IGNvbG9yIGZvciBzZWxlY3RlZCBjZWxsKHMpLlxuICAgICAqIEBkZWZhdWx0ICdyZ2IoMCwgMCwgMTI4KSdcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYigwLCAwLCAxMjgpJyxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3IgZm9yIHNlbGVjdGVkIGNlbGwocykuXG4gICAgICogQGRlZmF1bHQgJ3JnYmEoMTQ3LCAxODUsIDI1NSwgMC40NSknXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2JhKDE0NywgMTg1LCAyNTUsIDAuNjI1KScsXG5cblxuICAgIC8qKioqKioqKioqIFNFQ1RJT046IENPTFVNTiBIRUFERVIgQ09MT1JTICoqKioqKioqKiovXG5cbiAgICAvLyBJTVBPUlRBTlQgQ0FWRUFUOiBUaGUgY29kZSBpcyBpbmNvbnNpc3RlbnQgcmVnYXJkaW5nIHRoZSB0ZXJtaW5vbG9neS4gSXMgdGhlIFwiY29sdW1uIGhlYWRlclwiIHNlY3Rpb24gX3RoZSByb3dfIG9mIGNlbGxzIGF0IHRoZSB0b3AgKHRoYXQgYWN0IGFzIGhlYWRlcnMgZm9yIGVhY2ggY29sdW1uKSBvciBpcyBpdCBfdGhlIGNvbHVtbl8gb2YgY2VsbHMgKHRoYXQgYWN0IGFzIGhlYWRlcnMgZm9yIGVhY2ggcm93KT8gT2ggbXkuXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAnMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZidcbiAgICAgKiBAdHlwZSB7Y3NzRm9udH1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJGb250OiAnMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAncmdiKDI1LCAyNSwgMjUpJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJDb2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIGZvciBzZWxlY3RlZCBjb2x1bW5zJyBoZWFkZXJzLlxuICAgICAqIEBkZWZhdWx0ICdib2xkJ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQ6ICdib2xkIDEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgJ3JnYigyMjMsIDIyNywgMjMyKSdcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yOiAncmdiKDIyMywgMjI3LCAyMzIpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICdyZ2IoODAsIDgwLCA4MCknXG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYig4MCwgODAsIDgwKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAncmdiYSgyNTUsIDIyMCwgOTcsIDAuNDUpJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2JhKDI1NSwgMjIwLCA5NywgMC40NSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgJ3JnYigyNSwgMjUsIDI1KSdcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICdyZ2IoMjU1LCAxODAsIDApJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjU1LCAxODAsIDApJyxcblxuXG4gICAgLyoqKioqKioqKiogU0VDVElPTjogUk9XIEhFQURFUiBDT0xPUlMgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICcxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJ1xuICAgICAqIEB0eXBlIHtjc3NGb250fVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckZvbnQ6ICcxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICdyZ2IoMjUsIDI1LCAyNSknXG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICdyZ2IoMjIzLCAyMjcsIDIzMiknXG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckJhY2tncm91bmRDb2xvcjogJ3JnYigyMjMsIDIyNywgMjMyKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAncmdiKDgwLCA4MCwgODApJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoODAsIDgwLCA4MCknLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzdHlsZSBmb3Igc2VsZWN0ZWQgcm93cycgaGVhZGVycy5cbiAgICAgKiBAZGVmYXVsdCAnYm9sZCdcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Gb250OiAnYm9sZCAxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICdyZ2JhKDI1NSwgMjIwLCA5NywgMC40NSknXG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYmEoMjU1LCAyMjAsIDk3LCAwLjQ1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAncmdiKDI1LCAyNSwgMjUpJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByb3dIZWFkZXJGb3JlZ3JvdW5kUm93U2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgJ3JnYigyNTUsIDE4MCwgMCknXG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckJhY2tncm91bmRSb3dTZWxlY3Rpb25Db2xvcjogJ3JnYigyNTUsIDE4MCwgMCknLFxuXG5cbiAgICAvKioqKioqKioqKiBTRUNUSU9OOiBGSUxURVIgUk9XIENPTE9SUyAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgJzEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnXG4gICAgICogQHR5cGUge2Nzc0ZvbnR9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZmlsdGVyRm9udDogJzEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgJ3JnYigyNSwgMjUsIDI1KSdcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZmlsdGVyQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgJ3doaXRlJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJCYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAncmdiKDI1LCAyNSwgMjUpJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgJ3JnYigyNTUsIDIyMCwgOTcpJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjU1LCAyMjAsIDk3KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwLjgpJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJDZWxsQm9yZGVyU3R5bGU6ICdyZ2JhKDAsMCwwLDAuOCknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgMC40XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJDZWxsQm9yZGVyVGhpY2tuZXNzOiAwLjQsXG5cblxuICAgIC8qKioqKioqKioqIFNFQ1RJT046IFRSRUUgQ09MVU1OIENPTE9SUyAqKioqKioqKioqL1xuICAgIC8vIFRoZSBcInRyZWUgY29sdW1uXCIgY29udGFpbnMgdGhlIGhpZXJhcmNoaWNhbCBkcmlsbC1kb3duIGNvbnRyb2xzLlxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgJzEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnXG4gICAgICogQHR5cGUge2Nzc0ZvbnR9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdHJlZUNvbHVtbkZvbnQ6ICcxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICdyZ2IoMjUsIDI1LCAyNSknXG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRyZWVDb2x1bW5Db2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAncmdiKDIyMywgMjI3LCAyMzIpJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0cmVlQ29sdW1uQmFja2dyb3VuZENvbG9yOiAncmdiKDIyMywgMjI3LCAyMzIpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICdyZ2IoMjUsIDI1LCAyNSknXG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRyZWVDb2x1bW5Gb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgJ3JnYmEoMjU1LCAyMjAsIDk3LCAwLjQ1KSdcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdHJlZUNvbHVtbkJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYmEoMjU1LCAyMjAsIDk3LCAwLjQ1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAncmdiKDI1LCAyNSwgMjUpJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0cmVlQ29sdW1uRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICdyZ2IoMjU1LCAxODAsIDApJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0cmVlQ29sdW1uQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yOiAncmdiKDI1NSwgMTgwLCAwKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAncmdiKDIwMSwgMjAxLCAyMDEpJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3IyOiAncmdiKDIwMSwgMjAxLCAyMDEpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHZvZmZzZXQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAndmlzaWJsZSdcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNjcm9sbGJhckhvdmVyT3ZlcjogJ3Zpc2libGUnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgJ2hpZGRlbidcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNjcm9sbGJhckhvdmVyT2ZmOiAnaGlkZGVuJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IGB0cnVlYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNjcm9sbGluZ0VuYWJsZWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdlNjcm9sbGJhckNsYXNzUHJlZml4OiAnJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBoU2Nyb2xsYmFyQ2xhc3NQcmVmaXg6ICcnLFxuXG4gICAgLy90aGVzZSB1c2VkIHRvIGJlIGluIHRoZSBjb25zdGFudHMgZWxlbWVudFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgJ2NlbnRlcidcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZpeGVkUm93QWxpZ246ICdjZW50ZXInLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgJ2NlbnRlcidcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZpeGVkQ29sQWxpZ246ICdjZW50ZXInLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgNVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY2VsbFBhZGRpbmc6IDUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCBgdHJ1ZWBcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBncmlkTGluZXNIOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgYHRydWVgXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZ3JpZExpbmVzVjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICdyZ2IoMTk5LCAxOTkgMTk5KSdcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgbGluZUNvbG9yOiAncmdiKDE5OSwgMTk5LCAxOTkpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IDAuNFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgbGluZVdpZHRoOiAwLjQsXG5cblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IDE1XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBkZWZhdWx0Um93SGVpZ2h0OiAxNSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IDEwMFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZGVmYXVsdENvbHVtbldpZHRoOiAxMDAsXG5cbiAgICAvL2ZvciBpbW1lZGlhdGUgcGFpbnRpbmcsIHNldCB0aGVzZSB2YWx1ZXMgdG8gMCwgdHJ1ZSByZXNwZWN0aXZlbHlcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IDYwXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByZXBhaW50SW50ZXJ2YWxSYXRlOiA2MCxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByZXBhaW50SW1tZWRpYXRlbHk6IGZhbHNlLFxuXG4gICAgLy9lbmFibGUgb3IgZGlzYWJsZSBkb3VibGUgYnVmZmVyaW5nXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdXNlQml0QmxpdDogZmFsc2UsXG5cblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IGB0cnVlYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHVzZUhpRFBJOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgWydhbHQnLCAnZXNjJ11cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGVkaXRvckFjdGl2YXRpb25LZXlzOiBbJ2FsdCcsICdlc2MnXSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByZWFkT25seTogZmFsc2UsXG5cbiAgICAvLyBpbmhlcml0ZWQgYnkgY2VsbCByZW5kZXJlcnNcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IGdldFRleHRXaWR0aFxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRUZXh0V2lkdGg6IGdldFRleHRXaWR0aCxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IGdldFRleHRIZWlnaHRcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0VGV4dEhlaWdodDogZ2V0VGV4dEhlaWdodCxcblxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZml4ZWRDb2x1bW5Db3VudDogMCxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZpeGVkUm93Q291bnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBoZWFkZXJDb2x1bW5Db3VudDogMCxcblxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgYHRydWVgXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc2hvd1Jvd051bWJlcnM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCBgdHJ1ZWBcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzaG93VHJlZUNvbHVtbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IGB0cnVlYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNob3dIZWFkZXJSb3c6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCBgdHJ1ZWBcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzaG93RmlsdGVyUm93OiB0cnVlLFxuXG5cbiAgICAvKiogQ2xpY2tpbmcgaW4gYSBjZWxsIFwic2VsZWN0c1wiIGl0OyBpdCBpcyBhZGRlZCB0byB0aGUgc2VsZWN0IHJlZ2lvbiBhbmQgcmVwYWludGVkIHdpdGggXCJjZWxsIHNlbGVjdGlvblwiIGNvbG9ycy5cbiAgICAgKiBAZGVmYXVsdCBgdHJ1ZWBcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjZWxsU2VsZWN0aW9uOiB0cnVlLFxuXG4gICAgLyoqIENsaWNraW5nIGluIGEgcm93IGhlYWRlciAobGVmdG1vc3QgY29sdW1uKSBcInNlbGVjdHNcIiB0aGUgcm93OyB0aGUgZW50aXJlIHJvdyBpcyBhZGRlZCB0byB0aGUgc2VsZWN0IHJlZ2lvbiBhbmQgcmVwYWludGVkIHdpdGggXCJyb3cgc2VsZWN0aW9uXCIgY29sb3JzLlxuICAgICAqIEBkZWZhdWx0IGB0cnVlYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtblNlbGVjdGlvbjogdHJ1ZSxcblxuICAgIC8qKiBDbGlja2luZyBpbiBhIGNvbHVtbiBoZWFkZXIgKHRvcCByb3cpIFwic2VsZWN0c1wiIHRoZSBjb2x1bW47IHRoZSBlbnRpcmUgY29sdW1uIGlzIGFkZGVkIHRvIHRoZSBzZWxlY3QgcmVnaW9uIGFuZCByZXBhaW50ZWQgd2l0aCBcImNvbHVtbiBzZWxlY3Rpb25cIiBjb2xvcnMuXG4gICAgICogQGRlZmF1bHQgYHRydWVgXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93U2VsZWN0aW9uOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgYHRydWVgXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc2luZ2xlUm93U2VsZWN0aW9uTW9kZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsIDAsIDQ4LCAwLjIpJ1xuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25SZWdpb25PdmVybGF5Q29sb3I6ICdyZ2JhKDAsIDAsIDQ4LCAwLjIpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0ICdibGFjaydcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNlbGVjdGlvblJlZ2lvbk91dGxpbmVDb2xvcjogJ2JsYWNrJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IGB0cnVlYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtbkF1dG9zaXppbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCBgdHJ1ZWBcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByb3dOdW1iZXJBdXRvc2l6aW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGhlYWRlclRleHRXcmFwcGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93UmVzaXplOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IGB0cnVlYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGVkaXRhYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgYHRydWVgXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZWRpdE9uRG91YmxlQ2xpY2s6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCAzMjVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGRvdWJsZUNsaWNrRGVsYXk6IDMyNSxcblxuICAgIC8qKlxuICAgICAqIEdyaWQtbGV2ZWwgcHJvcGVydHkuXG4gICAgICogV2hlbiB1c2VyIHByZXNzZXMgYSBwcmludGFibGUgY2hhcmFjdGVyIGtleSBfb3JfIEJBQ0tTUEFDRSBfb3JfIERFTEVURTpcbiAgICAgKiAxLiBBY3RpdmF0ZSBjZWxsIGVkaXRvciBvbiBjdXJyZW50IGNlbGwgKGkuZS4sIG9yaWdpbiBvZiBtb3N0IHJlY2VudCBzZWxlY3Rpb24pLlxuICAgICAqIDIuIElmIGNlbGwgZWRpdG9yIGlzIGEgdGV4dCBlZGl0b3I6XG4gICAgICogICAgMS4gUmVwbGFjZSBjdXJyZW50IHZhbHVlIHdpdGggdGhlIGNoYXJhY3RlciB0aGUgdXNlciB0eXBlZDsgb3JcbiAgICAgKiAgICAyLiBDbGVhciBpdCBvbiBCQUNLU1BBQ0UsIERFTEVURSwgb3Igb3RoZXIgaW52YWxpZCBjaGFyYWN0ZXIgKF9lLmcuXyB3aGVuIHVzZXIgdHlwZXMgYSBsZXR0ZXIgYnV0IHRoZSBjZWxsIGVkaXRvciBvbmx5IGFjY2VwdHMgZGlnaXRzKS5cbiAgICAgKlxuICAgICAqID4gSW4gaW52b2tlZCwgdXNlciBoYXMgdGhlIG9wdGlvbiB0byBiYWNrIG91dCBieSBwcmVzc2luZyB0aGUgRVNDQVBFIGtleS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IGB0cnVlYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGVkaXRPbktleWRvd246IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCByZW5kZXJDZWxsRXJyb3JcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgcmVuZGVyQ2VsbEVycm9yOiByZW5kZXJDZWxsRXJyb3IsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2hlY2tib3hPbmx5Um93U2VsZWN0aW9uczogZmFsc2UsXG5cbiAgICAvKiogTmFtZSBvZiBhIGZvcm1hdHRlcnMgZm9yIGNlbGwgdGV4dC5cbiAgICAgKiBAc2VlIC9zcmMvRm9ybWF0dGVycy5qc1xuICAgICAqL1xuICAgIGZvcm1hdDogJ2RlZmF1bHQnLFxuXG4gICAgLyoqKioqKioqKiogSE9WRVIgQ09MT1JTICoqKioqKioqKiovXG5cbiAgICAvKiogQHR5cGVkZWYgaG92ZXJDb2xvcnNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlbmFibGU9ZmFsc2VdIC0gYGZhbHNlYCBtZWFucyBub3QgaGlsaXRlIG9uIGhvdmVyXG4gICAgICogQHByb3BlcnR5IHtjc3NDb2xvcn0gYmFja2dyb3VuZENvbG9yIC0gY2VsbCwgcm93LCBvciBjb2x1bW1uIGJhY2tncm91bmQgY29sb3IuIEFscGhhIGNoYW5uZWwgd2lsbCBiZSByZXNwZWN0ZWQgYW5kIGlmIGdpdmVuIHdpbGwgYmUgcGFpbnRlZCBvdmVyIHRoZSBjZWxscyBwcmVkZXRlcm1pbmVkIGNvbG9yLlxuICAgICAqIEBwcm9wZXJ0eSB7Y3NzQ29sb3J9IFtoZWFkZXIuYmFja2dyb3VuZENvbG9yPWJhY2tncm91bmRDb2xvcl0gLSBmb3IgY29sdW1ucyBhbmQgcm93cywgdGhpcyBpcyB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgY29sdW1uIG9yIHJvdyBcImhhbmRsZVwiIChoZWFkZXIgcm93cyBvciBjb2x1bW5zLCByZXNwZWN0aXZlbHkpLiAoTm90IHVzZWQgZm9yIGNlbGxzLilcbiAgICAgKi9cblxuICAgIC8qKiBPbiBtb3VzZSBob3Zlciwgd2hldGhlciB0byByZXBhaW50IHRoZSBjZWxsIGJhY2tncm91bmQgYW5kIGhvdy5cbiAgICAgKiBAdHlwZSB7aG92ZXJDb2xvcnN9XG4gICAgICogQGRlZmF1bHQgJ3sgZW5hYmxlZDogdHJ1ZSwgYmFja2dyb3VuZDogcmdiYSgxNjAsIDE2MCwgNDAsIDAuMzApIH0nXG4gICAgICovXG4gICAgaG92ZXJDZWxsSGlnaGxpZ2h0OiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMTYwLCAxNjAsIDQwLCAwLjQ1KSdcbiAgICB9LFxuXG4gICAgLyoqIE9uIG1vdXNlIGhvdmVyLCB3aGV0aGVyIHRvIHJlcGFpbnQgdGhlIHJvdyBiYWNrZ3JvdW5kIGFuZCBob3cuXG4gICAgICogQHR5cGUge2hvdmVyQ29sb3JzfVxuICAgICAqIEBkZWZhdWx0ICd7IGVuYWJsZWQ6IHRydWUsIGJhY2tncm91bmQ6IHJnYmEoMTAwLCAxMDAsIDI1LCAwLjE1KSB9J1xuICAgICAqL1xuICAgIGhvdmVyUm93SGlnaGxpZ2h0OiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMTAwLCAxMDAsIDI1LCAwLjMwKSdcblxuICAgIH0sXG5cbiAgICAvKiogT24gbW91c2UgaG92ZXIsIHdoZXRoZXIgdG8gcmVwYWludCB0aGUgY29sdW1uIGJhY2tncm91bmQgYW5kIGhvdy5cbiAgICAgKiBAdHlwZSB7aG92ZXJDb2xvcnN9XG4gICAgICogQGRlZmF1bHQgJ3sgZW5hYmxlZDogdHJ1ZSwgYmFja2dyb3VuZDogcmdiYSg2MCwgNjAsIDE1LCAwLjE1KSB9J1xuICAgICAqL1xuICAgIGhvdmVyQ29sdW1uSGlnaGxpZ2h0OiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoNjAsIDYwLCAxNSwgMC4xNSknXG4gICAgfSxcblxuXG4gICAgLyoqIERpc3BsYXkgY2VsbCBmb250IHdpdGggdW5kZXItc2NvcmUgbGluZSBkcmF3biBvdmVyIGl0LlxuICAgICAqID4gSW1wbGVtZW50YXRpb24gb2YgbGlua3MgcmlnaHQgbm93IGlzIG5vdCBhdXRvbWF0aWM7IHlvdSBtdXN0IGF0dGFjaCBhICdmaW4tY2xpY2snIGxpc3RlbmVyIHRvIHRoZSBoeXBlcmdyaWQgb2JqZWN0LCBldGMuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgICAqL1xuICAgIGxpbms6IGZhbHNlLFxuXG4gICAgLyoqIERpc3BsYXkgY2VsbCBmb250IHdpdGggc3RyaWtlLXRocm91Z2ggbGluZSBkcmF3biBvdmVyIGl0LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICAgKi9cbiAgICBzdHJpa2VUaHJvdWdoOiBmYWxzZSxcblxufTtcblxuLyoqIEB0eXBlZGVmIHtzdHJpbmd9IGNzc0NvbG9yXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jb2xvcl92YWx1ZVxuICovXG4vKiogQHR5cGVkZWYge3N0cmluZ30gY3NzRm9udFxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udFxuICovXG5cbnZhciB0ZXh0V2lkdGhDYWNoZSA9IG5ldyBMUlVDYWNoZSgyMDAwKTtcblxuZnVuY3Rpb24gZ2V0VGV4dFdpZHRoKGdjLCBzdHJpbmcpIHtcbiAgICBpZiAoc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBzdHJpbmcgPSBzdHJpbmcgKyAnJztcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIGtleSA9IGdjLmZvbnQgKyBzdHJpbmc7XG4gICAgdmFyIHdpZHRoID0gdGV4dFdpZHRoQ2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgICB3aWR0aCA9IGdjLm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgICAgIHRleHRXaWR0aENhY2hlLnNldChrZXksIHdpZHRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xufVxuXG52YXIgZm9udERhdGEgPSB7fTtcblxuZnVuY3Rpb24gZ2V0VGV4dEhlaWdodChmb250KSB7XG4gICAgdmFyIHJlc3VsdCA9IGZvbnREYXRhW2ZvbnRdO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgICAgdmFyIHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHRleHQudGV4dENvbnRlbnQgPSAnSGcnO1xuICAgICAgICB0ZXh0LnN0eWxlLmZvbnQgPSBmb250O1xuXG4gICAgICAgIHZhciBibG9jayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBibG9jay5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgIGJsb2NrLnN0eWxlLndpZHRoID0gJzFweCc7XG4gICAgICAgIGJsb2NrLnN0eWxlLmhlaWdodCA9ICcwcHgnO1xuXG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKHRleHQpO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoYmxvY2spO1xuXG4gICAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICBibG9jay5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ2Jhc2VsaW5lJztcblxuICAgICAgICAgICAgdmFyIGJsb2NrUmVjdCA9IGJsb2NrLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgcmVzdWx0LmFzY2VudCA9IGJsb2NrUmVjdC50b3AgLSB0ZXh0UmVjdC50b3A7XG5cbiAgICAgICAgICAgIGJsb2NrLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgICAgICAgIHJlc3VsdC5oZWlnaHQgPSBibG9ja1JlY3QudG9wIC0gdGV4dFJlY3QudG9wO1xuXG4gICAgICAgICAgICByZXN1bHQuZGVzY2VudCA9IHJlc3VsdC5oZWlnaHQgLSByZXN1bHQuYXNjZW50O1xuXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5oZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIGZvbnREYXRhW2ZvbnRdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vbGliL3BvbHlmaWxscycpO1xuXG5yZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7IC8vIEluc3RhbGxzIHRoZSBBcnJheS5maW5kIHBvbHlmaWxsLCBhcyBuZWVkZWRcblxudmFyIEh5cGVyZ3JpZCA9IHJlcXVpcmUoJy4vSHlwZXJncmlkJyk7XG5cbkh5cGVyZ3JpZC5pbWFnZXMgPSByZXF1aXJlKCcuLi9pbWFnZXMnKTtcbkh5cGVyZ3JpZC5iZWhhdmlvcnMgPSByZXF1aXJlKCcuL2JlaGF2aW9ycycpO1xuSHlwZXJncmlkLmNlbGxFZGl0b3JzID0gcmVxdWlyZSgnLi9jZWxsRWRpdG9ycycpO1xuSHlwZXJncmlkLmZlYXR1cmVzID0gcmVxdWlyZSgnLi9mZWF0dXJlcycpO1xuXG4od2luZG93LmZpbiA9IHdpbmRvdy5maW4gfHwge30pLkh5cGVyZ3JpZCA9IEh5cGVyZ3JpZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENlbGxDbGljayA9IEZlYXR1cmUuZXh0ZW5kKCdDZWxsQ2xpY2snLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbENsaWNrLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVGFwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBldmVudC5ncmlkQ2VsbC55ID49IGdyaWQuYmVoYXZpb3IuZ2V0SGVhZGVyUm93Q291bnQoKSAmJlxuICAgICAgICAgICAgZXZlbnQuZ3JpZENlbGwueCA+PSBncmlkLmJlaGF2aW9yLmdldEhlYWRlckNvbHVtbkNvdW50KClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBncmlkLmNlbGxDbGlja2VkKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVUYXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbENsaWNrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ2VsbEVkaXRpbmcgPSBGZWF0dXJlLmV4dGVuZCgnQ2VsbEVkaXRpbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRG91YmxlQ2xpY2tFZGl0b3JBY3RpdmF0aW9uID0gZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ2VkaXRPbkRvdWJsZUNsaWNrJyk7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQWN0aXZhdGVFZGl0b3IoZ3JpZCwgZXZlbnQsIGlzRG91YmxlQ2xpY2tFZGl0b3JBY3RpdmF0aW9uKSkge1xuICAgICAgICAgICAgZ3JpZC5vbkVkaXRvckFjdGl2YXRlKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlVGFwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNEb3VibGVDbGlja0VkaXRvckFjdGl2YXRpb24gPSBncmlkLnJlc29sdmVQcm9wZXJ0eSgnZWRpdE9uRG91YmxlQ2xpY2snKTtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tBY3RpdmF0ZUVkaXRvcihncmlkLCBldmVudCwgIWlzRG91YmxlQ2xpY2tFZGl0b3JBY3RpdmF0aW9uKSkge1xuICAgICAgICAgICAgZ3JpZC5vbkVkaXRvckFjdGl2YXRlKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVUYXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdGluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUhvbGRQdWxzZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRG91YmxlQ2xpY2tFZGl0b3JBY3RpdmF0aW9uID0gZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ2VkaXRPbkRvdWJsZUNsaWNrJyk7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQWN0aXZhdGVFZGl0b3IoZ3JpZCwgZXZlbnQsICFpc0RvdWJsZUNsaWNrRWRpdG9yQWN0aXZhdGlvbikpIHtcbiAgICAgICAgICAgZ3JpZC5vbkVkaXRvckFjdGl2YXRlKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVIb2xkUHVsc2UoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNoZWNrQWN0aXZhdGVFZGl0b3I6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50LCBpc0RvdWJsZUNsaWNrRWRpdG9yQWN0aXZhdGlvbikge1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBoZWFkZXJDb2x1bW5Db3VudCA9IGdyaWQuYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciBpc0ZpbHRlclJvdyA9IGdyaWQuaXNGaWx0ZXJSb3coZ3JpZENlbGwueSk7XG5cbiAgICAgICAgcmV0dXJuIGlzRG91YmxlQ2xpY2tFZGl0b3JBY3RpdmF0aW9uICYmXG4gICAgICAgICAgICBncmlkQ2VsbC54ID49IGhlYWRlckNvbHVtbkNvdW50ICYmXG4gICAgICAgICAgICAoaXNGaWx0ZXJSb3cgfHwgZ3JpZENlbGwueSA+PSBoZWFkZXJSb3dDb3VudCk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsRWRpdGluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENlbGxTZWxlY3Rpb24gPSBGZWF0dXJlLmV4dGVuZCgnQ2VsbFNlbGVjdGlvbicsIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50RHJhZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHRoZSBjZWxsIGNvb3JkaW5hdGVzIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvblxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgbGFzdERyYWdDZWxsOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHRpbWUgYW4gYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JMYXN0QXV0bzogMCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiQXV0b1N0YXJ0OiAwLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcbiAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdmFyIHZpZXdDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgZHggPSBjZWxsLng7XG4gICAgICAgIHZhciBkeSA9IGNlbGwueTtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gZ3JpZC5iZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgaGVhZGVyQ29sdW1uQ291bnQgPSBncmlkLmJlaGF2aW9yLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBjb2x1bW5Db3VudCA9IGdyaWQuYmVoYXZpb3IuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGlzT3V0c2lkZSA9IHZpZXdDZWxsLnggPj0gY29sdW1uQ291bnQ7XG5cbiAgICAgICAgdmFyIGlzSGVhZGVyID0gZHkgPCBoZWFkZXJSb3dDb3VudCB8fCBkeCA8IGhlYWRlckNvbHVtbkNvdW50O1xuXG4gICAgICAgIGlmICghZ3JpZC5pc0NlbGxTZWxlY3Rpb24oKSB8fCBpc1JpZ2h0Q2xpY2sgfHwgaXNIZWFkZXIgfHwgaXNPdXRzaWRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgICAgICB2YXIgbnVtRml4ZWRSb3dzID0gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgICAgIC8vaWYgd2UgYXJlIGluIHRoZSBmaXhlZCBhcmVhIGRvIG5vdCBhcHBseSB0aGUgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy9jaGVjayBib3RoIHggYW5kIHkgdmFsdWVzIGluZGVwZW5kZW50bHlcbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC54IDwgbnVtRml4ZWRDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgZHggPSB2aWV3Q2VsbC54O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmlld0NlbGwueSA8IG51bUZpeGVkUm93cykge1xuICAgICAgICAgICAgICAgIGR5ID0gdmlld0NlbGwueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRDZWxsID0gZ3JpZC5uZXdQb2ludChkeCwgZHkpO1xuXG4gICAgICAgICAgICB2YXIgcHJpbUV2ZW50ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICB2YXIga2V5cyA9IHByaW1FdmVudC5kZXRhaWwua2V5cztcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5leHRlbmRTZWxlY3Rpb24oZ3JpZCwgZENlbGwsIGtleXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzUmlnaHRDbGljayA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2s7XG5cbiAgICAgICAgaWYgKCFncmlkLmlzQ2VsbFNlbGVjdGlvbigpIHx8IGlzUmlnaHRDbGljayB8fCAhdGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgICAgICB2YXIgbnVtRml4ZWRSb3dzID0gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgICAgIHZhciBjZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgICAgICB2YXIgdmlld0NlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgICAgICB2YXIgZHggPSBjZWxsLng7XG4gICAgICAgICAgICB2YXIgZHkgPSBjZWxsLnk7XG5cbiAgICAgICAgICAgIC8vaWYgd2UgYXJlIGluIHRoZSBmaXhlZCBhcmVhIGRvIG5vdCBhcHBseSB0aGUgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy9jaGVjayBib3RoIHggYW5kIHkgdmFsdWVzIGluZGVwZW5kZW50bHlcbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC54IDwgbnVtRml4ZWRDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgZHggPSB2aWV3Q2VsbC54O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmlld0NlbGwueSA8IG51bUZpeGVkUm93cykge1xuICAgICAgICAgICAgICAgIGR5ID0gdmlld0NlbGwueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRDZWxsID0gZ3JpZC5uZXdQb2ludChkeCwgZHkpO1xuXG4gICAgICAgICAgICB2YXIgcHJpbUV2ZW50ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREcmFnID0gcHJpbUV2ZW50LmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHRoaXMubGFzdERyYWdDZWxsID0gZENlbGw7XG5cbiAgICAgICAgICAgIHRoaXMuY2hlY2tEcmFnU2Nyb2xsKGdyaWQsIHRoaXMuY3VycmVudERyYWcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIGRDZWxsLCBwcmltRXZlbnQuZGV0YWlsLmtleXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBjb21tYW5kID0gJ2hhbmRsZScgKyBldmVudC5kZXRhaWwuY2hhcjtcbiAgICAgICAgaWYgKHRoaXNbY29tbWFuZF0pIHtcbiAgICAgICAgICAgIHRoaXNbY29tbWFuZF0uY2FsbCh0aGlzLCBncmlkLCBldmVudC5kZXRhaWwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSBhIG1vdXNlZHJhZyBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgZ3JpZENlbGwsIGtleXMpIHtcblxuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBoZWFkZXJDb2x1bW5Db3VudCA9IGdyaWQuYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHggPSBncmlkQ2VsbC54O1xuICAgICAgICB2YXIgeSA9IGdyaWRDZWxsLnk7XG4gICAgICAgIHggPSBNYXRoLm1heChoZWFkZXJDb2x1bW5Db3VudCwgeCk7XG4gICAgICAgIHkgPSBNYXRoLm1heChoZWFkZXJSb3dDb3VudCwgeSk7XG5cbiAgICAgICAgdmFyIHByZXZpb3VzRHJhZ0V4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpO1xuICAgICAgICB2YXIgbW91c2VEb3duID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcblxuICAgICAgICAvL3ZhciBzY3JvbGxpbmdOb3cgPSBncmlkLmlzU2Nyb2xsaW5nTm93KCk7XG5cbiAgICAgICAgdmFyIG5ld1ggPSB4IC0gbW91c2VEb3duLng7XG4gICAgICAgIHZhciBuZXdZID0geSAtIG1vdXNlRG93bi55O1xuXG4gICAgICAgIGlmIChwcmV2aW91c0RyYWdFeHRlbnQueCA9PT0gbmV3WCAmJiBwcmV2aW91c0RyYWdFeHRlbnQueSA9PT0gbmV3WSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcblxuICAgICAgICBncmlkLnNlbGVjdChtb3VzZURvd24ueCwgbW91c2VEb3duLnksIG5ld1gsIG5ld1kpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgY2hlY2tzIHdoaWxlIHdlcmUgZHJhZ2dpbmcgaWYgd2UgZ28gb3V0c2lkZSB0aGUgdmlzaWJsZSBib3VuZHMsIGlmIHNvLCBraWNrIG9mZiB0aGUgZXh0ZXJuYWwgYXV0b3Njcm9sbCBjaGVjayBmdW5jdGlvbiAoYWJvdmUpXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGNoZWNrRHJhZ1Njcm9sbDogZnVuY3Rpb24oZ3JpZCwgbW91c2UpIHtcbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IGIuY29udGFpbnMobW91c2UpO1xuICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3coZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxEcmFnKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gbWFrZXMgc3VyZSB0aGF0IHdoaWxlIHdlIGFyZSBkcmFnZ2luZyBvdXRzaWRlIG9mIHRoZSBncmlkIHZpc2libGUgYm91bmRzLCB3ZSBzcmNyb2xsIGFjY29yZGluZ2x5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBzY3JvbGxEcmFnOiBmdW5jdGlvbihncmlkKSB7XG5cbiAgICAgICAgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmFnU3RhcnRlZEluSGVhZGVyQXJlYSA9IGdyaWQuaXNNb3VzZURvd25JbkhlYWRlckFyZWEoKTtcbiAgICAgICAgdmFyIGxhc3REcmFnQ2VsbCA9IHRoaXMubGFzdERyYWdDZWxsO1xuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpO1xuICAgICAgICB2YXIgeE9mZnNldCA9IDA7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gMDtcblxuICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICB2YXIgZHJhZ0VuZEluRml4ZWRBcmVhWCA9IGxhc3REcmFnQ2VsbC54IDwgbnVtRml4ZWRDb2x1bW5zO1xuICAgICAgICB2YXIgZHJhZ0VuZEluRml4ZWRBcmVhWSA9IGxhc3REcmFnQ2VsbC55IDwgbnVtRml4ZWRSb3dzO1xuXG4gICAgICAgIGlmICghZHJhZ1N0YXJ0ZWRJbkhlYWRlckFyZWEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnggPCBiLm9yaWdpbi54KSB7XG4gICAgICAgICAgICAgICAgeE9mZnNldCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueSA8IGIub3JpZ2luLnkpIHtcbiAgICAgICAgICAgICAgICB5T2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueCA+IGIub3JpZ2luLnggKyBiLmV4dGVudC54KSB7XG4gICAgICAgICAgICB4T2Zmc2V0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy55ID4gYi5vcmlnaW4ueSArIGIuZXh0ZW50LnkpIHtcbiAgICAgICAgICAgIHlPZmZzZXQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyYWdDZWxsT2Zmc2V0WCA9IHhPZmZzZXQ7XG4gICAgICAgIHZhciBkcmFnQ2VsbE9mZnNldFkgPSB5T2Zmc2V0O1xuXG4gICAgICAgIGlmIChkcmFnRW5kSW5GaXhlZEFyZWFYKSB7XG4gICAgICAgICAgICBkcmFnQ2VsbE9mZnNldFggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYWdFbmRJbkZpeGVkQXJlYVkpIHtcbiAgICAgICAgICAgIGRyYWdDZWxsT2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGxhc3REcmFnQ2VsbC5wbHVzWFkoZHJhZ0NlbGxPZmZzZXRYLCBkcmFnQ2VsbE9mZnNldFkpO1xuICAgICAgICBncmlkLnNjcm9sbEJ5KHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgbGFzdERyYWdDZWxsLCBbXSk7IC8vIHVwZGF0ZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuc2Nyb2xsRHJhZy5iaW5kKHRoaXMsIGdyaWQpLCAyNSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGV4dGVuZCBhIHNlbGVjdGlvbiBvciBjcmVhdGUgb25lIGlmIHRoZXJlIGlzbnQgeWV0XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JpZENlbGwgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgZXh0ZW5kU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCBncmlkQ2VsbCwga2V5cykge1xuICAgICAgICB2YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpID49IDA7XG4gICAgICAgIHZhciBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSA+PSAwO1xuICAgICAgICAvLyB2YXIgc2Nyb2xsVG9wID0gZ3JpZC5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgLy8gdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHZhciBudW1GaXhlZENvbHVtbnMgPSAwOy8vZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIC8vIHZhciBudW1GaXhlZFJvd3MgPSAwOy8vZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgdmFyIG1vdXNlUG9pbnQgPSBncmlkLmdldE1vdXNlRG93bigpO1xuICAgICAgICB2YXIgeCA9IGdyaWRDZWxsLng7IC8vIC0gbnVtRml4ZWRDb2x1bW5zICsgc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIHkgPSBncmlkQ2VsbC55OyAvLyAtIG51bUZpeGVkUm93cyArIHNjcm9sbFRvcDtcblxuICAgICAgICAvL3dlcmUgb3V0c2lkZSBvZiB0aGUgZ3JpZCBkbyBub3RoaW5nXG4gICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy93ZSBoYXZlIHJlcGVhdGVkIGEgY2xpY2sgaW4gdGhlIHNhbWUgc3BvdCBkZXNsZWN0IHRoZSB2YWx1ZSBmcm9tIGxhc3QgdGltZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBoYXNDVFJMICYmXG4gICAgICAgICAgICB4ID09PSBtb3VzZVBvaW50LnggJiZcbiAgICAgICAgICAgIHkgPT09IG1vdXNlUG9pbnQueVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBncmlkLnBvcE1vdXNlRG93bigpO1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhc0NUUkwgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3QobW91c2VQb2ludC54LCBtb3VzZVBvaW50LnksIHggLSBtb3VzZVBvaW50LnggKyAxLCB5IC0gbW91c2VQb2ludC55ICsgMSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCh4IC0gbW91c2VQb2ludC54ICsgMSwgeSAtIG1vdXNlUG9pbnQueSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3QoeCwgeSwgMCwgMCk7XG4gICAgICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KHgsIHkpKTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgfVxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlRE9XTlNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDAsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDAsIC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIC0xLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAxLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlRE9XTjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgLy9rZWVwIHRoZSBicm93c2VyIHZpZXdwb3J0IGZyb20gYXV0byBzY3JvbGxpbmcgb24ga2V5IGV2ZW50XG4gICAgICAgIGV2ZW50LnByaW1pdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uKCk7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAwLCBjb3VudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICAvL2tlZXAgdGhlIGJyb3dzZXIgdmlld3BvcnQgZnJvbSBhdXRvIHNjcm9sbGluZyBvbiBrZXkgZXZlbnRcbiAgICAgICAgZXZlbnQucHJpbWl0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmdldEF1dG9TY3JvbGxBY2NlbGVyYXRpb24oKTtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIDAsIC1jb3VudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIC0xLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIDEsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJZiB3ZSBhcmUgaG9sZGluZyBkb3duIHRoZSBzYW1lIG5hdmlnYXRpb24ga2V5LCBhY2NlbGVyYXRlIHRoZSBpbmNyZW1lbnQgd2Ugc2Nyb2xsXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgIHZhciBlbGFwc2VkID0gdGhpcy5nZXRBdXRvU2Nyb2xsRHVyYXRpb24oKSAvIDIwMDA7XG4gICAgICAgIGNvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkKSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBzdGFydCB0aW1lIHRvIHJpZ2h0IG5vdyB3aGVuIHdlIGluaXRpYXRlIGFuIGF1dG8gc2Nyb2xsXG4gICAgICovXG4gICAgc2V0QXV0b1Njcm9sbFN0YXJ0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JBdXRvU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGF1dG9zY3JvbGwgc3RhcnQgdGltZSBpZiB3ZSBoYXZlbid0IGF1dG9zY3JvbGxlZCB3aXRoaW4gdGhlIGxhc3QgNTAwbXMgb3RoZXJ3aXNlIHVwZGF0ZSB0aGUgY3VycmVudCBhdXRvc2Nyb2xsIHRpbWVcbiAgICAgKi9cbiAgICBwaW5nQXV0b1Njcm9sbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF1dG9TY3JvbGxTdGFydFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNiTGFzdEF1dG8gPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgaG93IGxvbmcgd2UgaGF2ZSBiZWVuIGF1dG8gc2Nyb2xsaW5nXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbER1cmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zYkF1dG9TdGFydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXVnbWVudCB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIGV4dGVudCBieSAob2Zmc2V0WCxvZmZzZXRZKSBhbmQgc2Nyb2xsIGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2hpZnRTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFgsIG9mZnNldFkpIHtcblxuICAgICAgICB2YXIgbWF4Q29sdW1ucyA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIHZhciBtYXhSb3dzID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1ucygpIC0gMTtcbiAgICAgICAgdmFyIG1heFZpZXdhYmxlUm93cyA9IGdyaWQuZ2V0VmlzaWJsZVJvd3MoKSAtIDE7XG5cbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICBtYXhDb2x1bW5zID0gTWF0aC5taW4obWF4Q29sdW1ucywgbWF4Vmlld2FibGVDb2x1bW5zKTtcbiAgICAgICAgICAgIG1heFJvd3MgPSBNYXRoLm1pbihtYXhSb3dzLCBtYXhWaWV3YWJsZVJvd3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHZhciBleHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKTtcblxuICAgICAgICB2YXIgbmV3WCA9IGV4dGVudC54ICsgb2Zmc2V0WDtcbiAgICAgICAgdmFyIG5ld1kgPSBleHRlbnQueSArIG9mZnNldFk7XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWluKG1heENvbHVtbnMgLSBvcmlnaW4ueCwgTWF0aC5tYXgoLW9yaWdpbi54LCBuZXdYKSk7XG4gICAgICAgIG5ld1kgPSBNYXRoLm1pbihtYXhSb3dzIC0gb3JpZ2luLnksIE1hdGgubWF4KC1vcmlnaW4ueSwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgbmV3WCwgbmV3WSk7XG5cbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQobmV3WCwgbmV3WSkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsQ29sSXNWaXNpYmxlKG5ld1ggKyBvcmlnaW4ueCwgb2Zmc2V0WCkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbFJvd0lzVmlzaWJsZShuZXdZICsgb3JpZ2luLnksIG9mZnNldFkpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXBsYWNlIHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gd2l0aCBhIHNpbmdsZSBjZWxsIHNlbGVjdGlvbiB0aGF0IGlzIG1vdmVkIChvZmZzZXRYLG9mZnNldFkpIGZyb20gdGhlIHByZXZpb3VzIHNlbGVjdGlvbiBleHRlbnQuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuXG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcbiAgICAgICAgdmFyIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxO1xuXG4gICAgICAgIHZhciBtYXhWaWV3YWJsZUNvbHVtbnMgPSBncmlkLmdldFZpc2libGVDb2x1bW5zQ291bnQoKSAtIDE7XG4gICAgICAgIHZhciBtYXhWaWV3YWJsZVJvd3MgPSBncmlkLmdldFZpc2libGVSb3dzQ291bnQoKSAtIDE7XG5cbiAgICAgICAgdmFyIG1pblJvd3MgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBtaW5Db2xzID0gZ3JpZC5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuXG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IE1hdGgubWluKG1heENvbHVtbnMsIG1heFZpZXdhYmxlQ29sdW1ucyk7XG4gICAgICAgICAgICBtYXhSb3dzID0gTWF0aC5taW4obWF4Um93cywgbWF4Vmlld2FibGVSb3dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSk7XG5cbiAgICAgICAgdmFyIG5ld1ggPSBtb3VzZUNvcm5lci54ICsgb2Zmc2V0WDtcbiAgICAgICAgdmFyIG5ld1kgPSBtb3VzZUNvcm5lci55ICsgb2Zmc2V0WTtcblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucywgTWF0aC5tYXgobWluQ29scywgbmV3WCkpO1xuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cywgTWF0aC5tYXgobWluUm93cywgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0KG5ld1gsIG5ld1ksIDAsIDApO1xuICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KG5ld1gsIG5ld1kpKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsQ29sSXNWaXNpYmxlKG5ld1gsIG9mZnNldFgpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSwgb2Zmc2V0WSkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsU2VsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sdW1uQXV0b3NpemluZyA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5BdXRvc2l6aW5nJywge1xuXG4gICAgLyoqXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uQXV0b3NpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAvL3ZhciBoZWFkZXJDb2xDb3VudCA9IGdyaWQuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIGlmIChncmlkQ2VsbC55IDw9IGhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICBncmlkLmF1dG9zaXplQ29sdW1uKGdyaWRDZWxsLngpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uQXV0b3NpemluZztcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyogZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmVhdHVyZSBpcyByZXNwb25zaWJsZSBmb3IgY29sdW1uIGRyYWcgYW5kIGRyb3AgcmVvcmRlcmluZy5cbi8vIFRoaXMgb2JqZWN0IGlzIGEgbWVzcyBhbmQgZGVzcGVyYXRlbHkgbmVlZHMgYSBjb21wbGV0ZSByZXdyaXRlLi4uLi5cblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxudmFyIGNvbHVtbkFuaW1hdGlvblRpbWUgPSAxNTA7XG52YXIgZHJhZ2dlcjtcbnZhciBkcmFnZ2VyQ1RYO1xudmFyIGZsb2F0Q29sdW1uO1xudmFyIGZsb2F0Q29sdW1uQ1RYO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sdW1uTW92aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtbk1vdmluZycsIHtcblxuICAgIC8qKlxuICAgICAqIHF1ZXVlIHVwIHRoZSBhbmltYXRpb25zIHRoYXQgbmVlZCB0byBwbGF5IHNvIHRoZXkgYXJlIGRvbmUgc3luY2hyb25vdXNseVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmbG9hdGVyQW5pbWF0aW9uUXVldWU6IFtdLFxuXG4gICAgLyoqXG4gICAgICogYW0gSSBjdXJyZW50bHkgYXV0byBzY3JvbGxpbmcgcmlnaHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgY3VycmVudGx5IGF1dG8gc2Nyb2xsaW5nIGxlZnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogaXMgdGhlIGRyYWcgbWVjaGFuaXNtIGN1cnJlbnRseSBlbmFibGVkIChcImFybWVkXCIpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0FybWVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgZHJhZ2dpbmcgcmlnaHQgbm93XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNvbHVtbiBpbmRleCBvZiB0aGUgY3VycmVudGx5IGRyYWdnZWQgY29sdW1uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnQ29sOiAtMSxcblxuICAgIC8qKlxuICAgICAqIGFuIG9mZnNldCB0byBwb3NpdGlvbiB0aGUgZHJhZ2dlZCBpdGVtIGZyb20gdGhlIGN1cnNvclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ09mZnNldDogMCxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdpdmUgbWUgYW4gb3Bwb3J0dW5pdHkgdG8gaW5pdGlhbGl6ZSBzdHVmZiBvbiB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZU9uOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuaXNGbG9hdGluZ05vdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0KGdyaWQpO1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGluaXRpYWxpemUgYW5pbWF0aW9uIHN1cHBvcnQgb24gdGhlIGdyaWRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICghZHJhZ2dlcikge1xuICAgICAgICAgICAgZHJhZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgZHJhZ2dlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzBweCcpO1xuICAgICAgICAgICAgZHJhZ2dlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwcHgnKTtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkcmFnZ2VyKTtcbiAgICAgICAgICAgIGRyYWdnZXJDVFggPSBkcmFnZ2VyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbG9hdENvbHVtbikge1xuICAgICAgICAgICAgZmxvYXRDb2x1bW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGZsb2F0Q29sdW1uLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMHB4Jyk7XG4gICAgICAgICAgICBmbG9hdENvbHVtbi5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwcHgnKTtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmbG9hdENvbHVtbik7XG4gICAgICAgICAgICBmbG9hdENvbHVtbkNUWCA9IGZsb2F0Q29sdW1uLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBnZXRDYW5EcmFnQ3Vyc29yTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC1ncmFiJztcbiAgICB9LFxuXG4gICAgZ2V0RHJhZ2dpbmdDdXJzb3JOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICctd2Via2l0LWdyYWJiaW5nJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgLy92YXIgeTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyhldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuZHJhZ3N0YXJ0LnggLSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueCk7XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgMTApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzSGVhZGVyUm93KGdyaWQsIGV2ZW50KSAmJiB0aGlzLmRyYWdBcm1lZCAmJiAhdGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRyYWdDb2wgPSBncmlkQ2VsbC54O1xuICAgICAgICAgICAgdGhpcy5kcmFnT2Zmc2V0ID0gZXZlbnQubW91c2VQb2ludC54O1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hDaGFpbigpO1xuICAgICAgICAgICAgeCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS54IC0gdGhpcy5kcmFnT2Zmc2V0O1xuICAgICAgICAgICAgLy95ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURyYWdDb2x1bW4oZ3JpZCwgeCwgdGhpcy5kcmFnQ29sKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHggPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueCAtIHRoaXMuZHJhZ09mZnNldDtcbiAgICAgICAgICAgIC8veSA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS55O1xuICAgICAgICAgICAgdGhpcy5kcmFnQ29sdW1uKGdyaWQsIHgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGdyaWQuYmVoYXZpb3IuaXNDb2x1bW5SZW9yZGVyYWJsZSgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0hlYWRlclJvdyhncmlkLCBldmVudCkgJiYgZXZlbnQuZ3JpZENlbGwueCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmdldERyYWdnaW5nQ3Vyc29yTmFtZSgpO1xuICAgICAgICAgICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgLy92YXIgY29sID0gZXZlbnQuZ3JpZENlbGwueDtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIC8vZGVsYXkgaGVyZSB0byBnaXZlIG90aGVyIGV2ZW50cyBhIGNoYW5jZSB0byBiZSBkcm9wcGVkXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVuZERyYWdDb2x1bW4oZ3JpZCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoQ2hhaW4oKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnQ29sID0gLTE7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnQXJtZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcblxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nICYmIGV2ZW50Lm1vdXNlUG9pbnQueSA8IDUgJiYgZXZlbnQudmlld1BvaW50LnkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gdGhpcy5nZXRDYW5EcmFnQ3Vyc29yTmFtZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0hlYWRlclJvdyhncmlkLCBldmVudCkgJiYgdGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmdldERyYWdnaW5nQ3Vyc29yTmFtZSgpOyAvL21vdmUnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgaXMgdGhlIG1haW4gZXZlbnQgaGFuZGxlciB0aGF0IG1hbmFnZXMgdGhlIGRyYWdnaW5nIG9mIHRoZSBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZHJhZ2dlZFRvVGhlUmlnaHQgLSBhcmUgd2UgbW92aW5nIHRvIHRoZSByaWdodFxuICAgICAqL1xuICAgIGZsb2F0Q29sdW1uVG86IGZ1bmN0aW9uKGdyaWQsIGRyYWdnZWRUb1RoZVJpZ2h0KSB7XG4gICAgICAgIHRoaXMuZmxvYXRpbmdOb3cgPSB0cnVlO1xuXG4gICAgICAgIHZhciByZW5kZXJlciA9IGdyaWQuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgdmFyIGNvbEVkZ2VzID0gcmVuZGVyZXIuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICB2YXIgZmxvYXRlckluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyLmNvbHVtbkluZGV4O1xuICAgICAgICB2YXIgZHJhZ2dlckluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuICAgICAgICB2YXIgaGRwaXJhdGlvID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmhkcGlyYXRpbztcblxuICAgICAgICB2YXIgZHJhZ2dlclN0YXJ0WDtcbiAgICAgICAgdmFyIGZsb2F0ZXJTdGFydFg7XG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBkcmFnZ2VyV2lkdGggPSBncmlkLmdldENvbHVtbldpZHRoKGRyYWdnZXJJbmRleCk7XG4gICAgICAgIHZhciBmbG9hdGVyV2lkdGggPSBncmlkLmdldENvbHVtbldpZHRoKGZsb2F0ZXJJbmRleCk7XG5cbiAgICAgICAgdmFyIG1heCA9IGdyaWQuZ2V0VmlzaWJsZUNvbHVtbnNDb3VudCgpO1xuXG4gICAgICAgIHZhciBkb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGZvZmZzZXQgPSAwO1xuXG4gICAgICAgIGlmIChkcmFnZ2VySW5kZXggPj0gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgZG9mZnNldCA9IHNjcm9sbExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsb2F0ZXJJbmRleCA+PSBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBmb2Zmc2V0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmFnZ2VkVG9UaGVSaWdodCkge1xuICAgICAgICAgICAgZHJhZ2dlclN0YXJ0WCA9IGNvbEVkZ2VzW01hdGgubWluKG1heCwgZHJhZ2dlckluZGV4IC0gZG9mZnNldCldO1xuICAgICAgICAgICAgZmxvYXRlclN0YXJ0WCA9IGNvbEVkZ2VzW01hdGgubWluKG1heCwgZmxvYXRlckluZGV4IC0gZm9mZnNldCldO1xuXG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuc3RhcnRYID0gKGRyYWdnZXJTdGFydFggKyBmbG9hdGVyV2lkdGgpICogaGRwaXJhdGlvO1xuICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyLnN0YXJ0WCA9IGRyYWdnZXJTdGFydFggKiBoZHBpcmF0aW87XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsb2F0ZXJTdGFydFggPSBjb2xFZGdlc1tNYXRoLm1pbihtYXgsIGZsb2F0ZXJJbmRleCAtIGZvZmZzZXQpXTtcbiAgICAgICAgICAgIGRyYWdnZXJTdGFydFggPSBmbG9hdGVyU3RhcnRYICsgZHJhZ2dlcldpZHRoO1xuXG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuc3RhcnRYID0gZmxvYXRlclN0YXJ0WCAqIGhkcGlyYXRpbztcbiAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlci5zdGFydFggPSBkcmFnZ2VyU3RhcnRYICogaGRwaXJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGdyaWQuc3dhcENvbHVtbnMoZHJhZ2dlckluZGV4LCBmbG9hdGVySW5kZXgpO1xuICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXggPSBmbG9hdGVySW5kZXg7XG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlci5jb2x1bW5JbmRleCA9IGRyYWdnZXJJbmRleDtcblxuXG4gICAgICAgIHRoaXMuZmxvYXRlckFuaW1hdGlvblF1ZXVlLnVuc2hpZnQodGhpcy5kb0NvbHVtbk1vdmVBbmltYXRpb24oZ3JpZCwgZmxvYXRlclN0YXJ0WCwgZHJhZ2dlclN0YXJ0WCkpO1xuXG4gICAgICAgIHRoaXMuZG9GbG9hdGVyQW5pbWF0aW9uKGdyaWQpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIG1hbmlmZXN0IHRoZSBjb2x1bW4gZHJhZyBhbmQgZHJvcCBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmbG9hdGVyU3RhcnRYIC0gdGhlIHggc3RhcnQgY29vcmRpbmF0ZSBvZiB0aGUgY29sdW1uIHVuZGVybmVhdGggdGhhdCBmbG9hdHMgYmVoaW5kIHRoZSBkcmFnZ2VkIGNvbHVtblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkcmFnZ2VyU3RhcnRYIC0gdGhlIHggc3RhcnQgY29vcmRpbmF0ZSBvZiB0aGUgZHJhZ2dlZCBjb2x1bW5cbiAgICAgKi9cbiAgICBkb0NvbHVtbk1vdmVBbmltYXRpb246IGZ1bmN0aW9uKGdyaWQsIGZsb2F0ZXJTdGFydFgsIGRyYWdnZXJTdGFydFgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGZsb2F0Q29sdW1uO1xuICAgICAgICAgICAgZC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBmbG9hdGVyU3RhcnRYICsgJ3B4LCAnICsgMCArICdweCknKTtcblxuICAgICAgICAgICAgLy9kLnN0eWxlLndlYmtpdC13ZWJraXQtVHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgZmxvYXRlclN0YXJ0WCArICdweCwgJyArIDAgKyAncHgpJztcbiAgICAgICAgICAgIC8vZC5zdHlsZS53ZWJraXQtd2Via2l0LVRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIGZsb2F0ZXJTdGFydFggKyAncHgsICcgKyAwICsgJ3B4KSc7XG5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2l0aW9uJywgKHNlbGYuaXNXZWJraXQgPyAnLXdlYmtpdC0nIDogJycpICsgJ3RyYW5zZm9ybSAnICsgY29sdW1uQW5pbWF0aW9uVGltZSArICdtcyBlYXNlJyk7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgZHJhZ2dlclN0YXJ0WCArICdweCwgJyArIC0yICsgJ3B4KScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIC8vbmVlZCB0byBjaGFuZ2UgdGhpcyB0byBrZXkgZnJhbWVzXG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9GbG9hdGVyQW5pbWF0aW9uKGdyaWQpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmlzRmxvYXRpbmdOb3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGNvbHVtbkFuaW1hdGlvblRpbWUgKyA1MCk7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIG1hbmlmZXN0IHRoZSBmbG9hdGVyIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZG9GbG9hdGVyQW5pbWF0aW9uOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLmZsb2F0ZXJBbmltYXRpb25RdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmxvYXRpbmdOb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmZsb2F0ZXJBbmltYXRpb25RdWV1ZS5wb3AoKTtcbiAgICAgICAgYW5pbWF0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNyZWF0ZSB0aGUgZmxvYXQgY29sdW1uIGF0IGNvbHVtbkluZGV4IHVuZGVybmVhdGggdGhlIGRyYWdnZWQgY29sdW1uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGNvbHVtbiB0aGF0IHdpbGwgYmUgZmxvYXRpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVGbG9hdENvbHVtbjogZnVuY3Rpb24oZ3JpZCwgY29sdW1uSW5kZXgpIHtcblxuICAgICAgICB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgaWYgKGNvbHVtbkluZGV4IDwgZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVuZGVyZXIgPSBncmlkLmdldFJlbmRlcmVyKCk7XG4gICAgICAgIHZhciBjb2x1bW5FZGdlcyA9IHJlbmRlcmVyLmdldENvbHVtbkVkZ2VzKCk7XG5cbiAgICAgICAgdmFyIGNvbHVtbldpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCk7XG4gICAgICAgIHZhciBjb2xIZWlnaHQgPSBncmlkLmRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBkID0gZmxvYXRDb2x1bW47XG4gICAgICAgIHZhciBzdHlsZSA9IGQuc3R5bGU7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGdyaWQuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHN0eWxlLnRvcCA9IChsb2NhdGlvbi50b3AgLSAyKSArICdweCc7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBsb2NhdGlvbi5sZWZ0ICsgJ3B4JztcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBncmlkLmdldEhpRFBJKGZsb2F0Q29sdW1uQ1RYKTtcblxuICAgICAgICBkLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBNYXRoLnJvdW5kKGNvbHVtbldpZHRoICogaGRwaVJhdGlvKSArICdweCcpO1xuICAgICAgICBkLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgTWF0aC5yb3VuZChjb2xIZWlnaHQgKiBoZHBpUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgIHN0eWxlLmJveFNoYWRvdyA9ICcwIDEwcHggMjBweCByZ2JhKDAsMCwwLDAuMTkpLCAwIDZweCA2cHggcmdiYSgwLDAsMCwwLjIzKSc7XG4gICAgICAgIHN0eWxlLndpZHRoID0gY29sdW1uV2lkdGggKyAncHgnOyAvL01hdGgucm91bmQoY29sdW1uV2lkdGggLyBoZHBpUmF0aW8pICsgJ3B4JztcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gY29sSGVpZ2h0ICsgJ3B4JzsgLy9NYXRoLnJvdW5kKGNvbEhlaWdodCAvIGhkcGlSYXRpbykgKyAncHgnO1xuICAgICAgICBzdHlsZS5ib3JkZXJUb3AgPSAnMXB4IHNvbGlkICcgKyByZW5kZXJlci5yZXNvbHZlUHJvcGVydHkoJ2xpbmVDb2xvcicpO1xuICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByZW5kZXJlci5yZXNvbHZlUHJvcGVydHkoJ2JhY2tncm91bmRDb2xvcicpO1xuXG4gICAgICAgIHZhciBzdGFydFggPSBjb2x1bW5FZGdlc1tjb2x1bW5JbmRleCAtIHNjcm9sbExlZnRdO1xuICAgICAgICBzdGFydFggPSBzdGFydFggKiBoZHBpUmF0aW87XG5cbiAgICAgICAgZmxvYXRDb2x1bW5DVFguc2NhbGUoaGRwaVJhdGlvLCBoZHBpUmF0aW8pO1xuXG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlciA9IHtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgIGN0eDogZmxvYXRDb2x1bW5DVFgsXG4gICAgICAgICAgICBzdGFydFg6IHN0YXJ0WCxcbiAgICAgICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY29sSGVpZ2h0LFxuICAgICAgICAgICAgaGRwaXJhdGlvOiBoZHBpUmF0aW9cbiAgICAgICAgfTtcblxuICAgICAgICBzdHlsZS56SW5kZXggPSAnNCc7XG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHN0YXJ0WCArICdweCwgJyArIC0yICsgJ3B4KScpO1xuICAgICAgICBzdHlsZS5jdXJzb3IgPSB0aGlzLmdldERyYWdnaW5nQ3Vyc29yTmFtZSgpO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBmdW5jdGlvbiBmb3Igc2V0dGluZyBjcm9zcyBicm93c2VyIGNzcyBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGRlc2NyaXB0b25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYXNzaWduXG4gICAgICovXG4gICAgc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHk6IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdVByb3BlcnR5ID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnN1YnN0cigxKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsICd3ZWJraXQnICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnTW96JyArIHVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ21zJyArIHVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ08nICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IGZ1bmN0aW9uIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgb24gSFRNTEVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGRlc2NyaXB0b25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYXNzaWduXG4gICAgICovXG4gICAgc2V0UHJvcDogZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eSBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNyZWF0ZSB0aGUgZHJhZ2dlZCBjb2x1bW4gYXQgY29sdW1uSW5kZXggYWJvdmUgdGhlIGZsb2F0ZWQgY29sdW1uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHRoYXQgd2lsbCBiZSBmbG9hdGluZ1xuICAgICAqL1xuICAgIGNyZWF0ZURyYWdDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIHgsIGNvbHVtbkluZGV4KSB7XG5cbiAgICAgICAgdmFyIGZpeGVkQ29sdW1uQ291bnQgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIGlmIChjb2x1bW5JbmRleCA8IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZ3JpZC5nZXRSZW5kZXJlcigpO1xuICAgICAgICB2YXIgY29sdW1uRWRnZXMgPSByZW5kZXJlci5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgaGRwaVJhdGlvID0gZ3JpZC5nZXRIaURQSShkcmFnZ2VyQ1RYKTtcbiAgICAgICAgdmFyIGNvbHVtbldpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCk7XG4gICAgICAgIHZhciBjb2xIZWlnaHQgPSBncmlkLmRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBkID0gZHJhZ2dlcjtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gZ3JpZC5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBzdHlsZSA9IGQuc3R5bGU7XG5cbiAgICAgICAgc3R5bGUudG9wID0gbG9jYXRpb24udG9wICsgJ3B4JztcbiAgICAgICAgc3R5bGUubGVmdCA9IGxvY2F0aW9uLmxlZnQgKyAncHgnO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIHN0eWxlLm9wYWNpdHkgPSAwLjg1O1xuICAgICAgICBzdHlsZS5ib3hTaGFkb3cgPSAnMCAxOXB4IDM4cHggcmdiYSgwLDAsMCwwLjMwKSwgMCAxNXB4IDEycHggcmdiYSgwLDAsMCwwLjIyKSc7XG4gICAgICAgIC8vc3R5bGUuekluZGV4ID0gMTAwO1xuICAgICAgICBzdHlsZS5ib3JkZXJUb3AgPSAnMXB4IHNvbGlkICcgKyByZW5kZXJlci5yZXNvbHZlUHJvcGVydHkoJ2xpbmVDb2xvcicpO1xuICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBncmlkLnJlbmRlcmVyLnJlc29sdmVQcm9wZXJ0eSgnYmFja2dyb3VuZENvbG9yJyk7XG5cbiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgTWF0aC5yb3VuZChjb2x1bW5XaWR0aCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIE1hdGgucm91bmQoY29sSGVpZ2h0ICogaGRwaVJhdGlvKSArICdweCcpO1xuXG4gICAgICAgIHN0eWxlLndpZHRoID0gY29sdW1uV2lkdGggKyAncHgnOyAvL01hdGgucm91bmQoY29sdW1uV2lkdGggLyBoZHBpUmF0aW8pICsgJ3B4JztcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gY29sSGVpZ2h0ICsgJ3B4JzsgLy9NYXRoLnJvdW5kKGNvbEhlaWdodCAvIGhkcGlSYXRpbykgKyAncHgnO1xuXG4gICAgICAgIHZhciBzdGFydFggPSBjb2x1bW5FZGdlc1tjb2x1bW5JbmRleCAtIHNjcm9sbExlZnRdO1xuICAgICAgICBzdGFydFggPSBzdGFydFggKiBoZHBpUmF0aW87XG5cbiAgICAgICAgZHJhZ2dlckNUWC5zY2FsZShoZHBpUmF0aW8sIGhkcGlSYXRpbyk7XG5cbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyID0ge1xuICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbkluZGV4LFxuICAgICAgICAgICAgY3R4OiBkcmFnZ2VyQ1RYLFxuICAgICAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbEhlaWdodCxcbiAgICAgICAgICAgIGhkcGlyYXRpbzogaGRwaVJhdGlvXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeCArICdweCwgLTVweCknKTtcbiAgICAgICAgc3R5bGUuekluZGV4ID0gJzUnO1xuICAgICAgICBzdHlsZS5jdXJzb3IgPSB0aGlzLmdldERyYWdnaW5nQ3Vyc29yTmFtZSgpO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyB0aGUgbWFpbiBkcmFnZ2luZyBsb2dpY1xuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgc3RhcnQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBkcmFnQ29sdW1uOiBmdW5jdGlvbihncmlkLCB4KSB7XG5cbiAgICAgICAgLy9UT0RPOiB0aGlzIGZ1bmN0aW9uIGlzIG92ZXJseSBjb21wbGV4LCByZWZhY3RvciB0aGlzIGluIHRvIHNvbWV0aGluZyBtb3JlIHJlYXNvbmFibGVcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAvL3ZhciByZW5kZXJlciA9IGdyaWQuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgLy92YXIgY29sdW1uRWRnZXMgPSByZW5kZXJlci5nZXRDb2x1bW5FZGdlcygpO1xuXG4gICAgICAgIHZhciBhdXRvU2Nyb2xsaW5nTm93ID0gdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0IHx8IHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0O1xuXG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBncmlkLmdldEhpRFBJKGRyYWdnZXJDVFgpO1xuXG4gICAgICAgIHZhciBkcmFnQ29sdW1uSW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIHZhciBjb2x1bW5XaWR0aCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci53aWR0aDtcblxuICAgICAgICB2YXIgbWluWCA9IDA7IC8vZ3JpZC5nZXRGaXhlZENvbHVtbnNXaWR0aCgpO1xuICAgICAgICB2YXIgbWF4WCA9IGdyaWQucmVuZGVyZXIuZ2V0RmluYWxWaXNhYmxlQ29sdW1uQm91bmRhcnkoKSAtIGNvbHVtbldpZHRoO1xuICAgICAgICB4ID0gTWF0aC5taW4oeCwgbWF4WCArIDE1KTtcbiAgICAgICAgeCA9IE1hdGgubWF4KG1pblggLSAxNSwgeCk7XG5cbiAgICAgICAgLy9hbSBJIGF0IG15IGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciBhdE1pbiA9IHggPCBtaW5YICYmIGRyYWdDb2x1bW5JbmRleCAhPT0gMDtcblxuICAgICAgICAvL2FtIEkgYXQgbXkgdXBwZXIgYm91bmRcbiAgICAgICAgdmFyIGF0TWF4ID0geCA+IG1heFg7XG5cbiAgICAgICAgdmFyIGQgPSBkcmFnZ2VyO1xuXG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zaXRpb24nLCAoc2VsZi5pc1dlYmtpdCA/ICctd2Via2l0LScgOiAnJykgKyAndHJhbnNmb3JtICcgKyAwICsgJ21zIGVhc2UsIGJveC1zaGFkb3cgJyArIGNvbHVtbkFuaW1hdGlvblRpbWUgKyAnbXMgZWFzZScpO1xuXG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHggKyAncHgsICcgKyAtMTAgKyAncHgpJyk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgb3ZlckNvbCA9IGdyaWQucmVuZGVyZXIuZ2V0Q29sdW1uRnJvbVBpeGVsWCh4ICsgKGQud2lkdGggLyAyIC8gaGRwaVJhdGlvKSk7XG5cbiAgICAgICAgaWYgKGF0TWluKSB7XG4gICAgICAgICAgICBvdmVyQ29sID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdE1heCkge1xuICAgICAgICAgICAgb3ZlckNvbCA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG9BRmxvYXQgPSBkcmFnQ29sdW1uSW5kZXggPiBvdmVyQ29sO1xuICAgICAgICBkb0FGbG9hdCA9IGRvQUZsb2F0IHx8IChvdmVyQ29sIC0gZHJhZ0NvbHVtbkluZGV4ID49IDEpO1xuXG4gICAgICAgIGlmIChkb0FGbG9hdCAmJiAhYXRNYXggJiYgIWF1dG9TY3JvbGxpbmdOb3cpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2VkVG9UaGVSaWdodCA9IGRyYWdDb2x1bW5JbmRleCA8IG92ZXJDb2w7XG4gICAgICAgICAgICAvLyBpZiAoZHJhZ2dlZFRvVGhlUmlnaHQpIHtcbiAgICAgICAgICAgIC8vICAgICBvdmVyQ29sID0gb3ZlckNvbCAtIDE7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Zsb2F0aW5nTm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmlzRmxvYXRpbmdOb3cgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGbG9hdENvbHVtbihncmlkLCBvdmVyQ29sKTtcbiAgICAgICAgICAgIHRoaXMuZmxvYXRDb2x1bW5UbyhncmlkLCBkcmFnZ2VkVG9UaGVSaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICh4IDwgbWluWCAtIDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0F1dG9TY3JvbGxUb0xlZnQoZ3JpZCwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA+IG1pblggLSAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2xldHMgY2hlY2sgZm9yIGF1dG9zY3JvbGwgdG8gcmlnaHQgaWYgd2VyZSB1cCBhZ2FpbnN0IGl0XG4gICAgICAgICAgICBpZiAoYXRNYXggfHwgeCA+IG1heFggKyAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tBdXRvU2Nyb2xsVG9SaWdodChncmlkLCB4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA8IG1heFggKyAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGF1dG9zY3JvbGwgdG8gdGhlIHJpZ2h0IGlmIG5lY2Vzc2FyeVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgc3RhcnQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBjaGVja0F1dG9TY3JvbGxUb1JpZ2h0OiBmdW5jdGlvbihncmlkLCB4KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nUmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nUmlnaHQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jaGVja0F1dG9TY3JvbGxUb1JpZ2h0KGdyaWQsIHgpO1xuICAgIH0sXG5cbiAgICBfY2hlY2tBdXRvU2Nyb2xsVG9SaWdodDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAoIXRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgaWYgKCFncmlkLmRyYWdnaW5nIHx8IHNjcm9sbExlZnQgPiAoZ3JpZC5zYkhTY3JvbGxDb25maWcucmFuZ2VTdG9wIC0gMikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHJhZ2dlZEluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuICAgICAgICBncmlkLnNjcm9sbEJ5KDEsIDApO1xuICAgICAgICB2YXIgbmV3SW5kZXggPSBkcmFnZ2VkSW5kZXggKyAxO1xuICAgICAgICBjb25zb2xlLmxvZyhuZXdJbmRleCwgZHJhZ2dlZEluZGV4KTtcbiAgICAgICAgZ3JpZC5zd2FwQ29sdW1ucyhuZXdJbmRleCwgZHJhZ2dlZEluZGV4KTtcbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4ID0gbmV3SW5kZXg7XG5cbiAgICAgICAgc2V0VGltZW91dCh0aGlzLl9jaGVja0F1dG9TY3JvbGxUb1JpZ2h0LmJpbmQodGhpcywgZ3JpZCwgeCksIDI1MCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGF1dG9zY3JvbGwgdG8gdGhlIGxlZnQgaWYgbmVjZXNzYXJ5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBzdGFydCBwb3NpdGlvblxuICAgICAqL1xuICAgIGNoZWNrQXV0b1Njcm9sbFRvTGVmdDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NoZWNrQXV0b1Njcm9sbFRvTGVmdChncmlkLCB4KTtcbiAgICB9LFxuXG4gICAgX2NoZWNrQXV0b1Njcm9sbFRvTGVmdDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAoIXRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIGlmICghZ3JpZC5kcmFnZ2luZyB8fCBzY3JvbGxMZWZ0IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcmFnZ2VkSW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIGdyaWQuc3dhcENvbHVtbnMoZHJhZ2dlZEluZGV4ICsgc2Nyb2xsTGVmdCwgZHJhZ2dlZEluZGV4ICsgc2Nyb2xsTGVmdCAtIDEpO1xuICAgICAgICBncmlkLnNjcm9sbEJ5KC0xLCAwKTtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLl9jaGVja0F1dG9TY3JvbGxUb0xlZnQuYmluZCh0aGlzLCBncmlkLCB4KSwgMjUwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgYSBjb2x1bW4gZHJhZyBoYXMgY29tcGxldGVkLCB1cGRhdGUgZGF0YSBhbmQgY2xlYW51cFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZW5kRHJhZ0NvbHVtbjogZnVuY3Rpb24oZ3JpZCkge1xuXG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICB2YXIgY29sdW1uSW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG5cbiAgICAgICAgaWYgKGNvbHVtbkluZGV4IDwgZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVuZGVyZXIgPSBncmlkLmdldFJlbmRlcmVyKCk7XG4gICAgICAgIHZhciBjb2x1bW5FZGdlcyA9IHJlbmRlcmVyLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXJ0WCA9IGNvbHVtbkVkZ2VzW2NvbHVtbkluZGV4IC0gc2Nyb2xsTGVmdF07XG4gICAgICAgIHZhciBkID0gZHJhZ2dlcjtcblxuICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2l0aW9uJywgKHNlbGYuaXNXZWJraXQgPyAnLXdlYmtpdC0nIDogJycpICsgJ3RyYW5zZm9ybSAnICsgY29sdW1uQW5pbWF0aW9uVGltZSArICdtcyBlYXNlLCBib3gtc2hhZG93ICcgKyBjb2x1bW5BbmltYXRpb25UaW1lICsgJ21zIGVhc2UnKTtcbiAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgc3RhcnRYICsgJ3B4LCAnICsgLTEgKyAncHgpJyk7XG4gICAgICAgIGQuc3R5bGUuYm94U2hhZG93ID0gJzBweCAwcHggMHB4ICM4ODg4ODgnO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIgPSBudWxsO1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIGdyaWQuZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGNvbHVtbkFuaW1hdGlvblRpbWUgKyA1MCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0hlYWRlclJvdzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgaXNGaXhlZCA9IGdyaWRDZWxsLnkgPT09IDA7XG4gICAgICAgIHJldHVybiBpc0ZpeGVkO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uTW92aW5nO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG4vKiBnbG9iYWwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENvbHVtblBpY2tlciA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5QaWNrZXInLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUGlja2VyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5VXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXkgPSBldmVudC5kZXRhaWwuY2hhci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIga2V5cyA9IGdyaWQucmVzb2x2ZVByb3BlcnR5KCdlZGl0b3JBY3RpdmF0aW9uS2V5cycpO1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICBncmlkLnRvZ2dsZUNvbHVtblBpY2tlcigpO1xuICAgICAgICB9XG4gICAgfSxcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uUGlja2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sdW1uUmVzaXppbmcgPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uUmVzaXppbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiB0aGUgaW5kZXggb2YgdGhlIGNvbHVtbiB3YWxsIHdlcmUgY3VycmVudGx5IGRyYWdnaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnSW5kZXg6IC0yLFxuXG4gICAgLyoqXG4gICAgICogdGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSB3aGVyZSB0aGUgZHJhZyB3YXMgaW5pdGlhdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnU3RhcnQ6IC0xLFxuXG4gICAgLyoqXG4gICAgICogdGhlIHN0YXJ0aW5nIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiB3ZSBhcmUgZHJhZ2dpbmdcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdJbmRleFN0YXJ0aW5nU2l6ZTogLTEsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IHRoZSBtb3VzZSB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIHRoZSBtb3VzZSBldmVudCB0byBxdWVyeVxuICAgICAqL1xuICAgIGdldE1vdXNlVmFsdWU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldCB0aGUgZ3JpZCBjZWxsIHgseSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXIuUG9pbnR9IGdyaWRDZWxsXG4gICAgICovXG4gICAgZ2V0R3JpZENlbGxWYWx1ZTogZnVuY3Rpb24oZ3JpZENlbGwpIHtcbiAgICAgICAgcmV0dXJuIGdyaWRDZWxsLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGdyaWRzIHgseSBzY3JvbGwgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiBvZiBpbnRlcmVzdFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgcm93L2NvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldEFyZWFTaXplOiBmdW5jdGlvbihncmlkLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRDb2x1bW5XaWR0aChpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiBhdCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgcm93L2NvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHRoZSB3aWR0aC9oZWlnaHQgdG8gc2V0IHRvXG4gICAgICovXG4gICAgc2V0QXJlYVNpemU6IGZ1bmN0aW9uKGdyaWQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBncmlkLnNldENvbHVtbldpZHRoKGluZGV4LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIHJlY2VudGx5IHJlbmRlcmVkIGFyZWEncyB3aWR0aC9oZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRQcmV2aW91c0Fic29sdXRlU2l6ZTogZnVuY3Rpb24oZ3JpZCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0UmVuZGVyZWRXaWR0aChpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm5zIHRoZSBpbmRleCBvZiB3aGljaCBkaXZpZGVyIEknbSBvdmVyXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb3ZlckFyZWFEaXZpZGVyOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5vdmVyQ29sdW1uRGl2aWRlcihldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbSBJIG92ZXIgdGhlIGNvbHVtbi9yb3cgYXJlYVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpcnN0Rml4ZWRPdGhlckFyZWE6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRmlyc3RGaXhlZFJvdyhncmlkLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGN1cnNvciBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDdXJzb3JOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdjb2wtcmVzaXplJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0luZGV4ID4gLTIpIHtcbiAgICAgICAgICAgIC8vdmFyIGZpeGVkQXJlYUNvdW50ID0gdGhpcy5nZXRGaXhlZEFyZWFDb3VudChncmlkKTtcbiAgICAgICAgICAgIC8vdmFyIG9mZnNldCA9IHRoaXMuZ2V0Rml4ZWRBcmVhU2l6ZShncmlkLCBmaXhlZEFyZWFDb3VudCArIGFyZWFJbmRleCk7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSB0aGlzLmdldE1vdXNlVmFsdWUoZXZlbnQpO1xuICAgICAgICAgICAgdmFyIHNjcm9sbFZhbHVlID0gdGhpcy5nZXRTY3JvbGxWYWx1ZShncmlkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWdJbmRleCA8IHRoaXMuZ2V0Rml4ZWRBcmVhQ291bnQoZ3JpZCkpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxWYWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLmdldFByZXZpb3VzQWJzb2x1dGVTaXplKGdyaWQsIHRoaXMuZHJhZ0luZGV4IC0gc2Nyb2xsVmFsdWUpO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gbW91c2UgLSBwcmV2aW91cztcbiAgICAgICAgICAgIHRoaXMuc2V0QXJlYVNpemUoZ3JpZCwgdGhpcy5kcmFnSW5kZXgsIGRpc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXQgdGhlIHdpZHRoL2hlaWdodCBvZiBhIHNwZWNpZmljIHJvdy9jb2x1bW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmVhSW5kZXggLSB0aGUgcm93L2NvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldFNpemU6IGZ1bmN0aW9uKGdyaWQsIGFyZWFJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBcmVhU2l6ZShncmlkLCBhcmVhSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBmaXhlZCBhcmVhIHJvd3MvY29sdW1ucyBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBnZXRPdGhlckZpeGVkQXJlYUNvdW50OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNFbmFibGVkID0gdGhpcy5pc0VuYWJsZWQoZ3JpZCk7XG4gICAgICAgIHZhciBvdmVyQXJlYSA9IHRoaXMub3ZlckFyZWFEaXZpZGVyKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCAmJiBvdmVyQXJlYSA+IC0xICYmIHRoaXMuaXNGaXJzdEZpeGVkT3RoZXJBcmVhKGdyaWQsIGV2ZW50KSkge1xuICAgICAgICAgICAgdmFyIHNjcm9sbFZhbHVlID0gdGhpcy5nZXRTY3JvbGxWYWx1ZShncmlkKTtcbiAgICAgICAgICAgIGlmIChvdmVyQXJlYSA8IHRoaXMuZ2V0Rml4ZWRBcmVhQ291bnQoZ3JpZCkpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxWYWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYWdJbmRleCA9IG92ZXJBcmVhIC0gMSArIHNjcm9sbFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnQgPSB0aGlzLmdldE1vdXNlVmFsdWUoZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5kcmFnSW5kZXhTdGFydGluZ1NpemUgPSAwO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hDaGFpbigpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRW5hYmxlZCA9IHRoaXMuaXNFbmFibGVkKGdyaWQpO1xuICAgICAgICBpZiAoaXNFbmFibGVkICYmIHRoaXMuZHJhZ0luZGV4ID4gLTIpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0luZGV4ID0gLTI7XG5cbiAgICAgICAgICAgIGV2ZW50LnByaW1pdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgLy9kZWxheSBoZXJlIHRvIGdpdmUgb3RoZXIgZXZlbnRzIGEgY2hhbmNlIHRvIGJlIGRyb3BwZWRcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGdyaWQuc3luY2hyb25pemVTY3JvbGxpbmdCb3VuZHJpZXMoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hDaGFpbigpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdJbmRleCA+IC0yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrRm9yQXJlYVJlc2l6ZUN1cnNvckNoYW5nZShncmlkLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBmaWxsIHRoaXMgaW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgY2hlY2tGb3JBcmVhUmVzaXplQ3Vyc29yQ2hhbmdlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNFbmFibGVkID0gdGhpcy5pc0VuYWJsZWQoZ3JpZCk7XG4gICAgICAgIGlmIChpc0VuYWJsZWQgJiYgdGhpcy5vdmVyQXJlYURpdmlkZXIoZ3JpZCwgZXZlbnQpID4gLTEgJiYgdGhpcy5pc0ZpcnN0Rml4ZWRPdGhlckFyZWEoZ3JpZCwgZXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMuZ2V0Q3Vyc29yTmFtZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0yXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEZpeGVkQXJlYUNvdW50OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHZhciBjb3VudCA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpICsgKGdyaWQuaXNTaG93Um93TnVtYmVycygpID8gMSA6IDApICsgKGdyaWQuaGFzSGllcmFyY2h5Q29sdW1uKCkgPyAxIDogMCk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRW5hYmxlZCA9IHRoaXMuaXNFbmFibGVkKGdyaWQpO1xuICAgICAgICB2YXIgaGFzQ3Vyc29yID0gdGhpcy5vdmVyQXJlYURpdmlkZXIoZ3JpZCwgZXZlbnQpID4gLTE7IC8vdGhpcy5jdXJzb3IgIT09IG51bGw7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgLy92YXIgaGVhZGVyQ29sQ291bnQgPSBncmlkLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICBpZiAoaXNFbmFibGVkICYmIGhhc0N1cnNvciAmJiAoZ3JpZENlbGwueSA8PSBoZWFkZXJSb3dDb3VudCkpIHtcbiAgICAgICAgICAgIGdyaWQuYXV0b3NpemVDb2x1bW4oZ3JpZENlbGwueCAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IC0yXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGlzRW5hYmxlZDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblJlc2l6aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEV4dHJhIG1zZWNzIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uIHdpdGggZmluY2FudmFzJ3MgZG91YmxlIGNsaWNrIHRpbWVyLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0dmFsdWUgNTBcbiAqIE5PVEU6IDUwIG1zZWNzIHNlZW1zIHRvIHdvcmsgd2VsbC4gMTAgYW5kIGV2ZW4gMjUgcHJvdmVkIGluc3VmZmljaWVudCBpbiBDaHJvbWUuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgUkFDRV9USU1FID0gNTA7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDb2x1bW5TZWxlY3Rpb24gPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uU2VsZWN0aW9uJywge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnJlbnREcmFnOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNlbGwgY29vcmRpbmF0ZXMgb2YgdGhlIHdoZXJlIHRoZSBtb3VzZSBwb2ludGVyIGlzIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgbGFzdERyYWdDZWxsOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHRpbWUgYW4gYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkxhc3RBdXRvOiAwLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHRpbWUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkF1dG9TdGFydDogMCxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZG91YmxlQ2xpY2tUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlQ2xpY2tUaW1lcik7IC8vIHByZXZlbnQgbW91c2VEb3duIGZyb20gY29udGludWluZ1xuICAgICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZG91YmxlQ2xpY2tUaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCghZ3JpZC5pc0NvbHVtblNlbGVjdGlvbigpIHx8IGV2ZW50Lm1vdXNlUG9pbnQueSA8IDUpICYmIHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcbiAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdmFyIHZpZXdDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgZHggPSBjZWxsLng7XG4gICAgICAgIHZhciBkeSA9IGNlbGwueTtcblxuICAgICAgICB2YXIgaXNIZWFkZXIgPSBncmlkLmlzU2hvd0hlYWRlclJvdygpICYmIGR5ID09PSAwICYmIGR4ICE9PSAtMTtcblxuICAgICAgICBpZiAoaXNSaWdodENsaWNrIHx8ICFpc0hlYWRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSE9MRCBPRkYgV0hJTEUgV0FJVElORyBGT1IgRE9VQkxFLUNMSUNLXG4gICAgICAgICAgICB0aGlzLmRvdWJsZUNsaWNrVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgICAgIGlmICh2aWV3Q2VsbC54IDwgbnVtRml4ZWRDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gdmlld0NlbGwueDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZENlbGwgPSBncmlkLm5ld1BvaW50KGR4LCAwKTtcblxuICAgICAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHByaW1FdmVudC5kZXRhaWwua2V5cztcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbihncmlkLCBkQ2VsbCwga2V5cyk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIGdyaWQucmVzb2x2ZVByb3BlcnR5KCdkb3VibGVDbGlja0RlbGF5JykgKyBSQUNFX1RJTUUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG5cbiAgICAgICAgaWYgKCghZ3JpZC5pc0NvbHVtblNlbGVjdGlvbigpIHx8IHRoaXMuaXNDb2x1bW5EcmFnZ2luZyhncmlkKSkgJiYgdGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc1JpZ2h0Q2xpY2sgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrO1xuXG4gICAgICAgIGlmIChpc1JpZ2h0Q2xpY2sgfHwgIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuXG4gICAgICAgICAgICB2YXIgY2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICAgICAgdmFyIHZpZXdDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICAgICAgdmFyIGR4ID0gY2VsbC54O1xuICAgICAgICAgICAgdmFyIGR5ID0gY2VsbC55O1xuXG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIC8vY2hlY2sgYm90aCB4IGFuZCB5IHZhbHVlcyBpbmRlcGVuZGVudGx5XG4gICAgICAgICAgICBpZiAodmlld0NlbGwueCA8IG51bUZpeGVkQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIGR4ID0gdmlld0NlbGwueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRDZWxsID0gZ3JpZC5uZXdQb2ludChkeCwgZHkpO1xuXG4gICAgICAgICAgICB2YXIgcHJpbUV2ZW50ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREcmFnID0gcHJpbUV2ZW50LmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHRoaXMubGFzdERyYWdDZWxsID0gZENlbGw7XG5cbiAgICAgICAgICAgIHRoaXMuY2hlY2tEcmFnU2Nyb2xsKGdyaWQsIHRoaXMuY3VycmVudERyYWcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIGRDZWxsLCBwcmltRXZlbnQuZGV0YWlsLmtleXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoZ3JpZC5nZXRMYXN0U2VsZWN0aW9uVHlwZSgpICE9PSAnY29sdW1uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tbWFuZCA9ICdoYW5kbGUnICsgZXZlbnQuZGV0YWlsLmNoYXI7XG4gICAgICAgIGlmICh0aGlzW2NvbW1hbmRdKSB7XG4gICAgICAgICAgICB0aGlzW2NvbW1hbmRdLmNhbGwodGhpcywgZ3JpZCwgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSBhIG1vdXNlZHJhZyBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCBncmlkQ2VsbCwga2V5cykge1xuICAgICAgICB2YXIgeCA9IGdyaWRDZWxsLng7XG4gICAgICAgIC8vICAgICAgICAgICAgdmFyIHByZXZpb3VzRHJhZ0V4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpO1xuICAgICAgICB2YXIgbW91c2VEb3duID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcblxuICAgICAgICB2YXIgbmV3WCA9IHggLSBtb3VzZURvd24ueDtcbiAgICAgICAgLy92YXIgbmV3WSA9IHkgLSBtb3VzZURvd24ueTtcblxuICAgICAgICAvLyBpZiAocHJldmlvdXNEcmFnRXh0ZW50LnggPT09IG5ld1ggJiYgcHJldmlvdXNEcmFnRXh0ZW50LnkgPT09IG5ld1kpIHtcbiAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgZ3JpZC5zZWxlY3RDb2x1bW4obW91c2VEb3duLngsIHgpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCAwKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBjaGVja3Mgd2hpbGUgd2VyZSBkcmFnZ2luZyBpZiB3ZSBnbyBvdXRzaWRlIHRoZSB2aXNpYmxlIGJvdW5kcywgaWYgc28sIGtpY2sgb2ZmIHRoZSBleHRlcm5hbCBhdXRvc2Nyb2xsIGNoZWNrIGZ1bmN0aW9uIChhYm92ZSlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgY2hlY2tEcmFnU2Nyb2xsOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpO1xuICAgICAgICB2YXIgaW5zaWRlID0gYi5jb250YWlucyhtb3VzZSk7XG4gICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgIGlmIChncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3codHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERyYWcoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB3aGlsZSB3ZSBhcmUgZHJhZ2dpbmcgb3V0c2lkZSBvZiB0aGUgZ3JpZCB2aXNpYmxlIGJvdW5kcywgd2Ugc3Jjcm9sbCBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2Nyb2xsRHJhZzogZnVuY3Rpb24oZ3JpZCkge1xuXG4gICAgICAgIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdERyYWdDZWxsID0gdGhpcy5sYXN0RHJhZ0NlbGw7XG4gICAgICAgIHZhciBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCk7XG4gICAgICAgIHZhciB4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHlPZmZzZXQgPSAwO1xuXG4gICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBkcmFnRW5kSW5GaXhlZEFyZWFYID0gbGFzdERyYWdDZWxsLnggPCBudW1GaXhlZENvbHVtbnM7XG4gICAgICAgIHZhciBkcmFnRW5kSW5GaXhlZEFyZWFZID0gbGFzdERyYWdDZWxsLnkgPCBudW1GaXhlZFJvd3M7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueCA8IGIub3JpZ2luLngpIHtcbiAgICAgICAgICAgIHhPZmZzZXQgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnggPiBiLm9yaWdpbi54ICsgYi5leHRlbnQueCkge1xuICAgICAgICAgICAgeE9mZnNldCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJhZ0NlbGxPZmZzZXRYID0geE9mZnNldDtcbiAgICAgICAgdmFyIGRyYWdDZWxsT2Zmc2V0WSA9IHlPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGRyYWdFbmRJbkZpeGVkQXJlYVgpIHtcbiAgICAgICAgICAgIGRyYWdDZWxsT2Zmc2V0WCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhZ0VuZEluRml4ZWRBcmVhWSkge1xuICAgICAgICAgICAgZHJhZ0NlbGxPZmZzZXRZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdERyYWdDZWxsID0gbGFzdERyYWdDZWxsLnBsdXNYWShkcmFnQ2VsbE9mZnNldFgsIGRyYWdDZWxsT2Zmc2V0WSk7XG4gICAgICAgIGdyaWQuc2Nyb2xsQnkoeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCBsYXN0RHJhZ0NlbGwsIFtdKTsgLy8gdXBkYXRlIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zY3JvbGxEcmFnLmJpbmQodGhpcywgZ3JpZCksIDI1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBleHRlbmQgYSBzZWxlY3Rpb24gb3IgY3JlYXRlIG9uZSBpZiB0aGVyZSBpc250IHlldFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyaWRDZWxsIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGV4dGVuZFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgZ3JpZENlbGwsIGtleXMpIHtcbiAgICAgICAgZ3JpZC5zdG9wRWRpdGluZygpO1xuICAgICAgICAvL3ZhciBoYXNDVFJMID0ga2V5cy5pbmRleE9mKCdDVFJMJykgIT09IC0xO1xuICAgICAgICB2YXIgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgIT09IC0xO1xuXG4gICAgICAgIC8vIHZhciBzY3JvbGxUb3AgPSBncmlkLmdldFZTY3JvbGxWYWx1ZSgpO1xuICAgICAgICAvLyB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgLy8gdmFyIG51bUZpeGVkQ29sdW1ucyA9IDA7Ly9ncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgLy8gdmFyIG51bUZpeGVkUm93cyA9IDA7Ly9ncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICB2YXIgbW91c2VQb2ludCA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHZhciB4ID0gZ3JpZENlbGwueDsgLy8gLSBudW1GaXhlZENvbHVtbnMgKyBzY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgeSA9IGdyaWRDZWxsLnk7IC8vIC0gbnVtRml4ZWRSb3dzICsgc2Nyb2xsVG9wO1xuXG4gICAgICAgIC8vd2VyZSBvdXRzaWRlIG9mIHRoZSBncmlkIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL3dlIGhhdmUgcmVwZWF0ZWQgYSBjbGljayBpbiB0aGUgc2FtZSBzcG90IGRlc2xlY3QgdGhlIHZhbHVlIGZyb20gbGFzdCB0aW1lXG4gICAgICAgIC8vIGlmIChtb3VzZVBvaW50ICYmIHggPT09IG1vdXNlUG9pbnQueCAmJiB5ID09PSBtb3VzZVBvaW50LnkpIHtcbiAgICAgICAgLy8gICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIC8vICAgICBncmlkLnBvcE1vdXNlRG93bigpO1xuICAgICAgICAvLyAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZiAoIWhhc0NUUkwgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgIC8vICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3RDb2x1bW4oeCwgbW91c2VQb2ludC54KTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KHggLSBtb3VzZVBvaW50LngsIDApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQudG9nZ2xlU2VsZWN0Q29sdW1uKHgsIGtleXMpO1xuICAgICAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCh4LCB5KSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlRE9XTlNISUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVBTSElGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOOiBmdW5jdGlvbihncmlkKSB7XG5cbiAgICAgICAgLy8gdmFyIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGdyaWQuZ2V0RHJhZ0V4dGVudCgpKTtcbiAgICAgICAgLy8gdmFyIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxO1xuXG4gICAgICAgIC8vIHZhciBuZXdYID0gbW91c2VDb3JuZXIueDtcbiAgICAgICAgLy8gdmFyIG5ld1kgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCkgKyBncmlkLmdldFZTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIC8vIG5ld1kgPSBNYXRoLm1pbihtYXhSb3dzLCBuZXdZKTtcblxuICAgICAgICAvLyBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAvLyBncmlkLnNlbGVjdChuZXdYLCBuZXdZLCAwLCAwKTtcbiAgICAgICAgLy8gZ3JpZC5zZXRNb3VzZURvd24obmV3IGdyaWQucmVjdGFuZ3VsYXIuUG9pbnQobmV3WCwgbmV3WSkpO1xuICAgICAgICAvLyBncmlkLnNldERyYWdFeHRlbnQobmV3IGdyaWQucmVjdGFuZ3VsYXIuUG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIC8vIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJZiB3ZSBhcmUgaG9sZGluZyBkb3duIHRoZSBzYW1lIG5hdmlnYXRpb24ga2V5LCBhY2NlbGVyYXRlIHRoZSBpbmNyZW1lbnQgd2Ugc2Nyb2xsXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgIHZhciBlbGFwc2VkID0gdGhpcy5nZXRBdXRvU2Nyb2xsRHVyYXRpb24oKSAvIDIwMDA7XG4gICAgICAgIGNvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkKSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHN0YXJ0IHRpbWUgdG8gcmlnaHQgbm93IHdoZW4gd2UgaW5pdGlhdGUgYW4gYXV0byBzY3JvbGxcbiAgICAgKi9cbiAgICBzZXRBdXRvU2Nyb2xsU3RhcnRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zYkF1dG9TdGFydCA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBhdXRvc2Nyb2xsIHN0YXJ0IHRpbWUgaWYgd2UgaGF2ZW4ndCBhdXRvc2Nyb2xsZWQgd2l0aGluIHRoZSBsYXN0IDUwMG1zIG90aGVyd2lzZSB1cGRhdGUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCB0aW1lXG4gICAgICovXG4gICAgcGluZ0F1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdXRvU2Nyb2xsU3RhcnRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zYkxhc3RBdXRvID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgaG93IGxvbmcgd2UgaGF2ZSBiZWVuIGF1dG8gc2Nyb2xsaW5nXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbER1cmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zYkF1dG9TdGFydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBdWdtZW50IHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gZXh0ZW50IGJ5IChvZmZzZXRYLG9mZnNldFkpIGFuZCBzY3JvbGwgaWYgbmVjZXNzYXJ5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaGlmdFNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WCkge1xuXG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1ucygpIC0gMTtcblxuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHZhciBleHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKTtcblxuICAgICAgICB2YXIgbmV3WCA9IGV4dGVudC54ICsgb2Zmc2V0WDtcbiAgICAgICAgLy92YXIgbmV3WSA9IGdyaWQuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucyAtIG9yaWdpbi54LCBNYXRoLm1heCgtb3JpZ2luLngsIG5ld1gpKTtcblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuICAgICAgICBncmlkLnNlbGVjdENvbHVtbihvcmlnaW4ueCwgb3JpZ2luLnggKyBuZXdYKTtcblxuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCAwKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxDb2xJc1Zpc2libGUobmV3WCArIG9yaWdpbi54LCBvZmZzZXRYKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXBsYWNlIHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gd2l0aCBhIHNpbmdsZSBjZWxsIHNlbGVjdGlvbiB0aGF0IGlzIG1vdmVkIChvZmZzZXRYLG9mZnNldFkpIGZyb20gdGhlIHByZXZpb3VzIHNlbGVjdGlvbiBleHRlbnQuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WCkge1xuXG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IE1hdGgubWluKG1heENvbHVtbnMsIG1heFZpZXdhYmxlQ29sdW1ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW91c2VDb3JuZXIgPSBncmlkLmdldE1vdXNlRG93bigpLnBsdXMoZ3JpZC5nZXREcmFnRXh0ZW50KCkpO1xuXG4gICAgICAgIHZhciBuZXdYID0gbW91c2VDb3JuZXIueCArIG9mZnNldFg7XG4gICAgICAgIC8vdmFyIG5ld1kgPSBncmlkLmdldFJvd0NvdW50KCk7XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWluKG1heENvbHVtbnMsIE1hdGgubWF4KDAsIG5ld1gpKTtcblxuICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICBncmlkLnNlbGVjdENvbHVtbihuZXdYKTtcbiAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludChuZXdYLCAwKSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbENvbElzVmlzaWJsZShuZXdYLCBvZmZzZXRYKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9LFxuXG4gICAgaXNDb2x1bW5EcmFnZ2luZzogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB2YXIgZHJhZ2dlciA9IGdyaWQubG9va3VwRmVhdHVyZSgnQ29sdW1uTW92aW5nJyk7XG4gICAgICAgIGlmICghZHJhZ2dlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0FjdGl2YXRlZCA9IGRyYWdnZXIuZHJhZ2dpbmcgJiYgIXRoaXMuZHJhZ2dpbmc7XG4gICAgICAgIHJldHVybiBpc0FjdGl2YXRlZDtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblNlbGVjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENvbHVtblNvcnRpbmcgPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uU29ydGluZycsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Tb3J0aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICBpZiAoZ3JpZC5pc1Nob3dIZWFkZXJSb3coKSAmJiBncmlkQ2VsbC55ID09PSAwICYmIGdyaWRDZWxsLnggIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5rZXlzO1xuICAgICAgICAgICAgZ3JpZC50b2dnbGVTb3J0KGdyaWRDZWxsLngsIGtleXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU29ydGluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciB5ID0gZXZlbnQuZ3JpZENlbGwueTtcbiAgICAgICAgaWYgKHRoaXMuaXNGaXhlZFJvdyhncmlkLCBldmVudCkgJiYgeSA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5Tb3J0aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL2xpYi9CYXNlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZGVzYyBpbnN0YW5jZXMgb2YgZmVhdHVyZXMgYXJlIGNvbm5lY3RlZCB0byBvbmUgYW5vdGhlciB0byBtYWtlIGEgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkgZm9yIGhhbmRsaW5nIGFsbCB0aGUgaW5wdXQgdG8gdGhlIGh5cGVyZ3JpZC5cbiAqL1xudmFyIEZlYXR1cmUgPSBCYXNlLmV4dGVuZCgnRmVhdHVyZScsIHtcblxuICAgIC8qKlxuICAgICAqIHRoZSBuZXh0IGZlYXR1cmUgdG8gYmUgZ2l2ZW4gYSBjaGFuY2UgdG8gaGFuZGxlIGluY29taW5nIGV2ZW50c1xuICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBuZXh0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSB0ZW1wb3JhcnkgaG9sZGluZyBmaWVsZCBmb3IgbXkgbmV4dCBmZWF0dXJlIHdoZW4gSSdtIGluIGEgZGlzY29ubmVjdGVkIHN0YXRlXG4gICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRldGFjaGVkOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGN1cnNvciBJIHdhbnQgdG8gYmUgZGlzcGxheWVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICovXG4gICAgY3Vyc29yOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNlbGwgbG9jYXRpb24gd2hlcmUgdGhlIGN1cnNvciBpcyBjdXJyZW50bHlcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnJlbnRIb3ZlckNlbGw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgbXkgbmV4dCBmaWVsZCwgb3IgaWYgaXQncyBwb3B1bGF0ZWQgZGVsZWdhdGUgdG8gdGhlIGZlYXR1cmUgaW4gbXkgbmV4dCBmaWVsZFxuICAgICAqIEBwYXJhbSB7RmVhdHVyZX0gbmV4dEZlYXR1cmUgLSB0aGlzIGlzIGhvdyB3ZSBidWlsZCB0aGUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cbiAgICBzZXROZXh0OiBmdW5jdGlvbihuZXh0RmVhdHVyZSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuc2V0TmV4dChuZXh0RmVhdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBuZXh0RmVhdHVyZTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoZWQgPSBuZXh0RmVhdHVyZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkaXNjb25uZWN0IG15IGNoaWxkXG4gICAgICovXG4gICAgZGV0YWNoQ2hhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZWF0dGFjaCBteSBjaGlsZCBmcm9tIHRoZSBkZXRhY2hlZCByZWZlcmVuY2VcbiAgICAgKi9cbiAgICBhdHRhY2hDaGFpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHRoaXMuZGV0YWNoZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSBtb3VzZSBtb3ZlIGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRXhpdDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRXhpdChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZUVudGVyOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VFbnRlcihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5VXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVXaGVlbE1vdmVkOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlV2hlZWxNb3ZlZChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUhvbGRQdWxzZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUhvbGRQdWxzZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVUYXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVUYXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUNvbnRleHRNZW51OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ29udGV4dE1lbnUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRvZ2dsZSB0aGUgY29sdW1uIHBpY2tlclxuICAgICAqL1xuXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQubW92ZVNpbmdsZVNlbGVjdChncmlkLCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRml4ZWRSb3c6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGlzRml4ZWQgPSBncmlkQ2VsbC55IDwgZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgICAgIHJldHVybiBpc0ZpeGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRmlyc3RGaXhlZFJvdzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgaXNGaXhlZCA9IGdyaWRDZWxsLnkgPCAxO1xuICAgICAgICByZXR1cm4gaXNGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpeGVkQ29sdW1uOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBpc0ZpeGVkID0gZ3JpZENlbGwueCA8IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICByZXR1cm4gaXNGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpcnN0Rml4ZWRDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGVkZ2UgPSBncmlkLmlzU2hvd1Jvd051bWJlcnMoKSA/IDAgOiAxO1xuICAgICAgICB2YXIgaXNGaXhlZCA9IGdyaWRDZWxsLnggPCBlZGdlO1xuICAgICAgICByZXR1cm4gaXNGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc1RvcExlZnQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc1RvcExlZnQgPSB0aGlzLmlzRml4ZWRSb3coZ3JpZCwgZXZlbnQpICYmIHRoaXMuaXNGaXhlZENvbHVtbihncmlkLCBldmVudCk7XG4gICAgICAgIHJldHVybiBpc1RvcExlZnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgc2V0Q3Vyc29yOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICBncmlkLmJlQ3Vyc29yKHRoaXMuY3Vyc29yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGluaXRpYWxpemVPbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGZWF0dXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRmlsdGVycyA9IEZlYXR1cmUuZXh0ZW5kKCdGaWx0ZXJzJywge1xuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChncmlkLmlzRmlsdGVyUm93KGV2ZW50LmdyaWRDZWxsLnkpKSB7XG4gICAgICAgICAgICBncmlkLm9uRWRpdG9yQWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRmVhdHVyZS5wcm90b3R5cGUuaGFuZGxlRG91YmxlQ2xpY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVUYXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChncmlkLmlzRmlsdGVyUm93KGV2ZW50LmdyaWRDZWxsLnkpKSB7XG4gICAgICAgICAgICBncmlkLm9uRWRpdG9yQWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRmVhdHVyZS5wcm90b3R5cGUuaGFuZGxlVGFwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlSG9sZFB1bHNlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNEb3VibGVDbGlja0VkaXRvckFjdGl2YXRpb24gPSBncmlkLnJlc29sdmVQcm9wZXJ0eSgnZWRpdE9uRG91YmxlQ2xpY2snKTtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tBY3RpdmF0ZUVkaXRvcihncmlkLCBldmVudCwgIWlzRG91YmxlQ2xpY2tFZGl0b3JBY3RpdmF0aW9uKSkge1xuICAgICAgICAgICBncmlkLm9uRWRpdG9yQWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUhvbGRQdWxzZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbnZhciBjb21tYW5kcyA9IHtcbiAgICBQQUdFRE9XTjogZnVuY3Rpb24oZ3JpZCkgeyBncmlkLnBhZ2VEb3duKCk7IH0sXG4gICAgUEFHRVVQOiBmdW5jdGlvbihncmlkKSB7IGdyaWQucGFnZVVwKCk7IH0sXG4gICAgUEFHRUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHsgZ3JpZC5wYWdlTGVmdCgpOyB9LFxuICAgIFBBR0VSSUdIVDogZnVuY3Rpb24oZ3JpZCkgeyBncmlkLnBhZ2VSaWdodCgpOyB9XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgS2V5UGFnaW5nID0gRmVhdHVyZS5leHRlbmQoJ0tleVBhZ2luZycsIHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBtZW1iZXJPZiBLZXlQYWdpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IGV2ZW50LmRldGFpbC5jaGFyO1xuICAgICAgICB2YXIgZnVuYyA9IGNvbW1hbmRzW2RldGFpbF07XG4gICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICBmdW5jKGdyaWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWdpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBPbkhvdmVyID0gRmVhdHVyZS5leHRlbmQoJ09uSG92ZXInLCB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBIaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQG1lbWJlck9mIE9uSG92ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgY3VycmVudEhvdmVyQ2VsbCA9IGdyaWQuZ2V0SG92ZXJDZWxsKCk7XG4gICAgICAgIGlmICghZXZlbnQuZ3JpZENlbGwuZXF1YWxzKGN1cnJlbnRIb3ZlckNlbGwpKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEhvdmVyQ2VsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VFeGl0KGdyaWQsIGN1cnJlbnRIb3ZlckNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZUVudGVyKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIGdyaWQuc2V0SG92ZXJDZWxsKGV2ZW50LmdyaWRDZWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gT25Ib3ZlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbHVtblJlc2l6aW5nID0gcmVxdWlyZSgnLi9Db2x1bW5SZXNpemluZycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUm93UmVzaXppbmcgPSBDb2x1bW5SZXNpemluZy5leHRlbmQoJ1Jvd1Jlc2l6aW5nJywge1xuXG4gICAgLyoqXG4gICAgICogdGhlIGluZGV4IG9mIHRoZSByb3cvY29sdW1uIHdlIGFyZSBkcmFnZ2luZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0FyZWE6IC0xLFxuXG4gICAgLyoqXG4gICAgICogdGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSB3aGVyZSB0aGUgZHJhZyB3YXMgaW5pdGlhdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnU3RhcnQ6IC0xLFxuXG4gICAgLyoqXG4gICAgICogdGhlIHN0YXJ0aW5nIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiB3ZSBhcmUgZHJhZ2dpbmdcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdBcmVhU3RhcnRpbmdTaXplOiAtMSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXQgdGhlIG1vdXNlIHgseSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gdGhlIG1vdXNlIGV2ZW50IHRvIHF1ZXJ5XG4gICAgICovXG4gICAgZ2V0TW91c2VWYWx1ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IHRoZSBncmlkIGNlbGwgeCx5IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGdyaWRDZWxsXG4gICAgICovXG4gICAgZ2V0R3JpZENlbGxWYWx1ZTogZnVuY3Rpb24oZ3JpZENlbGwpIHtcbiAgICAgICAgcmV0dXJuIGdyaWRDZWxsLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGdyaWRzIHgseSBzY3JvbGwgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0VlNjcm9sbFZhbHVlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiBvZiBpbnRlcmVzdFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgcm93L2NvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldEFyZWFTaXplOiBmdW5jdGlvbihncmlkLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRSb3dIZWlnaHQoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gYXQgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgd2lkdGgvaGVpZ2h0IHRvIHNldCB0b1xuICAgICAqL1xuICAgIHNldEFyZWFTaXplOiBmdW5jdGlvbihncmlkLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgZ3JpZC5zZXRSb3dIZWlnaHQoaW5kZXgsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybnMgdGhlIGluZGV4IG9mIHdoaWNoIGRpdmlkZXIgSSdtIG92ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvdmVyQXJlYURpdmlkZXI6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBncmlkLm92ZXJSb3dEaXZpZGVyKGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGFtIEkgb3ZlciB0aGUgY29sdW1uL3JvdyBhcmVhXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRmlyc3RGaXhlZE90aGVyQXJlYTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGaXJzdEZpeGVkQ29sdW1uKGdyaWQsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgY3Vyc29yIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldEN1cnNvck5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ3Jvdy1yZXNpemUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSByZWNlbnRseSByZW5kZXJlZCBhcmVhJ3Mgd2lkdGgvaGVpZ2h0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSByb3cvY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0UHJldmlvdXNBYnNvbHV0ZVNpemU6IGZ1bmN0aW9uKGdyaWQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldFJlbmRlcmVkSGVpZ2h0KGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgZml4ZWQgYXJlYSByb3dzL2NvbHVtbnMgY291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZ2V0T3RoZXJGaXhlZEFyZWFDb3VudDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0yXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEZpeGVkQXJlYUNvdW50OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldEZpeGVkUm93Q291bnQoKSArIGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IC0yXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGlzRW5hYmxlZDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5pc1Jvd1Jlc2l6ZWFibGUoKTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvd1Jlc2l6aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUm93U2VsZWN0aW9uID0gRmVhdHVyZS5leHRlbmQoJ1Jvd1NlbGVjdGlvbicsIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgY3VycmVudERyYWc6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2VsbCBjb29yZGluYXRlcyBvZiB0aGUgd2hlcmUgdGhlIG1vdXNlIHBvaW50ZXIgaXMgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBsYXN0RHJhZ0NlbGw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBhIG1pbGxpc2Vjb25kIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgcHJldmlvdXMgdGltZSBhbiBhdXRvc2Nyb2xsIHN0YXJ0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiTGFzdEF1dG86IDAsXG5cbiAgICAvKipcbiAgICAgKiBhIG1pbGxpc2Vjb25kIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgdGltZSB0aGUgY3VycmVudCBhdXRvc2Nyb2xsIHN0YXJ0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiQXV0b1N0YXJ0OiAwLFxuXG4gICAgZHJhZ0FybWVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0FybWVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy9nbG9iYWwgcm93IHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKGV2ZW50LmdyaWRDZWxsLnggPT09IC0xICYmIGV2ZW50LmdyaWRDZWxsLnkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBncmlkLnRvZ2dsZVNlbGVjdEFsbFJvd3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY1Jvd1NlbGVjdGlvbkNoYW5nZWRFdmVudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY1Jvd1NlbGVjdGlvbkNoYW5nZWRFdmVudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIGlzUmlnaHRDbGljayA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2s7XG4gICAgICAgIHZhciBjZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciB2aWV3Q2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGR4ID0gY2VsbC54O1xuICAgICAgICB2YXIgZHkgPSBjZWxsLnk7XG5cblxuICAgICAgICB2YXIgaXNIZWFkZXIgPSBncmlkLmlzU2hvd1Jvd051bWJlcnMoKSAmJiBkeCA8IDA7XG5cbiAgICAgICAgaWYgKCFncmlkLmlzUm93U2VsZWN0aW9uKCkgfHwgaXNSaWdodENsaWNrIHx8ICFpc0hlYWRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgbnVtRml4ZWRSb3dzID0gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgICAgIC8vaWYgd2UgYXJlIGluIHRoZSBmaXhlZCBhcmVhIGRvIG5vdCBhcHBseSB0aGUgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy9jaGVjayBib3RoIHggYW5kIHkgdmFsdWVzIGluZGVwZW5kZW50bHlcbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC55IDwgbnVtRml4ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgZHkgPSB2aWV3Q2VsbC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZENlbGwgPSBncmlkLm5ld1BvaW50KDAsIGR5KTtcblxuICAgICAgICAgICAgdmFyIHByaW1FdmVudCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgdmFyIGtleXMgPSBwcmltRXZlbnQuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbihncmlkLCBkQ2VsbCwga2V5cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzUmlnaHRDbGljayA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2s7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRyYWdBcm1lZCB8fCAhZ3JpZC5pc1Jvd1NlbGVjdGlvbigpIHx8IGlzUmlnaHRDbGljaykge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgbnVtRml4ZWRSb3dzID0gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgICAgIHZhciBjZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgICAgICB2YXIgdmlld0NlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgICAgICAvL3ZhciBkeCA9IGNlbGwueDtcbiAgICAgICAgICAgIHZhciBkeSA9IGNlbGwueTtcblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnkgPCBudW1GaXhlZFJvd3MpIHtcbiAgICAgICAgICAgICAgICBkeSA9IHZpZXdDZWxsLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkQ2VsbCA9IGdyaWQubmV3UG9pbnQoMCwgZHkpO1xuXG4gICAgICAgICAgICB2YXIgcHJpbUV2ZW50ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREcmFnID0gcHJpbUV2ZW50LmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHRoaXMubGFzdERyYWdDZWxsID0gZENlbGw7XG5cbiAgICAgICAgICAgIHRoaXMuY2hlY2tEcmFnU2Nyb2xsKGdyaWQsIHRoaXMuY3VycmVudERyYWcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIGRDZWxsLCBwcmltRXZlbnQuZGV0YWlsLmtleXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoZ3JpZC5nZXRMYXN0U2VsZWN0aW9uVHlwZSgpICE9PSAncm93Jykge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tbWFuZCA9ICdoYW5kbGUnICsgZXZlbnQuZGV0YWlsLmNoYXI7XG4gICAgICAgIGlmICh0aGlzW2NvbW1hbmRdKSB7XG4gICAgICAgICAgICB0aGlzW2NvbW1hbmRdLmNhbGwodGhpcywgZ3JpZCwgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSBhIG1vdXNlZHJhZyBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCBncmlkQ2VsbCwga2V5cykge1xuICAgICAgICB2YXIgeSA9IGdyaWRDZWxsLnk7XG4gICAgICAgIC8vICAgICAgICAgICAgdmFyIHByZXZpb3VzRHJhZ0V4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpO1xuICAgICAgICB2YXIgbW91c2VEb3duID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcblxuICAgICAgICB2YXIgbmV3WSA9IHkgLSBtb3VzZURvd24ueTtcbiAgICAgICAgLy92YXIgbmV3WSA9IHkgLSBtb3VzZURvd24ueTtcblxuICAgICAgICAvLyBpZiAocHJldmlvdXNEcmFnRXh0ZW50LnggPT09IG5ld1ggJiYgcHJldmlvdXNEcmFnRXh0ZW50LnkgPT09IG5ld1kpIHtcbiAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgZ3JpZC5zZWxlY3RSb3cobW91c2VEb3duLnksIHkpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBjaGVja3Mgd2hpbGUgd2VyZSBkcmFnZ2luZyBpZiB3ZSBnbyBvdXRzaWRlIHRoZSB2aXNpYmxlIGJvdW5kcywgaWYgc28sIGtpY2sgb2ZmIHRoZSBleHRlcm5hbCBhdXRvc2Nyb2xsIGNoZWNrIGZ1bmN0aW9uIChhYm92ZSlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgY2hlY2tEcmFnU2Nyb2xsOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpO1xuICAgICAgICB2YXIgaW5zaWRlID0gYi5jb250YWlucyhtb3VzZSk7XG4gICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgIGlmIChncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3codHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERyYWcoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB3aGlsZSB3ZSBhcmUgZHJhZ2dpbmcgb3V0c2lkZSBvZiB0aGUgZ3JpZCB2aXNpYmxlIGJvdW5kcywgd2Ugc3Jjcm9sbCBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2Nyb2xsRHJhZzogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3REcmFnQ2VsbCA9IHRoaXMubGFzdERyYWdDZWxsO1xuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpO1xuICAgICAgICB2YXIgeE9mZnNldCA9IDA7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gMDtcblxuICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICB2YXIgZHJhZ0VuZEluRml4ZWRBcmVhWCA9IGxhc3REcmFnQ2VsbC54IDwgbnVtRml4ZWRDb2x1bW5zO1xuICAgICAgICB2YXIgZHJhZ0VuZEluRml4ZWRBcmVhWSA9IGxhc3REcmFnQ2VsbC55IDwgbnVtRml4ZWRSb3dzO1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnkgPCBiLm9yaWdpbi55KSB7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy55ID4gYi5vcmlnaW4ueSArIGIuZXh0ZW50LnkpIHtcbiAgICAgICAgICAgIHlPZmZzZXQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyYWdDZWxsT2Zmc2V0WCA9IHhPZmZzZXQ7XG4gICAgICAgIHZhciBkcmFnQ2VsbE9mZnNldFkgPSB5T2Zmc2V0O1xuXG4gICAgICAgIGlmIChkcmFnRW5kSW5GaXhlZEFyZWFYKSB7XG4gICAgICAgICAgICBkcmFnQ2VsbE9mZnNldFggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYWdFbmRJbkZpeGVkQXJlYVkpIHtcbiAgICAgICAgICAgIGRyYWdDZWxsT2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGxhc3REcmFnQ2VsbC5wbHVzWFkoZHJhZ0NlbGxPZmZzZXRYLCBkcmFnQ2VsbE9mZnNldFkpO1xuICAgICAgICBncmlkLnNjcm9sbEJ5KHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgbGFzdERyYWdDZWxsLCBbXSk7IC8vIHVwZGF0ZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuc2Nyb2xsRHJhZy5iaW5kKHRoaXMsIGdyaWQpLCAyNSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgZXh0ZW5kIGEgc2VsZWN0aW9uIG9yIGNyZWF0ZSBvbmUgaWYgdGhlcmUgaXNudCB5ZXRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmlkQ2VsbCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBleHRlbmRTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIGdyaWRDZWxsLCBrZXlzKSB7XG4gICAgICAgIGdyaWQuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgLy92YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpICE9PSAtMTtcbiAgICAgICAgdmFyIGhhc1NISUZUID0ga2V5cy5pbmRleE9mKCdTSElGVCcpICE9PSAtMTtcblxuICAgICAgICB2YXIgbW91c2VQb2ludCA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHZhciB4ID0gZ3JpZENlbGwueDsgLy8gLSBudW1GaXhlZENvbHVtbnMgKyBzY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgeSA9IGdyaWRDZWxsLnk7IC8vIC0gbnVtRml4ZWRSb3dzICsgc2Nyb2xsVG9wO1xuXG4gICAgICAgIC8vd2VyZSBvdXRzaWRlIG9mIHRoZSBncmlkIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBncmlkLnNlbGVjdFJvdyh5LCBtb3VzZVBvaW50LnkpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgeSAtIG1vdXNlUG9pbnQueSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZC50b2dnbGVTZWxlY3RSb3coeSwga2V5cyk7XG4gICAgICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KHgsIHkpKTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgfVxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVBTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVFNISUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFRTSElGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURPV046IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUOiBmdW5jdGlvbihncmlkKSB7XG5cbiAgICAgICAgdmFyIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGdyaWQuZ2V0RHJhZ0V4dGVudCgpKTtcbiAgICAgICAgdmFyIG1heENvbHVtbnMgPSBncmlkLmdldENvbHVtbkNvdW50KCkgLSAxO1xuXG4gICAgICAgIHZhciBuZXdYID0gZ3JpZC5nZXRIZWFkZXJDb2x1bW5Db3VudCgpICsgZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIG5ld1kgPSBtb3VzZUNvcm5lci55O1xuXG4gICAgICAgIG5ld1ggPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBuZXdYKTtcblxuICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICBncmlkLnNlbGVjdChuZXdYLCBuZXdZLCAwLCAwKTtcbiAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludChuZXdYLCBuZXdZKSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJZiB3ZSBhcmUgaG9sZGluZyBkb3duIHRoZSBzYW1lIG5hdmlnYXRpb24ga2V5LCBhY2NlbGVyYXRlIHRoZSBpbmNyZW1lbnQgd2Ugc2Nyb2xsXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgIHZhciBlbGFwc2VkID0gdGhpcy5nZXRBdXRvU2Nyb2xsRHVyYXRpb24oKSAvIDIwMDA7XG4gICAgICAgIGNvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkKSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHN0YXJ0IHRpbWUgdG8gcmlnaHQgbm93IHdoZW4gd2UgaW5pdGlhdGUgYW4gYXV0byBzY3JvbGxcbiAgICAgKi9cbiAgICBzZXRBdXRvU2Nyb2xsU3RhcnRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zYkF1dG9TdGFydCA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBhdXRvc2Nyb2xsIHN0YXJ0IHRpbWUgaWYgd2UgaGF2ZW4ndCBhdXRvc2Nyb2xsZWQgd2l0aGluIHRoZSBsYXN0IDUwMG1zIG90aGVyd2lzZSB1cGRhdGUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCB0aW1lXG4gICAgICovXG4gICAgcGluZ0F1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdXRvU2Nyb2xsU3RhcnRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zYkxhc3RBdXRvID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgaG93IGxvbmcgd2UgaGF2ZSBiZWVuIGF1dG8gc2Nyb2xsaW5nXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbER1cmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zYkF1dG9TdGFydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBdWdtZW50IHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gZXh0ZW50IGJ5IChvZmZzZXRYLG9mZnNldFkpIGFuZCBzY3JvbGwgaWYgbmVjZXNzYXJ5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaGlmdFNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WSkge1xuXG4gICAgICAgIHZhciBtYXhSb3dzID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVSb3dzID0gZ3JpZC5nZXRWaXNpYmxlUm93cygpIC0gMTtcblxuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIG1heFJvd3MgPSBNYXRoLm1pbihtYXhSb3dzLCBtYXhWaWV3YWJsZVJvd3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHZhciBleHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKTtcblxuICAgICAgICB2YXIgbmV3WSA9IGV4dGVudC55ICsgb2Zmc2V0WTtcbiAgICAgICAgLy92YXIgbmV3WSA9IGdyaWQuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cyAtIG9yaWdpbi55LCBNYXRoLm1heCgtb3JpZ2luLnksIG5ld1kpKTtcblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbigpO1xuICAgICAgICBncmlkLnNlbGVjdFJvdyhvcmlnaW4ueSwgb3JpZ2luLnkgKyBuZXdZKTtcblxuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCBuZXdZKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSArIG9yaWdpbi55LCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVwbGFjZSB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIHdpdGggYSBzaW5nbGUgY2VsbCBzZWxlY3Rpb24gdGhhdCBpcyBtb3ZlZCAob2Zmc2V0WCxvZmZzZXRZKSBmcm9tIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gZXh0ZW50LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFkpIHtcblxuICAgICAgICB2YXIgbWF4Um93cyA9IGdyaWQuZ2V0Um93Q291bnQoKSAtIDE7XG5cbiAgICAgICAgdmFyIG1heFZpZXdhYmxlUm93cyA9IGdyaWQuZ2V0VmlzaWJsZVJvd3NDb3VudCgpIC0gMTtcblxuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIG1heFJvd3MgPSBNYXRoLm1pbihtYXhSb3dzLCBtYXhWaWV3YWJsZVJvd3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGdyaWQuZ2V0RHJhZ0V4dGVudCgpKTtcblxuICAgICAgICB2YXIgbmV3WSA9IG1vdXNlQ29ybmVyLnkgKyBvZmZzZXRZO1xuICAgICAgICAvL3ZhciBuZXdZID0gZ3JpZC5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIG5ld1kgPSBNYXRoLm1pbihtYXhSb3dzLCBNYXRoLm1heCgwLCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgZ3JpZC5zZWxlY3RSb3cobmV3WSk7XG4gICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQoMCwgbmV3WSkpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSwgb2Zmc2V0WSkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY1Jvd1NlbGVjdGlvbkNoYW5nZWRFdmVudCgpO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcblxuICAgIH0sXG5cbiAgICBpc1NpbmdsZVJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUm93U2VsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVGh1bWJ3aGVlbFNjcm9sbGluZyA9IEZlYXR1cmUuZXh0ZW5kKCdUaHVtYndoZWVsU2Nyb2xsaW5nJywge1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFRodW1id2hlZWxTY3JvbGxpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVXaGVlbE1vdmVkOiBmdW5jdGlvbihncmlkLCBlKSB7XG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByaW1FdmVudCA9IGUucHJpbWl0aXZlRXZlbnQsXG4gICAgICAgICAgICBkZWx0YVggPSBNYXRoLnNpZ24ocHJpbUV2ZW50LndoZWVsRGVsdGFYIHx8IC1wcmltRXZlbnQuZGVsdGFYKSxcbiAgICAgICAgICAgIGRlbHRhWSA9IE1hdGguc2lnbihwcmltRXZlbnQud2hlZWxEZWx0YVkgfHwgLXByaW1FdmVudC5kZWx0YVkpO1xuXG4gICAgICAgIGlmIChkZWx0YVggfHwgZGVsdGFZKSB7XG4gICAgICAgICAgICBncmlkLnNjcm9sbEJ5KFxuICAgICAgICAgICAgICAgIC1kZWx0YVggfHwgMCwgLy8gMCBpZiBOYU5cbiAgICAgICAgICAgICAgICAtZGVsdGFZIHx8IDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGh1bWJ3aGVlbFNjcm9sbGluZztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRmVhdHVyZTogcmVxdWlyZSgnLi9GZWF0dXJlJyksIC8vIGFic3RyYWN0IGJhc2UgY2xhc3NcbiAgICBDZWxsQ2xpY2s6IHJlcXVpcmUoJy4vQ2VsbENsaWNrJyksXG4gICAgQ2VsbEVkaXRpbmc6IHJlcXVpcmUoJy4vQ2VsbEVkaXRpbmcnKSxcbiAgICBDZWxsU2VsZWN0aW9uOiByZXF1aXJlKCcuL0NlbGxTZWxlY3Rpb24nKSxcbiAgICBDb2x1bW5BdXRvc2l6aW5nOiByZXF1aXJlKCcuL0NvbHVtbkF1dG9zaXppbmcnKSxcbiAgICBDb2x1bW5Nb3Zpbmc6IHJlcXVpcmUoJy4vQ29sdW1uTW92aW5nJyksXG4gICAgQ29sdW1uUmVzaXppbmc6IHJlcXVpcmUoJy4vQ29sdW1uUmVzaXppbmcnKSxcbiAgICBDb2x1bW5TZWxlY3Rpb246IHJlcXVpcmUoJy4vQ29sdW1uU2VsZWN0aW9uJyksXG4gICAgQ29sdW1uU29ydGluZzogcmVxdWlyZSgnLi9Db2x1bW5Tb3J0aW5nJyksXG4gICAgRmlsdGVyczogcmVxdWlyZSgnLi9GaWx0ZXJzJyksXG4gICAgS2V5UGFnaW5nOiByZXF1aXJlKCcuL0tleVBhZ2luZycpLFxuICAgIE9uSG92ZXI6IHJlcXVpcmUoJy4vT25Ib3ZlcicpLFxuICAgIENvbHVtblBpY2tlcjogcmVxdWlyZSgnLi9Db2x1bW5QaWNrZXInKSxcbiAgICBSb3dSZXNpemluZzogcmVxdWlyZSgnLi9Sb3dSZXNpemluZycpLFxuICAgIFJvd1NlbGVjdGlvbjogcmVxdWlyZSgnLi9Sb3dTZWxlY3Rpb24nKSxcbiAgICBUaHVtYndoZWVsU2Nyb2xsaW5nOiByZXF1aXJlKCcuL1RodW1id2hlZWxTY3JvbGxpbmcnKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlcHJlY2F0ZWQgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZWQnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnZXh0ZW5kLW1lJykuQmFzZTtcblxuQmFzZS5wcm90b3R5cGUuZGVwcmVjYXRlZCA9IGRlcHJlY2F0ZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcblxuLyoqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgSW5zdGFuY2VzIG9mIGZlYXR1cmVzIGFyZSBjb25uZWN0ZWQgdG8gb25lIGFub3RoZXIgdG8gbWFrZSBhIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5IGZvciBoYW5kbGluZyBhbGwgdGhlIGlucHV0IHRvIHRoZSBoeXBlcmdyaWQuXG4gKlxuICogU2VlIHtAbGluayBDZWxsUHJvdmlkZXIjaW5pdGlhbGl6ZXxpbml0aWFsaXplfSB3aGljaCBpcyBjYWxsZWQgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICovXG52YXIgQ2VsbFByb3ZpZGVyID0gQmFzZS5leHRlbmQoJ0NlbGxQcm92aWRlcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENvbnN0cnVjdG9yIGxvZ2ljXG4gICAgICogQGRlc2MgVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgdXBvbiBpbnN0YW50aWF0aW9uIG9mIHRoaXMgY2xhc3Mgb3Igb2YgYW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBmcm9tIHRoaXMgY2xhc3MuXG4gICAgICogPiBBbGwgYGluaXRpYWxpemUoKWAgbWV0aG9kcyBpbiB0aGUgaW5oZXJpdGFuY2UgY2hhaW4gYXJlIGNhbGxlZCwgaW4gdHVybiwgZWFjaCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IsIGJlZ2lubmluZyB3aXRoIHRoYXQgb2YgdGhlIG1vc3QgXCJzZW5pb3JcIiBjbGFzcyB0aHJvdWdoIHRoYXQgb2YgdGhlIGNsYXNzIG9mIHRoZSBuZXcgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jZWxsQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQ2VsbHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgcmVwbGFjZSB0aGlzIGZ1bmN0aW9uIGluIG9uIHlvdXIgaW5zdGFuY2Ugb2YgY2VsbFByb3ZpZGVyXG4gICAgICogQHJldHVybnMgY2VsbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSBhbiBvYmplY3Qgd2l0aCBldmVyeXRoaW5nIHlvdSBtaWdodCBuZWVkIGZvciByZW5kZXJlcmluZyBhIGNlbGxcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFByb3ZpZGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldENlbGw6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbENhY2hlLnNpbXBsZUNlbGxSZW5kZXJlcjtcbiAgICAgICAgY2VsbC5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyByZXBsYWNlIHRoaXMgZnVuY3Rpb24gaW4gb24geW91ciBpbnN0YW5jZSBvZiBjZWxsUHJvdmlkZXJcbiAgICAgKiBAcmV0dXJucyBjZWxsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIGFuIG9iamVjdCB3aXRoIGV2ZXJ5dGhpbmcgeW91IG1pZ2h0IG5lZWQgZm9yIHJlbmRlcmVyaW5nIGEgY2VsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Q29sdW1uSGVhZGVyQ2VsbDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsQ2FjaGUuc2ltcGxlQ2VsbFJlbmRlcmVyO1xuICAgICAgICBjZWxsLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHJlcGxhY2UgdGhpcyBmdW5jdGlvbiBpbiBvbiB5b3VyIGluc3RhbmNlIG9mIGNlbGxQcm92aWRlclxuICAgICAqIEByZXR1cm5zIGNlbGxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIC0gYW4gb2JqZWN0IHdpdGggZXZlcnl0aGluZyB5b3UgbWlnaHQgbmVlZCBmb3IgcmVuZGVyZXJpbmcgYSBjZWxsXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRSb3dIZWFkZXJDZWxsOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxDYWNoZS5zaW1wbGVDZWxsUmVuZGVyZXI7XG4gICAgICAgIGNlbGwuY29uZmlnID0gY29uZmlnO1xuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9LFxuXG4gICAgcGFpbnRCdXR0b246IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHZhbCA9IGNvbmZpZy52YWx1ZTtcbiAgICAgICAgdmFyIGMgPSBjb25maWcueDtcbiAgICAgICAgdmFyIHIgPSBjb25maWcueTtcbiAgICAgICAgdmFyIGJvdW5kcyA9IGNvbmZpZy5ib3VuZHM7XG4gICAgICAgIHZhciB4ID0gYm91bmRzLnggKyAyO1xuICAgICAgICB2YXIgeSA9IGJvdW5kcy55ICsgMjtcbiAgICAgICAgdmFyIHdpZHRoID0gYm91bmRzLndpZHRoIC0gMztcbiAgICAgICAgdmFyIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSAzO1xuICAgICAgICB2YXIgcmFkaXVzID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIGFyY0dyYWRpZW50ID0gZ2MuY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeCwgeSArIGhlaWdodCk7XG4gICAgICAgIGlmIChjb25maWcubW91c2VEb3duKSB7XG4gICAgICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyNCNUNCRUQnKTtcbiAgICAgICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzRkNzRlYScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjZmZmZmZmJyk7XG4gICAgICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJyNhYWFhYWEnKTtcbiAgICAgICAgfVxuICAgICAgICBnYy5maWxsU3R5bGUgPSBhcmNHcmFkaWVudDtcbiAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSAnIzAwMDAwMCc7XG4gICAgICAgIHJvdW5kUmVjdChnYywgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzLCBhcmNHcmFkaWVudCwgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIG94ID0gKHdpZHRoIC0gY29uZmlnLmdldFRleHRXaWR0aChnYywgdmFsKSkgLyAyO1xuICAgICAgICB2YXIgb3kgPSAoaGVpZ2h0IC0gY29uZmlnLmdldFRleHRIZWlnaHQoZ2MuZm9udCkuZGVzY2VudCkgLyAyO1xuXG4gICAgICAgIGlmIChnYy50ZXh0QmFzZWxpbmUgIT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICBnYy50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGdjLmZpbGxTdHlsZSA9ICcjMDAwMDAwJztcblxuICAgICAgICBjb25maWcuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICBnYy5maWxsVGV4dCh2YWwsIHggKyBveCwgeSArIG95KTtcblxuICAgICAgICAvL2lkZW50aWZ5IHRoYXQgd2UgYXJlIGEgYnV0dG9uXG4gICAgICAgIGNvbmZpZy5idXR0b25DZWxsc1tjICsgJywnICsgcl0gPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgZGVmYXVsdCBjZWxsIHJlbmRlcmluZyBmdW5jdGlvbiBmb3IgcmVuZGVyaW5nIGEgdmFuaWxsYSBjZWxsLlxuICAgICAqIEBkZXNjIEdyZWF0IGNhcmUgaGFzIGJlZW4gdGFrZW4gaW4gY3JhZnRpbmcgdGhpcyBmdW5jdGlvbiBhcyBpdCBuZWVkcyB0byBwZXJmb3JtIGV4dHJlbWVseSBmYXN0LiBSZWFkcyBvbiB0aGUgZ2Mgb2JqZWN0IGFyZSBleHBlbnNpdmUgYnV0IG5vdCBxdWl0ZSBhcyBleHBlbnNpdmUgYXMgd3JpdGVzIHRvIGl0LiBXZSBkbyBvdXIgYmVzdCB0byBhdm9pZCB3cml0ZXMsIHRoZW4gYXZvaWQgcmVhZHMuIENsaXBwaW5nIGJvdW5kcyBhcmUgbm90IHNldCBoZXJlIGFzIHRoaXMgaXMgYWxzbyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uLiBJbnN0ZWFkLCB3ZSB0cnVuY2F0ZSBvdmVyZmxvd2luZyB0ZXh0IGFuZCBjb250ZW50IGJ5IGZpbGxpbmcgYSByZWN0YW5nbGUgd2l0aCBiYWNrZ3JvdW5kIGNvbG9yIGNvbHVtbiBieSBjb2x1bW4gaW5zdGVhZCBvZiBjZWxsIGJ5IGNlbGwuICBUaGlzIGNvbHVtbiBieSBjb2x1bW4gZmlsbCBoYXBwZW5zIGhpZ2hlciB1cCBvbiB0aGUgc3RhY2sgaW4gYSBjYWxsaW5nIGZ1bmN0aW9uIGZyb20gZmluLWh5cGVyZ3JpZC1yZW5kZXJlci4gIFRha2Ugbm90ZSB3ZSBkbyBub3QgZG8gY2VsbCBieSBjZWxsIGJvcmRlciByZW5kZXJlcmluZyBhcyB0aGF0IGlzIGV4cGVuc2l2ZS4gIEluc3RlYWQgd2UgcmVuZGVyIG1hbnkgZmV3ZXIgZ3JpZGxpbmVzIGFmdGVyIGFsbCBjZWxscyBhcmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5ib3VuZHMueCAtIHRoZSB4IHNjcmVlbiBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcuYm91bmRzLnkgLSB0aGUgeSBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLmJvdW5kcy53aWR0aCAtIHRoZSB3aWR0aCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcuYm91bmRzLmhlaWdodCAtIHRoZSBoZWlnaHQgSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFByb3ZpZGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRlZmF1bHRDZWxsUGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHZhbCA9IGNvbmZpZy52YWx1ZSxcbiAgICAgICAgICAgIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICB3cmFwSGVhZGVycyA9IGNvbmZpZy5oZWFkZXJUZXh0V3JhcHBpbmcsXG4gICAgICAgICAgICBsZWZ0UGFkZGluZyA9IDIsIC8vVE9ETzogZml4IHRoaXNcbiAgICAgICAgICAgIGlzSGVhZGVyID0gY29uZmlnLnkgPT09IDA7XG5cbiAgICAgICAgdmFyIGxlZnRJY29uLCByaWdodEljb24sIGNlbnRlckljb24sIGl4b2Zmc2V0LCBpeW9mZnNldCwgZm9udDtcblxuICAgICAgICAvLyBzZXR0aW5nIGdjIHByb3BlcnRpZXMgYXJlIGV4cGVuc2l2ZSwgbGV0J3Mgbm90IGRvIGl0IG5lZWRsZXNzbHlcblxuICAgICAgICBpZiAodmFsICYmIHZhbC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIGxlZnRJY29uID0gdmFsWzBdO1xuICAgICAgICAgICAgcmlnaHRJY29uID0gdmFsWzJdO1xuICAgICAgICAgICAgdmFsID0gdmFsWzFdO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmICh2YWwuY29uc3RydWN0b3IubmFtZSA9PT0gJ0hUTUxJbWFnZUVsZW1lbnQnKSB7IC8vIG11c3QgYmUgYW4gaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgY2VudGVySWNvbiA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdEljb24gJiYgbGVmdEljb24ubm9kZU5hbWUgIT09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgbGVmdEljb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0SWNvbiAmJiByaWdodEljb24ubm9kZU5hbWUgIT09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRJY29uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjZW50ZXJJY29uICYmIGNlbnRlckljb24ubm9kZU5hbWUgIT09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgY2VudGVySWNvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWwgPSB2YWxPckZ1bmModmFsLCBjb25maWcpO1xuICAgICAgICB2YWwgPSBjb25maWcuZm9ybWF0dGVyKHZhbCk7XG5cbiAgICAgICAgZm9udCA9IGNvbmZpZy5pc1NlbGVjdGVkID8gY29uZmlnLmZvcmVncm91bmRTZWxlY3Rpb25Gb250IDogY29uZmlnLmZvbnQ7XG5cbiAgICAgICAgaWYgKGdjLmZvbnQgIT09IGZvbnQpIHtcbiAgICAgICAgICAgIGdjLmZvbnQgPSBmb250O1xuICAgICAgICB9XG4gICAgICAgIGlmIChnYy50ZXh0QWxpZ24gIT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgZ2MudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnYy50ZXh0QmFzZWxpbmUgIT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICBnYy50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbGwgYmFja2dyb3VuZCBvbmx5IGlmIG91ciBiZ0NvbG9yIGlzIHBvcHVsYXRlZCBvciB3ZSBhcmUgYSBzZWxlY3RlZCBjZWxsXG4gICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IsIGhvdmVyLCBob3ZlckNvbG9yLCBzZWxlY3RDb2xvcixcbiAgICAgICAgICAgIGNvbG9ycyA9IFtdO1xuXG4gICAgICAgIGlmIChjb25maWcuaXNDZWxsSG92ZXJlZCAmJiBjb25maWcuaG92ZXJDZWxsSGlnaGxpZ2h0LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGhvdmVyQ29sb3IgPSBjb25maWcuaG92ZXJDZWxsSGlnaGxpZ2h0LmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcuaXNSb3dIb3ZlcmVkICYmIChob3ZlciA9IGNvbmZpZy5ob3ZlclJvd0hpZ2hsaWdodCkuZW5hYmxlZCkge1xuICAgICAgICAgICAgaG92ZXJDb2xvciA9IGNvbmZpZy5pc0dyaWRDb2x1bW4gfHwgIWhvdmVyLmhlYWRlciB8fCBob3Zlci5oZWFkZXIuYmFja2dyb3VuZENvbG9yID09PSB1bmRlZmluZWQgPyBob3Zlci5iYWNrZ3JvdW5kQ29sb3IgOiBob3Zlci5oZWFkZXIuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5pc0NvbHVtbkhvdmVyZWQgJiYgKGhvdmVyID0gY29uZmlnLmhvdmVyQ29sdW1uSGlnaGxpZ2h0KS5lbmFibGVkKSB7XG4gICAgICAgICAgICBob3ZlckNvbG9yID0gY29uZmlnLmlzR3JpZFJvdyB8fCAhaG92ZXIuaGVhZGVyIHx8IGhvdmVyLmhlYWRlci5iYWNrZ3JvdW5kQ29sb3IgPT09IHVuZGVmaW5lZCA/IGhvdmVyLmJhY2tncm91bmRDb2xvciA6IGhvdmVyLmhlYWRlci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFscGhhKGhvdmVyQ29sb3IpIDwgMSkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0Q29sb3IgPSB2YWxPckZ1bmMoY29uZmlnLmJhY2tncm91bmRTZWxlY3Rpb25Db2xvciwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYShzZWxlY3RDb2xvcikgPCAxKSB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gdmFsT3JGdW5jKGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhKGJhY2tncm91bmRDb2xvcikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9ycy5wdXNoKGJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChzZWxlY3RDb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvdmVyQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29sb3JzLnB1c2goaG92ZXJDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXJDb2xvcnMoZ2MsIGNvbG9ycywgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gZHJhdyB0ZXh0XG4gICAgICAgIHZhciB0aGVDb2xvciA9IHZhbE9yRnVuYyhjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5mb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgOiBjb25maWcuY29sb3IsIGNvbmZpZyk7XG4gICAgICAgIGlmIChnYy5maWxsU3R5bGUgIT09IHRoZUNvbG9yKSB7XG4gICAgICAgICAgICBnYy5maWxsU3R5bGUgPSB0aGVDb2xvcjtcbiAgICAgICAgICAgIGdjLnN0cm9rZVN0eWxlID0gdGhlQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNIZWFkZXIgJiYgd3JhcEhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTXVsdGlMaW5lVGV4dChnYywgeCwgeSwgaGVpZ2h0LCB3aWR0aCwgY29uZmlnLCB2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJTaW5nbGVMaW5lVGV4dChnYywgeCwgeSwgaGVpZ2h0LCB3aWR0aCwgY29uZmlnLCB2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGljb25XaWR0aCA9IDA7XG4gICAgICAgIGlmIChsZWZ0SWNvbikge1xuICAgICAgICAgICAgaXlvZmZzZXQgPSBNYXRoLnJvdW5kKChoZWlnaHQgLSBsZWZ0SWNvbi5oZWlnaHQpIC8gMik7XG4gICAgICAgICAgICBnYy5kcmF3SW1hZ2UobGVmdEljb24sIHggKyBsZWZ0UGFkZGluZywgeSArIGl5b2Zmc2V0KTtcbiAgICAgICAgICAgIGljb25XaWR0aCA9IE1hdGgubWF4KGxlZnRJY29uLndpZHRoICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0SWNvbiAmJiB3aWR0aCA+IDEuNzUgKiBoZWlnaHQpIHtcbiAgICAgICAgICAgIGl5b2Zmc2V0ID0gTWF0aC5yb3VuZCgoaGVpZ2h0IC0gcmlnaHRJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIHZhciByaWdodFggPSB4ICsgd2lkdGggLSByaWdodEljb24ud2lkdGg7XG4gICAgICAgICAgICBpZiAoYmFja2dyb3VuZENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsYXllckNvbG9ycyhnYywgY29sb3JzLCByaWdodFgsIHksIHJpZ2h0SWNvbi53aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2MuY2xlYXJSZWN0KHJpZ2h0WCwgeSwgcmlnaHRJY29uLndpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2MuZHJhd0ltYWdlKHJpZ2h0SWNvbiwgcmlnaHRYLCB5ICsgaXlvZmZzZXQpO1xuICAgICAgICAgICAgaWNvbldpZHRoID0gTWF0aC5tYXgocmlnaHRJY29uLndpZHRoICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNlbnRlckljb24pIHtcbiAgICAgICAgICAgIGl5b2Zmc2V0ID0gTWF0aC5yb3VuZCgoaGVpZ2h0IC0gY2VudGVySWNvbi5oZWlnaHQpIC8gMik7XG4gICAgICAgICAgICBpeG9mZnNldCA9IE1hdGgucm91bmQoKHdpZHRoIC0gY2VudGVySWNvbi53aWR0aCkgLyAyKTtcbiAgICAgICAgICAgIGdjLmRyYXdJbWFnZShjZW50ZXJJY29uLCB4ICsgd2lkdGggLSBpeG9mZnNldCAtIGNlbnRlckljb24ud2lkdGgsIHkgKyBpeW9mZnNldCk7XG4gICAgICAgICAgICBpY29uV2lkdGggPSBNYXRoLm1heChjZW50ZXJJY29uLndpZHRoICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jZWxsQm9yZGVyVGhpY2tuZXNzKSB7XG4gICAgICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGdjLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBnYy5saW5lV2lkdGggPSBjb25maWcuY2VsbEJvcmRlclRoaWNrbmVzcztcbiAgICAgICAgICAgIGdjLnN0cm9rZVN0eWxlID0gY29uZmlnLmNlbGxCb3JkZXJTdHlsZTtcblxuICAgICAgICAgICAgLy8gYW5pbWF0ZSB0aGUgZGFzaGVkIGxpbmUgYSBiaXQgaGVyZSBmb3IgZnVuXG5cbiAgICAgICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLm1pbldpZHRoID0gY29uZmlnLm1pbldpZHRoICsgMiAqIChpY29uV2lkdGgpO1xuICAgIH0sXG5cbiAgICByZW5kZXJNdWx0aUxpbmVUZXh0OiBmdW5jdGlvbihnYywgeCwgeSwgaGVpZ2h0LCB3aWR0aCwgY29uZmlnLCB2YWwpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZml0VGV4dChnYywgY29uZmlnLCB2YWwsIHdpZHRoKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyU2luZ2xlTGluZVRleHQoZ2MsIHgsIHksIGhlaWdodCwgd2lkdGgsIGNvbmZpZywgc3F1ZWV6ZSh2YWwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2xIRWRnZU9mZnNldCA9IGNvbmZpZy5jZWxsUGFkZGluZyxcbiAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IDAsXG4gICAgICAgICAgICB2YWxpZ25PZmZzZXQgPSBjb25maWcudm9mZnNldCxcbiAgICAgICAgICAgIGhhbGlnbiA9IGNvbmZpZy5oYWxpZ24sXG4gICAgICAgICAgICB0ZXh0SGVpZ2h0ID0gY29uZmlnLmdldFRleHRIZWlnaHQoY29uZmlnLmZvbnQpLmhlaWdodDtcblxuICAgICAgICBzd2l0Y2ggKGhhbGlnbikge1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC0gY29sSEVkZ2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IGNvbEhFZGdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhNaW4gPSAwLCB2TWluID0gTWF0aC5jZWlsKHRleHRIZWlnaHQgLyAyKTtcblxuICAgICAgICB2YWxpZ25PZmZzZXQgKz0gTWF0aC5jZWlsKChoZWlnaHQgLSAobGluZXMubGVuZ3RoIC0gMSkgKiB0ZXh0SGVpZ2h0KSAvIDIpO1xuXG4gICAgICAgIGhhbGlnbk9mZnNldCA9IE1hdGgubWF4KGhNaW4sIGhhbGlnbk9mZnNldCk7XG4gICAgICAgIHZhbGlnbk9mZnNldCA9IE1hdGgubWF4KHZNaW4sIHZhbGlnbk9mZnNldCk7XG5cbiAgICAgICAgZ2Muc2F2ZSgpOyAvLyBkZWZpbmUgYSBjbGlwcGluZyByZWdpb24gZm9yIGNlbGxcbiAgICAgICAgZ2MucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgZ2MuY2xpcCgpO1xuXG4gICAgICAgIGdjLnRleHRBbGlnbiA9IGhhbGlnbjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBnYy5maWxsVGV4dChsaW5lc1tpXSwgeCArIGhhbGlnbk9mZnNldCwgeSArIHZhbGlnbk9mZnNldCArIChpICogdGV4dEhlaWdodCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2MucmVzdG9yZSgpOyAvLyBkaXNjYXJkIGNsaXBwaW5nIHJlZ2lvblxuICAgIH0sXG5cbiAgICByZW5kZXJTaW5nbGVMaW5lVGV4dDogZnVuY3Rpb24oZ2MsIHgsIHksIGhlaWdodCwgd2lkdGgsIGNvbmZpZywgdmFsKSB7XG4gICAgICAgIHZhciBjb2xIRWRnZU9mZnNldCA9IGNvbmZpZy5jZWxsUGFkZGluZyxcbiAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IDAsXG4gICAgICAgICAgICB2YWxpZ25PZmZzZXQgPSBjb25maWcudm9mZnNldCxcbiAgICAgICAgICAgIGhhbGlnbiA9IGNvbmZpZy5oYWxpZ24sXG4gICAgICAgICAgICBpc0NlbGxIb3ZlcmVkID0gY29uZmlnLmlzQ2VsbEhvdmVyZWQsXG4gICAgICAgICAgICBpc0xpbmsgPSBjb25maWcubGluaztcblxuICAgICAgICB2YXIgZm9udE1ldHJpY3MgPSBjb25maWcuZ2V0VGV4dEhlaWdodChjb25maWcuZm9udCk7XG4gICAgICAgIHZhciB0ZXh0V2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCB2YWwpO1xuXG4gICAgICAgIC8vd2UgbXVzdCBzZXQgdGhpcyBpbiBvcmRlciB0byBjb21wdXRlIHRoZSBtaW5pbXVtIHdpZHRoXG4gICAgICAgIC8vZm9yIGNvbHVtbiBhdXRvc2l6aW5nIHB1cnBvc2VzXG4gICAgICAgIGNvbmZpZy5taW5XaWR0aCA9IHRleHRXaWR0aCArICgyICogY29sSEVkZ2VPZmZzZXQpO1xuXG4gICAgICAgIHN3aXRjaCAoaGFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgLy90ZXh0V2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCBjb25maWcudmFsdWUpO1xuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC0gY29sSEVkZ2VPZmZzZXQgLSB0ZXh0V2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIC8vdGV4dFdpZHRoID0gY29uZmlnLmdldFRleHRXaWR0aChnYywgY29uZmlnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSAod2lkdGggLSB0ZXh0V2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IGNvbEhFZGdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFsaWduT2Zmc2V0ID0gTWF0aC5tYXgoMCwgaGFsaWduT2Zmc2V0KTtcbiAgICAgICAgdmFsaWduT2Zmc2V0ID0gdmFsaWduT2Zmc2V0ICsgTWF0aC5jZWlsKGhlaWdodCAvIDIpO1xuXG4gICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGdjLmZpbGxUZXh0KHZhbCwgeCArIGhhbGlnbk9mZnNldCwgeSArIHZhbGlnbk9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDZWxsSG92ZXJlZCkge1xuICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAoaXNMaW5rKSB7XG4gICAgICAgICAgICAgICAgdW5kZXJsaW5lKGNvbmZpZywgZ2MsIHZhbCwgeCArIGhhbGlnbk9mZnNldCwgeSArIHZhbGlnbk9mZnNldCArIE1hdGguZmxvb3IoZm9udE1ldHJpY3MuaGVpZ2h0IC8gMiksIDEpO1xuICAgICAgICAgICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5zdHJpa2VUaHJvdWdoID09PSB0cnVlKSB7XG4gICAgICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHN0cmlrZVRocm91Z2goY29uZmlnLCBnYywgdmFsLCB4ICsgaGFsaWduT2Zmc2V0LCB5ICsgdmFsaWduT2Zmc2V0ICsgTWF0aC5mbG9vcihmb250TWV0cmljcy5oZWlnaHQgLyAyKSwgMSk7XG4gICAgICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBtZW1iZXJPZiBDZWxsUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgRW1lcnNvbidzIHBhaW50IGZ1bmN0aW9uIGZvciBhIHNsaWRlciBidXR0b24uIGN1cnJlbnRseSB0aGUgdXNlciBjYW5ub3QgaW50ZXJhY3Qgd2l0aCBpdFxuICAgICAqL1xuICAgIHBhaW50U2xpZGVyOiBmdW5jdGlvbihnYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvLyBnYy5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIC8vIHZhciB2YWwgPSB0aGlzLmNvbmZpZy52YWx1ZTtcbiAgICAgICAgLy8gdmFyIHJhZGl1cyA9IGhlaWdodCAvIDI7XG4gICAgICAgIC8vIHZhciBvZmZzZXQgPSB3aWR0aCAqIHZhbDtcbiAgICAgICAgLy8gdmFyIGJnQ29sb3IgPSB0aGlzLmNvbmZpZy5pc1NlbGVjdGVkID8gdGhpcy5jb25maWcuYmdTZWxDb2xvciA6ICcjMzMzMzMzJztcbiAgICAgICAgLy8gdmFyIGJ0bkdyYWRpZW50ID0gZ2MuY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeCwgeSArIGhlaWdodCk7XG4gICAgICAgIC8vIGJ0bkdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBiZ0NvbG9yKTtcbiAgICAgICAgLy8gYnRuR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjNjY2NjY2Jyk7XG4gICAgICAgIC8vIHZhciBhcmNHcmFkaWVudCA9IGdjLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAvLyBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyNhYWFhYWEnKTtcbiAgICAgICAgLy8gYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjNzc3Nzc3Jyk7XG4gICAgICAgIC8vIGdjLmZpbGxTdHlsZSA9IGJ0bkdyYWRpZW50O1xuICAgICAgICAvLyByb3VuZFJlY3QoZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgYnRuR3JhZGllbnQpO1xuICAgICAgICAvLyBpZiAodmFsIDwgMS4wKSB7XG4gICAgICAgIC8vICAgICBnYy5maWxsU3R5bGUgPSBhcmNHcmFkaWVudDtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAgIGdjLmZpbGxTdHlsZSA9ICcjZWVlZWVlJztcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgLy8gZ2MuYXJjKHggKyBNYXRoLm1heChvZmZzZXQgLSByYWRpdXMsIHJhZGl1cyksIHkgKyByYWRpdXMsIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAvLyBnYy5maWxsKCk7XG4gICAgICAgIC8vIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICAvLyB0aGlzLmNvbmZpZy5taW5XaWR0aCA9IDEwMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgYSBzcGFya2xpbmUsIGJlY2F1c2UgaXQncyBhIGJhcmNoYXJ0IHdlJ3ZlIGNoYW5nZWQgdGhlIG5hbWUgOykuXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSB5IHNjcmVlbiBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludFNwYXJrYmFyOiBmdW5jdGlvbihnYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuY29uZmlnLnZhbHVlO1xuICAgICAgICBpZiAoIXZhbCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIHZhciBlV2lkdGggPSB3aWR0aCAvIGNvdW50O1xuICAgICAgICB2YXIgZmdDb2xvciA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5mZ1NlbENvbG9yIDogdGhpcy5jb25maWcuZmdDb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmJnQ29sb3IgfHwgdGhpcy5jb25maWcuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhpcy5jb25maWcuaXNTZWxlY3RlZCA/IHRoaXMuY29uZmlnLmJnU2VsQ29sb3IgOiB0aGlzLmNvbmZpZy5iZ0NvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiYXJoZWlnaHQgPSB2YWxbaV0gLyAxMTAgKiBoZWlnaHQ7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4ICsgNSwgeSArIGhlaWdodCAtIGJhcmhlaWdodCwgZVdpZHRoICogMC42NjY2LCBiYXJoZWlnaHQpO1xuICAgICAgICAgICAgeCA9IHggKyBlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuY29uZmlnLm1pbldpZHRoID0gY291bnQgKiAxMDtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBBIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHNwYXJrbGluZS4gIHNlZSBbRWR3YXJkIFR1ZnRlIHNwYXJrbGluZV0oaHR0cDovL3d3dy5lZHdhcmR0dWZ0ZS5jb20vYmJvYXJkL3EtYW5kLWEtZmV0Y2gtbXNnP21zZ19pZD0wMDAxT1IpXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSB5IHNjcmVlbiBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludFNwYXJrbGluZTogZnVuY3Rpb24oZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmNvbmZpZy52YWx1ZTtcbiAgICAgICAgaWYgKCF2YWwgfHwgIXZhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY291bnQgPSB2YWwubGVuZ3RoO1xuICAgICAgICB2YXIgZVdpZHRoID0gd2lkdGggLyBjb3VudDtcblxuICAgICAgICB2YXIgZmdDb2xvciA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5mZ1NlbENvbG9yIDogdGhpcy5jb25maWcuZmdDb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmJnQ29sb3IgfHwgdGhpcy5jb25maWcuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhpcy5jb25maWcuaXNTZWxlY3RlZCA/IHRoaXMuY29uZmlnLmJnU2VsQ29sb3IgOiB0aGlzLmNvbmZpZy5iZ0NvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSBmZ0NvbG9yO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBmZ0NvbG9yO1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmFyaGVpZ2h0ID0gdmFsW2ldIC8gMTEwICogaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IGJhcmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdjLmxpbmVUbyh4ICsgNSwgeSArIGhlaWdodCAtIGJhcmhlaWdodCk7XG4gICAgICAgICAgICBnYy5hcmMoeCArIDUsIHkgKyBoZWlnaHQgLSBiYXJoZWlnaHQsIDEsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICB4ID0geCArIGVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZy5taW5XaWR0aCA9IGNvdW50ICogMTA7XG4gICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgYSB0cmVlIGNlbGwgcmVuZGVyZXIgZm9yIHVzZSBtYWlubHkgd2l0aCB0aGUgcXRyZWUuXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSB5IHNjcmVlbiBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0cmVlQ2VsbFJlbmRlcmVyOiBmdW5jdGlvbihnYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5jb25maWcudmFsdWUuZGF0YTtcbiAgICAgICAgdmFyIGluZGVudCA9IHRoaXMuY29uZmlnLnZhbHVlLmluZGVudDtcbiAgICAgICAgdmFyIGljb24gPSB0aGlzLmNvbmZpZy52YWx1ZS5pY29uO1xuXG4gICAgICAgIC8vZmlsbCBiYWNrZ3JvdW5kIG9ubHkgaWYgb3VyIGJnQ29sb3IgaXMgcG9wdWxhdGVkIG9yIHdlIGFyZSBhIHNlbGVjdGVkIGNlbGxcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmJnQ29sb3IgfHwgdGhpcy5jb25maWcuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhpcy5jb25maWcuaXNTZWxlY3RlZCA/IHRoaXMuY29uZmlnLmJnU2VsQ29sb3IgOiB0aGlzLmNvbmZpZy5iZ0NvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZhbCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZ25PZmZzZXQgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhpcy5jb25maWcuaXNTZWxlY3RlZCA/IHRoaXMuY29uZmlnLmZnU2VsQ29sb3IgOiB0aGlzLmNvbmZpZy5mZ0NvbG9yO1xuICAgICAgICBnYy5maWxsVGV4dChpY29uICsgdmFsLCB4ICsgaW5kZW50LCB5ICsgdmFsaWduT2Zmc2V0KTtcblxuICAgICAgICB2YXIgdGV4dFdpZHRoID0gdGhpcy5jb25maWcuZ2V0VGV4dFdpZHRoKGdjLCBpY29uICsgdmFsKTtcbiAgICAgICAgdmFyIG1pbldpZHRoID0geCArIGluZGVudCArIHRleHRXaWR0aCArIDEwO1xuICAgICAgICB0aGlzLmNvbmZpZy5taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBBbiBlbXB0eSBpbXBsZW1lbnRhdGlvbiBvZiBhIGNlbGwgcmVuZGVyZXIsIHNlZSBbdGhlIG51bGwgb2JqZWN0IHBhdHRlcm5dKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/TnVsbE9iamVjdCkuXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSB5IHNjcmVlbiBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlbXB0eUNlbGxSZW5kZXJlcjogZnVuY3Rpb24oZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXRpYWxpemVDZWxsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5jZWxsQ2FjaGUuc2ltcGxlQ2VsbFJlbmRlcmVyID0ge1xuICAgICAgICAgICAgcGFpbnQ6IHRoaXMuZGVmYXVsdENlbGxQYWludCxcbiAgICAgICAgICAgIHJlbmRlclNpbmdsZUxpbmVUZXh0OiB0aGlzLnJlbmRlclNpbmdsZUxpbmVUZXh0LFxuICAgICAgICAgICAgcmVuZGVyTXVsdGlMaW5lVGV4dDogdGhpcy5yZW5kZXJNdWx0aUxpbmVUZXh0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2VsbENhY2hlLnNsaWRlckNlbGxSZW5kZXJlciA9IHtcbiAgICAgICAgICAgIHBhaW50OiB0aGlzLnBhaW50U2xpZGVyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2VsbENhY2hlLnNwYXJrYmFyQ2VsbFJlbmRlcmVyID0ge1xuICAgICAgICAgICAgcGFpbnQ6IHRoaXMucGFpbnRTcGFya2JhclxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNlbGxDYWNoZS5zcGFya2xpbmVDZWxsUmVuZGVyZXIgPSB7XG4gICAgICAgICAgICBwYWludDogdGhpcy5wYWludFNwYXJrbGluZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNlbGxDYWNoZS50cmVlQ2VsbFJlbmRlcmVyID0ge1xuICAgICAgICAgICAgcGFpbnQ6IHRoaXMudHJlZUNlbGxSZW5kZXJlclxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNlbGxDYWNoZS5lbXB0eUNlbGxSZW5kZXJlciA9IHtcbiAgICAgICAgICAgIHBhaW50OiB0aGlzLmVtcHR5Q2VsbFJlbmRlcmVyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2VsbENhY2hlLmJ1dHRvblJlbmRlcmVyID0ge1xuICAgICAgICAgICAgcGFpbnQ6IHRoaXMucGFpbnRCdXR0b24sXG4gICAgICAgICAgICAvL2RlZmF1bHRDZWxsUGFpbnQ6IHRoaXMuZGVmYXVsdENlbGxQYWludFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNlbGxDYWNoZS5saW5rQ2VsbFJlbmRlcmVyID0ge1xuICAgICAgICAgICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgICAgICBzZWxmLmRlZmF1bHRDZWxsUGFpbnQoZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBsYXllckNvbG9ycyhnYywgY29sb3JzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29sb3JzLmZvckVhY2goZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIGdjLmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB2YWxPckZ1bmModmYsIGNvbmZpZykge1xuICAgIHZhciByZXN1bHQgPSAodHlwZW9mIHZmKVswXSA9PT0gJ2YnID8gdmYoY29uZmlnKSA6IHZmO1xuICAgIHJldHVybiByZXN1bHQgfHwgcmVzdWx0ID09PSAwID8gcmVzdWx0IDogJyc7XG59XG5cbmZ1bmN0aW9uIHVuZGVybGluZShjb25maWcsIGdjLCB0ZXh0LCB4LCB5LCB0aGlja25lc3MpIHtcbiAgICB2YXIgd2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCB0ZXh0KTtcblxuICAgIHN3aXRjaCAoZ2MudGV4dEFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICB4IC09ICh3aWR0aCAvIDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHggLT0gd2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvL2djLmJlZ2luUGF0aCgpO1xuICAgIGdjLmxpbmVXaWR0aCA9IHRoaWNrbmVzcztcbiAgICBnYy5tb3ZlVG8oeCArIDAuNSwgeSArIDAuNSk7XG4gICAgZ2MubGluZVRvKHggKyB3aWR0aCArIDAuNSwgeSArIDAuNSk7XG59XG5cbmZ1bmN0aW9uIHN0cmlrZVRocm91Z2goY29uZmlnLCBnYywgdGV4dCwgeCwgeSwgdGhpY2tuZXNzKSB7XG4gICAgdmFyIGZvbnRNZXRyaWNzID0gY29uZmlnLmdldFRleHRIZWlnaHQoY29uZmlnLmZvbnQpO1xuICAgIHZhciB3aWR0aCA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIHRleHQpO1xuICAgIHkgPSB5IC0gKGZvbnRNZXRyaWNzLmhlaWdodCAqIDAuNCk7XG5cbiAgICBzd2l0Y2ggKGdjLnRleHRBbGlnbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgeCAtPSAod2lkdGggLyAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICB4IC09IHdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy9nYy5iZWdpblBhdGgoKTtcbiAgICBnYy5saW5lV2lkdGggPSB0aGlja25lc3M7XG4gICAgZ2MubW92ZVRvKHggKyAwLjUsIHkgKyAwLjUpO1xuICAgIGdjLmxpbmVUbyh4ICsgd2lkdGggKyAwLjUsIHkgKyAwLjUpO1xufVxuXG5mdW5jdGlvbiBmaW5kTGluZXMoZ2MsIGNvbmZpZywgd29yZHMsIHdpZHRoKSB7XG5cbiAgICBpZiAod29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB3b3JkcztcbiAgICB9XG5cbiAgICAvLyBzdGFydGluZyB3aXRoIGp1c3QgdGhlIGZpcnN0IHdvcmTigKZcbiAgICB2YXIgc3RpbGxGaXRzLCBsaW5lID0gW3dvcmRzLnNoaWZ0KCldO1xuICAgIHdoaWxlIChcbiAgICAgICAgLy8gc28gbG9uZSBhcyBsaW5lIHN0aWxsIGZpdHMgd2l0aGluIGN1cnJlbnQgY29sdW1u4oCmXG4gICAgKHN0aWxsRml0cyA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIGxpbmUuam9pbignICcpKSA8IHdpZHRoKVxuICAgICAgICAvLyDigKZBTkQgdGhlcmUgYXJlIG1vcmUgd29yZHMgYXZhaWxhYmxl4oCmXG4gICAgJiYgd29yZHMubGVuZ3RoXG4gICAgICAgICkge1xuICAgICAgICAvLyDigKZhZGQgYW5vdGhlciB3b3JkIHRvIGVuZCBvZiBsaW5lIGFuZCByZXRlc3RcbiAgICAgICAgbGluZS5wdXNoKHdvcmRzLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICAgIXN0aWxsRml0cyAvLyBpZiBsaW5lIGlzIG5vdyB0b28gbG9uZ+KAplxuICAgICAgICAmJiBsaW5lLmxlbmd0aCA+IDEgLy8g4oCmQU5EIGlzIG11bHRpcGxlIHdvcmRz4oCmXG4gICAgKSB7XG4gICAgICAgIHdvcmRzLnVuc2hpZnQobGluZS5wb3AoKSk7IC8vIOKApmJhY2sgb2ZmIGJ5IChpLmUuLCByZW1vdmUpIG9uZSB3b3JkXG4gICAgfVxuXG4gICAgbGluZSA9IFtsaW5lLmpvaW4oJyAnKV07XG5cbiAgICBpZiAod29yZHMubGVuZ3RoKSB7IC8vIGlmIHRoZXJlJ3MgYW55dGhpbmcgbGVmdOKAplxuICAgICAgICBsaW5lID0gbGluZS5jb25jYXQoZmluZExpbmVzKGdjLCBjb25maWcsIHdvcmRzLCB3aWR0aCkpOyAvLyDigKZicmVhayBpdCB1cCBhcyB3ZWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmU7XG59XG5cbmZ1bmN0aW9uIGZpdFRleHQoZ2MsIGNvbmZpZywgc3RyaW5nLCB3aWR0aCkge1xuICAgIHJldHVybiBmaW5kTGluZXMoZ2MsIGNvbmZpZywgc3F1ZWV6ZShzdHJpbmcpLnNwbGl0KCcgJyksIHdpZHRoKTtcbn1cblxuLy8gdHJpbSBzdHJpbmc7IHRoZW4gcmVkdWNlIGFsbCBydW5zIG9mIG11bHRpcGxlIHNwYWNlcyB0byBhIHNpbmdsZSBzcGFjZVxuZnVuY3Rpb24gc3F1ZWV6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gKHN0cmluZyArICcnKS50cmltKCkucmVwbGFjZSgvXFxzXFxzKy9nLCAnICcpO1xufVxuXG5mdW5jdGlvbiByb3VuZFJlY3QoZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgZmlsbCwgc3Ryb2tlKSB7XG5cbiAgICBpZiAoIXN0cm9rZSkge1xuICAgICAgICBzdHJva2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXJhZGl1cykge1xuICAgICAgICByYWRpdXMgPSA1O1xuICAgIH1cbiAgICBnYy5iZWdpblBhdGgoKTtcbiAgICBnYy5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgZ2MubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gICAgZ2MucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gICAgZ2MubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgZ2MucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgZ2MubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgZ2MubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgICBnYy5zdHJva2UoKTtcbiAgICB9XG4gICAgaWYgKGZpbGwpIHtcbiAgICAgICAgZ2MuZmlsbCgpO1xuICAgIH1cbiAgICBnYy5jbG9zZVBhdGgoKTtcbn1cblxuZnVuY3Rpb24gYWxwaGEoY3NzQ29sb3JTcGVjKSB7XG4gICAgaWYgKGNzc0NvbG9yU3BlYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBzbyBub3QgdmlzaWJsZTsgdHJlYXQgYXMgdHJhbnNwYXJlbnRcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZXMgPSBjc3NDb2xvclNwZWMubWF0Y2goYWxwaGEucmVnZXgpO1xuXG4gICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgLy8gYW4gb3BhcXVlIGNvbG9yIChhIGNvbG9yIHNwZWMgd2l0aCBubyBhbHBoYSBjaGFubmVsKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICB2YXIgQSA9IG1hdGNoZXNbNF07XG5cbiAgICBpZiAoQSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGNzc0NvbG9yU3BlYyBtdXN0IGhhdmUgYmVlbiAndHJhbnNwYXJlbnQnXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBOdW1iZXIoQSk7XG59XG5cbmFscGhhLnJlZ2V4ID0gL14odHJhbnNwYXJlbnR8KChSR0J8SFNMKUFcXCguKixcXHMqKFtcXGRcXC5dKylcXCkpKSQvaTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsUHJvdmlkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSRUdFWFBfQk9PTFMgPSAvXFxiKEFORHxPUnxOT1IpXFxiL2dpLFxuICAgIFJFR0VYUF9DRUxMX0ZJTFRFUiA9IC9eXFxzKig8PXw+PXw8PnxbPOKJpOKJoOKJpT49XXwoTk9UICk/KElOfENPTlRBSU5TfEJFR0lOU3xFTkRTfExJS0UpICk/KC4qPylcXHMqJC9pLFxuICAgIEVYUCA9ICcoLio/KScsIEJSID0gJ1xcXFxiJyxcbiAgICBQUkVGSVggPSAnXicgKyBFWFAgKyBCUixcbiAgICBJTkZJWCA9IEJSICsgRVhQICsgQlIsXG4gICAgUE9TVEZJWCA9IEJSICsgRVhQICsgJyQnLFxuICAgIG9wTWFwID0ge1xuICAgICAgICAnPj0nOiAn4omlJyxcbiAgICAgICAgJzw9JzogJ+KJpCcsXG4gICAgICAgICc8Pic6ICfiiaAnXG4gICAgfTtcblxudmFyIG9wdGlvbnNQcm90b3R5cGUgPSB7XG4gICAgYXV0b0xvb2t1cEJ5TmFtZTogdHJ1ZSxcbiAgICBhdXRvTG9va3VwQnlBbGlhczogdHJ1ZSxcbiAgICBjYXNlU2Vuc2l0aXZlQ29sdW1uTmFtZXM6IGZhbHNlXG59O1xuXG4vKipcbiAqIEBtb2R1bGUgQ1FMXG4gKlxuICogQHN1bW1hcnkgQ29sdW1uIFF1ZXJ5IExhbmd1YWdlXG4gKlxuICogQGF1dGhvciBKb25hdGhhbiBFaXRlbiA8am9uYXRoYW5Ab3BlbmZpbi5jb20+XG4gKlxuICogQGRlc2MgVGhpcyBncmFtbWFyIGNhbWUgZnJvbSB0aGUgbGVnYWN5IHN5c3RlbSBpbiB1c2UgYXQgQmFyY2xheXMgd2hlcmUgdGhleSBlbnRlciBzeW50YXggaW50byBfY29sdW1uIGZpbHRlciBjZWxscy5fIEFzIGluIEh5cGVyZ3JpZCwgZWFjaCBjb2x1bW4ncyBmaWx0ZXIgY2VsbCBpcyBkaXJlY3RseSBiZWxvdyB0aGUgY29sdW1uIGhlYWRlciwgYWJvdmUgdGhlIGRhdGEgcm93cy5cbiAqXG4gKiBUaGUgb3JpZ2luYWwgZ3JhbW1hciB3YXMgc2ltcGx5OlxuICpcbiAqID4gX2V4cHJlc3Npb25fIDo6PSBbIF9vcC1zeW1ib2xfIF0gX29wZXJhbmRfXG4gKiA+IF9vcC1zeW5tYm9sXyA6Oj0gYD1gIHwgYDw+YCB8IGA8YCB8IGA+YCB8IGA8PWAgfCBgPj1gXG4gKiA+IF9vcGVyYW5kXyA6Oj0gX2NvbHVtbi1uYW1lXyB8IF9yYW5kb20tdGV4dF9cbiAqXG4gKiBXZSBleHBhbmRlZCB0aGlzIGdyYW1tYXIgYXMgZm9sbG93czpcbiAqXG4gKiA+IF9leHByZXNzaW9uXyA6Oj0gX3NpbXBsZS1leHByZXNzaW9uXyB7IF9sb2dpYy1vcF8gX3NpbXBsZS1leHByZXNzaW9uXyB9XG4gKiA+IF9zaW1wbGUtZXhwcmVzc2lvbl8gOjo9IFsgX29wZXJhdG9yXyBdIF9vcGVyYW5kX1xuICogPiBfb3BlcmF0b3JfIDo6PSBfb3Atc3ltYm9sXyB8IF9vcC1waHJhc2VfXG4gKiA+IF9vcC1zeW1ib2xfIDo6PSBgPWAgfCBgPD5gIHwgYDxgIHwgYD5gIHwgYDw9YCB8IGA+PWBcbiAqID4gX29wLXBocmFzZV8gOjo9IFsgYE5PVGAgX3doaXRlLXNwYWNlXyBdIF9vcC13b3JkXyBfd2hpdGUtc3BhY2VfXG4gKiA+IF9vcC13b3JkXyA6Oj0gYFNUQVJUU2AgfCBgRU5EU2AgfCBgQ09OVEFJTlNgIHwgYExJS0VgIHwgYElOYFxuICogPiBfb3BlcmFuZF8gOjo9IF9jb2x1bW4tbmFtZV8gfCBfY29sdW1uIGFsaWFzXyB8IF9yYW5kb20tdGV4dF9cbiAqID4gX2xvZ2ljLW9wXyA6Oj0gIF93aGl0ZS1zcGFjZV8gKCBgQU5EYCB8IGBPUmAgfCBgTk9SYCApIF93aGl0ZS1zcGFjZV9cbiAqXG4gKiBOb3RlczpcbiAqIDEuIFRoZSBkZWZhdWx0IF9vcC1zeW1ib2xfIGlzIFwiZXF1YWxzXCIgd2hlbiBubyBvcGVyYXRvciBpcyBnaXZlbi5cbiAqIDIuIE9yZGVyIG9mIG9wZXJhdGlvbnMgaW4gdW5kZWZpbmVkLlxuICogMy4gSW4gcGFydGljdWxhciwgdGhlcmUgaXMgbm8gcHJlY2VkZW5jZSBmb3IgbG9naWNhbCBvcGVyYXRvcnMgYW5kIHRvIHJlc29sdmUgYW55IGFtYmlndWl0eSBhcyB0byB3aGljaCBiaW5kcyBtb3JlIHRpZ2h0bHksIGFsbCBzdWNoIG9wZXJhdG9ycyBpbiBhbiBleHByZXNzaW9uIF9tdXN0IGJlIHRoZSBzYW1lLl8gSWYgeW91IG5lZWQgdG8gZ3JvdXAgdHdvIGV4cHJlc3Npb25zIG1vcmUgdGlnaHRseSwgcHV0IHRoZW0gaW4gYSBzdWJleHByZXNzaW9uLlxuICogNC4gV29yZHMgYXJlIHNob3duIGluIHRoZSBncmFtbWFyIGFib3ZlIGluIHVwcGVyIGNhc2UuIEhvd2V2ZXIsIHRoZXkgbWF5IGJlIGFueSBtaXh0dXJlIG9mIHVwcGVyIGFuZCBsb3dlciBjYXNlLlxuICogNS4gX3doaXRlLXNwYWNlXyBpcyBvcHRpb25hbCBpZiBmb2xsb3dpbmcgb3IgcHJlY2VkaW5nIGEgbm9uLWFscGhhIGNoYXJhY3Rlciwgc3BlY2lmaWNhbGx5LF8gYW4gX29wLXN5bWJvbF8pLlxuICpcbiAqIFRoZSBvcmlnaW5hbCBncmFtbWFyIHdhcyBkZXRlcm1pbmlzdGljICh1bmFtYmlndW91cyksIGNvbnNpc3RpbmcgZW50aXJlbHkgb2YgYSBzaW5nbGUgb3BlcmFuZCAoYWZ0ZXIgdGhlIG9wdGlvbmFsIG9wZXJhdG9yLCB0aGF0IGlzKS4gVGhlIG9uZSBleGNlcHRpb24gaXMgd2hlbiB0aGF0IG9wZXJhbmQgaXMgYW4gZXhhY3QgKGNhc2UtaW5zZW5zaXRpdmUpIG1hdGNoIGZvciB0aGUgbmFtZSAob3IgYWxpYXMpIG9mIGEgY29sdW1uLCBpdCB3b3VsZCBpbmRpcmVjdCB0byB0aGF0IG5hbWVkIGNvbHVtbidzIHZhbHVlLiBUaHVzLCB0aGVyZSBpcyBubyB3YXkgdG8gdXNlIGEgY29sdW1uIG5hbWUgYXMgYSBsaXRlcmFsLlxuICpcbiAqIFRoZSBleHRlbmRlZCBncmFtbWFyIGlzIGRlZmluaXRlbHkgbm9uLWRldGVybWluaXN0aWMgYmVjYXVzZSwgaW4gYWRkaXRpb24gdG8gdGhlIGFib3ZlLCB0aGUgd29yZHMgYGFuZGAsIGBvcmAsIGFuZCBgbm9yYCBhbHNvIGNhbm5vdCBiZSBwYXJ0IG9mIGEgbGl0ZXJhbC4gSW4gYSBmdXR1cmUgcmVsZWFzZSwgd2UgcGxhbiB0byBhbGxvdyBvcHRpb25hbCBwYWlyZWQgcXVvdGF0aW9uIG1hcmtzIG9yIHBhcmVudGhlc2VzIHRvIHNvbHZlIHRoaXMgcHJvYmxlbTpcbiAqXG4gKiA+IF9xdW90ZWQtb3BlcmFuZF8gOjo9ICggYCdgIHwgYFwiYCB8IGAoYCApIF9vcGVyYW5kXyAoIGAnYCB8IGBcImAgfCBgKWAgKVxuICpcbiAqIEBwYXJhbSB7RmlsdGVyVHJlZX0gc2NoZW1hIC0gQ29sdW1uIHNjaGVtYSBmb3IgY29sdW1uIG5hbWUgcmVjb2duaXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5wcm9wUmVzb2x2ZXJdXG4gKi9cbmZ1bmN0aW9uIENvbHVtblF1ZXJ5TGFuZ3VhZ2Uoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zUHJvdG90eXBlKTtcblxuICAgIGlmIChvcHRpb25zKSB7IHRoaXMuc2V0T3B0aW9ucyhmdW5jdGlvbihrZXkpIHsgcmV0dXJuIG9wdGlvbnNba2V5XTsgfSk7IH1cbn1cblxuQ29sdW1uUXVlcnlMYW5ndWFnZS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogQ29sdW1uUXVlcnlMYW5ndWFnZS5wcm90b3R5cGUuY29uc3RydWN0b3IsXG5cbiAgICAvKiogT3ZlcnJpZGUgZGVmYXVsdCBwcm9wZXJ0aWVzIHdpdGggcHJvcGVydGllcyBkZWZpbmVkIGJ5IHN1cHBsaWVkIHByb3BlcnR5IHJlc29sdmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb3BSZXNvbHZlclxuICAgICAqL1xuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKHByb3BSZXNvbHZlcikge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9uc1Byb3RvdHlwZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNQcm90b3R5cGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gcHJvcFJlc29sdmVyKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9uc1trZXldOyAvLyByZXZlYWxzIHByb3RvdHlwZSAoZGVmYXVsdCkgdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRXh0cmFjdCB0aGUgYm9vbGVhbiBvcGVyYXRvcnMgZnJvbSBhbiBleHByZXNzaW9uIGNoYWluLlxuICAgICAqIEBkZXNjIFJldHVybnMgbGlzdCBvZiBob21vZ2VuZW91cyBvcGVyYXRvcnMgdHJhbnNmb3JtZWQgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBhbGwgdGhlIGJvb2xlYW4gb3BlcmF0b3JzIGluIHRoZSBjaGFpbiBhcmUgbm90IGlkZW50aWNhbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3FsXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGNhcHR1cmVCb29sZWFuczogZnVuY3Rpb24oY3FsKSB7XG4gICAgICAgIHZhciBib29sZWFucyA9IGNxbC5tYXRjaChSRUdFWFBfQk9PTFMpO1xuXG4gICAgICAgIGlmIChib29sZWFucykge1xuICAgICAgICAgICAgdmFyIGhldGVyb2dlbmVvdXNPcGVyYXRvciA9IGJvb2xlYW5zLmZpbmQoZnVuY3Rpb24ob3AsIGkpIHtcbiAgICAgICAgICAgICAgICBib29sZWFuc1tpXSA9IG9wLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW5zW2ldICE9PSBib29sZWFuc1swXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaGV0ZXJvZ2VuZW91c09wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgICAgICAgICAgICAgJ0V4cGVjdGVkIGhvbW9nZW5lb3VzIGJvb2xlYW4gb3BlcmF0b3JzLicsXG4gICAgICAgICAgICAgICAgICAgICdZb3UgY2Fubm90IG1peCA8Y29kZT5BTkQ8L2NvZGU+LCA8Y29kZT5PUjwvY29kZT4sIGFuZCA8Y29kZT5OT1I8L2NvZGU+IG9wZXJhdG9ycyBoZXJlLicsXG4gICAgICAgICAgICAgICAgICAgICcoRXZlcnl0aGluZyBhZnRlciB5b3VyIDxjb2RlIHN0eWxlPVwiY29sb3I6cmVkXCI+JyArIGhldGVyb2dlbmVvdXNPcGVyYXRvci50b1VwcGVyQ2FzZSgpICsgJzwvY29kZT4gd2FzIGlnbm9yZWQuKScsXG4gICAgICAgICAgICAgICAgICAgICc8aT5UaXA6IFlvdSBjYW4gY3JlYXRlIG1vcmUgY29tcGxleCBmaWx0ZXJzIGJ5IHVzaW5nIE1hbmFnZSBGaWx0ZXJzLjwvaT4nXG4gICAgICAgICAgICAgICAgXS5qb2luKCc8YnI+JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvb2xlYW5zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCcmVhayBhbiBleHByZXNzaW9uIGNoYWluIGludG8gYSBsaXN0IG9mIGV4cHJlc3Npb25zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjcWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgY2FwdHVyZUV4cHJlc3Npb25zOiBmdW5jdGlvbihjcWwsIGJvb2xlYW5zKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9ucywgcmU7XG5cbiAgICAgICAgaWYgKGJvb2xlYW5zKSB7XG4gICAgICAgICAgICByZSA9IG5ldyBSZWdFeHAoUFJFRklYICsgYm9vbGVhbnMuam9pbihJTkZJWCkgKyBQT1NURklYLCAnaScpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBjcWwubWF0Y2gocmUpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMuc2hpZnQoKTsgLy8gZGlzY2FyZCBbMF0gKGlucHV0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBbY3FsXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByZXNzaW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTWFrZSBhIGxpc3Qgb2YgY2hpbGRyZW4gb3V0IG9mIGEgbGlzdCBvZiBleHByZXNzaW9ucy5cbiAgICAgKiBAZGVzYyBVc2VzIG9ubHkgX2NvbXBsZXRlXyBleHByZXNzaW9ucyAoYSB2YWx1ZSBPUiBhbiBvcGVyYXRvciArIGEgdmFsdWUpLlxuICAgICAqXG4gICAgICogSWdub3JlcyBfaW5jb21wbGV0ZV8gZXhwcmVzc2lvbnMgKGVtcHR5IHN0cmluZyBPUiBhbiBvcGVyYXRvciAtIGEgdmFsdWUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbHVtbk5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBleHByZXNzaW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge2V4cHJlc3Npb25TdGF0ZVtdfSB3aGVyZSBgZXhwcmVzc2lvblN0YXRlYCBpcyBvbmUgb2Y6XG4gICAgICogKiBge2NvbHVtbjogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCBsaXRlcmFsOiBzdHJpbmd9YFxuICAgICAqICogYHtjb2x1bW46IHN0cmluZywgb3BlcmF0b3I6IHN0cmluZywgY29sdW1uMjogc3RyaW5nLCBlZGl0b3I6ICdDb2x1bW5zJ31gXG4gICAgICovXG4gICAgbWFrZUNoaWxkcmVuOiBmdW5jdGlvbihjb2x1bW5OYW1lLCBleHByZXNzaW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtdLFxuICAgICAgICAgICAgb3JwaGFuZWRPcHMgPSBbXTtcblxuICAgICAgICBleHByZXNzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gZXhwcmVzc2lvbi5tYXRjaChSRUdFWFBfQ0VMTF9GSUxURVIpLFxuICAgICAgICAgICAgICAgICAgICBvcCA9IHBhcnRzWzFdICYmIHBhcnRzWzFdLnRyaW0oKS50b1VwcGVyQ2FzZSgpIHx8ICc9JyxcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ycGhhbmVkT3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wYXJlTGl0ZXJhbCA9IHNlbGYuY29tcGFyYWJsZShsaXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IHNlbGYuc2NoZW1hLmZpbmQoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVMaXRlcmFsID09PSAoc2VsZi5hdXRvTG9va3VwQnlOYW1lICYmIHNlbGYuY29tcGFyYWJsZShjb2x1bW4ubmFtZSB8fCBjb2x1bW4pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVMaXRlcmFsID09PSAoc2VsZi5hdXRvTG9va3VwQnlBbGlhcyAmJiBzZWxmLmNvbXBhcmFibGUoY29sdW1uLmFsaWFzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBvcE1hcFtvcF0gfHwgb3BcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb2x1bW4yID0gZmllbGROYW1lLm5hbWUgfHwgZmllbGROYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZWRpdG9yID0gJ0NvbHVtbnMnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubGl0ZXJhbCA9IGxpdGVyYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwICYmIG9ycGhhbmVkT3BzLmxlbmd0aCA+IDAgfHwgb3JwaGFuZWRPcHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIFJFRCA9ICcgPGNvZGUgc3R5bGU9XCJjb2xvcjpyZWRcIj4nO1xuICAgICAgICAgICAgaWYgKG9ycGhhbmVkT3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG9ycGhhbmVkT3BzID0gW1xuICAgICAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgYSB2YWx1ZSBmb2xsb3dpbmcnICsgUkVEICsgb3JwaGFuZWRPcHMgK1xuICAgICAgICAgICAgICAgICAgICAnPC9jb2RlPiB0byBjb21wYXJlIGFnYWluc3QgdGhlIGNvbHVtbi4nLFxuICAgICAgICAgICAgICAgICAgICAnVGhlIGluY29tcGxldGUgZXhwcmVzc2lvbiB3YXMgaWdub3JlZC4nXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3JwaGFuZWRPcHMgPSBbXG4gICAgICAgICAgICAgICAgICAgICdFeHBlY3RlZCB2YWx1ZXMgZm9sbG93aW5nJyArIFJFRCArIG9ycGhhbmVkT3BzLmpvaW4oJzwvY29kZT4gYW5kJyArIFJFRCkgKyAnPC9jb2RlPiB0byBjb21wYXJlIGFnYWluc3QgdGhlIGNvbHVtbi4nLFxuICAgICAgICAgICAgICAgICAgICAnVGhlIGluY29tcGxldGUgZXhwcmVzc2lvbnMgd2VyZSBpZ25vcmVkLidcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcnBoYW5lZE9wTXNnID0gb3JwaGFuZWRPcHMuam9pbignPGJyPicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcnBoYW5lZE9wTXNnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH0sXG5cbiAgICBjb21wYXJhYmxlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5jYXNlU2Vuc2l0aXZlQ29sdW1uTmFtZXMgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE1ha2UgYSBcImxvY2tlZFwiIHN1YmV4cHJlc3Npb24gZGVmaW5pdGlvbiBvYmplY3QgZnJvbSBhbiBleHByZXNzaW9uIGNoYWluLlxuICAgICAqIEBkZXNjIF9Mb2NrZWRfIG1lYW5zIGl0IGlzIGxvY2tlZCB0byBhIHNpbmdsZSBmaWVsZC5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlcmUgaXMgb25seSBhIHNpbmdsZSBleHByZXNzaW9uIGluIHRoZSBjaGFpbiwgdGhlIGBvcGVyYXRvcmAgaXMgb21pdHRlZCAoZGVmYXVsdHMgdG8gYCdvcC1hbmQnYCkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbHVtbk5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3FsIC0gQSBDUUwgZXhwcmVzc2lvbiAob25lIG9yIG1vcmUgc2ltcGxlIGV4cHJlc3Npb25zIGFsbCBzZXBhcmF0ZWQgYnkgdGhlIHNhbWUgbG9naWNhbCBvcGVyYXRvcikuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHx7b3BlcmF0b3I6IHN0cmluZywgY2hpbGRyZW46IHN0cmluZ1tdLCBzY2hlbWE6IHN0cmluZ1tdfX1cbiAgICAgKiBgdW5kZWZpbmVkYCB3aGVuIHRoZXJlIGFyZSBubyBjb21wbGV0ZSBleHByZXNzaW9uc1xuICAgICAqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpDUUxcbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24oY29sdW1uTmFtZSwgY3FsKSB7XG4gICAgICAgIC8vIHJlZHVjZSBhbGwgcnVucyBvZiB3aGl0ZSBzcGFjZSB0byBhIHNpbmdsZSBzcGFjZTsgdGhlbiB0cmltXG4gICAgICAgIGNxbCA9IGNxbC5yZXBsYWNlKC9cXHNcXHMrL2csICcgJykudHJpbSgpO1xuXG4gICAgICAgIHZhciBib29sZWFucyA9IHRoaXMuY2FwdHVyZUJvb2xlYW5zKGNxbCksXG4gICAgICAgICAgICBleHByZXNzaW9ucyA9IHRoaXMuY2FwdHVyZUV4cHJlc3Npb25zKGNxbCwgYm9vbGVhbnMpLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLm1ha2VDaGlsZHJlbihjb2x1bW5OYW1lLCBleHByZXNzaW9ucyksXG4gICAgICAgICAgICBvcGVyYXRvciA9IGJvb2xlYW5zICYmIGJvb2xlYW5zWzBdLFxuICAgICAgICAgICAgc3RhdGU7XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbHVtbkZpbHRlcicsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVyYXRvciA9ICdvcC0nICsgb3BlcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNxbCA9IGNxbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblF1ZXJ5TGFuZ3VhZ2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGaWx0ZXJUcmVlID0gcmVxdWlyZSgnZmlsdGVyLXRyZWUnKTtcbi8vdmFyIEZpbHRlclRyZWUgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9maWx0ZXItdHJlZS9zcmMvanMvRmlsdGVyVHJlZScpO1xudmFyIHBvcE1lbnUgPSByZXF1aXJlKCdwb3AtbWVudScpO1xuXG52YXIgQ29sdW1uUXVlcnlMYW5ndWFnZSA9IHJlcXVpcmUoJy4vQ29sdW1uUXVlcnlMYW5ndWFnZScpO1xuXG4vKlxuZnVuY3Rpb24gQ29sdW1uUXVlcnlMYW5ndWFnZSgpIHt9XG5cbkNvbHVtblF1ZXJ5TGFuZ3VhZ2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oY29sdW1uTmFtZSwgc3RhdGUpIHtcbiAgICBzdGF0ZSA9ICB7XG4gICAgICAgIHR5cGU6ICdjb2x1bW5GaWx0ZXInLFxuICAgICAgICBjaGlsZHJlbjogWyB7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbk5hbWUsXG4gICAgICAgICAgICBvcGVyYXRvcjogJz4nLFxuICAgICAgICAgICAgbGl0ZXJhbDogJzInXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uTmFtZSxcbiAgICAgICAgICAgIG9wZXJhdG9yOiAnPCcsXG4gICAgICAgICAgICBsaXRlcmFsOiAnOCdcbiAgICAgICAgfSBdXG4gICAgfTtcbiAgICByZXR1cm4gc3RhdGU7XG59O1xuXG5Db2x1bW5RdWVyeUxhbmd1YWdlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24oKSB7fTtcbiovXG5cbi8qKiBAdHlwZWRlZiB7ZnVuY3Rpb259IGZpZWxkc1Byb3ZpZGVyRnVuY1xuICogQHJldHVybnMge21lbnVPcHRpb25bXX0gc2VlIGpzZG9jIHR5cGVkZWYgaW4gcG9wLW1lbnUuanNcbiAqL1xuXG52YXIgUVVJRVRfVkFMSURBVElPTiA9IHtcbiAgICBhbGVydDogZmFsc2UsXG4gICAgZm9jdXM6IGZhbHNlXG59O1xuXG4vKiogQGNvbnN0cnVjdG9yXG4gKlxuICogQGRlc2MgVGhpcyBleHRlbnNpb24gb2YgRmlsdGVyVHJlZSBmb3JjZXMgYSBzcGVjaWZpYyB0cmVlIHN0cnVjdHVyZS5cbiAqIFNlZSB7QGxpbmsgbWFrZU5ld1Jvb3R9IGZvciBhIGRlc2NyaXB0aW9uLlxuICpcbiAqIEBwYXJhbSB7RmlsdGVyVHJlZU9wdGlvbnNPYmplY3R9IG9wdGlvbnMgLSBZb3UgbXVzdCBwcm92aWRlIGNvbHVtbiBzY2hlbWEsIGVpdGhlciBmb3IgdGhlIHdob2xlIGZpbHRlciB0cmVlIHRocm91Z2ggYG9wdGlvbnMuc2NoZW1hYCBvciBgb3B0aW9ucy5zdGF0ZS5zY2hlbWFgIG9yIGZvciB0aGUgc3BlY2lmaWMgbm9kZXMgdGhhdCBuZWVkIHRvIHJlbmRlciBjb2x1bW4gbGlzdCBkcm9wLWRvd25zLlxuICpcbiAqID4gTk9URTogSWYgYG9wdGlvbnMuc3RhdGVgIGlzIHVuZGVmaW5lZCwgaXQgaXMgZGVmaW5lZCBoZXJlIGFzIGEgbmV3IHtAbGluayBtYWtlTmV3Um9vdHxlbXB0eSBzdGF0ZSBzY2FmZm9sZCkgdG8gaG9sZCBuZXcgdGFibGUgZmlsdGVyIGFuZCBjb2x1bW4gZmlsdGVyIGV4cHJlc3Npb25zIHRvIGJlIGFkZGVkIHRocm91Z2ggVUkuXG4gKi9cbnZhciBDdXN0b21GaWx0ZXIgPSBGaWx0ZXJUcmVlLmV4dGVuZCgnQ3VzdG9tRmlsdGVyJywge1xuXG4gICAgcHJlSW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuXG4gICAgICAgICAgICAvLyBTZXQgdXAgdGhlIGRlZmF1bHQgXCJIeXBlcmZpbHRlclwiIHByb2ZpbGUgKHNlZSBmdW5jdGlvbiBjb21tZW50cylcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhdGUgPSBvcHRpb25zLnN0YXRlIHx8IHRoaXMubWFrZU5ld1Jvb3QoKTtcblxuICAgICAgICAgICAgLy8gVXBvbiBjcmVhdGlvbiBvZiBhICdjb2x1bW5GaWx0ZXInIG5vZGUsIGZvcmNlIHRoZSBzY2hlbWEgdG8gdGhlIG9uZSBjb2x1bW5cbiAgICAgICAgICAgIGlmICgob3B0aW9ucy50eXBlIHx8IG9wdGlvbnMuc3RhdGUgJiYgb3B0aW9ucy5zdGF0ZS50eXBlKSA9PT0gJ2NvbHVtbkZpbHRlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYSA9IFtcbiAgICAgICAgICAgICAgICAgICAgcG9wTWVudS5maW5kSXRlbShvcHRpb25zLnBhcmVudC5yb290LnNjaGVtYSwgb3B0aW9ucy5zdGF0ZS5jaGlsZHJlblswXS5jb2x1bW4pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhY3RTdWJ0cmVlcygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBjb252ZW5pZW5jZSB2YXJzIHRvIHJlZmVyZW5jZSB0aGUgMiByb290IFwiSHlwZXJmaWx0ZXJcIiBub2Rlc1xuICAgICAqL1xuICAgIGV4dHJhY3RTdWJ0cmVlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByb290Tm9kZXMgPSB0aGlzLnJvb3QuY2hpbGRyZW47XG4gICAgICAgIHRoaXMudGFibGVGaWx0ZXIgPSByb290Tm9kZXNbMF07XG4gICAgICAgIHRoaXMuY29sdW1uRmlsdGVycyA9IHJvb3ROb2Rlc1sxXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTWFrZSBhIG5ldyBlbXB0eSBIeXBlcmdyaWQgZmlsdGVyIHRyZWUgc3RhdGUgb2JqZWN0LlxuICAgICAqIEBkZXNjIFRoaXMgZnVuY3Rpb24gbWFrZXMgYSBuZXcgZGVmYXVsdCBzdGF0ZSBvYmplY3QgYXMgdXNlZCBieSBIeXBlcmdyaWQsIGEgcm9vdCB3aXRoIGV4YWN0bHkgdHdvIHBlcnNpc3RlZCBjaGlsZCBub2RlczpcbiAgICAgKlxuICAgICAqICogY2hpbGRyZW5bMF0gcmVwcmVzZW50cyB0aGUgX3RhYmxlIGZpbHRlcixfIGEgc2VyaWVzIG9mIGFueSBudW1iZXIgb2YgZmlsdGVyIGV4cHJlc3Npb25zIGFuZC9vciBzdWJleHByZXNzaW9uc1xuICAgICAqICogY2hpbGRyZW5bMV0gcmVwcmVzZW50cyB0aGUgX2NvbHVtbiBmaWx0ZXJzLF8gYSBzZXJpZXMgb2Ygc3ViZXhwcmVzc2lvbnMsIG9uZSBwZXIgYWN0aXZlIGNvbHVtbiBmaWx0ZXJcbiAgICAgKlxuICAgICAqIFRoZSBgb3BlcmF0b3JgIHByb3BlcnRpZXMgZm9yIGFsbCBzdWJleHByZXNzaW9ucyBkZWZhdWx0IHRvIGAnb3AtYW5kJ2AsIHdoaWNoIG1lYW5zOlxuICAgICAqICogQU5EIGFsbCB0YWJsZSBmaWx0ZXIgZXhwcmVzc2lvbnMgYW5kIHN1YmV4cHJlc3Npb25zIHRvZ2V0aGVyIChtYXkgYmUgY2hhbmdlZCBmcm9tIFVJKVxuICAgICAqICogQU5EIGFsbCBjb2x1bW4gRmlsdGVycyBzdWJleHByZXNzaW9ucyB0b2dldGhlciAoY2Fubm90IGJlIGNoYW5nZWQgZnJvbSBVSSlcbiAgICAgKiAqIEFORCB0YWJsZSBmaWx0ZXJzIGFuZCBjb2x1bW4gZmlsdGVycyB0b2dldGhlciAoY2Fubm90IGJlIGNoYW5nZWQgZnJvbSBVSSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIGEgSHlwZXJmaWx0ZXIgcm9vdFxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmZpbHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtYWtlTmV3Um9vdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy50YWJsZUZpbHRlciA9IHtcbiAgICAgICAgICAgIHBlcnNpc3Q6IHRydWUsXG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIC8vIHRhYmxlIGZpbHRlciBleHByZXNzaW9ucyBhbmQgc3ViZXhwcmVzc2lvbnMgZ28gaGVyZVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY29sdW1uRmlsdGVycyA9IHtcbiAgICAgICAgICAgIHBlcnNpc3Q6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiAnY29sdW1uRmlsdGVycycsXG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIC8vIHN1YmV4cHJlc3Npb25zIHdpdGggdHlwZSAnY29sdW1uRmlsdGVyJyBnbyBoZXJlLCBvbmUgZm9yIGVhY2ggYWN0aXZlIGNvbHVtbiBmaWx0ZXJcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZmlsdGVyID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlRmlsdGVyLFxuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uRmlsdGVyc1xuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkZpbHRlcjogZnVuY3Rpb24oY29sdW1uTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5GaWx0ZXJzLmNoaWxkcmVuLmZpbmQoZnVuY3Rpb24oY29sdW1uRmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uRmlsdGVyLmNoaWxkcmVuLmxlbmd0aCAmJiBjb2x1bW5GaWx0ZXIuY2hpbGRyZW5bMF0uY29sdW1uID09PSBjb2x1bW5OYW1lO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uTmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc3ludGF4PSdDUUwnXSBTZWUgZGV0ZWN0U3RhdGUgaW4gRmlsdGVyTm9kZS5qcy5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5GaWx0ZXJTdGF0ZTogZnVuY3Rpb24oY29sdW1uTmFtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYWNoZVtjb2x1bW5OYW1lXTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBzdWJleHByZXNzaW9uID0gdGhpcy5nZXRDb2x1bW5GaWx0ZXIoY29sdW1uTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChzdWJleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5bnRheCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zeW50YXggfHwgJ0NRTCc7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3ViZXhwcmVzc2lvbi5nZXRTdGF0ZSh7IHN5bnRheDogc3ludGF4IH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jYWNoZVtjb2x1bW5OYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbk5hbWVcbiAgICAgKiBAcGFyYW0gc3RhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnN5bnRheD0nQ1FMJ10gU2VlIGRldGVjdFN0YXRlIGluIEZpbHRlck5vZGUuanMuXG4gICAgICovXG4gICAgc2V0Q29sdW1uRmlsdGVyU3RhdGU6IGZ1bmN0aW9uKGNvbHVtbk5hbWUsIHN0YXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzeW50YXggPSBvcHRpb25zICYmIG9wdGlvbnMuc3ludGF4LFxuICAgICAgICAgICAgaXNDcWwgPSBzeW50YXggPT09IHVuZGVmaW5lZCB8fCBzeW50YXggPT09ICdDUUwnLFxuICAgICAgICAgICAgc3ViZXhwcmVzc2lvbiA9IHRoaXMuZ2V0Q29sdW1uRmlsdGVyKGNvbHVtbk5hbWUpO1xuXG4gICAgICAgIGlmIChpc0NxbCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLkNRTCkge1xuICAgICAgICAgICAgICAgIC8vIHNldCB1cCBhIG5ldyBDUUwgaW5zdGFuY2UgZm9yIHRoaXMgY29sdW1uIHByaW9yIHRvIGZpcnN0IHVzZVxuICAgICAgICAgICAgICAgIHRoaXMuQ1FMID0gbmV3IENvbHVtblF1ZXJ5TGFuZ3VhZ2UodGhpcy5yb290LnNjaGVtYSk7XG5cbiAgICAgICAgICAgICAgICAvLyBiaW5kIGl0IHRvIHRoaXMgY29sdW1uJ3MgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIHRoaXMuQ1FMLnNldE9wdGlvbnMocmVzb2x2ZVByb3BlcnR5LmJpbmQodGhpcywgY29sdW1uTmFtZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHNvbWUgQ1FMIHN0YXRlIHN5bnRheCBpbnRvIGEgZmlsdGVyIHRyZWUgc3RhdGUgb2JqZWN0XG4gICAgICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLkNRTC5wYXJzZShjb2x1bW5OYW1lLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZVtjb2x1bW5OYW1lXSA9IHRoaXMuQ1FMLmNxbDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gdGhpcy5DUUwub3JwaGFuZWRPcE1zZztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZS5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdWJleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBzdWJleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGlzIGNvbHVtblxuICAgICAgICAgICAgICAgIHN1YmV4cHJlc3Npb24uc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgYSBzdWJleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGlzIGNvbHVtblxuICAgICAgICAgICAgICAgIHN1YmV4cHJlc3Npb24gPSB0aGlzLmNvbHVtbkZpbHRlcnMuYWRkKHN0YXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3ViZXhwcmVzc2lvbi5pbnZhbGlkKFFVSUVUX1ZBTElEQVRJT04pO1xuICAgICAgICB9IGVsc2UgLyogIXN0YXRlICovIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBzdWJleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGlzIGNvbHVtblxuICAgICAgICAgICAgc3ViZXhwcmVzc2lvbi5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBBbGwgcmVtYWluaW5nIG1ldGhvZHMgYXJlIGNvLXJvdXRpbmVzIGNhbGxlZCBmcm9tIGdyaWQuZGlhbG9nXG4gICAgLy8gU2VlIGNlbGxFZGl0b3JzL0ZpbHRlci5qc1xuXG4gICAgaW5pdGlhbGl6ZURpYWxvZzogZnVuY3Rpb24oKSB7XG5cbiAgICB9LFxuXG4gICAgb25TaG93OiBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuICAgIH0sXG5cbiAgICBvbk9rOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52YWxpZCgpO1xuICAgIH0sXG5cbiAgICBvblJlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgIH0sXG5cbiAgICBvbkRlbGV0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICB9LFxuXG4gICAgb25DYW5jZWw6IGZ1bmN0aW9uKCkge1xuXG4gICAgfSxcblxuICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlc3QuYmluZCh0aGlzKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnR5KGNvbHVtbk5hbWUsIHByb3BlcnR5TmFtZSkge1xuICAgIC8vdG9kbzogZmluaXNoIHRoaXNcbiAgICAvL3JldHVybiBjb2x1bW4ucmVzb2x2ZVByb3BlcnR5KCdmaWx0ZXJDcWwnICsga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyKDEpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDdXN0b21GaWx0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5uKG51bWJlcikge1xuICAgIHJldHVybiAobnVtYmVyIDwgMTAgPyAnLTAnIDogJy0nKSArIG51bWJlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGF0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZVxuICAgICAgICAgICAgPyB2YWx1ZS5nZXRGdWxsWWVhcigpICsgbm4odmFsdWUuZ2V0TW9udGgoKSArIDEpICsgbm4odmFsdWUuZ2V0RGF0ZSgpKVxuICAgICAgICAgICAgOiB2YWx1ZSArICcnO1xuICAgIH0sXG4gICAgZGVmYXVsdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICsgJyc7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgb2lkUHJlZml4ID0gJy5+LiMlXyc7IC8vdGhpcyBzaG91bGQgYmUgc29tZXRoaW5nIHdlIG5ldmVyIHdpbGwgc2VlIGF0IHRoZSBiZWdpbmluZyBvZiBhIHN0cmluZ1xuICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgIHZhciBoYXNoID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciB0eXBlT2YgPSB0eXBlb2Yga2V5O1xuICAgICAgICBzd2l0Y2ggKHR5cGVPZikge1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2lkUHJlZml4ICsgdHlwZU9mICsgJ18nICsga2V5O1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2lkUHJlZml4ICsgdHlwZU9mICsgJ18nICsga2V5O1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9pZFByZWZpeCArIHR5cGVPZiArICdfJyArIGtleTtcbiAgICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9pZFByZWZpeCArIHR5cGVPZiArICdfJyArIGtleTtcbiAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9pZFByZWZpeCArICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAvKmVzbGludC1kaXNhYmxlICovXG4gICAgICAgICAgICAgICAgaWYgKCFrZXkuX19fZmluaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkuX19fZmluaGFzaCA9IG9pZFByZWZpeCArIGNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleS5fX19maW5oYXNoO1xuICAgICAgICAgICAgICAgIC8qZXNsaW50LWVuYWJsZSAqL1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIE9iamVjdC5pcyBwb2x5ZmlsbCwgY291cnRlc3kgb2YgQFdlYlJlZmxlY3Rpb25cbiAgICB2YXIgaXMgPSBPYmplY3QuaXMgfHxcbiAgICAgICAgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgPT09IGIgPyBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiIDogYSAhPSBhICYmIGIgIT0gYjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICB9O1xuXG4gICAgLy8gTW9yZSByZWxpYWJsZSBpbmRleE9mLCBjb3VydGVzeSBvZiBAV2ViUmVmbGVjdGlvblxuICAgIHZhciBiZXR0ZXJJbmRleE9mID0gZnVuY3Rpb24oYXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IDApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFyci5sZW5ndGg7IGktLSAmJiAhaXMoYXJyW2ldLCB2YWx1ZSk7KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgPSBbXS5pbmRleE9mLmNhbGwoYXJyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIE1hcHB5KCkge1xuICAgICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfVxuXG4gICAgTWFwcHkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGhhc2hDb2RlID0gaGFzaChrZXkpO1xuICAgICAgICBpZiAodGhpcy5kYXRhW2hhc2hDb2RlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhW2hhc2hDb2RlXSA9IHZhbHVlO1xuICAgIH07XG5cbiAgICBNYXBweS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBoYXNoQ29kZSA9IGhhc2goa2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtoYXNoQ29kZV07XG4gICAgfTtcblxuICAgIE1hcHB5LnByb3RvdHlwZS5nZXRJZkFic2VudCA9IGZ1bmN0aW9uKGtleSwgaWZBYnNlbnRGdW5jKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGlmQWJzZW50RnVuYyhrZXksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgTWFwcHkucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cy5sZW5ndGg7XG4gICAgfTtcblxuICAgIE1hcHB5LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmtleXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgfTtcblxuICAgIE1hcHB5LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGhhc2hDb2RlID0gaGFzaChrZXkpO1xuICAgICAgICBpZiAodGhpcy5kYXRhW2hhc2hDb2RlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gYmV0dGVySW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG4gICAgICAgIHRoaXMua2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBkZWxldGUgdGhpcy5kYXRhW2hhc2hDb2RlXTtcbiAgICB9O1xuXG4gICAgTWFwcHkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGZ1bmModmFsdWUsIGtleSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTWFwcHkucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG4gICAgICAgIHZhciBuZXdNYXAgPSBuZXcgTWFwcHkoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSBmdW5jKHZhbHVlLCBrZXksIHRoaXMpO1xuICAgICAgICAgICAgbmV3TWFwLnNldChrZXksIHRyYW5zZm9ybWVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3TWFwO1xuICAgIH07XG5cbiAgICBNYXBweS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcbiAgICAgICAgdmFyIG5ld01hcCA9IG5ldyBNYXBweSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIG5ld01hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld01hcDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcHB5O1xuXG59KSgpO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG4vKiBnbG9iYWwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpO1xuXG52YXIgaW1hZ2VzID0gcmVxdWlyZSgnLi4vLi4vaW1hZ2VzJyk7XG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAqIEBzZWUgW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgZmluLWh5cGVyZ3JpZC1yZW5kZXJlciBpcyB0aGUgY2FudmFzIGVuYWJsZWQgdG9wIGxldmVsIHN1YiBjb21wb25lbnQgdGhhdCBoYW5kbGVzIHRoZSByZW5kZXJlcmluZyBvZiB0aGUgR3JpZC5cbiAqXG4gKiBJdCByZWxpZXMgb24gdHdvIG90aGVyIGV4dGVybmFsIHN1YnByb2plY3RzXG4gKlxuICogMS4gZmluLWNhbnZhczogYSB3cmFwcGVyIHRvIHByb3ZpZGUgYSBzaW1wbGVyIGludGVyZmFjZSB0byB0aGUgSFRNTDUgY2FudmFzIGNvbXBvbmVudFxuICogMi4gcmVjdGFuZ3VsYXI6IGEgc21hbGwgbnBtIG1vZHVsZSBwcm92aWRpbmcgUG9pbnQgYW5kIFJlY3RhbmdsZSBvYmplY3RzXG4gKlxuICogVGhlIGZpbi1oeXBlcmdyaWQtcmVuZGVyZXIgaXMgaW4gYSB1bmlxdWUgcG9zaXRpb24gdG8gcHJvdmlkZSBjcml0aWNhbCBmdW5jdGlvbmFsaXR5IHRvIHRoZSBmaW4taHlwZXJncmlkIGluIGEgaGlnaHRseSBwZXJmb3JtYW50IG1hbm5lci5cbiAqIEJlY2F1c2UgaXQgTVVTVCBpdGVyYXRlIG92ZXIgYWxsIHRoZSB2aXNpYmxlIGNlbGxzIGl0IGNhbiBzdG9yZSB2YXJpb3VzIGJpdHMgb2YgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgZW5jYXBzdWxhdGVkIGFzIGEgc2VydmljZSBmb3IgY29uc3VtcHRpb24gYnkgdGhlIGZpbi1oeXBlcmdyaWQgY29tcG9uZW50LlxuICpcbiAqIEluc3RhbmNlcyBvZiB0aGlzIG9iamVjdCBoYXZlIGJhc2ljYWxseSBmb3VyIG1haW4gZnVuY3Rpb25zLlxuICpcbiAqIDEuIHJlbmRlciBmaXhlZCByb3cgaGVhZGVyc1xuICogMi4gcmVuZGVyIGZpeGVkIGNvbCBoZWFkZXJzXG4gKiAzLiByZW5kZXIgbWFpbiBkYXRhIGNlbGxzXG4gKiA0LiByZW5kZXIgZ3JpZCBsaW5lc1xuICpcbiAqIFNhbWUgcGFyYW1ldGVycyBhcyB7QGxpbmsgUmVuZGVyZXIjaW5pdGlhbGl6ZXxpbml0aWFsaXplfSwgd2hpY2ggaXMgY2FsbGVkIGJ5IHRoaXMgY29uc3RydWN0b3IuXG4gKlxuICovXG52YXIgUmVuZGVyZXIgPSBCYXNlLmV4dGVuZCgnUmVuZGVyZXInLCB7XG5cbiAgICAvL3RoZSBzaGFyZWQgc2luZ2xlIGl0ZW0gXCJwb29sZWRcIiBjZWxsIG9iamVjdCBmb3IgZHJhd2luZyBlYWNoIGNlbGxcbiAgICBjZWxsOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICB9LFxuXG4gICAgc2Nyb2xsSGVpZ2h0OiAwLFxuXG4gICAgdmlld0hlaWdodDogMCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzID0gW107XG4gICAgICAgIHRoaXMuY29sdW1uRWRnZXNJbmRleE1hcCA9IFtdO1xuICAgICAgICB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzID0gW107XG4gICAgICAgIHRoaXMucm93RWRnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yb3dFZGdlc0luZGV4TWFwID0gW107XG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMgPSBbXTtcbiAgICAgICAgdGhpcy52aXNpYmxlUm93cyA9IFtdO1xuICAgICAgICB0aGlzLmluc2VydGlvbkJvdW5kcyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb25zdHJ1Y3RvciBsb2dpY1xuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHVwb24gaW5zdGFudGlhdGlvbiBvZiB0aGlzIGNsYXNzIG9yIG9mIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgZnJvbSB0aGlzIGNsYXNzLlxuICAgICAqID4gQWxsIGBpbml0aWFsaXplKClgIG1ldGhvZHMgaW4gdGhlIGluaGVyaXRhbmNlIGNoYWluIGFyZSBjYWxsZWQsIGluIHR1cm4sIGVhY2ggd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBiZWdpbm5pbmcgd2l0aCB0aGF0IG9mIHRoZSBtb3N0IFwic2VuaW9yXCIgY2xhc3MgdGhyb3VnaCB0aGF0IG9mIHRoZSBjbGFzcyBvZiB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9LFxuXG4gICAgLy90aGlzIGZ1bmN0aW9uIGNvbXB1dGVzIHRoZSBncmlkIGNvb3JkaW5hdGVzIHVzZWQgZm9yIGV4dHJlbWVseSBmYXN0IGl0ZXJhdGlvbiBvdmVyXG4gICAgLy9wYWludGluZyB0aGUgZ3JpZCBjZWxscy4gdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IGZhc3QsIGZvciB0aG91c2FuZCByb3dzIFggMTAwIGNvbHVtbnNcbiAgICAvL29uIGEgbW9kZXN0IG1hY2hpbmUgdGFraW5nIHVzdWFsbHkgMG1zIGFuZCBubyBtb3JlIHRoYXQgMyBtcy5cbiAgICBjb21wdXRlQ2VsbHNCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuZ2V0U2Nyb2xsVG9wKCksXG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gdGhpcy5nZXRTY3JvbGxMZWZ0KCksXG5cbiAgICAgICAgICAgIG51bUNvbHVtbnMgPSB0aGlzLmdldENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICBudW1GaXhlZENvbHVtbnMgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKSxcblxuICAgICAgICAgICAgbnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgICAgIG51bUZpeGVkUm93cyA9IHRoaXMuZ2V0Rml4ZWRSb3dDb3VudCgpLFxuXG4gICAgICAgICAgICBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuICAgICAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgICAgIG51bWJlck9mQm90dG9tVG90YWxzUm93cyA9IGdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsLmdldEJvdHRvbVRvdGFscygpLmxlbmd0aCxcbiAgICAgICAgICAgIHZpZXdXaWR0aCA9IGJvdW5kcy53aWR0aCB8fCBncmlkLmNhbnZhcy53aWR0aCwgLy8gaWYgMCwgd2UgbXVzdCBiZSBpbiBib290c3RyYXBcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSBib3VuZHMuaGVpZ2h0IC0gbnVtYmVyT2ZCb3R0b21Ub3RhbHNSb3dzICogZ3JpZC5iZWhhdmlvci5nZXREZWZhdWx0Um93SGVpZ2h0KCksXG5cbiAgICAgICAgICAgIGluc2VydGlvbkJvdW5kc0N1cnNvciA9IDAsXG4gICAgICAgICAgICBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlID0gMCxcblxuICAgICAgICAgICAgc3RhcnQgPSAwLFxuICAgICAgICAgICAgeCA9IDAsIHkgPSAwLFxuICAgICAgICAgICAgYywgcixcbiAgICAgICAgICAgIHZ4LCB2eSxcbiAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICBmaXJzdFZYLCBsYXN0VlgsXG4gICAgICAgICAgICBmaXJzdFZZLCBsYXN0Vlk7XG5cbiAgICAgICAgdGhpcy5nZXRDb2x1bW5FZGdlcygpLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucm93RWRnZXMubGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzWzBdID0gMDtcbiAgICAgICAgdGhpcy5yb3dFZGdlc1swXSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gMDtcblxuICAgICAgICB0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudmlzaWJsZVJvd3MubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5FZGdlc0luZGV4TWFwID0gW107XG4gICAgICAgIHRoaXMucm93RWRnZXNJbmRleE1hcCA9IFtdO1xuXG4gICAgICAgIHRoaXMuaW5zZXJ0aW9uQm91bmRzID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkpIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzWy0xXSA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjID0gc3RhcnQ7IGMgPCBudW1Db2x1bW5zOyBjKyspIHtcbiAgICAgICAgICAgIHZ4ID0gYztcbiAgICAgICAgICAgIGlmIChjID49IG51bUZpeGVkQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIHZ4ID0gdnggKyBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFZYID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RWWCA9IHZ4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0VlggPSB2eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gdmlld1dpZHRoIHx8IG51bUNvbHVtbnMgPD0gdngpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aCh2eCk7XG4gICAgICAgICAgICB4ID0geCArIHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5FZGdlc1tjICsgMV0gPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1uc1tjXSA9IHZ4O1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5FZGdlc0luZGV4TWFwW3Z4XSA9IGM7XG5cbiAgICAgICAgICAgIGluc2VydGlvbkJvdW5kc0N1cnNvciA9IGluc2VydGlvbkJvdW5kc0N1cnNvciArIE1hdGgucm91bmQod2lkdGggLyAyKSArIHByZXZpb3VzSW5zZXJ0aW9uQm91bmRzQ3Vyc29yVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmluc2VydGlvbkJvdW5kcy5wdXNoKGluc2VydGlvbkJvdW5kc0N1cnNvcik7XG4gICAgICAgICAgICBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlID0gTWF0aC5yb3VuZCh3aWR0aCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChyID0gMDsgciA8IG51bVJvd3M7IHIrKykge1xuICAgICAgICAgICAgdnkgPSByO1xuICAgICAgICAgICAgaWYgKHIgPj0gbnVtRml4ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgdnkgPSB2eSArIHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RWWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0VlkgPSB2eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFZZID0gdnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA+IHZpZXdIZWlnaHQgfHwgbnVtUm93cyA8PSB2eSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVpZ2h0ID0gZ3JpZC5nZXRSb3dIZWlnaHQodnkpO1xuICAgICAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnJvd0VkZ2VzW3IgKyAxXSA9IE1hdGgucm91bmQoeSk7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVSb3dzW3JdID0gdnk7XG4gICAgICAgICAgICB0aGlzLnJvd0VkZ2VzSW5kZXhNYXBbdnldID0gcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdIZWlnaHQgPSB2aWV3SGVpZ2h0O1xuICAgICAgICB0aGlzLmRhdGFXaW5kb3cgPSB0aGlzLmdyaWQubmV3UmVjdGFuZ2xlKGZpcnN0VlgsIGZpcnN0VlksIGxhc3RWWCAtIGZpcnN0VlgsIGxhc3RWWSAtIGZpcnN0VlkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH0gYSBwcm9wZXJ0eSB2YWx1ZSBhdCBhIGtleSwgZGVsZWdhdGVzIHRvIHRoZSBncmlkXG4gICAgICovXG4gICAgcmVzb2x2ZVByb3BlcnR5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoa2V5KTtcbiAgICB9LFxuXG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBgLmdyaWRgIHByb3BlcnR5IGluc3RlYWQuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBnZXRHcmlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ3JpZCcsIHsgc2luY2U6ICcwLjInIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgTm90aWZ5IHRoZSBmaW4taHlwZXJncmlkIGV2ZXJ5dGltZSB3ZSd2ZSByZXBhaW50ZWQuXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHBhaW50OiBmdW5jdGlvbihnYykge1xuICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckdyaWQoZ2MpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLmdyaWRSZW5kZXJlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBBbnN3ZXIgaG93IG1hbnkgcm93cyB3ZSByZW5kZXJlZFxuICAgICAqL1xuICAgIGdldFZpc2libGVSb3dzQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlUm93cy5sZW5ndGggLSAxO1xuICAgIH0sXG5cbiAgICBnZXRWaXNpYmxlU2Nyb2xsSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld0hlaWdodCAtIHRoaXMuZ3JpZC5nZXRGaXhlZFJvd3NIZWlnaHQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gUm93cyB3ZSBqdXN0IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGdldFZpc2libGVSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVJvd3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1lciBvZiBjb2x1bW5zIHdlIGp1c3QgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnNDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aCAtIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDb2x1bW5zIHdlIGp1c3QgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQ29sdW1ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjb2x1bW4gaW5kZXggd2huZSB0aGUgbW91c2VFdmVudCBjb29yZGluYXRlcyBhcmUgb3ZlciBhIGNvbHVtbiBkaXZpZGVyLlxuICAgICAqL1xuICAgIG92ZXJDb2x1bW5EaXZpZGVyOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHggPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIHZhciB3aGljaENvbCA9IGVkZ2VzLmluZGV4T2YoeCAtIDEpO1xuICAgICAgICBpZiAod2hpY2hDb2wgPCAwKSB7XG4gICAgICAgICAgICB3aGljaENvbCA9IGVkZ2VzLmluZGV4T2YoeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdoaWNoQ29sIDwgMCkge1xuICAgICAgICAgICAgd2hpY2hDb2wgPSBlZGdlcy5pbmRleE9mKHggLSAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hpY2hDb2wgPCAwKSB7XG4gICAgICAgICAgICB3aGljaENvbCA9IGVkZ2VzLmluZGV4T2YoeCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aGljaENvbCA8IDApIHtcbiAgICAgICAgICAgIHdoaWNoQ29sID0gZWRnZXMuaW5kZXhPZih4IC0gMyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gd2hpY2hDb2w7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IGluZGV4IHdoZW4gdGhlIG1vdXNlRXZlbnQgY29vcmRpbmF0ZXMgYXJlIG92ZXIgYSByb3cgZGl2aWRlci5cbiAgICAgKi9cbiAgICBvdmVyUm93RGl2aWRlcjogZnVuY3Rpb24oeSkge1xuICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgICAgdmFyIHdoaWNoID0gdGhpcy5yb3dFZGdlcy5pbmRleE9mKHkgKyAxKTtcbiAgICAgICAgaWYgKHdoaWNoIDwgMCkge1xuICAgICAgICAgICAgd2hpY2ggPSB0aGlzLnJvd0VkZ2VzLmluZGV4T2YoeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdoaWNoIDwgMCkge1xuICAgICAgICAgICAgd2hpY2ggPSB0aGlzLnJvd0VkZ2VzLmluZGV4T2YoeSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aGljaDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGxcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBCb3VuZGluZyByZWN0IG9mIHRoZSBnaXZlbiBgY2VsbGAuXG4gICAgICovXG4gICAgZ2V0Qm91bmRzT2ZDZWxsOiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRCb3VuZHNPZkNlbGwoY2VsbC54LCBjZWxsLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQm91bmRpbmcgcmVjdCBvZiBjZWxsIHdpdGggdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIF9nZXRCb3VuZHNPZkNlbGw6IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgdmFyIHhPdXRzaWRlID0gZmFsc2UsXG4gICAgICAgICAgICB5T3V0c2lkZSA9IGZhbHNlLFxuICAgICAgICAgICAgY2VsbCA9IHRoaXMuY2VsbDtcblxuICAgICAgICB2YXIgeSwgeCA9IHRoaXMuY29sdW1uRWRnZXNJbmRleE1hcFtjXTtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeCA9IHRoaXMuY29sdW1uRWRnZXNJbmRleE1hcFtjIC0gMV07XG4gICAgICAgICAgICB4T3V0c2lkZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3ksIG94ID0gdGhpcy5jb2x1bW5FZGdlc1t4XSxcbiAgICAgICAgICAgIGN5LCBjeCA9IHRoaXMuY29sdW1uRWRnZXNbeCArIDFdLFxuICAgICAgICAgICAgZXksIGV4ID0gY3ggLSBveDtcblxuICAgICAgICBjZWxsLnggPSB4T3V0c2lkZSA/IGN4IDogb3g7XG4gICAgICAgIGNlbGwud2lkdGggPSB4T3V0c2lkZSA/IDAgOiBleDtcblxuICAgICAgICBpZiAociA8IDApIHsgLy8gYm90dG9tIHRvdGFscyByb3dzXG4gICAgICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdyaWQuYmVoYXZpb3IsXG4gICAgICAgICAgICAgICAgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblxuICAgICAgICAgICAgZXkgPSBiZWhhdmlvci5nZXREZWZhdWx0Um93SGVpZ2h0KCk7XG4gICAgICAgICAgICBveSA9IGJvdW5kcy5oZWlnaHQgKyByICogZXk7XG4gICAgICAgICAgICBjeSA9IG95ICsgZXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5ID0gdGhpcy5yb3dFZGdlc0luZGV4TWFwW3JdO1xuICAgICAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHkgPSB0aGlzLnJvd0VkZ2VzSW5kZXhNYXBbciAtIDFdO1xuICAgICAgICAgICAgICAgIHlPdXRzaWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3kgPSB0aGlzLnJvd0VkZ2VzW3ldO1xuICAgICAgICAgICAgY3kgPSB0aGlzLnJvd0VkZ2VzW3kgKyAxXTtcbiAgICAgICAgICAgIGV5ID0gY3kgLSBveTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNlbGwueSA9IHlPdXRzaWRlID8gY3kgOiBveTtcbiAgICAgICAgY2VsbC5oZWlnaHQgPSB5T3V0c2lkZSA/IDAgOiBleTtcblxuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGFuc3dlciB0aGUgY29sdW1uIGluZGV4IHVuZGVyIHRoZSBjb29yZGluYXRlIGF0IHBpeGVsWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjb2x1bW4gaW5kZXggdW5kZXIgdGhlIGNvb3JkaW5hdGUgYXQgcGl4ZWxYLlxuICAgICAqL1xuICAgIGdldENvbHVtbkZyb21QaXhlbFg6IGZ1bmN0aW9uKHBpeGVsWCkge1xuICAgICAgICB2YXIgd2lkdGggPSAwLFxuICAgICAgICAgICAgZml4ZWRDb2x1bW5Db3VudCA9IHRoaXMuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IHRoaXMuZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKSxcbiAgICAgICAgICAgIGVkZ2VzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAxOyBjIDwgZWRnZXMubGVuZ3RoIC0gMTsgYysrKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGVkZ2VzW2NdIC0gKGVkZ2VzW2NdIC0gZWRnZXNbYyAtIDFdKSAvIDI7XG4gICAgICAgICAgICBpZiAocGl4ZWxYIDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA+IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGMgKyBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYyAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPiBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBjID0gYyArIHNjcm9sbExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGMgLSAxO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBbnN3ZXIgc3BlY2lmaWMgZGF0YSBjZWxsIGNvb3JkaW5hdGVzIGdpdmVuIG1vdXNlIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gQ2VsbCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIGdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yO1xuICAgICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICAgICAgdmFyIHgsIHksIGMsIHI7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgICAgIHZhciBjb2x1bW5FZGdlcyA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgdmFyIGZpeGVkQ29sdW1uQ291bnQgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKTsgLy8gKyBncmlkU2l6ZTtcbiAgICAgICAgdmFyIGZpeGVkUm93Q291bnQgPSB0aGlzLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICAvLyB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IHRoaXMuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICAvLyB2YXIgZml4ZWRSb3dDb3VudCA9IHRoaXMuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuICAgICAgICB2YXIgc2Nyb2xsWCA9IHRoaXMuZ2V0U2Nyb2xsTGVmdCgpO1xuICAgICAgICB2YXIgc2Nyb2xsWSA9IHRoaXMuZ2V0U2Nyb2xsVG9wKCk7XG5cbiAgICAgICAgZm9yIChjID0gMDsgYyA8IGNvbHVtbkVkZ2VzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGNvbHVtbkVkZ2VzW2NdO1xuICAgICAgICAgICAgaWYgKHBvaW50LnggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLm1heCgwLCBwb2ludC54IC0gcHJldmlvdXMgLSAyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgYy0tO1xuICAgICAgICBwcmV2aW91cyA9IDA7XG4gICAgICAgIGZvciAociA9IDA7IHIgPCB0aGlzLnJvd0VkZ2VzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLnJvd0VkZ2VzW3JdO1xuICAgICAgICAgICAgaWYgKHBvaW50LnkgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5tYXgoMCwgcG9pbnQueSAtIHByZXZpb3VzIC0gMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91cyA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByLS07XG4gICAgICAgIGlmIChwb2ludC54IDwgMCkge1xuICAgICAgICAgICAgYyA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2ludC55IDwgMCkge1xuICAgICAgICAgICAgciA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZpZXdQb2ludCA9IHRoaXMuZ3JpZC5uZXdQb2ludChjLCByKTtcblxuICAgICAgICAvL2NvbXBlbnNhdGUgaWYgd2UgYXJlIHNjcm9sbGVkXG4gICAgICAgIGlmIChjID49IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIGMgPSBjICsgc2Nyb2xsWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAociA+PSBmaXhlZFJvd0NvdW50KSB7XG4gICAgICAgICAgICByID0gciArIHNjcm9sbFk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhbnNsYXRlZEluZGV4ID0gLTE7XG5cbiAgICAgICAgdmFyIGNvbHVtbiA9IGJlaGF2aW9yLmdldENvbHVtbihjKTtcbiAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgdHJhbnNsYXRlZEluZGV4ID0gY29sdW1uLmluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiB0aGlzLmdyaWQubmV3UG9pbnQoYywgciksXG4gICAgICAgICAgICBtb3VzZVBvaW50OiB0aGlzLmdyaWQubmV3UG9pbnQoeCwgeSksXG4gICAgICAgICAgICB2aWV3UG9pbnQ6IHZpZXdQb2ludCxcbiAgICAgICAgICAgIGRhdGFDZWxsOiB0aGlzLmdyaWQubmV3UG9pbnQodHJhbnNsYXRlZEluZGV4LCByKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IERldGVybWluZXMgaWYgYSBjb2x1bW4gaXMgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXggLSB0aGUgY29sdW1uIGluZGV4KlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICovXG4gICAgaXNDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICB2YXIgaXNWaXNpYmxlID0gdGhpcy52aXNpYmxlQ29sdW1ucy5pbmRleE9mKGNvbEluZGV4KSAhPT0gLTE7XG4gICAgICAgIHJldHVybiBpc1Zpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgd2lkdGggeCBjb29yZGluYXRlIG9mIHRoZSBsYXN0IHJlbmRlcmVkIGNvbHVtblxuICAgICAqL1xuICAgIGdldEZpbmFsVmlzYWJsZUNvbHVtbkJvdW5kYXJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlzTWF4WCA9IHRoaXMuaXNMYXN0Q29sdW1uVmlzaWJsZSgpO1xuICAgICAgICB2YXIgY2hvcCA9IGlzTWF4WCA/IDIgOiAxO1xuICAgICAgICB2YXIgY29sV2FsbCA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKVt0aGlzLmdldENvbHVtbkVkZ2VzKCkubGVuZ3RoIC0gY2hvcF07XG4gICAgICAgIHZhciByZXN1bHQgPSBNYXRoLm1pbihjb2xXYWxsLCB0aGlzLmdldEJvdW5kcygpLndpZHRoIC0gMjAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IERldGVybWluZXMgdmlzaWJpbGl0eSBvZiBhIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSB0aGUgcm93IGluZGV4XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiByb3cgaXMgZnVsbHkgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc1Jvd1Zpc2libGU6IGZ1bmN0aW9uKHJvd0luZGV4KSB7XG4gICAgICAgIHZhciBpc1Zpc2libGUgPSB0aGlzLnZpc2libGVSb3dzLmluZGV4T2Yocm93SW5kZXgpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIGlzVmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IERldGVybWluZXMgaWYgYSBjZWxsIGlzIHNlbGVjdGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggY2VsbCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBjZWxsIGNvb3JkaW5hdGUqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjZWxsIGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICovXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmlzU2VsZWN0ZWQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBtYWluIGZvcmtpbmcgb2YgdGhlIHJlbmRlcmVyaW5nIHRhc2suXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICovXG4gICAgcmVuZGVyR3JpZDogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgdGhpcy5wYWludENlbGxzKGdjKTtcbiAgICAgICAgdGhpcy5wYWludEdyaWRsaW5lcyhnYyk7XG4gICAgICAgIHRoaXMucmVuZGVyT3ZlcnJpZGVzKGdjKTtcbiAgICAgICAgdGhpcy5yZW5kZXJGb2N1c0NlbGwoZ2MpO1xuICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgZm9jdXNMaW5lU3RlcDogW1xuICAgICAgICBbNSwgNV0sXG4gICAgICAgIFswLCAxLCA1LCA0XSxcbiAgICAgICAgWzAsIDIsIDUsIDNdLFxuICAgICAgICBbMCwgMywgNSwgMl0sXG4gICAgICAgIFswLCA0LCA1LCAxXSxcbiAgICAgICAgWzAsIDUsIDUsIDBdLFxuICAgICAgICBbMSwgNSwgNCwgMF0sXG4gICAgICAgIFsyLCA1LCAzLCAwXSxcbiAgICAgICAgWzMsIDUsIDIsIDBdLFxuICAgICAgICBbNCwgNSwgMSwgMF1cbiAgICBdLFxuXG4gICAgcmVuZGVyRm9jdXNDZWxsOiBmdW5jdGlvbihnYykge1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyRm9jdXNDZWxsKGdjKTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJGb2N1c0NlbGw6IGZ1bmN0aW9uKGdjKSB7XG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbnMgfHwgc2VsZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1tzZWxlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbW91c2VEb3duID0gc2VsZWN0aW9uLm9yaWdpbjtcbiAgICAgICAgaWYgKG1vdXNlRG93bi54ID09PSAtMSkge1xuICAgICAgICAgICAgLy9ubyBzZWxlY3RlZCBhcmVhLCBsZXRzIGV4aXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aXNpYmxlQ29sdW1ucyA9IHRoaXMuZ2V0VmlzaWJsZUNvbHVtbnMoKTtcbiAgICAgICAgdmFyIHZpc2libGVSb3dzID0gdGhpcy5nZXRWaXNpYmxlUm93cygpO1xuICAgICAgICB2YXIgbGFzdFZpc2libGVDb2x1bW4gPSB2aXNpYmxlQ29sdW1uc1t2aXNpYmxlQ29sdW1ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGxhc3RWaXNpYmxlUm93ID0gdmlzaWJsZVJvd3NbdmlzaWJsZVJvd3MubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgdmFyIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQ7XG5cbiAgICAgICAgdmFyIGRwT1ggPSBNYXRoLm1pbihtb3VzZURvd24ueCwgbW91c2VEb3duLnggKyBleHRlbnQueCk7XG4gICAgICAgIHZhciBkcE9ZID0gTWF0aC5taW4obW91c2VEb3duLnksIG1vdXNlRG93bi55ICsgZXh0ZW50LnkpO1xuXG4gICAgICAgIC8vbGV0cyBjaGVjayBpZiBvdXIgc2VsZWN0aW9uIHJlY3RhbmdsZSBpcyBzY3JvbGxlZCBvdXRzaWRlIG9mIHRoZSB2aXNpYmxlIGFyZWFcbiAgICAgICAgaWYgKGRwT1ggPiBsYXN0VmlzaWJsZUNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuOyAvL3RoZSB0b3Agb2Ygb3VyIHJlY3RhbmdsZSBpcyBiZWxvdyB2aXNpYmxlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRwT1kgPiBsYXN0VmlzaWJsZVJvdykge1xuICAgICAgICAgICAgcmV0dXJuOyAvL3RoZSBsZWZ0IG9mIG91ciByZWN0YW5nbGUgaXMgdG8gdGhlIHJpZ2h0IG9mIGJlaW5nIHZpc2libGVcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcEVYID0gTWF0aC5tYXgobW91c2VEb3duLngsIG1vdXNlRG93bi54ICsgZXh0ZW50LngpICsgMTtcbiAgICAgICAgZHBFWCA9IE1hdGgubWluKGRwRVgsIDEgKyBsYXN0VmlzaWJsZUNvbHVtbik7XG5cbiAgICAgICAgdmFyIGRwRVkgPSBNYXRoLm1heChtb3VzZURvd24ueSwgbW91c2VEb3duLnkgKyBleHRlbnQueSkgKyAxO1xuICAgICAgICBkcEVZID0gTWF0aC5taW4oZHBFWSwgMSArIGxhc3RWaXNpYmxlUm93KTtcblxuICAgICAgICB2YXIgbyA9IHRoaXMuX2dldEJvdW5kc09mQ2VsbChkcE9YLCBkcE9ZKTtcbiAgICAgICAgdmFyIG94ID0gTWF0aC5yb3VuZCgoby54ID09PSB1bmRlZmluZWQpID8gdGhpcy5ncmlkLmdldEZpeGVkQ29sdW1uc1dpZHRoKCkgOiBvLngpO1xuICAgICAgICB2YXIgb3kgPSBNYXRoLnJvdW5kKChvLnkgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdyaWQuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCkgOiBvLnkpO1xuICAgICAgICAvLyB2YXIgb3cgPSBvLndpZHRoO1xuICAgICAgICAvLyB2YXIgb2ggPSBvLmhlaWdodDtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl9nZXRCb3VuZHNPZkNlbGwoZHBFWCwgZHBFWSk7XG4gICAgICAgIHZhciBleCA9IE1hdGgucm91bmQoKGUueCA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ3JpZC5nZXRGaXhlZENvbHVtbnNXaWR0aCgpIDogZS54KTtcbiAgICAgICAgdmFyIGV5ID0gTWF0aC5yb3VuZCgoZS55ID09PSB1bmRlZmluZWQpID8gdGhpcy5ncmlkLmdldEZpeGVkUm93c0hlaWdodCgpIDogZS55KTtcbiAgICAgICAgLy8gdmFyIGV3ID0gZS53aWR0aDtcbiAgICAgICAgLy8gdmFyIGVoID0gZS5oZWlnaHQ7XG4gICAgICAgIHZhciB4ID0gTWF0aC5taW4ob3gsIGV4KTtcbiAgICAgICAgdmFyIHkgPSBNYXRoLm1pbihveSwgZXkpO1xuICAgICAgICB2YXIgd2lkdGggPSAxICsgZXggLSBveDtcbiAgICAgICAgdmFyIGhlaWdodCA9IDEgKyBleSAtIG95O1xuICAgICAgICBpZiAoeCA9PT0gZXgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gb3ggLSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA9PT0gZXkpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IG95IC0gZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoICogaGVpZ2h0IDwgMSkge1xuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgb25seSBhIHNraW5ueSBsaW5lLCBkb24ndCByZW5kZXIgYW55dGhpbmdcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdjLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdzZWxlY3Rpb25SZWdpb25PdmVybGF5Q29sb3InKTtcbiAgICAgICAgZ2MuZmlsbCgpO1xuICAgICAgICBnYy5saW5lV2lkdGggPSAxO1xuICAgICAgICBnYy5zdHJva2VTdHlsZSA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdzZWxlY3Rpb25SZWdpb25PdXRsaW5lQ29sb3InKTtcblxuICAgICAgICAvLyBhbmltYXRlIHRoZSBkYXNoZWQgbGluZSBhIGJpdCBoZXJlIGZvciBmdW5cblxuICAgICAgICBnYy5zdHJva2UoKTtcblxuICAgICAgICAvL2djLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy9nYy5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XG5cbiAgICAgICAgLy8gYW5pbWF0ZSB0aGUgZGFzaGVkIGxpbmUgYSBiaXQgaGVyZSBmb3IgZnVuXG4gICAgICAgIC8vZ2Muc2V0TGluZURhc2godGhpcy5mb2N1c0xpbmVTdGVwW01hdGguZmxvb3IoMTAgKiAoRGF0ZS5ub3coKSAvIDMwMCAlIDEpKSAlIHRoaXMuZm9jdXNMaW5lU3RlcC5sZW5ndGhdKTtcblxuICAgICAgICAvL2djLnN0cm9rZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgaXRlcmF0ZSB0aGUgcmVuZGVyZXJpbmcgb3ZlcnJpZGVzIGFuZCBtYW5pZmVzdCBlYWNoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICovXG4gICAgcmVuZGVyT3ZlcnJpZGVzOiBmdW5jdGlvbihnYykge1xuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLmdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGU7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgICAgICAgICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcnJpZGUgPSBjYWNoZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck92ZXJyaWRlKGdjLCBvdmVycmlkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjb3B5IGVhY2ggb3ZlcnJpZGVzIHNwZWNpZmllZCBhcmVhIHRvIGl0J3MgdGFyZ2V0IGFuZCBibGFuayBvdXQgdGhlIHNvdXJjZSBhcmVhXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICogQHBhcmFtIHtPdmVycmlkZU9iamVjdH0gb3ZlcnJpZGUgLSBhbiBvYmplY3Qgd2l0aCBkZXRhaWxzIGNvbnRhaW4gYW4gYXJlYSBhbmQgYSB0YXJnZXQgY29udGV4dFxuICAgICAqL1xuICAgIHJlbmRlck92ZXJyaWRlOiBmdW5jdGlvbihnYywgb3ZlcnJpZGUpIHtcbiAgICAgICAgLy9sZXRzIGJsYW5rIG91dCB0aGUgZHJhZyByb3dcbiAgICAgICAgdmFyIGhkcGlSYXRpbyA9IG92ZXJyaWRlLmhkcGlyYXRpbztcbiAgICAgICAgLy92YXIgZWRnZXMgPSB0aGlzLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIHZhciBzdGFydFggPSBvdmVycmlkZS5zdGFydFg7IC8vaGRwaVJhdGlvICogZWRnZXNbb3ZlcnJpZGUuY29sdW1uSW5kZXhdO1xuICAgICAgICB2YXIgd2lkdGggPSBvdmVycmlkZS53aWR0aCArIDE7XG4gICAgICAgIHZhciBoZWlnaHQgPSBvdmVycmlkZS5oZWlnaHQ7XG4gICAgICAgIHZhciB0YXJnZXRDVFggPSBvdmVycmlkZS5jdHg7XG4gICAgICAgIHZhciBpbWdEYXRhID0gZ2MuZ2V0SW1hZ2VEYXRhKHN0YXJ0WCwgMCwgTWF0aC5yb3VuZCh3aWR0aCAqIGhkcGlSYXRpbyksIE1hdGgucm91bmQoaGVpZ2h0ICogaGRwaVJhdGlvKSk7XG4gICAgICAgIHRhcmdldENUWC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdiYWNrZ3JvdW5kQ29sb3IyJyk7XG4gICAgICAgIGdjLmZpbGxSZWN0KE1hdGgucm91bmQoc3RhcnRYIC8gaGRwaVJhdGlvKSwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDdXJyZW50IHZlcnRpY2FsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRTY3JvbGxUb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmdldFZTY3JvbGxWYWx1ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ3VycmVudCBob3Jpem9udGFsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRTY3JvbGxMZWZ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICB9LFxuXG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBgLmdyaWQuYmVoYXZpb3JgIHByb3BlcnR5IGluc3RlYWQuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtCZWhhdmlvcn0gVGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICovXG4gICAgZ2V0QmVoYXZpb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdncmlkLmJlaGF2aW9yJywgeyBzaW5jZTogJzAuMicgfSk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkVkZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uRWRnZXM7XG4gICAgfSxcblxuICAgIGdldFJvd0VkZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93RWRnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGxhc3QgY29sIHdhcyByZW5kZXJlZCAoaXMgdmlzaWJsZSlcbiAgICAgKi9cbiAgICBpc0xhc3RDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3RDb2x1bW5JbmRleCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb2x1bW5zLmluZGV4T2YobGFzdENvbHVtbkluZGV4KSAhPT0gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVuZGVyZWQgY29sdW1uIHdpZHRoIGF0IGluZGV4XG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRXaWR0aDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uRWRnZXMoKVtpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVuZGVyZWQgcm93IGhlaWdodCBhdCBpbmRleFxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkSGVpZ2h0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dFZGdlc1tpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7ZmluLWNhbnZhc30gbXkgW2Zpbi1jYW52YXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9zdGV2ZXdpcnRzL2Zpbi1jYW52YXMpXG4gICAgICovXG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBVc2VyIGlzIGN1cnJlbnRseSBkcmFnZ2luZyBhIGNvbHVtbiBmb3IgcmVvcmRlcmluZy5cbiAgICAgKi9cbiAgICBpc0RyYWdnaW5nQ29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5pc0RyYWdnaW5nQ29sdW1uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IHRvIGdvdG8gZm9yIGEgcGFnZSB1cC5cbiAgICAgKi9cbiAgICBnZXRQYWdlVXBSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0VmlzaWJsZVNjcm9sbEhlaWdodCgpLFxuICAgICAgICAgICAgaGVhZGVyUm93cyA9IHRoaXMuZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCksXG4gICAgICAgICAgICB0b3AgPSB0aGlzLmRhdGFXaW5kb3cub3JpZ2luLnkgLSBoZWFkZXJSb3dzLFxuICAgICAgICAgICAgc2NhbkhlaWdodCA9IDA7XG4gICAgICAgIHdoaWxlIChzY2FuSGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIHRvcCA+IC0xKSB7XG4gICAgICAgICAgICBzY2FuSGVpZ2h0ID0gc2NhbkhlaWdodCArIGdyaWQuZ2V0Um93SGVpZ2h0KHRvcCk7XG4gICAgICAgICAgICB0b3AtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wICsgMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3cgdG8gZ290byBmb3IgYSBwYWdlIGRvd24uXG4gICAgICovXG4gICAgZ2V0UGFnZURvd25Sb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVhZGVyUm93cyA9IHRoaXMuZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgICAgIHZhciByb3dOdW0gPSB0aGlzLmRhdGFXaW5kb3cuY29ybmVyLnkgLSBoZWFkZXJSb3dzIC0gMTtcbiAgICAgICAgcmV0dXJuIHJvd051bTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cy5cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0Um93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBoZWFkZXIgcm93cy5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgaGVhZGVyIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBTbWFydCByZW5kZXIgdGhlIGdyaWQuXG4gICAgICogQGRlc2MgUGFpbnQgYWxsIHRoZSBjZWxscyBvZiBhIGdyaWQsIGluY2x1ZGluZyBhbGwgXCJmaXhlZFwiIGNvbHVtbnMgYW5kIHJvd3MuXG4gICAgICogV2Ugc25hcHNob3QgdGhlIGNvbnRleHQgdG8gaW5zdXJlIGFnYWluc3QgaXRzIHBvbGx1dGlvbi5cbiAgICAgKiBgdHJ5Li4uY2F0Y2hgIHN1cnJvdW5kcyBlYWNoIGNlbGwgcGFpbnQgaW4gY2FzZSBhIGNlbGwgZWRpdG9yIHRocm93cyBhbiBlcnJvci5cbiAgICAgKiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBlcnJvci1sb2dnZWQgdG8gY29uc29sZSBBTkQgZGlzcGxheWVkIGluIGNlbGwuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHBhaW50Q2VsbHM6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIHZhciByZW5kZXJDZWxsRXJyb3IsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgeCwgeSxcbiAgICAgICAgICAgIGMsIHIsXG5cbiAgICAgICAgICAgIGNvbHVtbkVkZ2VzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpLFxuICAgICAgICAgICAgcm93RWRnZXMgPSB0aGlzLnJvd0VkZ2VzLFxuXG4gICAgICAgICAgICB2aXNpYmxlQ29scyA9IHRoaXMuZ2V0VmlzaWJsZUNvbHVtbnMoKSxcbiAgICAgICAgICAgIHZpc2libGVSb3dzID0gdGhpcy5nZXRWaXNpYmxlUm93cygpLFxuXG4gICAgICAgICAgICBiZWhhdmlvciA9IHRoaXMuZ3JpZC5iZWhhdmlvcixcblxuICAgICAgICAgICAgY2xpcFggPSAwLFxuICAgICAgICAgICAgY2xpcFkgPSAwLFxuICAgICAgICAgICAgY2xpcFdpZHRoLFxuICAgICAgICAgICAgY2xpcEhlaWdodCA9IHRoaXMuZ2V0Qm91bmRzKCkuaGVpZ2h0LFxuXG4gICAgICAgICAgICBsb29wU3RhcnQgPSB0aGlzLmdyaWQuaXNTaG93Um93TnVtYmVycygpID8gLTEgOiAwLFxuICAgICAgICAgICAgbG9vcExlbmd0aCA9IHZpc2libGVDb2xzLmxlbmd0aDsgLy8gcmVnYXJkbGVzcyBvZiBsb29wU3RhcnQsIGR1ZSB0byBkZWZpbml0aW9uIG9mIC5sZW5ndGhcblxuICAgICAgICB0aGlzLmJ1dHRvbkNlbGxzID0ge307XG5cbiAgICAgICAgaWYgKGxvb3BMZW5ndGgpIHsgLy8gdGhpcyBpZiBwcmV2ZW50cyBwYWludGluZyBqdXN0IHRoZSBmaXhlZCBjb2x1bW5zIHdoZW4gdGhlcmUgYXJlIG5vIHZpc2libGUgY29sdW1uc1xuXG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBjb2x1bW4uLi5cbiAgICAgICAgICAgIGZvciAoeCA9IGxvb3BTdGFydDsgeCA8IGxvb3BMZW5ndGg7IHgrKywgY2xpcFggKz0gY2xpcFdpZHRoKSB7XG5cbiAgICAgICAgICAgICAgICBjID0gdmlzaWJsZUNvbHNbeF07XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbk1pbldpZHRoc1tjXSA9IDA7XG4gICAgICAgICAgICAgICAgcmVuZGVyQ2VsbEVycm9yID0gYmVoYXZpb3IuZ2V0Q29sdW1uUHJvcGVydGllcyhjKS5yZW5kZXJDZWxsRXJyb3I7XG5cbiAgICAgICAgICAgICAgICBnYy5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGlwIHRvIHZpc2libGUgcG9ydGlvbiBvZiBjb2x1bW4gdG8gcHJldmVudCBvdmVyZmxvdyB0byByaWdodC4gUHJldmlvdXNseSB3ZSBjbGlwcGVkIHRvIGVudGlyZSB2aXNpYmxlIGdyaWQgYW5kIGRlYWx0IHdpdGggb3ZlcmZsb3cgYnkgb3ZlcnBhaW50aW5nIHdpdGggbmV4dCBjb2x1bW4uIEhvd2V2ZXIsIHRoaXMgc3RyYXRlZ3kgZmFpbHMgd2hlbiB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kIChubyBiYWNrZ3JvdW5kIGNvbG9yKS5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZiBleHRyYSBjbGlwKCkgY2FsbHMgcGVyIGNvbHVtbiBhZmZlY3QgcGVyZm9ybWFuY2UgKG5vdCB0aGUgY2xpcHBpbmcgaXRzZWxmIHdoaWNoIHdhcyBoYXBwZW5pbmcgYW55d2F5LCBidXQgdGhlIGNsaXAgY2FsbHMgd2hpY2ggc2V0IHVwIHRoZSBjbGlwcGluZyksIHVzZSBwcmV2aW91cyBzdHJhdGVneSB3aGVuIHRoZXJlIGlzIGEgYmFja2dyb3VuZCBjb2xvclxuICAgICAgICAgICAgICAgIGNsaXBXaWR0aCA9IGNvbHVtbkVkZ2VzW3ggLSBsb29wU3RhcnRdIC0gY2xpcFg7XG4gICAgICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgZ2MucmVjdChjbGlwWCwgY2xpcFksIGNsaXBXaWR0aCwgY2xpcEhlaWdodCk7XG4gICAgICAgICAgICAgICAgZ2MuY2xpcCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggcm93IChvZiBlYWNoIGNvbHVtbikuLi5cbiAgICAgICAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgdmlzaWJsZVJvd3MubGVuZ3RoOyB5KyspIHtcblxuICAgICAgICAgICAgICAgICAgICByID0gdmlzaWJsZVJvd3NbeV07XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFpbnRDZWxsKGdjLCBjLCByKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAociA9PT0gOSAmJiBjID09PSAyKSB7IHRocm93IEVycm9yKCdTaGUgc2VsbHMgc2VhIHNoZWxscyBieSB0aGUgc2VhIHNob3JlLicpOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gZSAmJiAoZS5tZXNzYWdlIHx8IGUpIHx8ICdVbmtub3duIGVycm9yLic7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW5kZXJDZWxsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3R2MgPSBnYy5nYyB8fCBnYywgLy8gRG9uJ3QgbG9nIHRoZXNlIGNhbnZhcyBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJZID0gcm93RWRnZXNbeV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyckhlaWdodCA9IHJvd0VkZ2VzW3kgKyAxXSAtIGVyclk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdHYy5zYXZlKCk7IC8vIGRlZmluZSBjbGlwcGluZyByZWdpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdHYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdHYy5yZWN0KGNsaXBYLCBlcnJZLCBjbGlwV2lkdGgsIGVyckhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3R2MuY2xpcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyQ2VsbEVycm9yKHJhd0djLCBtZXNzYWdlLCBjbGlwWCwgZXJyWSwgY2xpcFdpZHRoLCBlcnJIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3R2MucmVzdG9yZSgpOyAvLyBkaXNjYXJkIGNsaXBwaW5nIHJlZ2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBCb3R0b20gdG90YWxzIHJvd3MuLi5cbiAgICAgICAgICAgICAgICBmb3IgKHkgPSAtYmVoYXZpb3IuZGF0YU1vZGVsLmdldEJvdHRvbVRvdGFscygpLmxlbmd0aDsgeTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50Q2VsbChnYywgYywgeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ2MucmVzdG9yZSgpOyAvLyBSZW1vdmUgY29sdW1uJ3MgY2xpcCByZWdpb24gKGFuZCBhbnl0aGluZyBlbHNlIHJlbmRlckNlbGxFcnJvcigpIG1pZ2h0IGhhdmUgc2V0KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0TnVtYmVyQ29sdW1uV2lkdGgoZ2MsIGJlaGF2aW9yLCB0aGlzLmdyaWQuZ2V0Um93Q291bnQoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBXZSBvcHRlZCB0byBub3QgcGFpbnQgYm9yZGVycyBmb3IgZWFjaCBjZWxsIGFzIHRoYXQgd2FzIGV4dHJlbWVseSBleHBlbnNpdmUuIEluc3RlYWQgd2UgZHJhdyBncmlkbGluZXMgaGVyZS4gQWxzbyB3ZSByZWNvcmQgdGhlIHdpZHRocyBhbmQgaGVpZ2h0cyBmb3IgbGF0ZXIuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICovXG4gICAgcGFpbnRHcmlkbGluZXM6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIHZhciB4LCB5LCBjLCByID0gMDtcblxuICAgICAgICB2YXIgY29sV2lkdGhzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgcm93SGVpZ2h0cyA9IHRoaXMucm93RWRnZXM7XG5cbiAgICAgICAgdmFyIHZpZXdXaWR0aCA9IGNvbFdpZHRoc1tjb2xXaWR0aHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciB2aWV3SGVpZ2h0ID0gdGhpcy5nZXRCb3VuZHMoKS5oZWlnaHQ7IC8vcm93SGVpZ2h0c1tyb3dIZWlnaHRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHZhciBkcmF3VGhlbUggPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZ3JpZExpbmVzSCcpO1xuICAgICAgICB2YXIgZHJhd1RoZW1WID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2dyaWRMaW5lc1YnKTtcbiAgICAgICAgdmFyIGxpbmVDb2xvciA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdsaW5lQ29sb3InKTtcblxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcblxuICAgICAgICBpZiAoZHJhd1RoZW1WKSB7XG4gICAgICAgICAgICBmb3IgKGMgPSAwOyBjIDwgY29sV2lkdGhzLmxlbmd0aCArIDE7IGMrKykge1xuICAgICAgICAgICAgICAgIHggPSBjb2xXaWR0aHNbY10gKyAwLjU7XG4gICAgICAgICAgICAgICAgZ2MubW92ZVRvKHgsIDApO1xuICAgICAgICAgICAgICAgIGdjLmxpbmVUbyh4LCB2aWV3SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmF3VGhlbUgpIHtcbiAgICAgICAgICAgIGZvciAociA9IDA7IHIgPCByb3dIZWlnaHRzLmxlbmd0aCAtIDE7IHIrKykge1xuICAgICAgICAgICAgICAgIHkgPSByb3dIZWlnaHRzW3JdICsgMC41O1xuICAgICAgICAgICAgICAgIGdjLm1vdmVUbygwLCB5KTtcbiAgICAgICAgICAgICAgICBnYy5saW5lVG8odmlld1dpZHRoLCB5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQm90dG9tIHRvdGFscyByb3dzLi4uXG4gICAgICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdyaWQuYmVoYXZpb3IsXG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0ID0gYmVoYXZpb3IuZ2V0RGVmYXVsdFJvd0hlaWdodCgpO1xuICAgICAgICAgICAgZm9yIChyID0gLWJlaGF2aW9yLmRhdGFNb2RlbC5nZXRCb3R0b21Ub3RhbHMoKS5sZW5ndGgsIHkgPSB0aGlzLmdldEJvdW5kcygpLmhlaWdodDsgcjsgcisrKSB7XG4gICAgICAgICAgICAgICAgeSAtPSByb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgZ2MubW92ZVRvKDAsIHkpO1xuICAgICAgICAgICAgICAgIGdjLmxpbmVUbyh2aWV3V2lkdGgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XG4gICAgICAgIGdjLmxpbmVXaWR0aCA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdsaW5lV2lkdGgnKTtcbiAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICovXG4gICAgcGFpbnRDZWxsOiBmdW5jdGlvbihnYywgeCwgeSkge1xuICAgICAgICBnYy5tb3ZlVG8oMCwgMCk7XG5cbiAgICAgICAgdmFyIGMgPSB0aGlzLmdldFZpc2libGVDb2x1bW5zKClbeF0sXG4gICAgICAgICAgICByID0gdGhpcy5nZXRWaXNpYmxlUm93cygpW3ldO1xuXG4gICAgICAgIGlmIChjKSB7IC8vc29tZXRoaW5nIGlzIGJlaW5nIHZpZXdlZCBhdCBhdCB0aGUgbW9tZW50IChvdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLl9wYWludENlbGwoZ2MsIGMsIHIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wYWludENlbGw6IGZ1bmN0aW9uKGdjLCBjLCByKSB7XG5cbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQsXG4gICAgICAgICAgICBiZWhhdmlvciA9IGdyaWQuYmVoYXZpb3IsXG4gICAgICAgICAgICBiYXNlUHJvcGVydGllcyA9IGJlaGF2aW9yLmdldENvbHVtblByb3BlcnRpZXMoYyk7XG5cbiAgICAgICAgaWYgKGJhc2VQcm9wZXJ0aWVzLmlzTnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbHVtblByb3BlcnRpZXMgPSBiYXNlUHJvcGVydGllcyxcblxuICAgICAgICAgICAgaGVhZGVyUm93Q291bnQgPSBiZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpLFxuICAgICAgICAgICAgaXNHcmlkUm93ID0gciA+PSBoZWFkZXJSb3dDb3VudCxcbiAgICAgICAgICAgIGlzRm9vdGVyUm93ID0gciA8IDAsXG4gICAgICAgICAgICBpc0hlYWRlclJvdyA9ICFpc0dyaWRSb3cgJiYgIWlzRm9vdGVyUm93LFxuICAgICAgICAgICAgaXNGaWx0ZXJSb3cgPSBncmlkLmlzRmlsdGVyUm93KHIpLFxuXG4gICAgICAgICAgICBoZWFkZXJDb2x1bW5Db3VudCA9IGJlaGF2aW9yLmdldEhlYWRlckNvbHVtbkNvdW50KCksXG4gICAgICAgICAgICBpc0dyaWRDb2x1bW4gPSBjID49IGhlYWRlckNvbHVtbkNvdW50LFxuICAgICAgICAgICAgaXNTaG93Um93TnVtYmVycyA9IGdyaWQuaXNTaG93Um93TnVtYmVycygpLFxuICAgICAgICAgICAgaXNIaWVyYXJjaHlDb2x1bW4gPSBncmlkLmlzSGllcmFyY2h5Q29sdW1uKGMpLFxuXG4gICAgICAgICAgICBpc1Jvd1NlbGVjdGVkID0gZ3JpZC5pc1Jvd1NlbGVjdGVkKHIpLFxuICAgICAgICAgICAgaXNDb2x1bW5TZWxlY3RlZCA9IGdyaWQuaXNDb2x1bW5TZWxlY3RlZChjKSxcbiAgICAgICAgICAgIGlzQ2VsbFNlbGVjdGVkID0gZ3JpZC5pc0NlbGxTZWxlY3RlZChjLCByKSxcbiAgICAgICAgICAgIGlzQ2VsbFNlbGVjdGVkSW5Db2x1bW4gPSBncmlkLmlzQ2VsbFNlbGVjdGVkSW5Db2x1bW4oYyksXG4gICAgICAgICAgICBpc0NlbGxTZWxlY3RlZEluUm93ID0gZ3JpZC5pc0NlbGxTZWxlY3RlZEluUm93KHIpLFxuICAgICAgICAgICAgYXJlQWxsUm93c1NlbGVjdGVkID0gZ3JpZC5hcmVBbGxSb3dzU2VsZWN0ZWQoKSxcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzO1xuXG4gICAgICAgIGlmICgoaXNTaG93Um93TnVtYmVycyAmJiBjID09PSAtMSkgfHwgaXNIaWVyYXJjaHlDb2x1bW4pIHtcbiAgICAgICAgICAgIGlmIChpc1Jvd1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzLnJvd0hlYWRlclJvd1NlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcy5yb3dIZWFkZXIpO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzU2VsZWN0ZWQgPSBpc0NlbGxTZWxlY3RlZEluUm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNVc2VyRGF0YUFyZWEgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0hlYWRlclJvdyB8fCBpc0Zvb3RlclJvdykge1xuICAgICAgICAgICAgaWYgKGlzRmlsdGVyUm93KSB7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzLmZpbHRlclByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDb2x1bW5TZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcy5jb2x1bW5IZWFkZXJDb2x1bW5TZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3BlcnRpZXMuY29sdW1uSGVhZGVyKTtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1NlbGVjdGVkID0gaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzVXNlckRhdGFBcmVhID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNIaWVyYXJjaHlDb2x1bW4pIHtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcy5yb3dIZWFkZXIpO1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IGlzQ2VsbFNlbGVjdGVkSW5Sb3c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IGlzQ2VsbFNlbGVjdGVkIHx8IGlzUm93U2VsZWN0ZWQgfHwgaXNDb2x1bW5TZWxlY3RlZDtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzVXNlckRhdGFBcmVhID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3dOdW0gPSByIC0gaGVhZGVyUm93Q291bnQgKyAxO1xuXG4gICAgICAgIGlmIChjID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKHIgPT09IDApIHsgLy8gaGVhZGVyIGxhYmVsIHJvdyBnZXRzIFwibWFzdGVyXCIgY2hlY2tib3hcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcy52YWx1ZSA9IFtpbWFnZXMuY2hlY2tib3goYXJlQWxsUm93c1NlbGVjdGVkKSwgJycsIG51bGxdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0ZpbHRlclJvdykgeyAvLyBubyBjaGVja2JveCBidXQgc2hvdyBmaWx0ZXIgaWNvblxuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLnZhbHVlID0gW2ltYWdlcy5maWx0ZXIoZmFsc2UpLCAnJywgbnVsbF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSGVhZGVyUm93IHx8IGlzRm9vdGVyUm93KSB7IC8vIG5vIGNoZWNrYm94IG9uIFwidG90YWxzXCIgcm93c1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLnZhbHVlID0gJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLnZhbHVlID0gW2ltYWdlcy5jaGVja2JveChpc1Jvd1NlbGVjdGVkKSwgcm93TnVtLCBudWxsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmhhbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy52YWx1ZSA9IGdyaWQuZ2V0VmFsdWUoYywgcik7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5oYWxpZ24gPSBncmlkLmdldENvbHVtbkFsaWdubWVudChjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzR3JpZENvbHVtbiA9IGlzR3JpZENvbHVtbjtcbiAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNHcmlkUm93ID0gaXNHcmlkUm93O1xuICAgICAgICBjZWxsUHJvcGVydGllcy5pc0NvbHVtbkhvdmVyZWQgPSBncmlkLmlzQ29sdW1uSG92ZXJlZChjKSAmJiBpc0dyaWRDb2x1bW47XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzUm93SG92ZXJlZCA9IGdyaWQuaXNSb3dIb3ZlcmVkKHIpICYmIGlzR3JpZFJvdztcbiAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNDZWxsSG92ZXJlZCA9IGdyaWQuaXNIb3ZlcmVkKGMsIHIpICYmIGlzR3JpZENvbHVtbiAmJiBpc0dyaWRSb3c7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmJvdW5kcyA9IHRoaXMuX2dldEJvdW5kc09mQ2VsbChjLCByKTtcbiAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNDZWxsU2VsZWN0ZWQgPSBpc0NlbGxTZWxlY3RlZDtcbiAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNSb3dTZWxlY3RlZCA9IGlzUm93U2VsZWN0ZWQ7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzQ29sdW1uU2VsZWN0ZWQgPSBpc0NvbHVtblNlbGVjdGVkO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5pc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZSA9IGdyaWQuaXNJbkN1cnJlbnRTZWxlY3Rpb25SZWN0YW5nbGUoYywgcik7XG5cbiAgICAgICAgaWYgKGdyaWQubW91c2VEb3duU3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IGdyaWQubW91c2VEb3duU3RhdGUuZ3JpZENlbGw7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5tb3VzZURvd24gPSBwb2ludC54ID09PSBjICYmIHBvaW50LnkgPT09IHI7XG4gICAgICAgIH1cblxuICAgICAgICBjZWxsUHJvcGVydGllcy54ID0gYztcbiAgICAgICAgY2VsbFByb3BlcnRpZXMueSA9IHI7XG5cbiAgICAgICAgYmVoYXZpb3IuY2VsbFByb3BlcnRpZXNQcmVQYWludE5vdGlmaWNhdGlvbihjZWxsUHJvcGVydGllcyk7XG5cbiAgICAgICAgdmFyIGNlbGwgPSBiZWhhdmlvci5nZXRDZWxsUmVuZGVyZXIoY2VsbFByb3BlcnRpZXMsIGMsIHIpO1xuICAgICAgICB2YXIgb3ZlcnJpZGVzID0gYmVoYXZpb3IuZ2V0Q2VsbFByb3BlcnRpZXMoYywgcik7XG5cbiAgICAgICAgLy9kZWNsYXJhdGl2ZSBjZWxsIHByb3BlcnRpZXNcbiAgICAgICAgXyhjZWxsUHJvcGVydGllcykuZXh0ZW5kT3duKG92ZXJyaWRlcyk7XG5cbiAgICAgICAgLy9hbGxvdyB0aGUgcmVuZGVyZXIgdG8gaWRlbnRpZnkgaXRzZWxmIGlmIGl0J3MgYSBidXR0b25cbiAgICAgICAgY2VsbFByb3BlcnRpZXMuYnV0dG9uQ2VsbHMgPSB0aGlzLmJ1dHRvbkNlbGxzO1xuICAgICAgICB2YXIgZm9ybWF0VHlwZSA9IGNlbGxQcm9wZXJ0aWVzLmlzVXNlckRhdGFBcmVhID8gY2VsbFByb3BlcnRpZXMuZm9ybWF0IDogJ2RlZmF1bHQnO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5mb3JtYXR0ZXIgPSBncmlkLmdldEZvcm1hdHRlcihmb3JtYXRUeXBlKTtcbiAgICAgICAgY2VsbC5wYWludChnYywgY2VsbFByb3BlcnRpZXMpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZWRDb2x1bW5NaW5XaWR0aHNbY10gPSBNYXRoLm1heChjZWxsUHJvcGVydGllcy5taW5XaWR0aCB8fCAwLCB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzW2NdKTtcbiAgICAgICAgY29sdW1uUHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCA9IHRoaXMucmVuZGVyZWRDb2x1bW5NaW5XaWR0aHNbY107XG4gICAgfSxcblxuICAgIGlzVmlld2FibGVCdXR0b246IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgdmFyIGtleSA9IGMgKyAnLCcgKyByO1xuICAgICAgICByZXR1cm4gdGhpcy5idXR0b25DZWxsc1trZXldID09PSB0cnVlO1xuICAgIH0sXG5cbiAgICBnZXRSb3dOdW1iZXJzV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sRWRnZXMgPSB0aGlzLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIGlmIChjb2xFZGdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xFZGdlc1swXTtcbiAgICB9LFxuXG4gICAgc3RhcnRBbmltYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgICAgICAgICBzZWxmLmFuaW1hdGUoKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5nZXRDYW52YXMoKS5jYW52YXNDVFg7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJGb2N1c0NlbGwoY3R4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHM7XG4gICAgfSxcblxuICAgIHNldEJvdW5kczogZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ib3VuZHMgPSBib3VuZHMpO1xuICAgIH1cblxufSk7XG5cbmZ1bmN0aW9uIHNldE51bWJlckNvbHVtbldpZHRoKGdjLCBiZWhhdmlvciwgbWF4Um93KSB7XG4gICAgdmFyIGNvbHVtblByb3BlcnRpZXMgPSBiZWhhdmlvci5nZXRDb2x1bW5Qcm9wZXJ0aWVzKC0xKSxcbiAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBjb2x1bW5Qcm9wZXJ0aWVzLnJvd0hlYWRlcixcbiAgICAgICAgaWNvbiA9IGltYWdlcy5jaGVja2VkO1xuXG4gICAgZ2MuZm9udCA9IGNlbGxQcm9wZXJ0aWVzLmZvbnQ7XG5cbiAgICBjb2x1bW5Qcm9wZXJ0aWVzLnByZWZlcnJlZFdpZHRoID0gaWNvbi53aWR0aCArIDcgKyBjZWxsUHJvcGVydGllcy5nZXRUZXh0V2lkdGgoZ2MsIG1heFJvdyArIDEpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmFuZ2VTZWxlY3Rpb25Nb2RlbCA9IHJlcXVpcmUoJ3NwYXJzZS1ib29sZWFuLWFycmF5Jyk7XG5cbi8qKlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgV2UgcmVwcmVzZW50IHNlbGVjdGlvbnMgYXMgYSBsaXN0IG9mIHJlY3RhbmdsZXMgYmVjYXVzZSBsYXJnZSBhcmVhcyBjYW4gYmUgcmVwcmVzZW50ZWQgYW5kIHRlc3RlZCBhZ2FpbnN0IHF1aWNrbHkgd2l0aCBhIG1pbmltYWwgYW1vdW50IG9mIG1lbW9yeSB1c2FnZS4gQWxzbyB3ZSBuZWVkIHRvIG1haW50YWluIHRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcyBmbGF0dGVuZWQgY291bnRlciBwYXJ0cyBzbyB3ZSBjYW4gdGVzdCBmb3Igc2luZ2xlIGRpbWVuc2lvbiBjb250YWlucy4gVGhpcyBpcyBob3cgd2Uga25vdyB0byBoaWdobGlnaHQgdGhlIGZpeGVkIHJlZ2lvbnMgb24gdGhlIGVkZ2VzIG9mIHRoZSBncmlkLlxuICovXG5cbmZ1bmN0aW9uIFNlbGVjdGlvbk1vZGVsKGdyaWQpIHtcblxuICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBzZWxlY3Rpb25zXG4gICAgICogQHR5cGUge1JlY3RhbmdsZVtdfVxuICAgICAqIEBzdW1tYXJ5IFRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcy5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGFuIGVtcHR5IGFycmF5IHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5zZWxlY3Rpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBmbGF0dGVuZWRYXG4gICAgICogQHR5cGUge1JlY3RhbmdsZVtdfVxuICAgICAqIEBzdW1tYXJ5IFRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcyBmbGF0dGVuZWQgaW4gdGhlIGhvcml6b250YWwgZGlyZWN0aW9uIChubyB3aWR0aCkuXG4gICAgICogQGRlc2MgQ3JlYXRlZCBhcyBhbiBlbXB0eSBhcnJheSB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRoaXMuZmxhdHRlbmVkWCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgZmxhdHRlbmVkWVxuICAgICAqIEB0eXBlIHtSZWN0YW5nbGVbXX1cbiAgICAgKiBAc3VtbWFyeSBUaGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMgZmxhdHRlbmVkIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24gKG5vIGhlaWdodCkuXG4gICAgICogQGRlc2MgQ3JlYXRlZCBhcyBhbiBlbXB0eSBhcnJheSB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRoaXMuZmxhdHRlbmVkWSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgcm93U2VsZWN0aW9uTW9kZWxcbiAgICAgKiBAdHlwZSB7UmFuZ2VTZWxlY3Rpb25Nb2RlbH1cbiAgICAgKiBAc3VtbWFyeSBUaGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMuXG4gICAgICogQGRlc2MgQ3JlYXRlZCBhcyBhIG5ldyBSYW5nZVNlbGVjdGlvbk1vZGVsIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbCA9IG5ldyBSYW5nZVNlbGVjdGlvbk1vZGVsKCk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBjb2x1bW5TZWxlY3Rpb25Nb2RlbFxuICAgICAqIEB0eXBlIHtSYW5nZVNlbGVjdGlvbk1vZGVsfVxuICAgICAqIEBzdW1tYXJ5IFRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcy5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGEgbmV3IFJhbmdlU2VsZWN0aW9uTW9kZWwgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsID0gbmV3IFJhbmdlU2VsZWN0aW9uTW9kZWwoKTtcblxuICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJycpO1xufVxuXG5TZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFsbFJvd3NTZWxlY3RlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0TGFzdFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxzID0gdGhpcy5zZWxlY3Rpb25zO1xuICAgICAgICB2YXIgc2VsID0gc2Vsc1tzZWxzLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gc2VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0TGFzdFNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0U2VsZWN0aW9uVHlwZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHR5cGVcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0TGFzdFNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVHlwZSA9IHR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2VsZWN0IHRoZSByZWdpb24gZGVzY3JpYmVkIGJ5IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveCAtIG9yaWdpbiB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3kgLSBvcmlnaW4geSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleSAtIGV4dGVudCB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBzZWxlY3Q6IGZ1bmN0aW9uKG94LCBveSwgZXgsIGV5KSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmdyaWQubmV3UmVjdGFuZ2xlKG94LCBveSwgZXgsIGV5KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zLnB1c2gobmV3U2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy5mbGF0dGVuZWRYLnB1c2gobmV3U2VsZWN0aW9uLmZsYXR0ZW5YQXQoMCkpO1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFkucHVzaChuZXdTZWxlY3Rpb24uZmxhdHRlbllBdCgwKSk7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ2NlbGwnKTtcbiAgICAgICAgdGhpcy5ncmlkLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveCAtIG9yaWdpbiB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3kgLSBvcmlnaW4geSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleSAtIGV4dGVudCB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICB0b2dnbGVTZWxlY3Q6IGZ1bmN0aW9uKG94LCBveSwgZXgsIGV5KSB7XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkLCBpbmRleDtcblxuICAgICAgICBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0aW9ucy5maW5kKGZ1bmN0aW9uKHNlbGVjdGlvbiwgaWR4KSB7XG4gICAgICAgICAgICBpbmRleCA9IGlkeDtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLm9yaWdpbi54ID09PSBveCAmJiBzZWxlY3Rpb24ub3JpZ2luLnkgPT09IG95ICYmXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmV4dGVudC54ID09PSBleCAmJiBzZWxlY3Rpb24uZXh0ZW50LnkgPT09IGV5XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5mbGF0dGVuZWRYLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5lZFkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChveCwgb3ksIGV4LCBleSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlbW92ZSB0aGUgbGFzdCBzZWxlY3Rpb24gdGhhdCB3YXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRTZWxlY3Rpb246IGZ1bmN0aW9uKGRvbnRDbGVhclJvd1NlbGVjdGlvbnMpIHtcbiAgICAgICAgZG9udENsZWFyUm93U2VsZWN0aW9ucyA9IGRvbnRDbGVhclJvd1NlbGVjdGlvbnMgPT09IHRydWU7XG4gICAgICAgIGlmICghZG9udENsZWFyUm93U2VsZWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRBbGxSb3dzU2VsZWN0ZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbnMubGVuZ3RoKSB7IC0tdGhpcy5zZWxlY3Rpb25zLmxlbmd0aDsgfVxuICAgICAgICBpZiAodGhpcy5mbGF0dGVuZWRYLmxlbmd0aCkgeyAtLXRoaXMuZmxhdHRlbmVkWC5sZW5ndGg7IH1cbiAgICAgICAgaWYgKHRoaXMuZmxhdHRlbmVkWS5sZW5ndGgpIHsgLS10aGlzLmZsYXR0ZW5lZFkubGVuZ3RoOyB9XG4gICAgICAgIC8vdGhpcy5nZXRHcmlkKCkuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY29sdW1uJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdyb3cnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyUm93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5jbGVhcigpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdyb3cnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZXJlIGFyZSBhY3RpdmUgc2VsZWN0aW9uKHMpLlxuICAgICAqL1xuICAgIGhhc1NlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25zLmxlbmd0aCAhPT0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1Jvd1NlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucm93U2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzQ29sdW1uU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBTZWxlY3Rpb24gY292ZXJzIGEgc3BlY2lmaWMgY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWRJblJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDZWxsU2VsZWN0ZWQodGhpcy5mbGF0dGVuZWRYLCAwLCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIFNlbGVjdGlvbiBjb3ZlcnMgYSBzcGVjaWZpYyByb3cuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluQ29sdW1uOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NlbGxTZWxlY3RlZCh0aGlzLmZsYXR0ZW5lZFksIHgsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2VsZWN0aW9uIHF1ZXJ5IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY2VsbCBpcyBzZWxlY3RlZCAocGFydCBvZiBhbiBhY3RpdmUgc2VsZWN0aW9uKS5cbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZVtdfSBzZWxlY3Rpb25zIC0gU2VsZWN0aW9uIHJlY3RhbmdsZXMgdG8gc2VhcmNoIHRocm91Z2guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNDb2x1bW5TZWxlY3RlZCh4KSB8fFxuICAgICAgICAgICAgdGhpcy5pc1Jvd1NlbGVjdGVkKHkpIHx8XG4gICAgICAgICAgICB0aGlzLl9pc0NlbGxTZWxlY3RlZCh0aGlzLnNlbGVjdGlvbnMsIHgsIHkpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2VsbFNlbGVjdGVkKHRoaXMuc2VsZWN0aW9ucywgeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0NlbGxTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0aW9ucywgeCwgeSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAhIXNlbGVjdGlvbnMuZmluZChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnJlY3RhbmdsZUNvbnRhaW5zKHNlbGVjdGlvbiwgeCwgeSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQGRlc2MgZW1wdHkgb3V0IGFsbCBvdXIgc3RhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbihkb250Q2xlYXJSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgIGRvbnRDbGVhclJvd1NlbGVjdGlvbnMgPSBkb250Q2xlYXJSb3dTZWxlY3Rpb25zID09PSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5mbGF0dGVuZWRYLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZmxhdHRlbmVkWS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICAgIGlmICghZG9udENsZWFyUm93U2VsZWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRBbGxSb3dzU2VsZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vdGhpcy5nZXRHcmlkKCkuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG94IC0gb3JpZ2luIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV5IC0gZXh0ZW50IHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUmVjdGFuZ2xlU2VsZWN0ZWQ6IGZ1bmN0aW9uKG94LCBveSwgZXgsIGV5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc2VsZWN0aW9ucy5maW5kKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ub3JpZ2luLnggPT09IG94ICYmIHNlbGVjdGlvbi5vcmlnaW4ueSA9PT0gb3kgJiZcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZXh0ZW50LnggPT09IGV4ICYmIHNlbGVjdGlvbi5leHRlbnQueSA9PT0gZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpc0NvbHVtblNlbGVjdGVkOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQoeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufCp9XG4gICAgICovXG4gICAgaXNSb3dTZWxlY3RlZDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxSb3dzU2VsZWN0ZWQgfHwgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHgxXG4gICAgICogQHBhcmFtIHgyXG4gICAgICovXG4gICAgc2VsZWN0Q29sdW1uOiBmdW5jdGlvbih4MSwgeDIpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5zZWxlY3QoeDEsIHgyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY29sdW1uJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZWxlY3RBbGxSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLnNldEFsbFJvd3NTZWxlY3RlZCh0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gICAgc2V0QWxsUm93c1NlbGVjdGVkOiBmdW5jdGlvbihpc0l0KSB7XG4gICAgICAgIHRoaXMuYWxsUm93c1NlbGVjdGVkID0gaXNJdDtcbiAgICB9LFxuXG4gICAgYXJlQWxsUm93c1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsUm93c1NlbGVjdGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHkxXG4gICAgICogQHBhcmFtIHkyXG4gICAgICovXG4gICAgc2VsZWN0Um93OiBmdW5jdGlvbih5MSwgeTIpIHtcbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5zZWxlY3QoeTEsIHkyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgncm93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geDFcbiAgICAgKiBAcGFyYW0geDJcbiAgICAgKi9cbiAgICBkZXNlbGVjdENvbHVtbjogZnVuY3Rpb24oeDEsIHgyKSB7XG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoeDEsIHgyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY29sdW1uJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geTFcbiAgICAgKiBAcGFyYW0geTJcbiAgICAgKi9cbiAgICBkZXNlbGVjdFJvdzogZnVuY3Rpb24oeTEsIHkyKSB7XG4gICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoeTEsIHkyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgncm93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5hcmVBbGxSb3dzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgdmFyIGhlYWRlclJvd3MgPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMuZ3JpZC5nZXRSb3dDb3VudCgpIC0gaGVhZGVyUm93cztcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkocm93Q291bnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gaSArIGhlYWRlclJvd3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfEFycmF5LkFycmF5Lm51bWJlcn1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICAgaXNDb2x1bW5PclJvd1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKSB8fCAhdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0RmxhdHRlbmVkWXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBzZXQgPSB7fTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdG9wID0gc2VsZWN0aW9uLm9yaWdpbi55O1xuICAgICAgICAgICAgdmFyIHNpemUgPSBzZWxlY3Rpb24uZXh0ZW50LnkgKyAxO1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBzaXplOyByKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGkgPSByICsgdG9wO1xuICAgICAgICAgICAgICAgIGlmICghc2V0W3RpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFt0aV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4IC0geTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICovXG4gICAgc2VsZWN0Um93c0Zyb21DZWxsczogZnVuY3Rpb24ob2Zmc2V0LCBkb250Q2xlYXJSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgICBkb250Q2xlYXJSb3dTZWxlY3Rpb25zID0gZG9udENsZWFyUm93U2VsZWN0aW9ucyA9PT0gdHJ1ZTtcblxuICAgICAgICB2YXIgc20gPSB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsO1xuXG4gICAgICAgIGlmICghZG9udENsZWFyUm93U2VsZWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRBbGxSb3dzU2VsZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgc20uY2xlYXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIHRvcCA9IHNlbGVjdGlvbi5vcmlnaW4ueSxcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBzZWxlY3Rpb24uZXh0ZW50Lnk7XG4gICAgICAgICAgICB0b3AgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc20uc2VsZWN0KHRvcCwgdG9wICsgZXh0ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICovXG4gICAgc2VsZWN0Q29sdW1uc0Zyb21DZWxsczogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICAgIHZhciBzbSA9IHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHNtLmNsZWFyKCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHNlbGVjdGlvbi5vcmlnaW4ueCxcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBzZWxlY3Rpb24uZXh0ZW50Lng7XG4gICAgICAgICAgICBsZWZ0ICs9IG9mZnNldDtcbiAgICAgICAgICAgIHNtLnNlbGVjdChsZWZ0LCBsZWZ0ICsgZXh0ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgaXNJbkN1cnJlbnRTZWxlY3Rpb25SZWN0YW5nbGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLnNlbGVjdGlvbnNbdGhpcy5zZWxlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gbGFzdCAmJiB0aGlzLnJlY3RhbmdsZUNvbnRhaW5zKGxhc3QsIHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHJlY3RcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgcmVjdGFuZ2xlQ29udGFpbnM6IGZ1bmN0aW9uKHJlY3QsIHgsIHkpIHsgLy9UT0RPOiBleHBsb3JlIHdoeSB0aGlzIHdvcmtzIGFuZCBjb250YWlucyBvbiByZWN0YW5nbHVsYXIgZG9lcyBub3RcbiAgICAgICAgdmFyIG1pblggPSByZWN0Lm9yaWdpbi54O1xuICAgICAgICB2YXIgbWluWSA9IHJlY3Qub3JpZ2luLnk7XG4gICAgICAgIHZhciBtYXhYID0gbWluWCArIHJlY3QuZXh0ZW50Lng7XG4gICAgICAgIHZhciBtYXhZID0gbWluWSArIHJlY3QuZXh0ZW50Lnk7XG5cbiAgICAgICAgaWYgKHJlY3QuZXh0ZW50LnggPCAwKSB7XG4gICAgICAgICAgICBtaW5YID0gbWF4WDtcbiAgICAgICAgICAgIG1heFggPSByZWN0Lm9yaWdpbi54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY3QuZXh0ZW50LnkgPCAwKSB7XG4gICAgICAgICAgICBtaW5ZID0gbWF4WTtcbiAgICAgICAgICAgIG1heFkgPSByZWN0Lm9yaWdpbi55O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9XG4gICAgICAgICAgICB4ID49IG1pblggJiZcbiAgICAgICAgICAgIHkgPj0gbWluWSAmJlxuICAgICAgICAgICAgeCA8PSBtYXhYICYmXG4gICAgICAgICAgICB5IDw9IG1heFk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdGlvbk1vZGVsO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcblxuXG52YXIgQU5JTUFUSU9OX1RJTUUgPSA1MDAsXG4gICAgVFJBTlNJVElPTiA9IEFOSU1BVElPTl9USU1FICsgJ21zIGVhc2UtaW4nO1xuXG4vKiogQGNvbnN0cnVjdG9yXG4gKiBAZGVzYyBJbnN0YW5jZXMgb2YgZmVhdHVyZXMgYXJlIGNvbm5lY3RlZCB0byBvbmUgYW5vdGhlciB0byBtYWtlIGEgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkgZm9yIGhhbmRsaW5nIGFsbCB0aGUgaW5wdXQgdG8gdGhlIGh5cGVyZ3JpZC5cbiAqXG4gKiBTZWUge0BsaW5rIFRhYmxlRGlhbG9nI2luaXRpYWxpemV8aW5pdGlhbGl6ZX0gd2hpY2ggaXMgY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAqL1xudmFyIFRhYmxlRGlhbG9nID0gQmFzZS5leHRlbmQoJ1RhYmxlRGlhbG9nJywge1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVPdmVybGF5U3VyZmFjZSgpO1xuICAgICAgICB0aGlzLm9wZW5Ob3cgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE92ZXJsYXkucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJucyB0cnVlIGlmIHRoZSBvdmVybGF5IGlzIG9wZW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGlzT3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW5Ob3c7XG4gICAgfSxcblxuICAgIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcGVuTm93ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnYmFja2dyb3VuZENvbG9yJyk7XG5cbiAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlLnRvcCA9IHRoaXMub3ZlcmxheS5zdHlsZS5ib3R0b20gPSB0aGlzLm92ZXJsYXkuc3R5bGUucmlnaHQgPSB0aGlzLm92ZXJsYXkuc3R5bGUubGVmdCA9IDA7XG5cbiAgICAgICAgc2VsZi5vdmVybGF5LnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnJztcblxuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUubWFyZ2luID0gJzE1cHggMzVweCAzNXB4IDE1cHgnO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS56SW5kZXggPSAxMDA7XG5cbiAgICAgICAgdGhpcy5jbG9zZVRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRoaXMuX2Nsb3Nlcikge1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBzZWxmLmdldENoYXJGb3IoZS5rZXlDb2RlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gc2VsZi5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnZWRpdG9yQWN0aXZhdGlvbktleXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGtleSkgPiAtMSB8fCBlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5vdmVybGF5LnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnb3BhY2l0eSAnICsgQU5JTUFUSU9OX1RJTUUgKyAnbXMgZWFzZS1pbic7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNlbGYuX2Nsb3NlciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNlbGYub3ZlcmxheS5zdHlsZS5vcGFjaXR5ID0gMC45NTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5vdmVybGF5LmZvY3VzKCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgT3ZlcmxheS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBvcGVuIHRoZSBvdmVybGF5XG4gICAgICogIyMjIyByZXR1cm5zOiB0eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBvcGVuRnJvbTogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3Blbk5vdyA9IHRydWU7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5vdmVybGF5LnN0eWxlO1xuICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdyaWQucmVzb2x2ZVByb3BlcnR5KCdiYWNrZ3JvdW5kQ29sb3InKTtcblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5ncmlkLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIG1hcmdpbnMgPSByZWN0LnkgKyAncHggJyArXG4gICAgICAgICAgICAgICAgKGJvdW5kcy53aWR0aCAtIChyZWN0LnggKyByZWN0LndpZHRoKSkgKyAncHggJyArXG4gICAgICAgICAgICAgICAgKGJvdW5kcy5oZWlnaHQgLSAocmVjdC55ICsgcmVjdC5oZWlnaHQpKSArICdweCAnICtcbiAgICAgICAgICAgICAgICByZWN0LnggKyAncHgnO1xuXG4gICAgICAgIHN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnJztcblxuICAgICAgICBzdHlsZS50b3AgPSBzdHlsZS5yaWdodCA9IHN0eWxlLmJvdHRvbSA9IHN0eWxlLmxlZnQgPSAwO1xuXG4gICAgICAgIHN0eWxlLm1hcmdpbiA9IG1hcmdpbnM7XG4gICAgICAgIHN0eWxlLnpJbmRleCA9IDEwMDtcbiAgICAgICAgc3R5bGUub3BhY2l0eSA9IDE7XG5cbiAgICAgICAgdGhpcy5jbG9zZVRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN0eWxlLm1hcmdpbiA9IG1hcmdpbnM7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jbG9zZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gc2VsZi5nZXRDaGFyRm9yKGUua2V5Q29kZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHNlbGYuZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ2VkaXRvckFjdGl2YXRpb25LZXlzJyk7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMuaW5kZXhPZihrZXkpID4gLTEgfHwgZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9ncmlkLnNldEZvY3VzYWJsZShmYWxzZSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBzZWxmLl9jbG9zZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnbWFyZ2luLXRvcCAnICsgVFJBTlNJVElPTiArICcsIG1hcmdpbi1yaWdodCAnICsgVFJBTlNJVElPTiArICcsIG1hcmdpbi1ib3R0b20gJyArIFRSQU5TSVRJT04gKyAnLCBtYXJnaW4tbGVmdCAnICsgVFJBTlNJVElPTjtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUubWFyZ2luID0gJzE1cHggMzVweCAzNXB4IDE1cHgnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5vdmVybGF5LmZvY3VzKCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBPdmVybGF5LnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNsb3NlIHRoZSBvdmVybGF5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vZ3JpZC5zZXRGb2N1c2FibGUodHJ1ZSk7XG4gICAgICAgIHRoaXMub3Blbk5vdyA9IGZhbHNlO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fY2xvc2VyLCBmYWxzZSk7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuY2xvc2VUcmFuc2l0aW9uKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmNsZWFyKCk7XG4gICAgICAgICAgICBzZWxmLm92ZXJsYXkuc3R5bGUuekluZGV4ID0gLTEwMDA7XG4gICAgICAgICAgICBpZiAoc2VsZi5vbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5vbkNsb3NlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5ncmlkLnRha2VGb2N1cygpO1xuICAgICAgICB9LCBBTklNQVRJT05fVElNRSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBPdmVybGF5LnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGluaXRpYWxpemUgdGhlIG92ZXJsYXkgc3VyZmFjZSBpbnRvIHRoZSBncmlkXG4gICAgICogIyMjIyByZXR1cm5zOiB0eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplT3ZlcmxheVN1cmZhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5vdmVybGF5LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICAgICAgdGhpcy5vdmVybGF5LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgZnVuY3Rpb24oZXZ0KSB7IGV2dC5zdG9wUHJvcGFnYXRpb24oKTsgfSk7XG5cbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5vdmVybGF5LnN0eWxlO1xuICAgICAgICBzdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuICAgICAgICBzdHlsZS5ib3hTaGFkb3cgPSAnMCAxOXB4IDM4cHggcmdiYSgwLDAsMCwwLjMwKSwgMCAxNXB4IDEycHggcmdiYSgwLDAsMCwwLjIyKSc7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgICAgICBzdHlsZS5tYXJnaW4gPSAwO1xuICAgICAgICBzdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gICAgICAgIC8vc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAvL3N0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnbWFyZ2luLXRvcCAnICsgVFJBTlNJVElPTiArICcsIG1hcmdpbi1yaWdodCAnICsgVFJBTlNJVElPTiArICcsIG1hcmdpbi1ib3R0b20gJyArIFRSQU5TSVRJT04gKyAnLCBtYXJnaW4tbGVmdCAnICsgVFJBTlNJVElPTjtcblxuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgc3R5bGUuekluZGV4ID0gMTA7XG4gICAgICAgIHRoaXMuZ3JpZC5kaXYuYXBwZW5kQ2hpbGQodGhpcy5vdmVybGF5KTtcbiAgICAgICAgLy9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMub3ZlcmxheSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBPdmVybGF5LnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldCBhIGh1bWFuIHJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBrZXkgcHJlc3NlZCBmcm9tIGl0J3MgaW50ZWdlciByZXByZXNlbnRhdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZWdlciAtIHRoZSBpbnRlZ2VyIHdlIHdhbnQgdGhlIGNoYXIgZm9yXG4gICAgICovXG4gICAgZ2V0Q2hhckZvcjogZnVuY3Rpb24oaW50ZWdlcikge1xuICAgICAgICB2YXIgY2hhck1hcCA9IHRoaXMuZ3JpZC5nZXRDYW52YXMoKS5nZXRDaGFyTWFwKCk7XG4gICAgICAgIHJldHVybiBjaGFyTWFwW2ludGVnZXJdWzBdO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheS5pbm5lckhUTUwgPSAnJztcbiAgICB9LFxuXG4gICAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5vdmVybGF5LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcblxuICAgIGdldEFuaW1hdGlvblRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQU5JTUFUSU9OX1RJTUU7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGFibGVEaWFsb2c7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGNvbnNvbGUud2FybiBwb2x5ZmlsbCBhcyBuZWVkZWRcbi8vIHVzZWQgZm9yIGRlcHJlY2F0aW9uIHdhcm5pbmdzXG5pZiAoIWNvbnNvbGUud2Fybikge1xuICAgIGNvbnNvbGUud2FybiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBbJ1dBUk5JTkc6J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xufVxuXG52YXIgZGVwcmVjYXRlZCA9IGZ1bmN0aW9uKGRvdFByb3BzLCBvcHRpb25zKSB7XG4gICAgdmFyIGNoYWluID0gZG90UHJvcHMuc3BsaXQoJy4nKSxcbiAgICAgICAgbWV0aG9kID0gY2hhaW5bY2hhaW4ubGVuZ3RoIC0gMV0sXG4gICAgICAgIGFzT2ZWZXJzaW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLmFzT2ZWZXJzaW9uLFxuICAgICAgICByZXN1bHQgPSB0aGlzLFxuICAgICAgICB3YXJuaW5nO1xuXG4gICAgbWV0aG9kID0gJ2dldCcgKyBtZXRob2RbMF0udG9VcHBlckNhc2UoKSArIG1ldGhvZC5zdWJzdHIoMSk7XG5cbiAgICB3YXJuaW5nID0gJy4nICsgbWV0aG9kICsgJygpIG1ldGhvZCBpcyBkZXByZWNhdGVkJztcblxuICAgIGlmIChhc09mVmVyc2lvbikge1xuICAgICAgICB3YXJuaW5nICs9ICcgYXMgb2YgdicgKyBvcHRpb25zLmFzT2ZWZXJzaW9uO1xuICAgIH1cblxuICAgIHdhcm5pbmcgKz0gJy4gVXNlIC4nICsgZG90UHJvcHM7XG5cbiAgICBpZiAoZG90UHJvcHNbZG90UHJvcHMubGVuZ3RoIC0gMV0gIT09ICcpJykge1xuICAgICAgICB3YXJuaW5nICs9ICcgcHJvcGVydHknO1xuICAgIH1cblxuICAgIHdhcm5pbmcgKz0gJyBpbnN0ZWFkLiAoV2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuKSc7XG5cbiAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG5cbiAgICBjaGFpbi5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0W2xpbmtdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuTWF0aC5zaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHtcbiAgICB4ID0gK3g7IC8vIGNvbnZlcnQgdG8gYSBudW1iZXJcbiAgICBpZiAoeCA9PT0gMCB8fCBpc05hTih4KSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgcmV0dXJuIHggPiAwID8gMSA6IC0xO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltYWdlcyA9IHJlcXVpcmUoJy4uLy4uL2ltYWdlcycpO1xuXG4vKipcbiAqIEBzdW1tYXJ5IFdyaXRlcyBlcnJvciBtZXNzYWdlIGludG8gY2VsbC5cbiAqXG4gKiBAZGVzYyBUaGlzIGZ1bmNpdG9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgY2FsbGVkIGFzIGZvbGxvd3M6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZ2Muc2F2ZSgpO1xuICogZ2MuYmVnaW5QYXRoKCk7XG4gKiBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICogZ2MuY2xpcCgpO1xuICogcmVuZGVyQ2VsbEVycm9yKGdjLCBtZXNzYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAqIGdjLnJlc3RvcmUoKTtcbiAqIGBgYFxuICpcbiAqIEJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLCB0aGlzIGZ1bmN0aW9uIHNob3VsZCBjbGVhciB0aGUgY2VsbCBieSBzZXR0aW5nIGBnYy5maWxsU3R5bGVgIGFuZCBjYWxsaW5nIGBnYy5maWxsKClgLlxuICpcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNlbGxFcnJvcihnYywgbWVzc2FnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgLy8gY2xlYXIgdGhlIGNlbGxcbiAgICAvLyAodGhpcyBtYWtlcyB1c2Ugb2YgdGhlIHJlY3QgcGF0aCBkZWZpbmVkIGJ5IHRoZSBjYWxsZXIpXG4gICAgZ2MuZmlsbFN0eWxlID0gJyNGRkQ1MDAnO1xuICAgIGdjLmZpbGwoKTtcblxuICAgIC8vIHJlbmRlciBjZWxsIGJvcmRlclxuICAgIGdjLnN0cm9rZVN0eWxlID0gZ2MuY3JlYXRlUGF0dGVybihpbWFnZXMuY2F1dGlvbiwgJ3JlcGVhdCcpO1xuICAgIGdjLmxpbmVXaWR0aCA9IDU7XG4gICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgZ2MubW92ZVRvKHgsIHkpOyAvLyBjYXV0aW9uOiBkbyBub3QgdXNlIHJlY3QoKSBoZXJlIGJlY2F1c2UgQ2hyb21lIGRvZXMgbm90IGNsaXAgaXRzIHN0cm9rZSBwcm9wZXJseVxuICAgIGdjLmxpbmVUbyh4ICsgd2lkdGgsIHkpO1xuICAgIGdjLmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgIGdjLmxpbmVUbyh4LCB5ICsgaGVpZ2h0KTtcbiAgICBnYy5saW5lVG8oeCwgeSk7XG4gICAgZ2Muc3Ryb2tlKCk7XG5cbiAgICAvLyBhZGp1c3QgY2xpcCByZWdpb24gdG8gcHJldmVudCB0ZXh0IGZyb20gcmVuZGVyaW5nIG92ZXIgcmlnaHQgYm9yZGVyIHNob3VsZCBpdCBvdmVyZmxvd1xuICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgIGdjLnJlY3QoeCwgeSwgd2lkdGggLSAyLCBoZWlnaHQpO1xuICAgIGdjLmNsaXAoKTtcblxuICAgIC8vIHJlbmRlciBtZXNzYWdlIHRleHRcbiAgICBnYy5maWxsU3R5bGUgPSAnI0EwMCc7XG4gICAgZ2MudGV4dEFsaWduID0gJ3N0YXJ0JztcbiAgICBnYy50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBnYy5mb250ID0gJ2JvbGQgNnB0IFwiYXJpYWwgbmFycm93XCIsIHZlcmRhbmEsIGdlbmV2YSc7XG4gICAgZ2MuZmlsbFRleHQobWVzc2FnZSwgeCArIDQsIHkgKyBoZWlnaHQgLyAyICsgMC41KTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlckNlbGxFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuLi8uLi9saWIvQmFzZScpO1xuXG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YUJhc2VOb2RlI2luaXRpYWxpemV8aW5pdGlhbGl6ZSgpfSBtZXRob2QgZm9yIHBhcmFtZXRlcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERhdGFOb2RlQmFzZSA9IEJhc2UuZXh0ZW5kKCdEYXRhTm9kZUJhc2UnLCB7XG5cbiAgICBpc051bGxPYmplY3Q6IGZhbHNlLFxuXG4gICAgSU5ERU5UOiAnICAgJywgLy8gMyBzcGFjZXNcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFOb2RlQmFzZS5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5sYWJlbCA9IGtleTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFOb2RlQmFzZS5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gWycnXTsgLy8gVE9ETzogV2h5IGlzIHRoaXMgZmlyc3QgZWxlbWVudCBuZWVkZWQ/XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UucHJvdG90eXBlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgICAgICogQGRlZmF1bHQgWycnXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IFtdOyAvLyBUT0RPOiBmb3JtZXJseSByb3dJbmRleFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQ2hpbGRyZW4gPSBmYWxzZTsgLy8gVE9ETzogV2hlcmUvaG93IGlzIHRoaXMgdXNlZD9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFOb2RlQmFzZS5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UucHJvdG90eXBlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFOb2RlQmFzZS5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3hdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBkZXB0aFxuICAgICAqL1xuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKGRlcHRoKSB7XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdGhpcy5jb21wdXRlRGVwdGhTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNvbXB1dGVEZXB0aFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBcnJheSh0aGlzLmRlcHRoICsgMSkuam9pbih0aGlzLklOREVOVCkgKyAnICAnICsgdGhpcy5sYWJlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvbXB1dGVIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkgeyAvLyBUT0RPOiBmb3JtZXJseSBnZXRBbGxSb3dJbmRleGVzXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBhZ2dyZWdhdG9yXG4gICAgICovXG4gICAgY29tcHV0ZUFnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXG4gICAgICAgIGlmIChpbmRleC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBncm91cHNPZmZzZXQgPSBOdW1iZXIoYWdncmVnYXRvci5oYXNHcm91cHMoKSk7XG5cbiAgICAgICAgICAgIC8vIHJlZGltZW5zaW9uIHRoZSBkYXRhXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGRhdGEubGVuZ3RoID0gZ3JvdXBzT2Zmc2V0ICsgYWdncmVnYXRvci5hZ2dyZWdhdGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIHNvcnRlciA9IGFnZ3JlZ2F0b3Iuc29ydGVySW5zdGFuY2U7XG4gICAgICAgICAgICBzb3J0ZXIuaW5kZXggPSBpbmRleDtcblxuICAgICAgICAgICAgYWdncmVnYXRvci5hZ2dyZWdhdGVzLmZvckVhY2goZnVuY3Rpb24oYWdncmVnYXRlLCBpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtncm91cHNPZmZzZXQgKyBpXSA9IGFnZ3JlZ2F0ZShzb3J0ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYWdncmVnYXRvclxuICAgICAqL1xuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oYWdncmVnYXRvcikge1xuICAgICAgICBhZ2dyZWdhdG9yLmFkZFZpZXcodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYucHJvdG90eXBlXG4gICAgICovXG4gICAgdG9nZ2xlRXhwYW5zaW9uU3RhdGU6IGZ1bmN0aW9uKCkgeyAvKiBhZ2dyZWdhdG9yICovXG4gICAgICAgIC8vZG8gbm90aGluZyBieSBkZWZhdWx0XG4gICAgfVxuXG59KTtcblxuLy9EYXRhTm9kZUJhc2UucHJvdG90eXBlLmFwcGx5QWdncmVnYXRlcyA9IERhdGFOb2RlQmFzZS5wcm90b3R5cGUuY29tcHV0ZUFnZ3JlZ2F0ZXM7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVCYXNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWFwID0gcmVxdWlyZSgnLi91dGlsL01hcHB5Jyk7XG52YXIgRGF0YU5vZGVCYXNlID0gcmVxdWlyZSgnLi9EYXRhTm9kZUJhc2UnKTtcblxudmFyIGV4cGFuZGVkTWFwID0ge1xuICAgIHRydWU6ICdcXHUyNWJjJywgLy8gQkxBQ0sgRE9XTi1QT0lOVElORyBUUklBTkdMRSBha2EgJ+KWvCdcbiAgICBmYWxzZTogJ1xcdTI1YjYnIC8vIEJMQUNLIFJJR0hULVBPSU5USU5HIFRSSUFOR0xFIGFrYSAn4pa2J1xufTtcblxuLyoqXG4gKiA+IFNlZSB7QGxpbmsgRGF0YU5vZGVHcm91cCNpbml0aWFsaXplfGluaXRpYWxpemUoKX0gbWV0aG9kIGZvciBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhTm9kZUJhc2VcbiAqL1xudmFyIERhdGFOb2RlR3JvdXAgPSBEYXRhTm9kZUJhc2UuZXh0ZW5kKCdEYXRhTm9kZUdyb3VwJywge1xuXG4gICAgZXh0ZW5kYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGRlcHRoXG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi52YWx1ZXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQudG9BcnJheShkZXB0aCArIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdGhpcy5jb21wdXRlRGVwdGhTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBjb21wdXRlRGVwdGhTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkodGhpcy5kZXB0aCArIDEpLmpvaW4odGhpcy5JTkRFTlQpICtcbiAgICAgICAgICAgIGV4cGFuZGVkTWFwW3RoaXMuZXhwYW5kZWRdICsgJyAnICtcbiAgICAgICAgICAgIHRoaXMubGFiZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldEluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5jb21wdXRlSW5kZXgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGNvbXB1dGVJbmRleDogZnVuY3Rpb24oKSB7IC8vIFRPRE86IGZvcm1lcmx5IGNvbXB1dGVBbGxSb3dJbmRleGVzXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZCA9IGFwcGVuZDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKGNoaWxkLmdldEluZGV4KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0b3JcbiAgICAgKi9cbiAgICB0b2dnbGVFeHBhbnNpb25TdGF0ZTogZnVuY3Rpb24oYWdncmVnYXRvcikgeyAvKiBhZ2dyZWdhdG9yICovXG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdGhpcy5jb21wdXRlRGVwdGhTdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUFnZ3JlZ2F0ZXMoYWdncmVnYXRvcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0b3JcbiAgICAgKi9cbiAgICBjb21wdXRlQWdncmVnYXRlczogZnVuY3Rpb24oYWdncmVnYXRvcikge1xuICAgICAgICBEYXRhTm9kZUJhc2UucHJvdG90eXBlLmNvbXB1dGVBZ2dyZWdhdGVzLmNhbGwodGhpcywgYWdncmVnYXRvcik7IC8vIGNhbGwgYmFzZSBjbGFzcydzIHZlcnNpb25cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmNvbXB1dGVBZ2dyZWdhdGVzKGFnZ3JlZ2F0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0b3JcbiAgICAgKi9cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgYWdncmVnYXRvci52aWV3LnB1c2godGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5idWlsZFZpZXcoYWdncmVnYXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvbXB1dGVIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMTtcblxuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICsgY2hpbGQuY29tcHV0ZUhlaWdodCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRoaXMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICB9XG5cbn0pO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAc3VtbWFyeSBBcnJheSBtaXhpbiB0byBhcHBlbmQgYW5vdGhlciBhcnJheSB0byBlbmQgb2YgYHRoaXNgIG9uZS5cbiAqIEBkZXNjIEFwcGVuZHMgaW4gcGxhY2UsIHVubGlrZSBgdGhpcy5jb25jYXQoKWAgd2hpY2ggY3JlYXRlcyBhIG5ldyBhcnJheS5cbiAqIFVzZXMgbGVzcyBtZW1vcnkgdGhhbiBjb25jYXQsIGltcG9ydGFudCB3aGVuIGBhcHBlbmRpeGAgaXMgaHVnZS5cbiAqID4gQ0FVVElPTjogTXV0YXRlcyBgdGhpc2AgYXJyYXkhXG4gKiBAcGFyYW0ge0FycmF5fSBhcHBlbmRpeFxuICogQHJldHVybnMge0FycmF5fSBSZWZlcmVuY2UgdG8gYHRoaXNgIChmb3IgY29udmVuaWVuY2UpXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZChhcHBlbmRpeCkge1xuICAgIHRoaXMuc3BsaWNlLmJpbmQodGhpcywgdGhpcy5sZW5ndGgsIDApLmFwcGx5KHRoaXMsIGFwcGVuZGl4KTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZUdyb3VwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YU5vZGVCYXNlID0gcmVxdWlyZSgnLi9EYXRhTm9kZUJhc2UnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFOb2RlQmFzZVxuICovXG52YXIgRGF0YU5vZGVMZWFmID0gRGF0YU5vZGVCYXNlLmV4dGVuZCgnRGF0YU5vZGVMZWFmJywge1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gZGVwdGhcbiAgICAgKi9cbiAgICB0b0FycmF5OiBmdW5jdGlvbihkZXB0aCkge1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRoaXMuZGF0YVswXSA9IHRoaXMuY29tcHV0ZURlcHRoU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWVyW119XG4gICAgICovXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYWdncmVnYXRvclxuICAgICAqL1xuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oYWdncmVnYXRvcikge1xuICAgICAgICBhZ2dyZWdhdG9yLmFkZFZpZXcodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBjb21wdXRlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZUxlYWY7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhTm9kZUdyb3VwID0gcmVxdWlyZSgnLi9EYXRhTm9kZUdyb3VwJyk7XG5cbi8qKlxuICogU2VlIHtAbGluayBEYXRhTm9kZUdyb3VwI2luaXRpYWxpemV8aW5pdGlhbGl6ZSgpfSBtZXRob2QgZm9yIHBhcmFtZXRlcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFOb2RlR3JvdXBcbiAqL1xudmFyIERhdGFOb2RlVHJlZSA9IERhdGFOb2RlR3JvdXAuZXh0ZW5kKCdEYXRhTm9kZVRyZWUnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi52YWx1ZXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQudG9BcnJheSgwKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBhZ2dyZWdhdG9yXG4gICAgICovXG4gICAgYnVpbGRWaWV3OiBmdW5jdGlvbihhZ2dyZWdhdG9yKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQuYnVpbGRWaWV3KGFnZ3JlZ2F0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBjb21wdXRlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IDE7XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKyBjaGlsZC5jb21wdXRlSGVpZ2h0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAodGhpcy5oZWlnaHQgPSBoZWlnaHQpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVUcmVlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVhZGVyaWZ5ID0gcmVxdWlyZSgnLi91dGlsL2hlYWRlcmlmeScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3RbXX0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGRzXG4gKi9cbmZ1bmN0aW9uIERhdGFTb3VyY2UoZGF0YSwgZmllbGRzKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzIHx8IGNvbXB1dGVGaWVsZE5hbWVzKGRhdGFbMF0pO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdFtdfVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG59XG5cbkRhdGFTb3VyY2UucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBEYXRhU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciwgLy8gcHJlc2VydmUgY29uc3RydWN0b3JcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmdldFJvdyh5KTtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dbdGhpcy5maWVsZHNbeF1dO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2V0Um93KHkpW3RoaXMuZmllbGRzW3hdXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZHMoKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHRoaXMuaGVhZGVycyB8fCB0aGlzLmdldERlZmF1bHRIZWFkZXJzKCkubWFwKGZ1bmN0aW9uKGVhY2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyaWZ5KGVhY2gpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldERlZmF1bHRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkc1xuICAgICAqL1xuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBoZWFkZXJzXG4gICAgICovXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVycykge1xuICAgICAgICBpZiAoIShoZWFkZXJzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICBlcnJvcignc2V0SGVhZGVycycsICdwYXJhbSAjMSBgaGVhZGVyc2Agbm90IGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0R3JhbmRUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL25vdGhpbmcgaGVyZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYXJyYXlPZlVuaWZvcm1PYmplY3RzXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oYXJyYXlPZlVuaWZvcm1PYmplY3RzKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGFycmF5T2ZVbmlmb3JtT2JqZWN0cztcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBlcnJvcihtZXRob2ROYW1lLCBtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhU291cmNlLicgKyBtZXRob2ROYW1lICsgJzogJyArIG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGaWVsZE5hbWVzKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QgfHwgW10pLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBlLnN1YnN0cigwLCAyKSAhPT0gJ19fJztcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YVNvdXJjZVNvcnRlciA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlcicpO1xudmFyIERhdGFOb2RlVHJlZSA9IHJlcXVpcmUoJy4vRGF0YU5vZGVUcmVlJyk7XG52YXIgRGF0YU5vZGVHcm91cCA9IHJlcXVpcmUoJy4vRGF0YU5vZGVHcm91cCcpO1xudmFyIERhdGFOb2RlTGVhZiA9IHJlcXVpcmUoJy4vRGF0YU5vZGVMZWFmJyk7XG52YXIgaGVhZGVyaWZ5ID0gcmVxdWlyZSgnLi91dGlsL2hlYWRlcmlmeScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtEYXRhU291cmNlfSBkYXRhU291cmNlXG4gKi9cbmZ1bmN0aW9uIERhdGFTb3VyY2VBZ2dyZWdhdG9yKGRhdGFTb3VyY2UpIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7RGF0YVNvdXJjZX1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtEYXRhTm9kZVRyZWV9XG4gICAgICovXG4gICAgdGhpcy50cmVlID0gbmV3IERhdGFOb2RlVHJlZSgnVG90YWxzJyk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICovXG4gICAgdGhpcy5pbmRleCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAqL1xuICAgIHRoaXMuYWdncmVnYXRlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAqL1xuICAgIHRoaXMuaGVhZGVycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAqL1xuICAgIHRoaXMuZ3JvdXBCeXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQGRlZmF1bHQgW11cbiAgICAgKi9cbiAgICB0aGlzLnZpZXcgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBkZWZhdWx0IHt9XG4gICAgICovXG4gICAgdGhpcy5zb3J0ZXJJbnN0YW5jZSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLnByZXNvcnRHcm91cHMgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQGRlZmF1bHQge31cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RBZ2dyZWdhdGUgPSB7fTtcblxuICAgIHRoaXMuc2V0QWdncmVnYXRlcyh7fSk7XG59XG5cbkRhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLCAvLyBwcmVzZXJ2ZSBjb25zdHJ1Y3RvclxuXG4gICAgaXNOdWxsT2JqZWN0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYWdncmVnYXRpb25zXG4gICAgICovXG4gICAgc2V0QWdncmVnYXRlczogZnVuY3Rpb24oYWdncmVnYXRpb25zKSB7XG4gICAgICAgIHRoaXMubGFzdEFnZ3JlZ2F0ZSA9IGFnZ3JlZ2F0aW9ucztcbiAgICAgICAgdGhpcy5jbGVhckFnZ3JlZ2F0aW9ucygpO1xuICAgICAgICB0aGlzLmhlYWRlcnMubGVuZ3RoID0gMDtcblxuICAgICAgICBpZiAodGhpcy5oYXNHcm91cHMoKSkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnB1c2goJ1RyZWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhZ2dyZWdhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQWdncmVnYXRlKGtleSwgYWdncmVnYXRpb25zW2tleV0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gbGFiZWxcbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqL1xuICAgIGFkZEFnZ3JlZ2F0ZTogZnVuY3Rpb24obGFiZWwsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnB1c2goaGVhZGVyaWZ5KGxhYmVsKSk7XG4gICAgICAgIHRoaXMuYWdncmVnYXRlcy5wdXNoKGZ1bmMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGNvbHVtbkluZGV4QXJyYXlcbiAgICAgKi9cbiAgICBzZXRHcm91cEJ5czogZnVuY3Rpb24oY29sdW1uSW5kZXhBcnJheSkge1xuICAgICAgICB2YXIgZ3JvdXBCeXMgPSB0aGlzLmdyb3VwQnlzO1xuICAgICAgICBncm91cEJ5cy5sZW5ndGggPSAwO1xuICAgICAgICBjb2x1bW5JbmRleEFycmF5LmZvckVhY2goZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgIGdyb3VwQnlzLnB1c2goY29sdW1uSW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRBZ2dyZWdhdGVzKHRoaXMubGFzdEFnZ3JlZ2F0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBhZGRHcm91cEJ5OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB0aGlzLmdyb3VwQnlzLnB1c2goaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzR3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5ncm91cEJ5cy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNBZ2dyZWdhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5hZ2dyZWdhdGVzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5idWlsZEdyb3VwVHJlZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdyb3VwQnlzLmxlbmd0aCA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhckFnZ3JlZ2F0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYWdncmVnYXRlcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmhlYWRlcnMubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGJ1aWxkR3JvdXBUcmVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyb3VwQnlzID0gdGhpcy5ncm91cEJ5cyxcbiAgICAgICAgICAgIGxlYWZEZXB0aCA9IGdyb3VwQnlzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLmRhdGFTb3VyY2UsXG4gICAgICAgICAgICByb3dDb3VudCA9IHNvdXJjZS5nZXRSb3dDb3VudCgpLFxuICAgICAgICAgICAgdHJlZSA9IHRoaXMudHJlZSA9IG5ldyBEYXRhTm9kZVRyZWUoJ1RvdGFscycpO1xuXG4gICAgICAgIC8vIGZpcnN0IHNvcnQgZGF0YVxuICAgICAgICBpZiAodGhpcy5wcmVzb3J0R3JvdXBzKSB7XG4gICAgICAgICAgICBncm91cEJ5cy5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbihncm91cEJ5KSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gbmV3IERhdGFTb3VyY2VTb3J0ZXIoc291cmNlKTtcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc29ydE9uKGdyb3VwQnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdHJlZTtcblxuICAgICAgICAgICAgZ3JvdXBCeXMuZm9yRWFjaChmdW5jdGlvbihnLCBjKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHNvdXJjZS5nZXRWYWx1ZShnLCByKSxcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yeURhdGFOb2RlID0gKGMgPT09IGxlYWZEZXB0aCkgPyBmYWN0b3J5RGF0YU5vZGVMZWFmIDogZmFjdG9yeURhdGFOb2RlR3JvdXA7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguY2hpbGRyZW4uZ2V0SWZVbmRlZmluZWQoa2V5LCBmYWN0b3J5RGF0YU5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBhdGguaW5kZXgucHVzaChyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc29ydGVySW5zdGFuY2UgPSBuZXcgRGF0YVNvdXJjZVNvcnRlcihzb3VyY2UpO1xuICAgICAgICB0cmVlLnRvQXJyYXkoKTtcbiAgICAgICAgdHJlZS5jb21wdXRlQWdncmVnYXRlcyh0aGlzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBkYXRhTm9kZVxuICAgICAqL1xuICAgIGFkZFZpZXc6IGZ1bmN0aW9uKGRhdGFOb2RlKSB7XG4gICAgICAgIHRoaXMudmlldy5wdXNoKGRhdGFOb2RlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnRyZWUuY29tcHV0ZUhlaWdodCgpO1xuICAgICAgICB0aGlzLnRyZWUuYnVpbGRWaWV3KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2aWV3TWFrZXNTZW5zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRWYWx1ZSh4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3cgPSB0aGlzLnZpZXdbeV07XG5cbiAgICAgICAgcmV0dXJuIHJvdyA/IHJvdy5nZXRWYWx1ZSh4KSA6IG51bGw7IC8vIFRPRE86IHdoYXQga2luZCBvZiBvYmplY3QgaXMgcm93Li4uID8gc2hvdWxkIGl0IGJlIHVuZmlsdHJlZD9cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVhZGVycygpLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aWV3Lmxlbmd0aDsgLy9oZWFkZXIgY29sdW1uXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geVxuICAgICAqL1xuICAgIGNsaWNrOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMudmlld1t5XTtcbiAgICAgICAgZ3JvdXAudG9nZ2xlRXhwYW5zaW9uU3RhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0SGVhZGVycygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnM7IC8vIFRPRE86IFZpZXdzIG92ZXJyaWRlIGRhdGFTb3VyY2UgaGVhZGVycyB3aXRoIHRoZWlyIG93biBoZWFkZXJzP1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGhlYWRlcnNcbiAgICAgKi9cbiAgICBzZXRIZWFkZXJzOiBmdW5jdGlvbihoZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXRIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp8bnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRGaWVsZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBmaWVsZHNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNldEZpZWxkcyhmaWVsZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEdyYW5kVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnRyZWU7XG4gICAgICAgIHJldHVybiBbdmlldy5kYXRhXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFJvdyh5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb2xsdXBzID0gdGhpcy52aWV3W3ldO1xuXG4gICAgICAgIHJldHVybiByb2xsdXBzID8gcm9sbHVwcyA6IHRoaXMudHJlZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBhcnJheU9mVW5pZm9ybU9iamVjdHNcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihhcnJheU9mVW5pZm9ybU9iamVjdHMpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNldERhdGEoYXJyYXlPZlVuaWZvcm1PYmplY3RzKTtcbiAgICAgICAgdGhpcy5hcHBseSgpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGZhY3RvcnlEYXRhTm9kZUxlYWYoa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhTm9kZUxlYWYoa2V5KTtcbn1cblxuZnVuY3Rpb24gZmFjdG9yeURhdGFOb2RlR3JvdXAoa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhTm9kZUdyb3VwKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZUFnZ3JlZ2F0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb259IGZpbHRlckZ1bmN0aW9uXG4gKiBAcGFyYW0gY2VsbFZhbHVlXG4gKiBAcGFyYW0ge29iamVjdH0gcm93T2JqZWN0IC0gUmVmZXJlbmNlIHRvIGB0aGlzLmRhdGFTb3VyY2UuZGF0YVtyXWAuXG4gKiBAcGFyYW0ge251bWJlcn0gciAtIFJvdyBudW1iZXIgKGluZGV4IHdpdGhpbiBgdGhpcy5kYXRhU291cmNlLmRhdGFgKS5cbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGF0YVNvdXJjZUluZGV4ZWRcbiAqL1xudmFyIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIgPSBEYXRhU291cmNlSW5kZXhlZC5leHRlbmQoJ0RhdGFTb3VyY2VHbG9iYWxGaWx0ZXInLCB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR2xvYmFsRmlsdGVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBmaWx0ZXJcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2ZpbHRlckZ1bmN0aW9ufVxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdsb2JhbEZpbHRlci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5maWx0ZXI7XG4gICAgICAgIHRoaXMuY2xlYXJJbmRleCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR2xvYmFsRmlsdGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlcikge1xuICAgICAgICAgICAgdGhpcy5jbGVhckluZGV4KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkSW5kZXgoZnVuY3Rpb24gYXBwbHlGaWx0ZXIociwgcm93T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyLnRlc3Qocm93T2JqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlciA/IHRoaXMuaW5kZXgubGVuZ3RoIDogdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZUdsb2JhbEZpbHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuLi8uLi9saWIvQmFzZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRGF0YVNvdXJjZUluZGV4ZWQgPSBCYXNlLmV4dGVuZCgnRGF0YVNvdXJjZUluZGV4ZWQnLCB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGRhdGFTb3VyY2VcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgdHJhbnNwb3NlWTogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleC5sZW5ndGggPyB0aGlzLmluZGV4W3ldIDogeTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3codGhpcy50cmFuc3Bvc2VZKHkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7KnxNaXhlZH1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFZhbHVlKHgsIHRoaXMudHJhbnNwb3NlWSh5KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc2V0VmFsdWUoeCwgdGhpcy50cmFuc3Bvc2VZKHkpLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfCp9XG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleC5sZW5ndGggfHwgdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEZpZWxkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGZpZWxkc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0RmllbGRzKGZpZWxkcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBoZWFkZXJzXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXRIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRIZWFkZXJzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRHcmFuZFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0R3JhbmRUb3RhbHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGFycmF5T2ZVbmlmb3JtT2JqZWN0c1xuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihhcnJheU9mVW5pZm9ybU9iamVjdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXREYXRhKGFycmF5T2ZVbmlmb3JtT2JqZWN0cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhckluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pbmRleC5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtmaWx0ZXJQcmVkaWNhdGV9IHByZWRpY2F0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICBidWlsZEluZGV4OiBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCksXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICAgICAgdGhpcy5jbGVhckluZGV4KCk7XG5cbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUuY2FsbCh0aGlzLCByLCB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93KHIpKSkge1xuICAgICAgICAgICAgICAgIGluZGV4LnB1c2gocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG59KTtcblxuLyoqIEB0eXBlZGVmIHtmdW5jdGlvbn0gZmlsdGVyUHJlZGljYXRlXG4gKiBAc3VtbWFyeSBBcHBsaWVzIGZpbHRlciB0byBnaXZlbiByb3cuXG4gKiBAcGFyYW0ge251Ym1lcn0gciAtIFJvdyBpbmRleCBvZiByb3cgZGF0YSB3aXRoaW4gcm93cyBhcnJheSBgdGhpcy5kYXRhU291cmNlLmRhdGFbXWAuXG4gKiBAcGFyYW0ge29iamVjdH0gcm93T2JqZWN0IC0gUm93IGRhdGE7IGVsZW1lbnQgb2YgYHRoaXMuZGF0YVNvdXJjZS5kYXRhW11gLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJvdyBxdWFsaWZpZXMgKHBhc3NlcyB0aHJvdWdoIGZpbHRlcikuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlSW5kZXhlZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFTb3VyY2VJbmRleGVkID0gcmVxdWlyZSgnLi9EYXRhU291cmNlSW5kZXhlZCcpO1xudmFyIHN0YWJsZVNvcnQgPSByZXF1aXJlKCcuL3V0aWwvc3RhYmxlU29ydCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGF0YVNvdXJjZUluZGV4ZWRcbiAqL1xudmFyIERhdGFTb3VyY2VTb3J0ZXIgPSBEYXRhU291cmNlSW5kZXhlZC5leHRlbmQoJ0RhdGFTb3VyY2VTb3J0ZXInLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVzY2VuZGluZ1NvcnQgPSBmYWxzZTsgLy8gVE9ETzogdGhpcyBkb2VzIG5vdCBzZWVtIHRvIGJlIGluIHVzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSWR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaXJlY3Rpb249MV1cbiAgICAgKi9cbiAgICBzb3J0T246IGZ1bmN0aW9uKGNvbElkeCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckluZGV4KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIGZvciB1c2UgaW4gZ2V0VmFsdWVcbiAgICAgICAgICAgICAgICBzdGFibGVTb3J0LnNvcnQodGhpcy5idWlsZEluZGV4KCksIGdldFZhbHVlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUocm93SWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsT3JGdW5jQ2FsbChzZWxmLmRhdGFTb3VyY2UuZ2V0VmFsdWUoY29sSWR4LCByb3dJZHgpKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp8ZnVuY3Rpb259IHZhbE9yRnVuY1xuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIHZhbE9yRnVuY0NhbGwodmFsT3JGdW5jKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWxPckZ1bmMgPT09ICdmdW5jdGlvbicgPyB2YWxPckZ1bmMoKSA6IHZhbE9yRnVuYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlU29ydGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YVNvdXJjZUluZGV4ZWQgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VJbmRleGVkJyk7XG52YXIgRGF0YVNvdXJjZVNvcnRlciA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGF0YVNvdXJjZUluZGV4ZWRcbiAqL1xudmFyIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUgPSBEYXRhU291cmNlSW5kZXhlZC5leHRlbmQoJ0RhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhdmVhdHM6XG4gICAgICAgICAqXG4gICAgICAgICAqIDEuIENvbHVtbnMgc2hvdWxkIGJlIHVuaXF1ZWx5IHJlcHJlc2VudGVkIChpLmUuLCBubyByZXBlYXRzIHdpdGggc2FtZSBjb2x1bW5JbmRleClcbiAgICAgICAgICogMi4gQ29sdW1ucyBzaG91bGQgYmUgYWRkZWQgbG93LSB0byBoaWdoLW9yZGVyIChpLmUuLCBtb3N0IGdyb3VwZWQgY29sdW1ucyBjb21lIGxhc3QpXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvcnRzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtEYXRhU291cmNlfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdCA9IHRoaXMuZGF0YVNvdXJjZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0LmdldFJvdyh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGNvbHVtbkluZGV4XG4gICAgICogQHBhcmFtIGRpcmVjdGlvblxuICAgICAqL1xuICAgIHNvcnRPbjogZnVuY3Rpb24oY29sdW1uSW5kZXgsIGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLnNvcnRzLnB1c2goW2NvbHVtbkluZGV4LCBkaXJlY3Rpb25dKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUucHJvdG90eXBlXG4gICAgICovXG4gICAgYXBwbHlTb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlYWNoID0gdGhpcy5kYXRhU291cmNlO1xuXG4gICAgICAgIHRoaXMuc29ydHMuZm9yRWFjaChmdW5jdGlvbihzb3J0KSB7XG4gICAgICAgICAgICBlYWNoID0gbmV3IERhdGFTb3VyY2VTb3J0ZXIoZWFjaCk7XG4gICAgICAgICAgICBlYWNoLnNvcnRPbi5hcHBseShlYWNoLCBzb3J0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sYXN0ID0gZWFjaDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJTb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc29ydHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5kYXRhU291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdC5nZXRWYWx1ZSh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5sYXN0LnNldFZhbHVlKHgsIHksIHZhbHVlKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBKU0RhdGFTb3VyY2U6IHJlcXVpcmUoJy4vRGF0YVNvdXJjZScpLFxuICAgIERhdGFTb3VyY2VTb3J0ZXI6IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlcicpLFxuICAgIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGU6IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZScpLFxuICAgIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXI6IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUdsb2JhbEZpbHRlcicpLFxuICAgIERhdGFTb3VyY2VBZ2dyZWdhdG9yOiByZXF1aXJlKCcuL0RhdGFTb3VyY2VBZ2dyZWdhdG9yJyksXG4gICAgdXRpbDoge1xuICAgICAgICBhZ2dyZWdhdGlvbnM6IHJlcXVpcmUoJy4vdXRpbC9hZ2dyZWdhdGlvbnMnKVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hcHB5KCkge1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMudmFsdWVzID0gW107XG59XG5cbk1hcHB5LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBNYXBweS5wcm90b3R5cGUuY29uc3RydWN0b3IsIC8vIHByZXNlcnZlIGNvbnN0cnVjdG9yXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTWFwcHkucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaGFzaENvZGUgPSBoYXNoKGtleSk7XG4gICAgICAgIGlmICghKGhhc2hDb2RlIGluIHRoaXMuZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFbaGFzaENvZGVdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGhhc2hDb2RlID0gaGFzaChrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2hhc2hDb2RlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgTWFwcHkucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGlmVW5kZWZpbmVkRnVuYyAtIFZhbHVlIGdldHRlciB3aGVuIHZhbHVlIGlzIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0SWZVbmRlZmluZWQ6IGZ1bmN0aW9uKGtleSwgaWZVbmRlZmluZWRGdW5jKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGlmVW5kZWZpbmVkRnVuYyhrZXkpO1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMua2V5cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBkZWxldGU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgaGFzaENvZGUgPSBoYXNoKGtleSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFbaGFzaENvZGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGJldHRlckluZGV4T2YodGhpcy5rZXlzLCBrZXkpO1xuICAgICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtoYXNoQ29kZV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRlZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZi5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZSh2YWx1ZSwga2V5LCBzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZVxuICAgICAqIEByZXR1cm5zIHtNYXBweX1cbiAgICAgKi9cbiAgICBtYXA6IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzLFxuICAgICAgICAgICAgbmV3TWFwID0gbmV3IE1hcHB5KCksXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoISh0eXBlb2YgaXRlcmF0ZWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICBpdGVyYXRlZSA9IHJlZmxlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChrZXkpLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgc2VsZik7XG4gICAgICAgICAgICBuZXdNYXAuc2V0KGtleSwgdHJhbnNmb3JtZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld01hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtNYXBweX1cbiAgICAgKi9cbiAgICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgICAgICBuZXdNYXAgPSBuZXcgTWFwcHkoKSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChrZXkpO1xuICAgICAgICAgICAgbmV3TWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdNYXA7XG4gICAgfVxuXG59O1xuXG52YXIgT0lEX1BSRUZJWCA9ICcufi4jJV8nOyAvL3RoaXMgc2hvdWxkIGJlIHNvbWV0aGluZyB3ZSBuZXZlciB3aWxsIHNlZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgc3RyaW5nXG52YXIgY291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGhhc2goa2V5KSB7XG4gICAgdmFyIHR5cGVPZiA9IHR5cGVvZiBrZXk7XG5cbiAgICBzd2l0Y2ggKHR5cGVPZikge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIHJldHVybiBPSURfUFJFRklYICsgdHlwZU9mICsgJ18nICsga2V5O1xuXG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICByZXR1cm4gJ1VOREVGSU5FRCc7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05VTEwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHdoZW4gbm90IG51bGw6XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiAoa2V5Ll9fX2Zpbmhhc2ggPSBrZXkuX19fZmluaGFzaCB8fCBPSURfUFJFRklYICsgY291bnRlcisrKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIH1cbn1cblxuLy8gT2JqZWN0LmlzIHBvbHlmaWxsLCBjb3VydGVzeSBvZiBAV2ViUmVmbGVjdGlvblxudmFyIGlzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiA/IGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGIgOiBhICE9IGEgJiYgYiAhPSBiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxufTtcblxuZnVuY3Rpb24gcmVmbGVjdGlvbih2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xufVxuXG4vLyBNb3JlIHJlbGlhYmxlIGluZGV4T2YsIGNvdXJ0ZXN5IG9mIEBXZWJSZWZsZWN0aW9uXG5mdW5jdGlvbiBiZXR0ZXJJbmRleE9mKGFyciwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IDApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tICYmICFpcyhhcnJbaV0sIHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IFtdLmluZGV4T2YuY2FsbChhcnIsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwcHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG1vZHVsZSBhZ2dyZWdhdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gYWdncmVnYXRpb25GdW5jdGlvblxuICogQHN1bW1hcnkgQSBib3VuZCBmdW5jdGlvbi5cbiAqIEBkZXNjIEFuIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBgY29sdW1uSW5kZXhgIHZhbHVlIHN1cHBsaWVkIHRvIG9uZSBvZiB0aGUgYWJvdmUgZmFjdG9yeSBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBcbiAqIEByZXR1cm5zIHsqfSBBZ2dyZWdhdGVkIHZhbHVlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjb3VudDogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3VtOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gc3VtLmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbWluOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gbWlubWF4LmJpbmQodGhpcywgY29sdW1uSW5kZXgsIE1hdGgubWluLCBJbmZpbml0eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBtYXg6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBtaW5tYXguYmluZCh0aGlzLCBjb2x1bW5JbmRleCwgTWF0aC5tYXgsIC1JbmZpbml0eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBhdmc6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBhdmcuYmluZCh0aGlzLCBjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmaXJzdDogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0LmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbGFzdDogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxhc3QuYmluZCh0aGlzLCBjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGRkZXY6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBzdGRkZXYuYmluZCh0aGlzLCBjb2x1bW5JbmRleCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY291bnQoZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAuZ2V0Um93Q291bnQoKTtcbn1cblxuZnVuY3Rpb24gc3VtKGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHZhciByID0gZ3JvdXAuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgbiA9IDA7XG5cbiAgICB3aGlsZSAoci0tKSB7XG4gICAgICAgIG4gKz0gZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIHIpO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBtaW5tYXgoY29sdW1uSW5kZXgsIG1ldGhvZCwgbiwgZ3JvdXApIHtcbiAgICB2YXIgciA9IGdyb3VwLmdldFJvd0NvdW50KCk7XG5cbiAgICB3aGlsZSAoci0tKSB7XG4gICAgICAgIG4gPSBtZXRob2QobiwgZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIHIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gYXZnKGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHJldHVybiBzdW0oY29sdW1uSW5kZXgsIGdyb3VwKSAvIGdyb3VwLmdldFJvd0NvdW50KCk7XG59XG5cbmZ1bmN0aW9uIGZpcnN0KGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHJldHVybiBncm91cC5nZXRWYWx1ZShjb2x1bW5JbmRleCwgMCk7XG59XG5cbmZ1bmN0aW9uIGxhc3QoY29sdW1uSW5kZXgsIGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLmdldFZhbHVlKGNvbHVtbkluZGV4LCBncm91cC5nZXRSb3dDb3VudCgpIC0gMSk7XG59XG5cbmZ1bmN0aW9uIHN0ZGRldihjb2x1bW5JbmRleCwgZ3JvdXApIHtcbiAgICB2YXIgcm93cyA9IGdyb3VwLmdldFJvd0NvdW50KCksXG4gICAgICAgIG1lYW4gPSBhdmcoY29sdW1uSW5kZXgsIGdyb3VwKTtcblxuICAgIGZvciAodmFyIGRldiwgciA9IHJvd3MsIHZhcmlhbmNlID0gMDsgci0tOyB2YXJpYW5jZSArPSBkZXYgKiBkZXYpIHtcbiAgICAgICAgZGV2ID0gZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIHIpIC0gbWVhbjtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHZhcmlhbmNlIC8gcm93cyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGhlYWRlcmlmeShzdHJpbmcpIHtcbiAgICByZXR1cm4gKC9bYS16XS8udGVzdChzdHJpbmcpID8gc3RyaW5nIDogc3RyaW5nLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIC5yZXBsYWNlKC9bXFxzXFwtX10qKFteXFxzXFwtX10pKFteXFxzXFwtX10rKS9nLCByZXBsYWNlcilcbiAgICAgICAgLnJlcGxhY2UoL1tBLVpdL2csICcgJCYnKVxuICAgICAgICAudHJpbSgpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlcihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGIudG9VcHBlckNhc2UoKSArIGM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGVhZGVyaWZ5OyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBOb3RlIHRoYXQge0BsaW5rIG1vZHVsZTpzdGFibGVTb3J0I3NvcnR8c29ydCgpfSBpcyB0aGUgb25seSBleHBvc2VkIG1ldGhvZC5cbiAqIEBtb2R1bGUgc3RhYmxlU29ydFxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogQHBhcmFtIHtib29sZWFufSBkZXNjZW5kaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIxXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHN0YWJpbGl6ZShjb21wYXJhdG9yLCBkZXNjZW5kaW5nLCBhcnIxLCBhcnIyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2hhZG93XG4gICAgdmFyIHggPSBhcnIxWzBdO1xuICAgIHZhciB5ID0gYXJyMlswXTtcblxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHggPSBkZXNjZW5kaW5nID8gYXJyMlsxXSA6IGFycjFbMV07XG4gICAgICAgIHkgPSBkZXNjZW5kaW5nID8gYXJyMVsxXSA6IGFycjJbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGFyYXRvcih4LCB5KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGFzY2VuZGluZ051bWJlcnMoeCwgeSkge1xuICAgIHJldHVybiB4IC0geTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRlc2NlbmRpbmdOdW1iZXJzKHgsIHkpIHtcbiAgICByZXR1cm4geSAtIHg7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHhcbiAqIEBwYXJhbSB5XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBhc2NlbmRpbmdBbGxPdGhlcnMoeCwgeSkge1xuICAgIHJldHVybiB4IDwgeSA/IC0xIDogMTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRlc2NlbmRpbmdBbGxPdGhlcnMoeCwgeSkge1xuICAgIHJldHVybiB5IDwgeCA/IC0xIDogMTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0gdHlwZU9mRGF0YVxuICogQHJldHVybnMge2Z1bmN0aW9uKHRoaXM6YXNjZW5kaW5nKX1cbiAqL1xuZnVuY3Rpb24gYXNjZW5kaW5nKHR5cGVPZkRhdGEpIHtcbiAgICByZXR1cm4gc3RhYmlsaXplLmJpbmQodGhpcywgdHlwZU9mRGF0YSA9PT0gJ251bWJlcicgPyBhc2NlbmRpbmdOdW1iZXJzIDogYXNjZW5kaW5nQWxsT3RoZXJzLCBmYWxzZSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHR5cGVPZkRhdGFcbiAqIEByZXR1cm5zIHtmdW5jdGlvbih0aGlzOmRlc2NlbmRpbmcpfVxuICovXG5mdW5jdGlvbiBkZXNjZW5kaW5nKHR5cGVPZkRhdGEpIHtcbiAgICByZXR1cm4gc3RhYmlsaXplLmJpbmQodGhpcywgdHlwZU9mRGF0YSA9PT0gJ251bWJlcicgPyBkZXNjZW5kaW5nTnVtYmVycyA6IGRlc2NlbmRpbmdBbGxPdGhlcnMsIHRydWUpO1xufVxuXG4vKipcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRWYWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtkaXJlY3Rpb249MV1cbiAqL1xuZnVuY3Rpb24gc29ydChpbmRleCwgZ2V0VmFsdWUsIGRpcmVjdGlvbikge1xuXG4gICAgdmFyIGNvbXBhcmUsIGk7XG5cbiAgICAvLyBhcHBseSBkZWZhdWx0c1xuICAgIGlmIChkaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXJlY3Rpb24gPSAxO1xuICAgIH1cblxuICAgIGlmIChpbmRleC5sZW5ndGgpIHsgLy8gc29tZXRoaW5nIHRvIGRvXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBiYWlsOiBub3RoaW5nIHRvIHNvcnRcblxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNvbXBhcmUgPSBhc2NlbmRpbmcodHlwZW9mIGdldFZhbHVlKDApKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICBjb21wYXJlID0gZGVzY2VuZGluZyh0eXBlb2YgZ2V0VmFsdWUoMCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBzb3J0Li4uLi5cbiAgICAgICAgdmFyIHRtcCA9IG5ldyBBcnJheShpbmRleC5sZW5ndGgpO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgaW5kZXggZm9yIFwic3RhYmlsaXR5XCJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0bXBbaV0gPSBbZ2V0VmFsdWUoaSksIGldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gdGhlIGFjdHVhbCBzb3J0XG4gICAgICAgIHRtcC5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIC8vIGNvcHkgdGhlIHNvcnRlZCB2YWx1ZXMgaW50byBvdXIgaW5kZXggdmVjdG9yXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5kZXhbaV0gPSB0bXBbaV1bMV07XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0cy5zb3J0ID0gc29ydDtcbiJdfQ==
