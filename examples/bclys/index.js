(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = { // This file generated by gulp-imagine-64 at 10:07:23 AM on 12/2/2015
	"1-abs-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAFFJREFUKFNjQAL/oTTD////CWJkgFMjEAgD8Q4gLkMSgwOsGoGgDCQExcRrRFJImo1ICqmnEUSiYJgkMgYCrDYia8TQBFVIJ6cCAXJ0QDGDDQD67OYX9wdp0wAAAABJRU5ErkJggg=="
	},
	"1-abs-up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAExJREFUKFPtjYEJACAIBN2hdZqr2dqu3tB8C5qghzPxlAQZJ4iWJ9E8DpACOmh7ZkLLwoWDNPJxSMONSwa5fzSBJy8z/9B6RpfVZaRO2oo/zJVRDvIAAAAASUVORK5CYII="
	},
	"1-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGtJREFUKFOtjoEJgDAQA6uiC7iOc3U2t3sT6Uu+XxDBwFliEtoisnYWM3vFtQG6mWZQ2sEJqvy7tQC6FUzdqLaMpCH1OB1KcXgjBZ8HDhSHEuCIZeW/IcRvwEMFyjey7HjQA317KsvMIuW4AFTUEgvs+3wkAAAAAElFTkSuQmCC"
	},
	"1-up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAFBJREFUKFPtjdsNQCEIQ93BdZzL2dwOjw9CuV93AEmOJbYNxcw2DHL2P5wHcdR0mAoDuvxFyXHzBrp4UZQAEoUvTL4oBpLDyiveXVnh5WVKm6iPR8RbHxLhAAAAAElFTkSuQmCC"
	},
	"2-abs-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAH5JREFUKFOVkAsNgDAMROcBBxjAAEJwgAMcYGGmsIAGLJS7piE3FjJ2yRvpxus+SWLxTWbWRFOJyAgyuDgNDjD9EWewAzZgvElTVCJshLJfXED3jjwu77pG7UKBCvHTAPgwWeY8Kn5KLN4i81SyyOOdgHfzqMixQBb9FWvSdgNN871AHwblVAAAAABJRU5ErkJggg=="
	},
	"2-abs-up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAJVJREFUKFN9kAEVgzAMRPEwBzOAgQnBwRzgYBZqCgtowAL7l6VtILB77zc01yttB7SfQRr+0j8uAugJBTb5sMBoni/QYNSQ91/wAW0g2Sbu9VAlhisubcSUeTCscYdrgt8fg0HJgQrScXXXt82DQckBgR6ghymtF0zKMSBQC2nS+mEBJYV0vBV0N1PzwiJKCtorZob5Cy2RFvXFQAKlAAAAAElFTkSuQmCC"
	},
	"2-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAJtJREFUKFOFkAsNAjEQRAsXMIADDJwBhOAABzjAwpnCAhqwUN4s2zJQCJO8bGa3018x1ayl1vqXpi3IrWVsuIcF7mrDFWYPTiC3gZUFD3ABbSDFJh6UumtBJ6WNsB/BtugbqSM8T7QBZQw0kK6rt57C24AyBgTagT5msV687Y02zAU9JNP7OfwV0vVuoLeF+swWUV6h7MUvjpTzA6fM6SVV2CbgAAAAAElFTkSuQmCC"
	},
	"2-up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAIxJREFUKFOVkFsRgDAMBOsBBxjAAEJwgAMcYAFTWEADFspe+iDQH8jMcrSX6yvEGA0KSf9fSB+k8DBD6GGDUx7sMGTvDhVccIQVtIDKFjHPNSH3bm9yaSGG/4MT/N5Rx9VdZxs7A2kDgupAD7PVOWciz4CgakiDOu8akCak4x2gu1lVzzUhTdBesSUsF/uHHu110bZRAAAAAElFTkSuQmCC"
	},
	"3-abs-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAJVJREFUKFONkQENhDAMRecBB2cAAyhAwTnAAQ6wgAa8nIXTcBbGf6NduiyEe8ljadlfOkiBbGvKOT8a6YLiJXf5oy2/8v1PcJKb5ABYJS+8LnTBqMFBFGOpjKfgIBl7t7pyGxQ+InecPcizMYZ8kzFLGnXUGLwLOTS5a6XuCqFFMib3A2p+Tfmq7GgMQU4+vC8/Vy+lEzGdowwHiWM2AAAAAElFTkSuQmCC"
	},
	"3-abs-up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAJtJREFUKFOFkQERwjAMResBBzOAgSmYAhzgAAdYmAa8YAENWID3SgM5soN/95om6e+lW0OPb5DLTz6bDQOaYIW7fbjBoffGAZdOmEZ9hjN4gTqBjZ6/TUE2B0NeZLLPDUI1BGgHjr32PDUI1SAoRvSNS6+lJqGaJGkBC/9H3ZDFOR8gFNMRHNP3KXN/zZQPEYrRr3ixN7i+aq09ARE7/LLO8L26AAAAAElFTkSuQmCC"
	},
	"3-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAKdJREFUKFN1kQERwjAMRQscGMDBDGBgCqYABzjAARamAS9YQAMWyn8hodlt/Xfv0p80uXQrSdXjX7XWLqGTwO3NNQ1iFh9B/S2uufEgcEexI+EaxUMwAN0F98Kb2hjXxmoMwlzMuVRfviMjnQVrz+ZTQWHdAFKsyBsny6WiwroJkiZBwlblsKDTFCI5RrHXdBOsyfsQnl8z5EsKrclzfMUnNef1y5XyBYgdtwl+Lm+LAAAAAElFTkSuQmCC"
	},
	"3-up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAJpJREFUKFONkQsRwjAQBeMBBzWAgSqoAhzgAAdYqAa8YAENWAi7+cAx6UDfzPaae32ZS5pyzgVEqe97qA9K58tMaYIVnnrwgFPzPqFOCM5wBTdQF9CY4u7vwBZNbuTiGA3KGOigAzj2WtbBoIwBQX1Ez7iUXjApY0iCFrDxf9QN2ZzjB5QhdAbH9HzKtb/m960ib/Gm17jXXkov3zEEuQ7h10oAAAAASUVORK5CYII="
	},
	"add-column": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAPVJREFUOE9jUKtncAbi/0RgZwZsACQBUlDwOhwrJtqA3OehyIrBGE0MvwFZj4OwYqjmc9rN7Ft1mtknQ9WLQLUjDEi/749sGxiDxLSb2N6giwMNOwOkIYYAGTjDQLOR5RNME0wMxgcafAxIi+AMA3Q+ugFQ7Iw3DEDiMI3oGMMA9DCA8bFpBmGoOoQBybd8MDBUEYpByGJAjDAg/poniiSIDwzErzA+ugHazWwngDQiEGMuuWHFWk2sH2CaYBiYHs4BadRojDjrjKIITew8UNNO3RbOWUB2LRBjJqTQkw5YMUgOivEn5aCjtlgx0QYQgbEYwMAAAEqqlSGCjw+bAAAAAElFTkSuQmCC"
	},
	"back": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAD8GlDQ1BJQ0MgUHJvZmlsZQAAOI2NVd1v21QUP4lvXKQWP6Cxjg4Vi69VU1u5GxqtxgZJk6XpQhq5zdgqpMl1bhpT1za2021Vn/YCbwz4A4CyBx6QeEIaDMT2su0BtElTQRXVJKQ9dNpAaJP2gqpwrq9Tu13GuJGvfznndz7v0TVAx1ea45hJGWDe8l01n5GPn5iWO1YhCc9BJ/RAp6Z7TrpcLgIuxoVH1sNfIcHeNwfa6/9zdVappwMknkJsVz19HvFpgJSpO64PIN5G+fAp30Hc8TziHS4miFhheJbjLMMzHB8POFPqKGKWi6TXtSriJcT9MzH5bAzzHIK1I08t6hq6zHpRdu2aYdJYuk9Q/881bzZa8Xrx6fLmJo/iu4/VXnfH1BB/rmu5ScQvI77m+BkmfxXxvcZcJY14L0DymZp7pML5yTcW61PvIN6JuGr4halQvmjNlCa4bXJ5zj6qhpxrujeKPYMXEd+q00KR5yNAlWZzrF+Ie+uNsdC/MO4tTOZafhbroyXuR3Df08bLiHsQf+ja6gTPWVimZl7l/oUrjl8OcxDWLbNU5D6JRL2gxkDu16fGuC054OMhclsyXTOOFEL+kmMGs4i5kfNuQ62EnBuam8tzP+Q+tSqhz9SuqpZlvR1EfBiOJTSgYMMM7jpYsAEyqJCHDL4dcFFTAwNMlFDUUpQYiadhDmXteeWAw3HEmA2s15k1RmnP4RHuhBybdBOF7MfnICmSQ2SYjIBM3iRvkcMki9IRcnDTthyLz2Ld2fTzPjTQK+Mdg8y5nkZfFO+se9LQr3/09xZr+5GcaSufeAfAww60mAPx+q8u/bAr8rFCLrx7s+vqEkw8qb+p26n11Aruq6m1iJH6PbWGv1VIY25mkNE8PkaQhxfLIF7DZXx80HD/A3l2jLclYs061xNpWCfoB6WHJTjbH0mV35Q/lRXlC+W8cndbl9t2SfhU+Fb4UfhO+F74GWThknBZ+Em4InwjXIyd1ePnY/Psg3pb1TJNu15TMKWMtFt6ScpKL0ivSMXIn9QtDUlj0h7U7N48t3i8eC0GnMC91dX2sTivgloDTgUVeEGHLTizbf5Da9JLhkhh29QOs1luMcScmBXTIIt7xRFxSBxnuJWfuAd1I7jntkyd/pgKaIwVr3MgmDo2q8x6IdB5QH162mcX7ajtnHGN2bov71OU1+U0fqqoXLD0wX5ZM005UHmySz3qLtDqILDvIL+iH6jB9y2x83ok898GOPQX3lk3Itl0A+BrD6D7tUjWh3fis58BXDigN9yF8M5PJH4B8Gr79/F/XRm8m241mw/wvur4BGDj42bzn+Vmc+NL9L8GcMn8F1kAcXgSteGGAAABUUlEQVQ4EWNgGLQgZY12e9oa/S/YHIgsx4JNQdwirXaG/4zljEyMjOjy6HJM6ArCJmr0CQjyVBgr2DH++fMXRRqbHIoLfOpU5nELMyfKCasy/Pv/h+H3d4QBuOTgLnDIkl/CI8aSqCCtyPDmywuGb78+Mfz6+g/sAnxyYBdYREs/4pNklRVX4Gd49u4Jw////xk4WTkZfn35x4BPDmQ62AW/f/y/+Pvbf4YfP38y/Prxh+HX9z8MX359ZvgJdAE+ObgBZ98+C3xx7dva+8c/MTCzMTL8+/ef4fvPbww/P/1hwCcHN4DhAMOf8xufh7y8/m3Vw2NfGFjYmRi+//gBDMT/DHjlgCagxMLFrS/C9f5I/Pz393+srCk3PBBBNuGSQzEApPDSzhdxmn8k/v37yxD/+wckFkDiIIBPDqICidR0EJ2t7y0J9AMmwCeHqZrWIgAZ4PYDxftGYgAAAABJRU5ErkJggg=="
	},
	"checked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAYJJREFUOE+NkstLglEQxf0fahG0iFrUxm2ElFDYLohCqCDaCAkWPaxIRbFFEJEaGEKLDCoMETRFUAMLyaIHBUG6sSKIMtKFqEhLT818ZUgmDhzu3DPn9z0uV1RrmUwmyGQyqNVqfFvViwBxu5RFPZuLSyGMKhz/qlEsRV19K8xm6y+w7bpBPFnAferjj3bdQX6DpHcAUwavAHUN2RGIZxBJZHH2mC/TUeydwwTZvBegLENNgw7sX6Wh1FswNmPEmjPCDyGRRwCtW9E3tMgdAtQw7GZjYcNX+gza2wJ3ZXsSZUuQ0vWCOV8SHfJJ/uluhbHUj1v8PKNMszIoQNRMHCShD6Wh8zyhrbOPwz8w+STKlCCJ7oRNUzQH63kBs5thBghePXxlj2aUoSxDPcuXPNiLAc5EEZ6HIkbmV2DYiXBPHs0o079+K0DTVj/s11mE00A0L+g4VcDp10qKZMAzytBhMaTRaPmYg885DlcSzSij0eoEiIouoUqlqqqaL2rlEok+Ad4vlfzPoVDsAAAAAElFTkSuQmCC"
	},
	"collapse": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAPNJREFUOE9jcIoq/Y+MGXCACUc6/4MwlIsAyJrwGaA3UeE/CEO5CECMAYEL3f4HHLCG4AWuqGpAmpAxVBgOQM42X6L2v+B1OBiD2H0H27FahAFAmjUnSP1Pv+//P/d5KBin3fP/r94vgREecA6ya/Q7lf+HnrD/n/U4CAWDxKym6mJ3BcwbhZsz/iu0C8ExyBUgjCxWsDEdbgiMgRIOMDZIcfItHzAGscGSuADM+TAMEgNpir/mCca4DMBrKkhTzCU3MCbbBRFnncGYkAvgmkAA2YDQkw5gTJQLoEwUA4KO2oIxUQYgY5AYSBMyBiscJICBAQCpROGZ6kqHfwAAAABJRU5ErkJggg=="
	},
	"down-arrow": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAUAAAAKCAYAAAB8OZQwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAA+SURBVBhXhYvRCgAgCAOtqP//4+WWhtBDB1duqBUQ/2W5LLtSMFyW020skuecwOGj6QzfkuExt1LlcqICgG3S7z/SL/jVpgAAAABJRU5ErkJggg=="
	},
	"down-rectangle": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAECAYAAABcDxXOAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAABpJREFUGFdjgIL/eDAKIKgABggqgAE0BQwMAPTlD/Fpi0JfAAAAAElFTkSuQmCC"
	},
	"down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAD8GlDQ1BJQ0MgUHJvZmlsZQAAOI2NVd1v21QUP4lvXKQWP6Cxjg4Vi69VU1u5GxqtxgZJk6XpQhq5zdgqpMl1bhpT1za2021Vn/YCbwz4A4CyBx6QeEIaDMT2su0BtElTQRXVJKQ9dNpAaJP2gqpwrq9Tu13GuJGvfznndz7v0TVAx1ea45hJGWDe8l01n5GPn5iWO1YhCc9BJ/RAp6Z7TrpcLgIuxoVH1sNfIcHeNwfa6/9zdVappwMknkJsVz19HvFpgJSpO64PIN5G+fAp30Hc8TziHS4miFhheJbjLMMzHB8POFPqKGKWi6TXtSriJcT9MzH5bAzzHIK1I08t6hq6zHpRdu2aYdJYuk9Q/881bzZa8Xrx6fLmJo/iu4/VXnfH1BB/rmu5ScQvI77m+BkmfxXxvcZcJY14L0DymZp7pML5yTcW61PvIN6JuGr4halQvmjNlCa4bXJ5zj6qhpxrujeKPYMXEd+q00KR5yNAlWZzrF+Ie+uNsdC/MO4tTOZafhbroyXuR3Df08bLiHsQf+ja6gTPWVimZl7l/oUrjl8OcxDWLbNU5D6JRL2gxkDu16fGuC054OMhclsyXTOOFEL+kmMGs4i5kfNuQ62EnBuam8tzP+Q+tSqhz9SuqpZlvR1EfBiOJTSgYMMM7jpYsAEyqJCHDL4dcFFTAwNMlFDUUpQYiadhDmXteeWAw3HEmA2s15k1RmnP4RHuhBybdBOF7MfnICmSQ2SYjIBM3iRvkcMki9IRcnDTthyLz2Ld2fTzPjTQK+Mdg8y5nkZfFO+se9LQr3/09xZr+5GcaSufeAfAww60mAPx+q8u/bAr8rFCLrx7s+vqEkw8qb+p26n11Aruq6m1iJH6PbWGv1VIY25mkNE8PkaQhxfLIF7DZXx80HD/A3l2jLclYs061xNpWCfoB6WHJTjbH0mV35Q/lRXlC+W8cndbl9t2SfhU+Fb4UfhO+F74GWThknBZ+Em4InwjXIyd1ePnY/Psg3pb1TJNu15TMKWMtFt6ScpKL0ivSMXIn9QtDUlj0h7U7N48t3i8eC0GnMC91dX2sTivgloDTgUVeEGHLTizbf5Da9JLhkhh29QOs1luMcScmBXTIIt7xRFxSBxnuJWfuAd1I7jntkyd/pgKaIwVr3MgmDo2q8x6IdB5QH162mcX7ajtnHGN2bov71OU1+U0fqqoXLD0wX5ZM005UHmySz3qLtDqILDvIL+iH6jB9y2x83ok898GOPQX3lk3Itl0A+BrD6D7tUjWh3fis58BXDigN9yF8M5PJH4B8Gr79/F/XRm8m241mw/wvur4BGDj42bzn+Vmc+NL9L8GcMn8F1kAcXgSteGGAAABV0lEQVQ4EWNgGGjAiM0BItl8/7mFGBh+fWdg+A/EMPBi6icM9SwwSWRa1oyHITbKjuHem9sQ4a8MDHtXPmB4gawIysZqwK/v/xk4v3Iw/ABqBAEOIP71A8zEIJgwRIACbJyMDJxcIG2EAVYXQLRxgm0Gs7nZGdhwmIfdAC5WBk5WTgYGoEYQALIYfoNZmATcAIuFxv9ffr/NwArULCbLxnD3z3UGLi52hv/ffjKAIoKHk41BvpXvP8gIQU5ZhgtFV8ExghIthgtV/3fHpTE8YbjLcPfTTYafQMUgA2CAA2jguuX3GK5mPITrgzNgitQWSv2fFlfIcOrPMYYP3z7AhBlAnlm5/AbDrYznKHowYuFW/DPGrEX9DGYszgwCQBtBGkH0yg03MTTDTcfG0N0i9f/o/yn/F/xP+K++Wgrsd2zq8Io5nND57w7EeBURkqy5UEmZAYQsAADbOWDTAxBmkQAAAABJRU5ErkJggg=="
	},
	"empty": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAANSURBVBhXY/j//z8DAAj8Av6IXwbgAAAAAElFTkSuQmCC"
	},
	"expand": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAQ9JREFUOE9jcIoq/Y+MgYCBFAw2AMahmQEK7UL/kTGyHFFeAGkKOmoLxhgGIHNwYZCm0JMOYIzVACCAC2JzEUhTxFlnMCboAmRvIBsQc8kNjPG6AETjMiD+micYE+UCZAwSA2lKvuUDxnhdgIwLNqWDFcNw+n1/MEYWK9iYjqoJhGE2O8QU/FdplPsfesL+f9bjIBQMErOaqgtUjuYCEA1zNghbpyT815wgBbY570Xo/9znof/T7vn/V++X+N93sB2iB6YYhpENALFBCs2XqP0veB0OxiA2TDMIo2gGYZgXYBgkFrjQ7X/AAWsIXuAKFoNhFM34sN5Ehf8g/Pj9QyAXIY6iCB8GORvZ6RD8nwEA/ZSbmLCRhEoAAAAASUVORK5CYII="
	},
	"filter-off": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAChSURBVChTzZHBCoUgFET9TqEiskgyWoutQvRLRIr+cR7XQAjiJW/1BgZmMUevXsY5xy9OoDEGMcYiUzeB67qibVuwQjVNA6311V+WBeM4vsLDMEApde/1fY9pmtI453neHEKAlBJd1z0fXtc16PbjODK07zvmeUZVVd8nooc75zJIOX3Gm6i0bVsGKf8xKIRIuyJTLgJJ3nvQzsjW2geIsQ/pr9hMVrSncAAAAABJRU5ErkJggg=="
	},
	"filter-on": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAACoSURBVChTY3BqfP2fHAzWmDbj7f8p294RhVOBasEa02e+/e/VBmQQCTxaX/9PnvYGoj5ywpv/Qd2ENft3vv4f1gfVBAP+nW/+h/a+ATtn1q73KHjytvdgg3070DTBgHvL6/8g22fsQGiaDmSHA21xaybgIpDHixa8hWssnA8NDEIApCh3LkIjiD2INYJCL2X6W3B8gdhEaQQBUOCA4gyE8+e9xaKJgQEA/74BNE3cElkAAAAASUVORK5CYII="
	},
	"forth": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAB3RJTUUH1wkbCxU7wwzUCQAAAAlwSFlzAAAewQAAHsEBw2lUUwAAAARnQU1BAACxjwv8YQUAAACcUExURQAAADhUH3CvOHa3O2igNDZRHl2OLzhUHztYIFF7Kj5dIUBgIkNlJEhtJXi4Pna2Oz1cIUNlJEhtJk94KVF8KlN/K1SBK1WCLFaELVqJLlyOL1+SMGOYMmmiNGmjNG+sN2+tN3GvOHKwOHKxOXOzOXS0OnS1OnW2O3e3PXi4Pn28RH+9RoC+R4bCUInDVJHHXpvMa5zNbqTReabSfVhfgkQAAAAQdFJOUwAEh4eOm56goqSprLPi9P64yPeoAAAAZklEQVQY043FRwKCMAAAwUVAqVYUpAjYY6P9/29eAuSmcxn4ba6rAWIxUQIu3dMYA/K2OU6HgEP9qTK7D0iru3glvgyI3+VJ7D0ZsHsUt8jVZMDmeg6dIWBdbq0xYBXMlIClqfaHL3HSC6GZKibEAAAAAElFTkSuQmCC"
	},
	"pause": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB3klEQVQ4jX2Tz0sbURzE3wY8xH+j3i1evBSrUhpRQUwURfxZIirEEiF4k1iqYC/VFjwI4smYlBaClqIHqTFojKmmZq2godgWvejBQgV/RqZvNuERYtYHA8PM7Of0XSH4LFIeKZ/UXEb0rx7IC0XWK5XyC6vm14KWgHZlyG8JSlnlRzm5ls5rswFlBr3bFq7Ez9QW/qR+oCZsAzOqJlwlsz3ZbYMbI7fnAvxiyK33IHm3gV93OxjU3ZCZl6L/LTN2br2X+ZBwZAOepgEv9W7s3YaQTEXh0fvTgIDw0idTm7JbBTcGoCEPwJXoQvx6EbvXXzGQ6FMA+t2bFaNzJV6YA3q/t2H94iNilwvo33EqAH3s8jMiF5/AjSnAGW/G8r8ZhM5n0RdvVwD60LnP6LgxBXRu2TF/No4vfyfh3G5WAHpm82cT4MYU0Bqrhe/Ei8DJCDq+1SsA/YfTUdkNgxtTQFP0OaaO3Jg+9qAlWq0A9MzYcXMfkLkDR6Qcbw87MXHoRGPkmboDembsHJGKPHeQAdStPcHrAztGDxpRv1amAPTM2HGTHyDPs3jpEcb22/Bmvx2Pl4rUKdMzY8fN/VMuMQBWSQ5qAXFF0fMHM81tIud1SL2Tep8RveuBvCD92X9NeXkWOHF72gAAAABJRU5ErkJggg=="
	},
	"play": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAANjr9RwUqgAAACBjSFJNAACHDwAAjA0AAPmTAACE5QAAe4IAAOt1AAA/tAAAIlh1a16cAAAD8GlDQ1BJQ0MgUHJvZmlsZQAASMeNVd1v21QUP4lvXKQWP6Cxjg4Vi69VU1u5GxqtxgZJk6XpQhq5zdgqpMl1bhpT1za2021Vn/YCbwz4A4CyBx6QeEIaDMT2su0BtElTQRXVJKQ9dNpAaJP2gqpwrq9Tu13GuJGvfznndz7v0TVAx1ea45hJGWDe8l01n5GPn5iWO1YhCc9BJ/RAp6Z7TrpcLgIuxoVH1sNfIcHeNwfa6/9zdVappwMknkJsVz19HvFpgJSpO64PIN5G+fAp30Hc8TziHS4miFhheJbjLMMzHB8POFPqKGKWi6TXtSriJcT9MzH5bAzzHIK1I08t6hq6zHpRdu2aYdJYuk9Q/881bzZa8Xrx6fLmJo/iu4/VXnfH1BB/rmu5ScQvI77m+BkmfxXxvcZcJY14L0DymZp7pML5yTcW61PvIN6JuGr4halQvmjNlCa4bXJ5zj6qhpxrujeKPYMXEd+q00KR5yNAlWZzrF+Ie+uNsdC/MO4tTOZafhbroyXuR3Df08bLiHsQf+ja6gTPWVimZl7l/oUrjl8OcxDWLbNU5D6JRL2gxkDu16fGuC054OMhclsyXTOOFEL+kmMGs4i5kfNuQ62EnBuam8tzP+Q+tSqhz9SuqpZlvR1EfBiOJTSgYMMM7jpYsAEyqJCHDL4dcFFTAwNMlFDUUpQYiadhDmXteeWAw3HEmA2s15k1RmnP4RHuhBybdBOF7MfnICmSQ2SYjIBM3iRvkcMki9IRcnDTthyLz2Ld2fTzPjTQK+Mdg8y5nkZfFO+se9LQr3/09xZr+5GcaSufeAfAww60mAPx+q8u/bAr8rFCLrx7s+vqEkw8qb+p26n11Aruq6m1iJH6PbWGv1VIY25mkNE8PkaQhxfLIF7DZXx80HD/A3l2jLclYs061xNpWCfoB6WHJTjbH0mV35Q/lRXlC+W8cndbl9t2SfhU+Fb4UfhO+F74GWThknBZ+Em4InwjXIyd1ePnY/Psg3pb1TJNu15TMKWMtFt6ScpKL0ivSMXIn9QtDUlj0h7U7N48t3i8eC0GnMC91dX2sTivgloDTgUVeEGHLTizbf5Da9JLhkhh29QOs1luMcScmBXTIIt7xRFxSBxnuJWfuAd1I7jntkyd/pgKaIwVr3MgmDo2q8x6IdB5QH162mcX7ajtnHGN2bov71OU1+U0fqqoXLD0wX5ZM005UHmySz3qLtDqILDvIL+iH6jB9y2x83ok898GOPQX3lk3Itl0A+BrD6D7tUjWh3fis58BXDigN9yF8M5PJH4B8Gr79/F/XRm8m241mw/wvur4BGDj42bzn+Vmc+NL9L8GcMn8F1kAcXhLu7iPAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGHRFWHRTb2Z0d2FyZQBwYWludC5uZXQgNC4wLjVlhTJlAAABPElEQVQ4T2MAgaoTYuJgBrmg+rhcXupCmf9Fe2TDoUKkgYpDChkgA+pOKf4v2il3qWC3pCZUijhQBjUg6Kjt/9CTDv+rDiv8z9skuzRhPgMHVAl+ULwX1YCIs87/Yy65/S/erfA/Z71MGVQZblC4SxarAfHXPP8n3/IBukbudfY6KVeockxQuBm/Aen3/f9nPQ76n7VK+nDGKmFpqDYEyNlInAG5z0P/F7wO/5+5VHomSvjkrJQmyYDURdJbY3eKc0O1MzCkLyfOgKT50rdSl0obQLUhANBEvAakLJD+mTRbIg6qHBMATcZqQMoimf+x0yX7oMpwg4RZkigGgNgxkyX3J0wVlYAqwQ8SZkAMSFsi8z96otSz2EkS9lAp4kDcNKncuKlS/8N7JPOhQqSB6ElCMm4lSNFCNGBgAAAY+v7rj5j+SgAAAABJRU5ErkJggg=="
	},
	"rectangle-spacer": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAECAYAAABcDxXOAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAA1JREFUGFdjGHSAgQEAAJQAAY8LvLEAAAAASUVORK5CYII="
	},
	"reset": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAL8SURBVDhPbZLZTxNRFMbnDzD65BsurC2tSFlENiG4EARBguzIGkBDwKAsIqA+EAIE45JgogaCxrdqgiQmxhAVjWIEpEioChRKUGmZTpeZaSlQ6OedoVYxnOSXe893vnPvzcml/o+V4WGJrbOmgm+tVLJN+UqeYL1Zp+TbLpy1qz7ud9m2D+u9tjq+qYTmLmbZuUvZIOsmNTnCauOvlWuX77dHuux/wzQ6sIvrbOziKrPBlqa64ZsrwF8u26Jxl4pg7WppxuSbHa52iuJry9rZgtOwZCdsUpgKC8nXtRqsDQ2SxgxY8pPddZbU2drSarHZdqsjxXTqqNl8MhYCXEkO1j59AFeeD6fFDMcXFazkQseECmxBuugROZMwtXKrQ0KxRdl95mPRMMdFgi3KxYZuEWtjn2FJT4HTTA4YHwN7rgTr8/PkkHFYUhNFrzkhjryssIgyRkWOmYKDYAoLxUr/MziNRmI6DUFzmkxwjI6Ie0tWJpwMA+5KA0whwaJmSkrqpgwSuZqRyGAMjyY3q2BXPgEjkRNkZAZarL56Le4FbfXlAGw9vTAGKETNKA1QUkxolJX28IEhOAJr4xOwPeiBkAswMSfAhMe6c/vTPtgePgbtLRdzY0o6Tem85WrdHl/opYFYffeevGIc+n1+ELR/ETTHt+/gWjug85SKGq0IU1K/5CFvf+71gwDXcQNO+wrMDVfF/F+4ztvYIPMxZOS6taX45BZKn5Z1d8HLf32BCAv+Clifv8A6TYO9cxd0TiEMBaWwkadvsBzY7l4s+MgheH/Igux0Wk4ixdTXe8wdDBvS7JdCYE4WDH1tA5aHR+AwMHDo9eDJ8HTnqzArVYgeAW1QhJKpur5T/EyWnkfHZ8mwpkhBYNpLhpkDIdAoDovMyIIw5envrs8eIcN90BsuNv+JxZor6dOHorWTPnKnmgxpO776HnBoYuJVS7e7ol1tW2O++JxsNiOvcTIkYlBNbp7w8seEtwzfImKhDjzUr8nMq14srtrtspOgqN9wa0YvcwzUuQAAAABJRU5ErkJggg=="
	},
	"sortable": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAAxSURBVChTY8AD/kNpkgBIEwwTDZA1Ea0ZmyYYHmQAmxNhmCAgSxMMkKUJBvBoYmAAAJCXH+FU1T8+AAAAAElFTkSuQmCC"
	},
	"swap": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAI9SURBVDjLpZNBS9RhEMZ/u60aZAdNSXdLrcxNS82DaRQVRBCUGngwwkOnvkB0yEt0qy/QKSrq5DUSQgLTSi01d80gcrXSTTdTViTU//+ded8ORihFYD4wl+FhYOY3T8A5x2YU3Ij54qOmp833zmX+14CWh431vm9OGs+8W9sPXOm49HsHqxarFhXbZ9W2EQxeECNnxUh0W2Y2kdwIcwtzJCbHY8+uvagBCAG0Vl3G4XDOYZ1jbPbj0ffJ0S6xQrT4AFszsxC1qFPycvJYXl45fOxG7ctXNweOB51zWBzW2V+l7MnbS21JLemFNBmhDIwIxhqMGowKxgjGNxkAISuWB2/uoqIE7Rb255dxMHKInO07CLkMxpMTpOZnmE7NEN4ZQUVITIyPDNyK1wEE1mJsud+QLUavl4cr2o5E64glhumJ9ag629TV1ttRd7VGNWQ/Dd6Ol/6VgguCDTjiYzGWvCWiReX4Pwxe2gPAX/Lx5rx1dAKt7c1OjCBGcOIoyC1kMb1IWTjKvqJSJqbGGR6Nk0gkOBitQMQyNDg0kmj/XA0QMr7hRPkp1ClqBbHKXNY88Q9xineVEC6IUFgQwZ62qFUsFm/Fq9p9Pvx66sl0XdD46y8sKiwuLZL6/o3nvd3Mp+cRJ4gVxCliFRFFjBqAQMOdM06MYHxB/FVEYqRPPG3z0/7qI/kazc/Pp7K6kuSXJEP9b2MznbM1f1D4l4oaI/Uq2qViJ1Ods9ENZ2Hy8dd+NdqtRivXUdhsnH8Cn6RstCM01H4AAAAASUVORK5CYII="
	},
	"unchecked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAARBJREFUOE+9krtug1AQRPldSio7FQ1tZImOkoKOBomGT0EURC5ino54yTw90WywQhTkIkVWGoF2zuxdrlD+t0zThKZpT0Vmxb8CQRCg6zr0fb8rer7vfwcPxxdcrx+YpgnzPGNZlh9ibxxHlGUJshLSdV0at9tNpg7DIBrX5+OkPM9BVkKGYSBJEtR1jbZrBdiqbVtUVYU0TUFWQq+nE+I4xvvlImGaW7FHjwxZCVmWhbfzGVmWoSgKWXUr9uiRISshx3FkEldomubXauzRI0NWQp7nyUR+NG/rfr/jUXxnjx5vmKyEbNuWox9Xvid6ZMhK6HA4wnVdhGGIKIp2RY8MWQmx+JuoqvpUZFb8L6UonyYL3uOtrFH+AAAAAElFTkSuQmCC"
	},
	"up-arrow": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAUAAAAKCAYAAAB8OZQwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAA9SURBVBhXbYvRCgAgCAOtqP//Y9tElw8NDrcDzd0DBCd7iSL3E0IvGOpf2fKXeZUFKDcYFMwBlDNWS76bXUM5P9In5AzyAAAAAElFTkSuQmCC"
	},
	"up-down-spin": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGJJREFUOE+lkwEKACEIBH2Zb/PnHsoGeaVJDUjGOgRRpKpkiIj+y4MME3eDR7kaKOVNsJyMNjIHzGy9YnW6J7qIcrriQimeCqORNABd0fpRTkt8uVUj7EsxC6vs/q3e/Q6iD2bwnByjPXHNAAAAAElFTkSuQmCC"
	},
	"up-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGFJREFUOE+lkkEKQCEIRD2ZJ3Ph3iN4WD9GflpYhj0YYowpGgJmbikd3gjMDFokwbuT1iAiurG5nomgqo5QaPo9ERQRI6Jf7sfGjudy2je23+i0Wl2oQ85TOdlfrJQOazF8br+rqTXQKn0AAAAASUVORK5CYII="
	},
	"up-rectangle": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAECAYAAABcDxXOAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABp0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjUuMTFH80I3AAAAHklEQVQYV2PAAv5DaZwApACGsQJkBVgVYlMAxQwMABOrD/GvP+EWAAAAAElFTkSuQmCC"
	},
	"up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAD8GlDQ1BJQ0MgUHJvZmlsZQAAOI2NVd1v21QUP4lvXKQWP6Cxjg4Vi69VU1u5GxqtxgZJk6XpQhq5zdgqpMl1bhpT1za2021Vn/YCbwz4A4CyBx6QeEIaDMT2su0BtElTQRXVJKQ9dNpAaJP2gqpwrq9Tu13GuJGvfznndz7v0TVAx1ea45hJGWDe8l01n5GPn5iWO1YhCc9BJ/RAp6Z7TrpcLgIuxoVH1sNfIcHeNwfa6/9zdVappwMknkJsVz19HvFpgJSpO64PIN5G+fAp30Hc8TziHS4miFhheJbjLMMzHB8POFPqKGKWi6TXtSriJcT9MzH5bAzzHIK1I08t6hq6zHpRdu2aYdJYuk9Q/881bzZa8Xrx6fLmJo/iu4/VXnfH1BB/rmu5ScQvI77m+BkmfxXxvcZcJY14L0DymZp7pML5yTcW61PvIN6JuGr4halQvmjNlCa4bXJ5zj6qhpxrujeKPYMXEd+q00KR5yNAlWZzrF+Ie+uNsdC/MO4tTOZafhbroyXuR3Df08bLiHsQf+ja6gTPWVimZl7l/oUrjl8OcxDWLbNU5D6JRL2gxkDu16fGuC054OMhclsyXTOOFEL+kmMGs4i5kfNuQ62EnBuam8tzP+Q+tSqhz9SuqpZlvR1EfBiOJTSgYMMM7jpYsAEyqJCHDL4dcFFTAwNMlFDUUpQYiadhDmXteeWAw3HEmA2s15k1RmnP4RHuhBybdBOF7MfnICmSQ2SYjIBM3iRvkcMki9IRcnDTthyLz2Ld2fTzPjTQK+Mdg8y5nkZfFO+se9LQr3/09xZr+5GcaSufeAfAww60mAPx+q8u/bAr8rFCLrx7s+vqEkw8qb+p26n11Aruq6m1iJH6PbWGv1VIY25mkNE8PkaQhxfLIF7DZXx80HD/A3l2jLclYs061xNpWCfoB6WHJTjbH0mV35Q/lRXlC+W8cndbl9t2SfhU+Fb4UfhO+F74GWThknBZ+Em4InwjXIyd1ePnY/Psg3pb1TJNu15TMKWMtFt6ScpKL0ivSMXIn9QtDUlj0h7U7N48t3i8eC0GnMC91dX2sTivgloDTgUVeEGHLTizbf5Da9JLhkhh29QOs1luMcScmBXTIIt7xRFxSBxnuJWfuAd1I7jntkyd/pgKaIwVr3MgmDo2q8x6IdB5QH162mcX7ajtnHGN2bov71OU1+U0fqqoXLD0wX5ZM005UHmySz3qLtDqILDvIL+iH6jB9y2x83ok898GOPQX3lk3Itl0A+BrD6D7tUjWh3fis58BXDigN9yF8M5PJH4B8Gr79/F/XRm8m241mw/wvur4BGDj42bzn+Vmc+NL9L8GcMn8F1kAcXgSteGGAAABVUlEQVQ4EWNgoDWouVD5H58dTPgkHU7o/D/9YzM+JbjldLdI/T/6f8r/Bf8T/quvlsLpCkZsRqgtlPo/La6K4dSfLQzfv/1k4ORiZ1iw7BLDrfhnGOoxBCCaC4GajzF8+PYBbj47kLVy+Q2GWxnPUfSghIHhQlWgzYUMTxjuAm2GaP4PdAEI/wDi8EgNBu0Z8ijegZtmsdD4/8vvtxlYuVgZFNWEGOyNdcAuAGn+DrT9yPL7DO+/fwW7SJBTluFC0VWwXhaYG0/En4Ubxr2a57+yuSbD4W8HwNKcQPLL918MD6s/gdU8ZLgK08aA4gW46LffDN9/A+39+hOMQS5ghUuiMrAbAFbzneEHkAZhkEG/wAywBAqB1YBf3/8DAxGHDhTtDAzwMEAWZ+NkZPjO/YOBA+R2EACGHRsHhIlOYjXg8akvDBPvbGP4BTTgP8wQdJ2Dhg8A9SSD4ETIHK4AAAAASUVORK5CYII="
	},
};

},{}],2:[function(require,module,exports){
'use strict';

/* eslint-env browser */

(function (module) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See https://github.com/joneit/mnm.

    /**
     * @summary Insert base stylesheet into DOM
     * @desc Creates a new `<style>...</style>` element from the named text string(s) and inserts it.
     * @param {string|string[]} cssRules
     * @param {string} [ID]
     * @param {string|Element|undefined|null} [referenceElement]
     * * `undefined` type (or omitted): injects stylesheet at top of `<head...</head>` element
     * * `null` value: injects stylesheet at bottom of `<head>...</head>` element
     * * `Element` type: injects stylesheet immediately before given element
     */
    function cssInjector(cssRules, ID, referenceElement) {
        if (ID) {
            ID = cssInjector.idPrefix + ID;

            if (document.getElementById(ID)) {
                return; // stylesheet already in DOM
            }
        }

        if (typeof referenceElement === 'string') {
            referenceElement = document.querySelector(referenceElement);
            if (!referenceElement) {
                throw 'Cannot find reference element for CSS injection.';
            }
        } else if (referenceElement && !(referenceElement instanceof Element)) {
            throw 'Given value not a reference element.';
        }

        var style = document.createElement('style');
        style.type = 'text/css';
        if (ID) {
            style.id = ID;
        }
        if (cssRules instanceof Array) {
            cssRules = cssRules.join('\n');
        }
        cssRules = '\n' + cssRules + '\n';
        if (style.styleSheet) {
            style.styleSheet.cssText = cssRules;
        } else {
            style.appendChild(document.createTextNode(cssRules));
        }

        var container = referenceElement && referenceElement.parentNode || document.head || document.getElementsByTagName('head')[0];

        if (referenceElement === undefined) {
            referenceElement = container.firstChild;
        }

        container.insertBefore(style, referenceElement);
    }

    cssInjector.idPrefix = 'injected-stylesheet-';

    // Interface
    module.exports = cssInjector;
})(
    typeof module === 'object' && module || (window.cssInjector = {}),
    typeof module === 'object' && module.exports || (window.cssInjector.exports = {})
) || (
    typeof module === 'object' || (window.cssInjector = window.cssInjector.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.cssInjector`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `module` object defined, we're in NodeJs so assume there is a `module` object with an `exports` object
 * 2. If `module` object undefined, we're in browser so define a `window.cssInjector` object with an `exports` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will always execute:
 * 1. If `module` object defined, then we're in NodeJs so we're done
 * 2. If `module` object undefined, then we're in browser so redefine`window.cssInjector` as its `exports` object
 */

},{}],3:[function(require,module,exports){
'use strict';

/** @namespace extend-me **/

/** @summary Extends an existing constructor into a new constructor.
 *
 * @returns {ChildConstructor} A new constructor, extended from the given context, possibly with some prototype additions.
 *
 * @desc Extends "objects" (constructors), with optional additional code, optional prototype additions, and optional prototype member aliases.
 *
 * > CAVEAT: Not to be confused with Underscore-style .extend() which is something else entirely. I've used the name "extend" here because other packages (like Backbone.js) use it this way. You are free to call it whatever you want when you "require" it, such as `var inherits = require('extend')`.
 *
 * Provide a constructor as the context and any prototype additions you require in the first argument.
 *
 * For example, if you wish to be able to extend `BaseConstructor` to a new constructor with prototype overrides and/or additions, basic usage is:
 *
 * ```javascript
 * var Base = require('extend-me').Base;
 * var BaseConstructor = Base.extend(basePrototype); // mixes in .extend
 * var ChildConstructor = BaseConstructor.extend(childPrototypeOverridesAndAdditions);
 * var GrandchildConstructor = ChildConstructor.extend(grandchildPrototypeOverridesAndAdditions);
 * ```
 *
 * This function (`extend()`) is added to the new extended object constructor as a property `.extend`, essentially making the object constructor itself easily "extendable." (Note: This is a property of each constructor and not a method of its prototype!)
 *
 * @param {string} [extendedClassName] - This is simply added to the prototype as $$CLASS_NAME. Useful for debugging because all derived constructors appear to have the same name ("Constructor") in the debugger. This property is ignored unless `extend.debug` is explicitly set to a truthy value.
 *
 * @param {extendedPrototypeAdditionsObject} [prototypeAdditions] - Object with members to copy to new constructor's prototype. Most members will be copied to the prototype. Some members, however, have special meanings as explained in the {@link extendedPrototypeAdditionsObject|type definition} (and may or may not be copied to the prototype).
 *
 * @property {boolean} [debug] - See parameter `extendedClassName` _(above)_.
 *
 * @property {object} Base - A convenient base class from which all other classes can be extended.
 *
 * @memberOf extend-me
 */
function extend(extendedClassName, prototypeAdditions) {
    switch (arguments.length) {
        case 0:
            prototypeAdditions = {};
            break;
        case 1:
            prototypeAdditions = extendedClassName;
            if (typeof prototypeAdditions !== 'object') {
                throw 'Single parameter overload must be object.';
            }
            extendedClassName = undefined;
            break;
        case 2:
            if (typeof extendedClassName !== 'string' || typeof prototypeAdditions !== 'object') {
                throw 'Two parameter overload must be string, object.';
            }
            break;
        default:
            throw 'Too many parameters';
    }

    function Constructor() {
        if (prototypeAdditions.preInitialize) {
            prototypeAdditions.preInitialize.apply(this, arguments);
        }

        initializePrototypeChain.apply(this, arguments);

        if (prototypeAdditions.postInitialize) {
            prototypeAdditions.postInitialize.apply(this, arguments);
        }
    }

    Constructor.extend = extend;

    var prototype = Constructor.prototype = Object.create(this.prototype);
    prototype.constructor = Constructor;

    if (extendedClassName && extend.debug) {
        prototype.$$CLASS_NAME = extendedClassName;
    }

    for (var key in prototypeAdditions) {
        if (prototypeAdditions.hasOwnProperty(key)) {
            var value = prototypeAdditions[key];
            switch (key) {
                case 'initializeOwn':
                    // already called above; not needed in prototype
                    break;
                case 'aliases':
                    for (var alias in value) {
                        if (value.hasOwnProperty(alias)) {
                            makeAlias(value[alias], alias);
                        }
                    }
                    break;
                default:
                    if (typeof value === 'string' && value[0] === '#') {
                        makeAlias(value, key.substr(1));
                    } else {
                        prototype[key] = value;
                    }
            }
        }
    }

    return Constructor;

    function makeAlias(value, key) { // eslint-disable-line no-shadow
        prototype[key] = prototypeAdditions[value];
    }
}

extend.Base = function () {};
extend.Base.extend = extend;

/** @typedef {function} extendedConstructor
 * @property prototype.super - A reference to the prototype this constructor was extended from.
 * @property [extend] - If `prototypeAdditions.extendable` was truthy, this will be a reference to {@link extend.extend|extend}.
 */

/** @typedef {object} extendedPrototypeAdditionsObject
 * @property {function} [initialize] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after similar function in all ancestors called with same signature.
 * @property {function} [initializeOwn] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after (all) the `initialize` function(s).
 * @property {object} [aliases] - Hash of aliases for prototype members in form `{ key: 'member', ... }` where `key` is the name of an alieas and `'member'` is the name of an existing member in the prototype. Each such key is added to the prototype as a reference to the named member. (The `aliases` object itself is *not* added to prototype.) Alternatively:
 * @property {string} [keys] - Arbitrary property names defined here with string values starting with a `#` character will alias the actual properties named in the strings (following the `#`). This is an alternative to providing an `aliases` hash, perhaps simpler (though subtler). (Use arbitrary identifiers here; don't use the name `keys`!)
 * @property {*} [arbitraryProperties] - Any additional arbitrary properties defined here will be added to the new constructor's prototype. (Use arbitrary identifiers here; don't use the name `aribitraryProperties`!)
 */

/** @summary Call all `initialize` methods found in prototype chain.
 * @desc This recursive routine is called by the constructor.
 * 1. Walks back the prototype chain to `Object`'s prototype
 * 2. Walks forward to new object, calling any `initialize` methods it finds along the way with the same context and arguments with which the constructor was called.
 * @private
 * @memberOf extend-me
 */
function initializePrototypeChain() {
    var term = this,
        args = arguments;
    recur(term);

    function recur(obj) {
        var proto = Object.getPrototypeOf(obj);
        if (proto.constructor !== Object) {
            recur(proto);
            if (proto.initialize) {
                proto.initialize.apply(term, args);
            }
        }
    }
}

module.exports = extend;

},{}],4:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

var cssInjector = require('css-injector');

/**
 * @constructor FinBar
 * @summary Create a scrollbar object.
 * @desc Creating a scrollbar is a three-step process:
 *
 * 1. Instantiate the scrollbar object by calling this constructor function. Upon instantiation, the DOM element for the scrollbar (with a single child element for the scrollbar "thumb") is created but is not insert it into the DOM.
 * 2. After instantiation, it is the caller's responsibility to insert the scrollbar, {@link FinBar#bar|this.bar}, into the DOM.
 * 3. After insertion, the caller must call {@link FinBar#resize|resize()} at least once to size and position the scrollbar and its thumb. After that, `resize()` should also be called repeatedly on resize events (as the content element is being resized).
 *
 * Suggested configurations:
 * * _**Unbound**_<br/>
 * The scrollbar serves merely as a simple range (slider) control. Omit both `options.onchange` and `options.content`.
 * * _**Bound to virtual content element**_<br/>
 * Virtual content is projected into the element using a custom event handler supplied by the programmer in `options.onchange`. A typical use case would be to handle scrolling of the virtual content. Other use cases include data transformations, graphics transformations, _etc._
 * * _**Bound to real content**_<br/>
 * Set `options.content` to the "real" content element but omit `options.onchange`. This will cause the scrollbar to use the built-in event handler (`this.scrollRealContent`) which implements smooth scrolling of the content element within the container.
 *
 * @param {finbarOptions} [options={}] - Options object. See the type definition for member details.
 */
function FinBar(options) {

    // make bound versions of all the mouse event handler
    var bound = this._bound = {};
    for (key in handlersToBeBound) {
        bound[key] = handlersToBeBound[key].bind(this);
    }

    /**
     * @name thumb
     * @summary The generated scrollbar thumb element.
     * @desc The thumb element's parent element is always the {@link FinBar#bar|bar} element.
     *
     * This property is typically referenced internally only. The size and position of the thumb element is maintained by `_calcThumb()`.
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var thumb = document.createElement('div');
    thumb.classList.add('thumb');
    thumb.onclick = bound.shortStop;
    thumb.onmouseover = bound.onmouseover;
    this.thumb = thumb;

    /**
     * @name bar
     * @summary The generated scrollbar element.
     * @desc The caller inserts this element into the DOM (typically into the content container) and then calls its {@link FinBar#resize|resize()} method.
     *
     * Thus the node tree is typically:
     * * A **content container** element, which contains:
     *    * The content element(s)
     *    * This **scrollbar element**, which in turn contains:
     *        * The **thumb element**
     *
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var bar = document.createElement('div');

    bar.classList.add('finbar-vertical');

    bar.appendChild(thumb);
    if (this.paging) {
        bar.onclick = bound.onclick;
    }
    this.bar = bar;

    options = options || {};

    // presets
    this.orientation = 'vertical';
    this._min = this._index = 0;
    this._max = 100;

    // options
    for (var key in options) {
        if (options.hasOwnProperty(key)) {
            var option = options[key];
            switch (key) {

            case 'index':
                this._index = option;
                break;

            case 'range':
                validRange(option);
                this._min = option.min;
                this._max = option.max;
                this.contentSize = option.max - option.min + 1;
                break;

            default:
                if (
                    key.charAt(0) !== '_' &&
                    typeof FinBar.prototype[key] !== 'function'
                ) {
                    // override prototype defaults for standard ;
                    // extend with additional properties (for use in onchange event handlers)
                    this[key] = option;
                }
                break;

            }
        }
    }

    cssInjector(cssFinBars, 'finbar-base', options.cssStylesheetReferenceElement);
}

FinBar.prototype = {

    /**
     * @summary The scrollbar orientation.
     * @desc Set by the constructor to either `'vertical'` or `'horizontal'`. See the similarly named property in the {@link finbarOptions} object.
     *
     * Useful values are `'vertical'` (the default) or `'horizontal'`.
     *
     * Setting this property resets `this.oh` and `this.deltaProp` and changes the class names so as to reposition the scrollbar as per the CSS rules for the new orientation.
     * @default 'vertical'
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set orientation(orientation) {
        if (orientation === this._orientation) {
            return;
        }

        this._orientation = orientation;

        /**
         * @readonly
         * @name oh
         * @summary <u>O</u>rientation <u>h</u>ash for this scrollbar.
         * @desc Set by the `orientation` setter to either the vertical or the horizontal orientation hash. The property should always be synchronized with `orientation`; do not update directly!
         *
         * This object is used internally to access scrollbars' DOM element properties in a generalized way without needing to constantly query the scrollbar orientation. For example, instead of explicitly coding `this.bar.top` for a vertical scrollbar and `this.bar.left` for a horizontal scrollbar, simply code `this.bar[this.oh.leading]` instead. See the {@link orientationHashType} definition for details.
         *
         * This object is useful externally for coding generalized {@link finbarOnChange} event handler functions that serve both horizontal and vertical scrollbars.
         * @type {orientationHashType}
         * @memberOf FinBar.prototype
         */
        this.oh = orientationHashes[this._orientation];

        if (!this.oh) {
            error('Invalid value for `options._orientation.');
        }

        /**
         * @name deltaProp
         * @summary The name of the `WheelEvent` property this scrollbar should listen to.
         * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
         *
         * Useful values are `'deltaX'`, `'deltaY'`, or `'deltaZ'`. A value of `null` means to ignore mouse wheel events entirely.
         *
         * The mouse wheel is one-dimensional and only emits events with `deltaY` data. This property is provided so that you can override the default of `'deltaX'` with a value of `'deltaY'` on your horizontal scrollbar primarily to accommodate certain "panoramic" interface designs where the mouse wheel should control horizontal rather than vertical scrolling. Just give `{ deltaProp: 'deltaY' }` in your horizontal scrollbar instantiation.
         *
         * Caveat: Note that a 2-finger drag on an Apple trackpad emits events with _both_ `deltaX ` and `deltaY` data so you might want to delay making the above adjustment until you can determine that you are getting Y data only with no X data at all (which is a sure bet you on a mouse wheel rather than a trackpad).

         * @type {object|null}
         * @memberOf FinBar.prototype
         */
        this.deltaProp = this.oh.delta;

        this.bar.className = this.bar.className.replace(/(vertical|horizontal)/g, orientation);

        if (this.bar.style.cssText || this.thumb.style.cssText) {
            this.bar.removeAttribute('style');
            this.thumb.removeAttribute('style');
            this.resize();
        }
    },
    get orientation() {
        return this._orientation;
    },

    /**
     * @summary Callback for scroll events.
     * @desc Set by the constructor via the similarly named property in the {@link finbarOptions} object. After instantiation, `this.onchange` may be updated directly.
     *
     * This event handler is called whenever the value of the scrollbar is changed through user interaction. The typical use case is when the content is scrolled. It is called with the `FinBar` object as its context and the current value of the scrollbar (its index, rounded) as the only parameter.
     *
     * Set this property to `null` to stop emitting such events.
     * @type {function(number)|null}
     * @memberOf FinBar.prototype
     */
    onchange: null,

    /**
     * @summary Add a CSS class name to the bar element's class list.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * The bar element's class list will always include `finbar-vertical` (or `finbar-horizontal` based on the current orientation). Whenever this property is set to some value, first the old prefix+orientation is removed from the bar element's class list; then the new prefix+orientation is added to the bar element's class list. This property causes _an additional_ class name to be added to the bar element's class list. Therefore, this property will only add at most one additional class name to the list.
     *
     * To remove _classname-orientation_ from the bar element's class list, set this property to a falsy value, such as `null`.
     *
     * > NOTE: You only need to specify an additional class name when you need to have mulltiple different styles of scrollbars on the same page. If this is not a requirement, then you don't need to make a new class; you would just create some additional rules using the same selectors in the built-in stylesheet (../css/finbars.css):
     * *`div.finbar-vertical` (or `div.finbar-horizontal`) for the scrollbar
     * *`div.finbar-vertical > div` (or `div.finbar-horizontal > div`) for the "thumb."
     *
     * Of course, your rules should come after the built-ins.
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set classPrefix(prefix) {
        if (this._classPrefix) {
            this.bar.classList.remove(this._classPrefix + this.orientation);
        }

        this._classPrefix = prefix;

        if (prefix) {
            this.bar.classList.add(prefix + '-' + this.orientation);
        }
    },
    get classPrefix() {
        return this._classPrefix;
    },

    /**
     * @name increment
     * @summary Number of scrollbar index units representing a pageful. Used exclusively for paging up and down and for setting thumb size relative to content size.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * Can also be given as a parameter to the {@link FinBar#resize|resize} method, which is pertinent because content area size changes affect the definition of a "pageful." However, you only need to do this if this value is being used. It not used when:
     * * you define `paging.up` and `paging.down`
     * * your scrollbar is using `scrollRealContent`
     * @type {number}
     * @memberOf FinBar.prototype
     */
    increment: 1,

    /**
     * @name barStyles
     * @summary Scrollbar styles to be applied by {@link FinBar#resize|resize()}.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * This is a value to be assigned to {@link FinBar#styles|styles} on each call to {@link FinBar#resize|resize()}. That is, a hash of values to be copied to the scrollbar element's style object on resize; or `null` for none.
     *
     * @see {@link FinBar#style|style}
     * @type {finbarStyles|null}
     * @memberOf FinBar.prototype
     */
    barStyles: null,

    /**
     * @name style
     * @summary Additional scrollbar styles.
     * @desc See type definition for more details. These styles are applied directly to the scrollbar's `bar` element.
     *
     * Values are adjusted as follows before being applied to the element:
     * 1. Included "pseudo-property" names from the scrollbar's orientation hash, {@link FinBar#oh|oh}, are translated to actual property names before being applied.
     * 2. When there are margins, percentages are translated to absolute pixel values because CSS ignores margins in its percentage calculations.
     * 3. If you give a value without a unit (a raw number), "px" unit is appended.
     *
     * General notes:
     * 1. It is always preferable to specify styles via a stylesheet. Only set this property when you need to specifically override (a) stylesheet value(s).
     * 2. Can be set directly or via calls to the {@link FinBar#resize|resize} method.
     * 3. Should only be set after the scrollbar has been inserted into the DOM.
     * 4. Before applying these new values to the element, _all_ in-line style values are reset (by removing the element's `style` attribute), exposing inherited values (from stylesheets).
     * 5. Empty object has no effect.
     * 6. Falsey value in place of object has no effect.
     *
     * > CAVEAT: Do not attempt to treat the object you assign to this property as if it were `this.bar.style`. Specifically, changing this object after assigning it will have no effect on the scrollbar. You must assign it again if you want it to have an effect.
     *
     * @see {@link FinBar#barStyles|barStyles}
     * @type {finbarStyles}
     * @memberOf FinBar.prototype
     */
    set style(styles) {
        var keys = Object.keys(styles = extend({}, styles, this._auxStyles));

        if (keys.length) {
            var bar = this.bar,
                barRect = bar.getBoundingClientRect(),
                container = this.container || bar.parentElement,
                containerRect = container.getBoundingClientRect(),
                oh = this.oh;

            // Before applying new styles, revert all styles to values inherited from stylesheets
            bar.removeAttribute('style');

            keys.forEach(function (key) {
                var val = styles[key];

                if (key in oh) {
                    key = oh[key];
                }

                if (!isNaN(Number(val))) {
                    val = (val || 0) + 'px';
                } else if (/%$/.test(val)) {
                    // When bar size given as percentage of container, if bar has margins, restate size in pixels less margins.
                    // (If left as percentage, CSS's calculation will not exclude margins.)
                    var oriented = axis[key],
                        margins = barRect[oriented.marginLeading] + barRect[oriented.marginTrailing];
                    if (margins) {
                        val = parseInt(val, 10) / 100 * containerRect[oriented.size] - margins + 'px';
                    }
                }

                bar.style[key] = val;
            });
        }
    },

    /**
     * @readonly
     * @name paging
     * @summary Enable page up/dn clicks.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * If truthy, listen for clicks in page-up and page-down regions of scrollbar.
     *
     * If an object, call `.paging.up()` on page-up clicks and `.paging.down()` will be called on page-down clicks.
     *
     * Changing the truthiness of this value after instantiation currently has no effect.
     * @type {boolean|object}
     * @memberOf FinBar.prototype
     */
    paging: true,

    /**
     * @name range
     * @summary Setter for the minimum and maximum scroll values.
     * @desc Set by the constructor. These values are the limits for {@link FooBar#index|index}.
     *
     * The setter accepts an object with exactly two numeric properties: `.min` which must be less than `.max`. The values are extracted and the object is discarded.
     *
     * The getter returns a new object with `.min` and '.max`.
     *
     * @type {rangeType}
     * @memberOf FinBar.prototype
     */
    set range(range) {
        validRange(range);
        this._min = range.min;
        this._max = range.max;
        this.contentSize = range.max - range.min + 1;
        this.index = this.index; // re-clamp
    },
    get range() {
        return {
            min: this._min,
            max: this._max
        };
    },

    /**
     * @summary Index value of the scrollbar.
     * @desc This is the position of the scroll thumb.
     *
     * Setting this value clamps it to {@link FinBar#min|min}..{@link FinBar#max|max}, scroll the content, and moves thumb.
     *
     * Getting this value returns the current index. The returned value will be in the range `min`..`max`. It is intentionally not rounded.
     *
     * Use this value as an alternative to (or in addition to) using the {@link FinBar#onchange|onchange} callback function.
     *
     * @see {@link FinBar#_setScroll|_setScroll}
     * @type {number}
     * @memberOf FinBar.prototype
     */
    set index(idx) {
        idx = Math.min(this._max, Math.max(this._min, idx)); // clamp it
        this._setScroll(idx);
        // this._setThumbSize();
    },
    get index() {
        return this._index;
    },

    /**
     * @private
     * @summary Move the thumb.
     * @desc Also displays the index value in the test panel and invokes the callback.
     * @param idx - The new scroll index, a value in the range `min`..`max`.
     * @param [scaled=f(idx)] - The new thumb position in pixels and scaled relative to the containing {@link FinBar#bar|bar} element, i.e., a proportional number in the range `0`..`thumbMax`. When omitted, a function of `idx` is used.
     * @memberOf FinBar.prototype
     */
    _setScroll: function (idx, scaled) {
        this._index = idx;

        // Display the index value in the test panel
        if (this.testPanelItem && this.testPanelItem.index instanceof Element) {
            this.testPanelItem.index.innerHTML = Math.round(idx);
        }

        // Call the callback
        if (this.onchange) {
            this.onchange.call(this, Math.round(idx));
        }

        // Move the thumb
        if (scaled === undefined) {
            scaled = (idx - this._min) / (this._max - this._min) * this._thumbMax;
        }
        this.thumb.style[this.oh.leading] = scaled + 'px';
    },

    scrollRealContent: function (idx) {
        var containerRect = this.content.parentElement.getBoundingClientRect(),
            sizeProp = this.oh.size,
            maxScroll = Math.max(0, this.content[sizeProp] - containerRect[sizeProp]),
            //scroll = Math.min(idx, maxScroll);
            scroll = (idx - this._min) / (this._max - this._min) * maxScroll;
        //console.log('scroll: ' + scroll);
        this.content.style[this.oh.leading] = -scroll + 'px';
    },

    /**
     * @summary Recalculate thumb position.
     *
     * @desc This method recalculates the thumb size and position. Call it once after inserting your scrollbar into the DOM, and repeatedly while resizing the scrollbar (which typically happens when the scrollbar's parent is resized by user.
     *
     * > This function shifts args if first arg omitted.
     *
     * @param {number} [increment=this.increment] - Resets {@link FooBar#increment|increment} (see).
     *
     * @param {finbarStyles} [barStyles=this.barStyles] - (See type definition for details.) Scrollbar styles to be applied to the bar element.
     *
     * Only specify a `barStyles` object when you need to override stylesheet values. If provided, becomes the new default (`this.barStyles`), for use as a default on subsequent calls.
     *
     * It is generally the case that the scrollbar's new position is sufficiently described by the current styles. Therefore, it is unusual to need to provide a `barStyles` object on every call to `resize`.
     *
     * @returns {FinBar} Self for chaining.
     * @memberOf FinBar.prototype
     */
    resize: function (increment, barStyles) {
        var bar = this.bar;

        if (!bar.parentNode) {
            return; // not in DOM yet so nothing to do
        }

        var container = this.container || bar.parentElement,
            containerRect = container.getBoundingClientRect();

        // shift args if if 1st arg omitted
        if (typeof increment === 'object') {
            barStyles = increment;
            increment = undefined;
        }

        this.style = this.barStyles = barStyles || this.barStyles;

        // Bound to real content: Content was given but no onchange handler.
        // Set up .onchange, .containerSize, and .increment.
        // Note this only makes sense if your index unit is pixels.
        if (this.content) {
            if (!this.onchange) {
                this.onchange = this.scrollRealContent;
                this.contentSize = this.content[this.oh.size];
                this._min = 0;
                this._max = this.contentSize - 1;
            }
        }
        if (this.onchange === this.scrollRealContent) {
            this.containerSize = containerRect[this.oh.size];
            this.increment = this.containerSize / (this.contentSize - this.containerSize) * (this._max - this._min);
        } else {
            this.containerSize = 1;
            this.increment = increment || this.increment;
        }

        var index = this.index;
        this.testPanelItem = this.testPanelItem || this._addTestPanelItem();
        this._setThumbSize();
        this.index = index;

        if (this.deltaProp !== null) {
            container.addEventListener('wheel', this._bound.onwheel);
        }

        return this;
    },

    /**
     * @summary Shorten trailing end of scrollbar by thickness of some other scrollbar.
     * @desc In the "classical" scenario where vertical scroll bar is on the right and horizontal scrollbar is on the bottom, you want to shorten the "trailing end" (bottom and right ends, respectively) of at least one of them so they don't overlay.
     *
     * This convenience function is an programmatic alternative to hardcoding the correct style with the correct value in your stylesheet; or setting the correct style with the correct value in the {@link FinBar#barStyles|barStyles} object.
     *
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     *
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenBy: function (otherFinBar) { return this.shortenEndBy('trailing', otherFinBar); },

    /**
     * @summary Shorten leading end of scrollbar by thickness of some other scrollbar.
     * @desc Supports non-classical scrollbar scenarios where vertical scroll bar may be on left and horizontal scrollbar may be on top, in which case you want to shorten the "leading end" rather than the trailing end.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    foreshortenBy: function (otherFinBar) { return this.shortenEndBy('leading', otherFinBar); },

    /**
     * @summary Generalized shortening function.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     * @param {string} whichEnd - a CSS style property name or an orientation hash name that translates to a CSS style property name.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenEndBy: function (whichEnd, otherFinBar) {
        if (!otherFinBar) {
            delete this._auxStyles;
        } else if (otherFinBar instanceof FinBar && otherFinBar.orientation !== this.orientation) {
            var otherStyle = window.getComputedStyle(otherFinBar.bar),
                ooh = orientationHashes[otherFinBar.orientation];
            this._auxStyles = {};
            this._auxStyles[whichEnd] = otherStyle[ooh.thickness];
        }
        return this; // for chaining
    },

    /**
     * @private
     * @summary Sets the proportional thumb size and hides thumb when 100%.
     * @desc The thumb size has an absolute minimum of 20 (pixels).
     * @memberOf FinBar.prototype
     */
    _setThumbSize: function () {
        var oh = this.oh,
            thumbComp = window.getComputedStyle(this.thumb),
            thumbMarginLeading = parseInt(thumbComp[oh.marginLeading]),
            thumbMarginTrailing = parseInt(thumbComp[oh.marginTrailing]),
            thumbMargins = thumbMarginLeading + thumbMarginTrailing,
            barSize = this.bar.getBoundingClientRect()[oh.size],
            thumbSize = Math.max(20, barSize * this.containerSize / this.contentSize);

        if (this.containerSize < this.contentSize) {
            this.bar.style.visibility = 'visible';
            this.thumb.style[oh.size] = thumbSize + 'px';
        } else {
            this.bar.style.visibility = 'hidden';
        }

        /**
         * @private
         * @name _thumbMax
         * @summary Maximum offset of thumb's leading edge.
         * @desc This is the pixel offset within the scrollbar of the thumb when it is at its maximum position at the extreme end of its range.
         *
         * This value takes into account the newly calculated size of the thumb element (including its margins) and the inner size of the scrollbar (the thumb's containing element, including _its_ margins).
         *
         * NOTE: Scrollbar padding is not taken into account and assumed to be 0 in the current implementation and is assumed to be `0`; use thumb margins in place of scrollbar padding.
         * @type {number}
         * @memberOf FinBar.prototype
         */
        this._thumbMax = barSize - thumbSize - thumbMargins;

        this._thumbMarginLeading = thumbMarginLeading; // used in mousedown
    },

    /**
     * @summary Remove the scrollbar.
     * @desc Unhooks all the event handlers and then removes the element from the DOM. Always call this method prior to disposing of the scrollbar object.
     * @memberOf FinBar.prototype
     */
    remove: function () {
        this._removeEvt('mousedown');
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        (this.container || this.bar.parentElement)._removeEvt('wheel', this._bound.onwheel);

        this.bar.onclick =
            this.thumb.onclick =
                this.thumb.onmouseover =
                    this.thumb.transitionend =
                        this.thumb.onmouseout = null;

        this.bar.remove();
    },

    /**
     * @private
     * @function _addTestPanelItem
     * @summary Append a test panel element.
     * @desc If there is a test panel in the DOM (typically an `<ol>...</ol>` element) with class names of both `this.classPrefix` and `'test-panel'` (or, barring that, any element with class name `'test-panel'`), an `<li>...</li>` element will be created and appended to it. This new element will contain a span for each class name given.
     *
     * You should define a CSS selector `.listening` for these spans. This class will be added to the spans to alter their appearance when a listener is added with that class name (prefixed with 'on').
     *
     * (This is an internal function that is called once by the constructor on every instantiation.)
     * @returns {Element|undefined} The appended `<li>...</li>` element or `undefined` if there is no test panel.
     * @memberOf FinBar.prototype
     */
    _addTestPanelItem: function () {
        var testPanelItem,
            testPanelElement = document.querySelector('.' + this._classPrefix + '.test-panel') || document.querySelector('.test-panel');

        if (testPanelElement) {
            var testPanelItemPartNames = [ 'mousedown', 'mousemove', 'mouseup', 'index' ],
                item = document.createElement('li');

            testPanelItemPartNames.forEach(function (partName) {
                item.innerHTML += '<span class="' + partName + '">' + partName.replace('mouse', '') + '</span>';
            });

            testPanelElement.appendChild(item);

            testPanelItem = {};
            testPanelItemPartNames.forEach(function (partName) {
                testPanelItem[partName] = item.getElementsByClassName(partName)[0];
            });
        }

        return testPanelItem;
    },

    _addEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.add('listening'); }
        window.addEventListener(evtName, this._bound['on' + evtName]);
    },

    _removeEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.remove('listening'); }
        window.removeEventListener(evtName, this._bound['on' + evtName]);
    }
};

function extend(obj) {
    for (var i = 1; i < arguments.length; ++i) {
        var objn = arguments[i];
        if (objn) {
            for (var key in objn) {
                obj[key] = objn[key];
            }
        }
    }
    return obj;
}

function validRange(range) {
    var keys = Object.keys(range),
        valid =  keys.length === 2 &&
            typeof range.min === 'number' &&
            typeof range.max === 'number' &&
            range.min <= range.max;

    if (!valid) {
        error('Invalid .range object.');
    }
}

/**
 * @private
 * @name handlersToBeBound
 * @type {object}
 * @desc The functions defined in this object are all DOM event handlers that are bound by the FinBar constructor to each new instance. In other words, the `this` value of these handlers, once bound, refer to the FinBar object and not to the event emitter. "Do not consume raw."
 */
var handlersToBeBound = {
    shortStop: function (evt) {
        evt.stopPropagation();
    },

    onwheel: function (evt) {
        this.index += evt[this.deltaProp];
        evt.stopPropagation();
        evt.preventDefault();
    },

    onclick: function (evt) {
        var thumbBox = this.thumb.getBoundingClientRect(),
            goingUp = evt[this.oh.coordinate] < thumbBox[this.oh.leading];

        if (typeof this.paging === 'object') {
            this.index = this.paging[goingUp ? 'up' : 'down'](Math.round(this.index));
        } else {
            this.index += goingUp ? -this.increment : this.increment;
        }

        // make the thumb glow momentarily
        this.thumb.classList.add('hover');
        var self = this;
        this.thumb.addEventListener('transitionend', function waitForIt() {
            this.removeEventListener('transitionend', waitForIt);
            self._bound.onmouseup(evt);
        });

        evt.stopPropagation();
    },

    onmouseover: function () {
        this.thumb.classList.add('hover');
        this.thumb.onmouseout = this._bound.onmouseout;
        this._addEvt('mousedown');
    },

    onmouseout: function () {
        this._removeEvt('mousedown');
        this.thumb.onmouseover = this._bound.onmouseover;
        this.thumb.classList.remove('hover');
    },

    onmousedown: function (evt) {
        this._removeEvt('mousedown');
        this.thumb.onmouseover = this.thumb.onmouseout = null;

        var thumbBox = this.thumb.getBoundingClientRect();
        this.pinOffset = evt[this.oh.axis] - thumbBox[this.oh.leading] + this.bar.getBoundingClientRect()[this.oh.leading] + this._thumbMarginLeading;
        document.documentElement.style.cursor = 'default';

        this._addEvt('mousemove');
        this._addEvt('mouseup');

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmousemove: function (evt) {
        var scaled = Math.min(this._thumbMax, Math.max(0, evt[this.oh.axis] - this.pinOffset));
        var idx = scaled / this._thumbMax * (this._max - this._min) + this._min;

        this._setScroll(idx, scaled);

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmouseup: function (evt) {
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        document.documentElement.style.cursor = 'auto';

        var thumbBox = this.thumb.getBoundingClientRect();
        if (
            thumbBox.left <= evt.clientX && evt.clientX <= thumbBox.right &&
            thumbBox.top <= evt.clientY && evt.clientY <= thumbBox.bottom
        ) {
            this._bound.onmouseover(evt);
        } else {
            this._bound.onmouseout(evt);
        }

        evt.stopPropagation();
        evt.preventDefault();
    }
};

var orientationHashes = {
    vertical: {
        coordinate:     'clientY',
        axis:           'pageY',
        size:           'height',
        outside:        'right',
        inside:         'left',
        leading:        'top',
        trailing:       'bottom',
        marginLeading:  'marginTop',
        marginTrailing: 'marginBottom',
        thickness:      'width',
        delta:          'deltaY'
    },
    horizontal: {
        coordinate:     'clientX',
        axis:           'pageX',
        size:           'width',
        outside:        'bottom',
        inside:         'top',
        leading:        'left',
        trailing:       'right',
        marginLeading:  'marginLeft',
        marginTrailing: 'marginRight',
        thickness:      'height',
        delta:          'deltaX'
    }
};

var axis = {
    top:    'vertical',
    bottom: 'vertical',
    height: 'vertical',
    left:   'horizontal',
    right:  'horizontal',
    width:  'horizontal'
};

var cssFinBars; // definition inserted by gulpfile between following comments
/* inject:css */
cssFinBars = 'div.finbar-horizontal,div.finbar-vertical{position:absolute;margin:3px}div.finbar-horizontal>.thumb,div.finbar-vertical>.thumb{position:absolute;background-color:#d3d3d3;-webkit-box-shadow:0 0 1px #000;-moz-box-shadow:0 0 1px #000;box-shadow:0 0 1px #000;border-radius:4px;margin:2px;opacity:.4;transition:opacity .5s}div.finbar-horizontal>.thumb.hover,div.finbar-vertical>.thumb.hover{opacity:1;transition:opacity .5s}div.finbar-vertical{top:0;bottom:0;right:0;width:11px}div.finbar-vertical>.thumb{top:0;right:0;width:7px}div.finbar-horizontal{left:0;right:0;bottom:0;height:11px}div.finbar-horizontal>.thumb{left:0;bottom:0;height:7px}';
/* endinject */

function error(msg) {
    throw 'finbars: ' + msg;
}

// Interface
module.exports = FinBar;

},{"css-injector":2}],5:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var rectangular = require('rectangular');

var gestures = require('./js/polymergestures.dev.js');
var GraphicsContext = require('./js/GraphicsContext.js');

var RESIZE_POLLING_INTERVAL = 200,
    paintables = [],
    resizables = [],
    paintLoopRunning = true,
    resizeLoopRunning = true,
    charMap = makeCharMap();

function Canvas(div, component) {
    var self = this;

    this.div = div;
    this._component = component;

    this.dragEndtime = Date.now();

    this.canvas = document.createElement('canvas');
    this.div.appendChild(this.canvas);

    this.canvas.style.outline = 'none';

    // this.focuser = document.createElement('button');
    // this.focuser.style.position = 'absolute';
    // this.focuser.style.top = '0px';
    // this.focuser.style.left = '0px';
    // this.focuser.style.zIndex = '-1';
    // this.focuser.style.outline = 'none';
    // this.div.appendChild(this.focuser);

    this.canvasCTX = this.canvas.getContext('2d');
    this.gc = new GraphicsContext(this.canvasCTX);

    this.buffer = document.createElement('canvas');
    this.bufferCTX = this.buffer.getContext('2d');
    this.bufferGC = new GraphicsContext(this.bufferCTX);

    this.mouseLocation = new rectangular.Point(-1, -1);
    this.dragstart = new rectangular.Point(-1, -1);
    //this.origin = new rectangular.Point(0, 0);
    this.bounds = new rectangular.Rectangle(0, 0, 0, 0);
    this.hasMouse = false;

    document.addEventListener('mousemove', function(e) {
        if (self.hasMouse || self.isDragging()) {
            self.finmousemove(e);
        }
    });
    document.addEventListener('mouseup', function(e) {
        self.finmouseup(e);
    });
    document.addEventListener('wheel', function(e) {
        self.finwheelmoved(e);
    });
    document.addEventListener('keydown', function(e) {
        self.finkeydown(e);
    });
    document.addEventListener('keyup', function(e) {
        self.finkeyup(e);
    });

    this.canvas.onmouseover = function() {
        self.hasMouse = true;
    };
    this.canvas.addEventListener('focus', function(e) {
        self.finfocusgained(e);
    });
    this.canvas.addEventListener('blur', function(e) {
        self.finfocuslost(e);
    });
    this.canvas.addEventListener('mousedown', function(e) {
        self.finmousedown(e);
    });
    this.canvas.addEventListener('mouseout', function(e) {
        self.hasMouse = false;
        self.finmouseout(e);
    });
    this.canvas.addEventListener('click', function(e) {
        self.finclick(e);
    });
    this.canvas.addEventListener('contextmenu', function(e) {
        self.fincontextmenu(e);
        e.preventDefault();
        return false;
    });

    gestures.addEventListener(this.canvas, 'tap', function(e) {
        self.fintap(e);
    });
    gestures.addEventListener(this.canvas, 'holdpulse', function(e) {
        self.finholdpulse(e);
    });
    gestures.addEventListener(this.canvas, 'flick', function(e) {
        self.finflick(e);
    });
    gestures.addEventListener(this.canvas, 'release', function(e) {
        self.finrelease(e);
    });
    gestures.addEventListener(this.canvas, 'trackstart', function(e) {
        self.fintrackstart(e);
    });
    gestures.addEventListener(this.canvas, 'track', function(e) {
        self.fintrack(e);
    });
    gestures.addEventListener(this.canvas, 'trackend', function(e) {
        self.fintrackend(e);
    });

    this.canvas.setAttribute('tabindex', 0);
    this.canvas.contentEditable = true;

    this.resize();

    this.beginResizing();
    this.beginPainting();
}

Canvas.prototype = {
    constructor: Canvas.prototype.constructor,
    div: null,
    _component: null,
    gestures: gestures, // TODO: why do we need this? (was previously at bottom of file)
    canvas: null,
    canvasCTX: null,
    focuser: null,
    buffer: null,
    ctx: null,
    mouseLocation: null,
    holdPulseCount: -1,
    dragstart: null,
    origin: null,
    bounds: null,
    dirty: false,
    size: null,
    mousedown: false,
    dragging: false,
    repeatKeyCount: 0,
    repeatKey: null,
    repeatKeyStartTime: 0,
    currentKeys: [],
    hasMouse: false,
    lastDoubleClickTime: 0,
    dragEndTime: 0,
    lastRepaintTime: 0,

    addEventListener: function(name, callback) {
        this.canvas.addEventListener(name, callback);
    },

    stopPaintLoop: function() {
        paintLoopRunning = false;
    },

    restartPaintLoop: function() {
        if (paintLoopRunning) {
            return; // already running
        }
        paintLoopRunning = true;
        requestAnimationFrame(paintLoopFunction);
    },

    stopResizeLoop: function() {
        resizeLoopRunning = false;
    },

    restartResizeLoop: function() {
        if (resizeLoopRunning) {
            return; // already running
        }
        resizeLoopRunning = true;
        setInterval(resizablesLoopFunction, 200);
    },

    detached: function() {
        this.stopPainting();
        this.stopResizing();
    },

    useHiDPI: function() {
        return this._component.resolveProperty('useHiDPI');
    },

    useBitBlit: function() {
        return this._component.resolveProperty('useBitBlit');
    },

    getFPS: function() {
        var fps = this._component.resolveProperty('repaintIntervalRate');
        return fps ? parseInt(fps) : 0;
    },

    tickPaint: function(now) {
        var fps = this.getFPS();
        if (fps === 0) {
            return;
        }
        var interval = 1000 / fps;

        var elapsed = now - this.lastRepaintTime;
        if (elapsed > interval && this.dirty) {
            this.lastRepaintTime = now - (elapsed % interval);
            this.paintNow();
        }
    },

    beginPainting: function() {
        var self = this;
        this.dirty = true;
        this.tickPainter = function(now) {
            self.tickPaint(now);
        };
        paintables.push(this);
    },

    stopPainting: function() {
        paintables.splice(paintables.indexOf(this), 1);
    },

    beginResizing: function() {
        var self = this;
        this.tickResizer = function() {
            self.checksize();
        };
        resizables.push(this);
    },

    stopResizing: function() {
        resizables.splice(resizables.indexOf(this), 1);
    },

    start: function() {
        this.beginPainting();
        this.beginResizing();
    },

    stop: function() {
        this.stopPainting();
        this.stopResizing();
    },

    checksize: function() {
        //this is expensive lets do it at some modulo
        var sizeNow = this.div.getBoundingClientRect();
        if (sizeNow.width !== this.size.width || sizeNow.height !== this.size.height) {
            this.sizeChangedNotification();
        }
    },

    sizeChangedNotification: function() {
        this.resize();
    },

    resize: function() {
        var box = this.size = this.div.getBoundingClientRect();

        this.canvas.width = this.buffer.width = box.width;
        this.canvas.height = this.buffer.height = box.height;

        //fix ala sir spinka, see
        //http://www.html5rocks.com/en/tutorials/canvas/hidpi/
        //just add 'hdpi' as an attribute to the fin-canvas tag
        var ratio = 1;
        var useBitBlit = this.useBitBlit();
        var isHIDPI = window.devicePixelRatio && this.useHiDPI();
        if (isHIDPI) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = this.canvasCTX.webkitBackingStorePixelRatio ||
                this.canvasCTX.mozBackingStorePixelRatio ||
                this.canvasCTX.msBackingStorePixelRatio ||
                this.canvasCTX.oBackingStorePixelRatio ||
                this.canvasCTX.backingStorePixelRatio || 1;

            ratio = devicePixelRatio / backingStoreRatio;
            //this.canvasCTX.scale(ratio, ratio);
        }
        var width = this.canvas.getAttribute('width');
        var height = this.canvas.getAttribute('height');
        this.canvas.width = width * ratio;
        this.canvas.height = height * ratio;
        this.buffer.width = width * ratio;
        this.buffer.height = height * ratio;

        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';
        this.buffer.style.width = width + 'px';
        this.buffer.style.height = height + 'px';

        this.bufferCTX.scale(ratio, ratio);
        if (isHIDPI && !useBitBlit) {
            this.canvasCTX.scale(ratio, ratio);
        }

        //this.origin = new rectangular.Point(Math.round(this.size.left), Math.round(this.size.top));
        this.bounds = new rectangular.Rectangle(0, 0, box.width, box.height);
        //setTimeout(function() {
        var comp = this._component;
        if (comp) {
            comp.setBounds(this.bounds);
        }
        this.resizeNotification();
        this.paintNow();
        //});
    },

    resizeNotification: function() {
        //to be overridden
    },

    getBounds: function() {
        return this.bounds;
    },

    paintNow: function() {
        var self = this;
        this.safePaintImmediately(function(gc) {
            gc.clearRect(0, 0, self.canvas.width, self.canvas.height);

            var comp = self._component;
            if (comp) {
                comp._paint(gc);
            }

            self.dirty = false;
        });
    },

    safePaintImmediately: function(paintFunction) {
        var useBitBlit = this.useBitBlit(),
            gc = useBitBlit ? this.bufferGC : this.gc;
        try {
            gc.save();
            paintFunction(gc);
        } catch (e) {
            console.error(e);
        } finally {
            gc.restore();
        }
        if (useBitBlit) {
            this.flushBuffer();
        }
    },

    flushBuffer: function() {
        if (this.buffer.width > 0 && this.buffer.height > 0) {
            this.canvasCTX.drawImage(this.buffer, 0, 0);
        }
    },

    dispatchNewEvent: function(event, name, detail) {
        detail = {
            detail: detail || {}
        };
        detail.detail.primitiveEvent = event;
        return this.canvas.dispatchEvent(new CustomEvent(name, detail));
    },

    dispatchNewMouseKeysEvent: function(event, name, detail) {
        detail = detail || {};
        detail.mouse = this.mouseLocation;
        detail.keys = this.currentKeys;
        return this.dispatchNewEvent(event, name, detail);
    },

    finmousemove: function(e) {
        if (!this.isDragging() && this.mousedown) {
            this.beDragging();
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragstart', {
                isRightClick: this.isRightClick(e)
            });
            this.dragstart = new rectangular.Point(this.mouseLocation.x, this.mouseLocation.y);
        }
        this.mouseLocation = this.getLocal(e);
        //console.log(this.mouseLocation);
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-drag', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
        }
        if (this.bounds.contains(this.mouseLocation)) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousemove');
        }
    },

    finmousedown: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.mousedown = true;

        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousedown', {
            isRightClick: this.isRightClick(e)
        });
        this.takeFocus();
    },

    finmouseup: function(e) {
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragend', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
            this.beNotDragging();
            this.dragEndtime = Date.now();
        }
        this.mousedown = false;
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseup', {
            isRightClick: this.isRightClick(e)
        });
        //this.mouseLocation = new rectangular.Point(-1, -1);
    },

    finmouseout: function(e) {
        if (!this.mousedown) {
            this.mouseLocation = new rectangular.Point(-1, -1);
        }
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseout');
    },

    finwheelmoved: function(e) {
        if (this.isDragging() || !this.hasFocus()) {
            return;
        }
        e.preventDefault();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-wheelmoved', {
            isRightClick: this.isRightClick(e)
        });
    },

    finclick: function(e) {
        if (Date.now() - this.lastClickTime < 250) {
            //this is a double click...
            this.findblclick(e);
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-click', {
            isRightClick: this.isRightClick(e)
        });
        this.lastClickTime = Date.now();
    },

    finrelease: function(e) {
        this.holdPulseCount = 0;
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-release');
    },

    finflick: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-flick', {
            isRightClick: this.isRightClick(e)
        });
    },

    fintrackstart: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-trackstart');
    },

    fintrack: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-track');
    },

    fintrackend: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-trackend');
    },

    finhold: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-hold', {
            isRightClick: this.isRightClick(e)
        });
    },

    finholdpulse: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-holdpulse', {
            count: this.holdPulseCount++
        });
    },

    fintap: function(e) {
        //this nonsense is to hold a tap if it's really a double click
        var self = this;
        var now = Date.now();
        var dif = now - this.lastDoubleClickTime;
        if (dif < 300) {
            return;
        }
        //dragend is also causing a tap
        //lets fix this here
        if (now - this.dragEndtime < 100) {
            return;
        }
        setTimeout(function() {
            self._fintap(e);
        }, 180);
    },

    _fintap: function(e) {
        //this nonsense is to hold a tap if it's really a double click
        var now = Date.now();
        var dif = now - this.lastDoubleClickTime;
        if (dif < 300) {
            return;
        }
        //this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-tap', {
            isRightClick: this.isRightClick(e)
        });
    },

    findblclick: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.lastDoubleClickTime = Date.now();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dblclick', {
            isRightClick: this.isRightClick(e)
        });
        //console.log('dblclick', this.currentKeys);
    },

    getCharMap: function() { //TODO: This is static. Make it a property of the constructor.
        return charMap;
    },

    finkeydown: function(e) {
        if (!this.hasFocus()) {
            return;
        }

        //e.preventDefault();
        var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
        if (e.repeat) {
            if (this.repeatKey === keyChar) {
                this.repeatKeyCount++;
            } else {
                this.repeatKey = keyChar;
                this.repeatKeyStartTime = Date.now();
            }
        } else {
            this.repeatKey = null;
            this.repeatKeyCount = 0;
            this.repeatKeyStartTime = 0;
        }
        if (this.currentKeys.indexOf(keyChar) === -1) {
            this.currentKeys.push(keyChar);
        }
        //console.log(keyChar, e.keyCode);
        this.dispatchNewEvent(e, 'fin-canvas-keydown', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeatCount: this.repeatKeyCount,
            repeatStartTime: this.repeatKeyStartTime,
            shift: e.shiftKey,
            identifier: e.keyIdentifier,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finkeyup: function(e) {
        var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
        this.currentKeys.splice(this.currentKeys.indexOf(keyChar), 1);
        if (!this.hasFocus()) {
            return;
        }
        this.repeatKeyCount = 0;
        this.repeatKey = null;
        this.repeatKeyStartTime = 0;
        this.dispatchNewEvent(e, 'fin-canvas-keyup', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeat: e.repeat,
            shift: e.shiftKey,
            identifier: e.keyIdentifier,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finfocusgained: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-gained');
    },

    finfocuslost: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-lost');
    },

    fincontextmenu: function(e) {
        if (e.ctrlKey && this.currentKeys.indexOf('CTRL') === -1) {
            this.currentKeys.push('CTRL');
        }
        if (Date.now() - this.lastClickTime < 250) {
            //this is a double click...
            this.findblclick(e);
            return;
        }
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-context-menu', {
            isRightClick: this.isRightClick(e)
        });
        this.lastClickTime = Date.now();
    },

    repaint: function() {
        var fps = this.getFPS();
        this.dirty = true;
        if (!paintLoopRunning || fps === 0) {
            this.paintNow();
        }
    },

    getMouseLocation: function() {
        return this.mouseLocation;
    },

    getOrigin: function() {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(rect.left, rect.top);
        return p;
    },

    getLocal: function(e) {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(e.clientX - rect.left, e.clientY - rect.top);
        return p;
    },

    hasFocus: function() {
        return document.activeElement === this.canvas;
    },

    takeFocus: function() {
        var self = this;
        if (!this.hasFocus()) {
            setTimeout(function() {
                self.canvas.focus();
            }, 10);
        }
    },

    beDragging: function() {
        this.dragging = true;
        this.disableDocumentElementSelection();
    },

    beNotDragging: function() {
        this.dragging = false;
        this.enableDocumentElementSelection();
    },

    isDragging: function() {
        return this.dragging;
    },

    disableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText + '-webkit-user-select: none';
    },

    enableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText.replace('-webkit-user-select: none', '');
    },

    setFocusable: function(truthy) {
        this.focuser.style.display = truthy ? '' : 'none';
    },

    isRightClick: function(e) {
        var isRightMB;
        e = e || window.event;

        if ('which' in e) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
            isRightMB = e.which === 3;
        } else if ('button' in e) { // IE, Opera
            isRightMB = e.button === 2;
        }
        return isRightMB;
    },

    dispatchEvent: function(e) {
        return this.canvas.dispatchEvent(e);
    }
};

function paintLoopFunction(now) {
    if (!paintLoopRunning) {
        return;
    }
    for (var i = 0; i < paintables.length; i++) {
        try {
            paintables[i].tickPainter(now);
        } catch (e) {
            console.error(e);
        }
    }
    requestAnimationFrame(paintLoopFunction);
}
requestAnimationFrame(paintLoopFunction);

function resizablesLoopFunction(now) {
    if (!resizeLoopRunning) {
        return;
    }
    for (var i = 0; i < resizables.length; i++) {
        try {
            resizables[i].tickResizer(now);
        } catch (e) {
            console.error(e);
        }
    }
}
setInterval(resizablesLoopFunction, RESIZE_POLLING_INTERVAL);

function makeCharMap() {
    var map = [];

    var empty = ['', ''];

    for (var i = 0; i < 256; i++) {
        map[i] = empty;
    }

    map[27] = ['ESC', 'ESCSHIFT'];
    map[192] = ['`', '~'];
    map[49] = ['1', '!'];
    map[50] = ['2', '@'];
    map[51] = ['3', '#'];
    map[52] = ['4', '$'];
    map[53] = ['5', '%'];
    map[54] = ['6', '^'];
    map[55] = ['7', '&'];
    map[56] = ['8', '*'];
    map[57] = ['9', '('];
    map[48] = ['0', ')'];
    map[189] = ['-', '_'];
    map[187] = ['=', '+'];
    map[8] = ['DELETE', 'DELETESHIFT'];
    map[9] = ['TAB', 'TABSHIFT'];
    map[81] = ['q', 'Q'];
    map[87] = ['w', 'W'];
    map[69] = ['e', 'E'];
    map[82] = ['r', 'R'];
    map[84] = ['t', 'T'];
    map[89] = ['y', 'Y'];
    map[85] = ['u', 'U'];
    map[73] = ['i', 'I'];
    map[79] = ['o', 'O'];
    map[80] = ['p', 'P'];
    map[219] = ['[', '{'];
    map[221] = [']', '}'];
    map[220] = ['\\', '|'];
    map[220] = ['CAPSLOCK', 'CAPSLOCKSHIFT'];
    map[65] = ['a', 'A'];
    map[83] = ['s', 'S'];
    map[68] = ['d', 'D'];
    map[70] = ['f', 'F'];
    map[71] = ['g', 'G'];
    map[72] = ['h', 'H'];
    map[74] = ['j', 'J'];
    map[75] = ['k', 'K'];
    map[76] = ['l', 'L'];
    map[186] = [';', ':'];
    map[222] = ['\'', '|'];
    map[13] = ['RETURN', 'RETURNSHIFT'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[90] = ['z', 'Z'];
    map[88] = ['x', 'X'];
    map[67] = ['c', 'C'];
    map[86] = ['v', 'V'];
    map[66] = ['b', 'B'];
    map[78] = ['n', 'N'];
    map[77] = ['m', 'M'];
    map[188] = [',', '<'];
    map[190] = ['.', '>'];
    map[191] = ['/', '?'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[17] = ['CTRL', 'CTRLSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[91] = ['COMMANDLEFT', 'COMMANDLEFTSHIFT'];
    map[32] = ['SPACE', 'SPACESHIFT'];
    map[93] = ['COMMANDRIGHT', 'COMMANDRIGHTSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[38] = ['UP', 'UPSHIFT'];
    map[37] = ['LEFT', 'LEFTSHIFT'];
    map[40] = ['DOWN', 'DOWNSHIFT'];
    map[39] = ['RIGHT', 'RIGHTSHIFT'];

    map[33] = ['PAGEUP', 'PAGEUPSHIFT'];
    map[34] = ['PAGEDOWN', 'PAGEDOWNSHIFT'];
    map[35] = ['PAGERIGHT', 'PAGERIGHTSHIFT'];
    map[36] = ['PAGELEFT', 'PAGELEFTSHIFT'];

    return map;
}

module.exports = Canvas;

},{"./js/GraphicsContext.js":6,"./js/polymergestures.dev.js":8,"rectangular":29}],6:[function(require,module,exports){
'use strict';

var consoleLogger = require('./gc-console-logger');

/**
 * @constructor
 * @param gc - The 2-D graphics context from your canvas
 * @param {boolean|apiLogger} [logger=true]
 * * `true` uses `gc-console-logger` function bound to 'gc.' as prefix
 * * string uses `gc-console-logger` function bound to string
 * * function used as is
 */
function GraphicsContext(gc, logger) {
    this.gc = gc;

    var self = this;
    var reWEBKIT = /^webkit/;

    switch (typeof logger) {

        case 'string':
            logger =  consoleLogger.bind(undefined, logger + '.');
            break;

        case 'boolean':
            if (logger === true) {
                logger = consoleLogger.bind(undefined, 'gc.');
            }
            break;

        case 'function':
            if (logger.length !== 3) {
                throw 'GraphicsContext: User-supplied API logger function does not accept three parameters.';
            }
            break;

        default:
            logger = false;
    }

    // Stub out all the prototype members of the canvas 2D graphics context:
    Object.keys(Object.getPrototypeOf(gc)).forEach(MakeStub);

    // Some older browsers (e.g., Chrome 40) did not have all members of canvas
    // 2D graphics context in the prototype so we make this additional call:
    Object.keys(gc).forEach(MakeStub);

    function MakeStub(key) {
        if (key in GraphicsContext.prototype || reWEBKIT.test(key)) {
            return;
        }
        if (typeof gc[key] === 'function') {
            self[key] = !logger ? gc[key].bind(gc) : function() {
                return logger(key, arguments, gc[key].apply(gc, arguments));
            };
        } else {
            Object.defineProperty(self, key, {
                get: function() {
                    var result = gc[key];
                    return logger ? logger(key, 'getter', result) : result;
                },
                set: function(value) {
                    gc[key] = logger ? logger(key, 'setter', value) : value;
                }
            });
        }
    }
}

module.exports = GraphicsContext;

},{"./gc-console-logger":7}],7:[function(require,module,exports){
'use strict';

var YIELDS = '\u27F9'; // LONG RIGHTWARDS DOUBLE ARROW

function consoleLogger(prefix, name, args, value) {
    var result = value;

    if (typeof value === 'string') {
        result = '"' + result + '"';
    }

    name = prefix + name;

    switch (args) {
        case 'getter':
            console.log(name, '=', result);
            break;

        case 'setter':
            console.log(name, YIELDS, result);
            break;

        default: // method call
            name += '(' + Array.prototype.slice.call(args).join(', ') + ')';
            if (result === undefined) {
                console.log(name);
            } else {
                console.log(name, YIELDS, result);
            }
    }

    return value;
}

module.exports = consoleLogger;

},{}],8:[function(require,module,exports){
/* eslint-disable */

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
//module.exports = {};

(function(scope) {
    var hasFullPath = false;

    // test for full event path support
    var pathTest = document.createElement('meta');
    if (pathTest.createShadowRoot) {
        var sr = pathTest.createShadowRoot();
        var s = document.createElement('span');
        sr.appendChild(s);
        pathTest.addEventListener('testpath', function(ev) {
            if (ev.path) {
                // if the span is in the event path, then path[0] is the real source for all events
                hasFullPath = ev.path[0] === s;
            }
            ev.stopPropagation();
        });
        var ev = new CustomEvent('testpath', {
            bubbles: true
        });
        // must add node to DOM to trigger event listener
        document.head.appendChild(pathTest);
        s.dispatchEvent(ev);
        pathTest.parentNode.removeChild(pathTest);
        sr = s = null;
    }
    pathTest = null;

    var target = {
        shadow: function(inEl) {
            if (inEl) {
                return inEl.shadowRoot || inEl.webkitShadowRoot;
            }
        },
        canTarget: function(shadow) {
            return shadow && Boolean(shadow.elementFromPoint);
        },
        targetingShadow: function(inEl) {
            var s = this.shadow(inEl);
            if (this.canTarget(s)) {
                return s;
            }
        },
        olderShadow: function(shadow) {
            var os = shadow.olderShadowRoot;
            if (!os) {
                var se = shadow.querySelector('shadow');
                if (se) {
                    os = se.olderShadowRoot;
                }
            }
            return os;
        },
        allShadows: function(element) {
            var shadows = [],
                s = this.shadow(element);
            while (s) {
                shadows.push(s);
                s = this.olderShadow(s);
            }
            return shadows;
        },
        searchRoot: function(inRoot, x, y) {
            var t, st, sr, os;
            if (inRoot) {
                t = inRoot.elementFromPoint(x, y);
                if (t) {
                    // found element, check if it has a ShadowRoot
                    sr = this.targetingShadow(t);
                } else if (inRoot !== document) {
                    // check for sibling roots
                    sr = this.olderShadow(inRoot);
                }
                // search other roots, fall back to light dom element
                return this.searchRoot(sr, x, y) || t;
            }
        },
        owner: function(element) {
            if (!element) {
                return document;
            }
            var s = element;
            // walk up until you hit the shadow root or document
            while (s.parentNode) {
                s = s.parentNode;
            }
            // the owner element is expected to be a Document or ShadowRoot
            if (s.nodeType != Node.DOCUMENT_NODE && s.nodeType != Node.DOCUMENT_FRAGMENT_NODE) {
                s = document;
            }
            return s;
        },
        findTarget: function(inEvent) {
            if (hasFullPath && inEvent.path && inEvent.path.length) {
                return inEvent.path[0];
            }
            var x = inEvent.clientX,
                y = inEvent.clientY;
            // if the listener is in the shadow root, it is much faster to start there
            var s = this.owner(inEvent.target);
            // if x, y is not in this root, fall back to document search
            if (!s.elementFromPoint(x, y)) {
                s = document;
            }
            return this.searchRoot(s, x, y);
        },
        findTouchAction: function(inEvent) {
            var n;
            if (hasFullPath && inEvent.path && inEvent.path.length) {
                var path = inEvent.path;
                for (var i = 0; i < path.length; i++) {
                    n = path[i];
                    if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
                        return n.getAttribute('touch-action');
                    }
                }
            } else {
                n = inEvent.target;
                while (n) {
                    if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
                        return n.getAttribute('touch-action');
                    }
                    n = n.parentNode || n.host;
                }
            }
            // auto is default
            return "auto";
        },
        LCA: function(a, b) {
            if (a === b) {
                return a;
            }
            if (a && !b) {
                return a;
            }
            if (b && !a) {
                return b;
            }
            if (!b && !a) {
                return document;
            }
            // fast case, a is a direct descendant of b or vice versa
            if (a.contains && a.contains(b)) {
                return a;
            }
            if (b.contains && b.contains(a)) {
                return b;
            }
            var adepth = this.depth(a);
            var bdepth = this.depth(b);
            var d = adepth - bdepth;
            if (d >= 0) {
                a = this.walk(a, d);
            } else {
                b = this.walk(b, -d);
            }
            while (a && b && a !== b) {
                a = a.parentNode || a.host;
                b = b.parentNode || b.host;
            }
            return a;
        },
        walk: function(n, u) {
            for (var i = 0; n && (i < u); i++) {
                n = n.parentNode || n.host;
            }
            return n;
        },
        depth: function(n) {
            var d = 0;
            while (n) {
                d++;
                n = n.parentNode || n.host;
            }
            return d;
        },
        deepContains: function(a, b) {
            var common = this.LCA(a, b);
            // if a is the common ancestor, it must "deeply" contain b
            return common === a;
        },
        insideNode: function(node, x, y) {
            var rect = node.getBoundingClientRect();
            return (rect.left <= x) && (x <= rect.right) && (rect.top <= y) && (y <= rect.bottom);
        },
        path: function(event) {
            var p;
            if (hasFullPath && event.path && event.path.length) {
                p = event.path;
            } else {
                p = [];
                var n = this.findTarget(event);
                while (n) {
                    p.push(n);
                    n = n.parentNode || n.host;
                }
            }
            return p;
        }
    };
    scope.targetFinding = target;
    /**
     * Given an event, finds the "deepest" node that could have been the original target before ShadowDOM retargetting
     *
     * @param {Event} Event An event object with clientX and clientY properties
     * @return {Element} The probable event origninator
     */
    scope.findTarget = target.findTarget.bind(target);
    /**
     * Determines if the "container" node deeply contains the "containee" node, including situations where the "containee" is contained by one or more ShadowDOM
     * roots.
     *
     * @param {Node} container
     * @param {Node} containee
     * @return {Boolean}
     */
    scope.deepContains = target.deepContains.bind(target);

    /**
     * Determines if the x/y position is inside the given node.
     *
     * Example:
     *
     *     function upHandler(event) {
     *       var innode = PolymerGestures.insideNode(event.target, event.clientX, event.clientY);
     *       if (innode) {
     *         // wait for tap?
     *       } else {
     *         // tap will never happen
     *       }
     *     }
     *
     * @param {Node} node
     * @param {Number} x Screen X position
     * @param {Number} y screen Y position
     * @return {Boolean}
     */
    scope.insideNode = target.insideNode;

})(exports);

(function() {
    function shadowSelector(v) {
        return 'html /deep/ ' + selector(v);
    }

    function selector(v) {
        return '[touch-action="' + v + '"]';
    }

    function rule(v) {
        return '{ -ms-touch-action: ' + v + '; touch-action: ' + v + ';}';
    }
    var attrib2css = [
        'none',
        'auto',
        'pan-x',
        'pan-y', {
            rule: 'pan-x pan-y',
            selectors: [
                'pan-x pan-y',
                'pan-y pan-x'
            ]
        },
        'manipulation'
    ];
    var styles = '';
    // only install stylesheet if the browser has touch action support
    var hasTouchAction = typeof document.head.style.touchAction === 'string';
    // only add shadow selectors if shadowdom is supported
    var hasShadowRoot = !window.ShadowDOMPolyfill && document.head.createShadowRoot;

    if (hasTouchAction) {
        attrib2css.forEach(function(r) {
            if (String(r) === r) {
                styles += selector(r) + rule(r) + '\n';
                if (hasShadowRoot) {
                    styles += shadowSelector(r) + rule(r) + '\n';
                }
            } else {
                styles += r.selectors.map(selector) + rule(r.rule) + '\n';
                if (hasShadowRoot) {
                    styles += r.selectors.map(shadowSelector) + rule(r.rule) + '\n';
                }
            }
        });

        var el = document.createElement('style');
        el.textContent = styles;
        document.head.appendChild(el);
    }
})();

/**
 * This is the constructor for new PointerEvents.
 *
 * New Pointer Events must be given a type, and an optional dictionary of
 * initialization properties.
 *
 * Due to certain platform requirements, events returned from the constructor
 * identify as MouseEvents.
 *
 * @constructor
 * @param {String} inType The type of the event to create.
 * @param {Object} [inDict] An optional dictionary of initial event properties.
 * @return {Event} A new PointerEvent of type `inType` and initialized with properties from `inDict`.
 */
(function(scope) {

    var MOUSE_PROPS = [
        'bubbles',
        'cancelable',
        'view',
        'detail',
        'screenX',
        'screenY',
        'clientX',
        'clientY',
        'ctrlKey',
        'altKey',
        'shiftKey',
        'metaKey',
        'button',
        'relatedTarget',
        'pageX',
        'pageY'
    ];

    var MOUSE_DEFAULTS = [
        false,
        false,
        null,
        null,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null,
        0,
        0
    ];

    var NOP_FACTORY = function() {
        return function() {};
    };

    var eventFactory = {
        // TODO(dfreedm): this is overridden by tap recognizer, needs review
        preventTap: NOP_FACTORY,
        makeBaseEvent: function(inType, inDict) {
            var e = document.createEvent('Event');
            e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);
            e.preventTap = eventFactory.preventTap(e);
            return e;
        },
        makeGestureEvent: function(inType, inDict) {
            inDict = inDict || Object.create(null);

            var e = this.makeBaseEvent(inType, inDict);
            for (var i = 0, keys = Object.keys(inDict), k; i < keys.length; i++) {
                k = keys[i];
                if (k !== 'bubbles' && k !== 'cancelable') {
                    e[k] = inDict[k];
                }
            }
            return e;
        },
        makePointerEvent: function(inType, inDict) {
            inDict = inDict || Object.create(null);

            var e = this.makeBaseEvent(inType, inDict);
            // define inherited MouseEvent properties
            for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
                p = MOUSE_PROPS[i];
                e[p] = inDict[p] || MOUSE_DEFAULTS[i];
            }
            e.buttons = inDict.buttons || 0;

            // Spec requires that pointers without pressure specified use 0.5 for down
            // state and 0 for up state.
            var pressure = 0;
            if (inDict.pressure) {
                pressure = inDict.pressure;
            } else {
                pressure = e.buttons ? 0.5 : 0;
            }

            // add x/y properties aliased to clientX/Y
            e.x = e.clientX;
            e.y = e.clientY;

            // define the properties of the PointerEvent interface
            e.pointerId = inDict.pointerId || 0;
            e.width = inDict.width || 0;
            e.height = inDict.height || 0;
            e.pressure = pressure;
            e.tiltX = inDict.tiltX || 0;
            e.tiltY = inDict.tiltY || 0;
            e.pointerType = inDict.pointerType || '';
            e.hwTimestamp = inDict.hwTimestamp || 0;
            e.isPrimary = inDict.isPrimary || false;
            e._source = inDict._source || '';
            return e;
        }
    };

    scope.eventFactory = eventFactory;
})(exports);

/**
 * This module implements an map of pointer states
 */
(function(scope) {
    var USE_MAP = window.Map && window.Map.prototype.forEach;
    var POINTERS_FN = function() {
        return this.size;
    };

    function PointerMap() {
        if (USE_MAP) {
            var m = new Map();
            m.pointers = POINTERS_FN;
            return m;
        } else {
            this.keys = [];
            this.values = [];
        }
    }

    PointerMap.prototype = {
        set: function(inId, inEvent) {
            var i = this.keys.indexOf(inId);
            if (i > -1) {
                this.values[i] = inEvent;
            } else {
                this.keys.push(inId);
                this.values.push(inEvent);
            }
        },
        has: function(inId) {
            return this.keys.indexOf(inId) > -1;
        },
        'delete': function(inId) {
            var i = this.keys.indexOf(inId);
            if (i > -1) {
                this.keys.splice(i, 1);
                this.values.splice(i, 1);
            }
        },
        get: function(inId) {
            var i = this.keys.indexOf(inId);
            return this.values[i];
        },
        clear: function() {
            this.keys.length = 0;
            this.values.length = 0;
        },
        // return value, key, map
        forEach: function(callback, thisArg) {
            this.values.forEach(function(v, i) {
                callback.call(thisArg, v, this.keys[i], this);
            }, this);
        },
        pointers: function() {
            return this.keys.length;
        }
    };

    scope.PointerMap = PointerMap;
})(exports);

(function(scope) {
    var CLONE_PROPS = [
        // MouseEvent
        'bubbles',
        'cancelable',
        'view',
        'detail',
        'screenX',
        'screenY',
        'clientX',
        'clientY',
        'ctrlKey',
        'altKey',
        'shiftKey',
        'metaKey',
        'button',
        'relatedTarget',
        // DOM Level 3
        'buttons',
        // PointerEvent
        'pointerId',
        'width',
        'height',
        'pressure',
        'tiltX',
        'tiltY',
        'pointerType',
        'hwTimestamp',
        'isPrimary',
        // event instance
        'type',
        'target',
        'currentTarget',
        'which',
        'pageX',
        'pageY',
        'timeStamp',
        // gesture addons
        'preventTap',
        'tapPrevented',
        '_source'
    ];

    var CLONE_DEFAULTS = [
        // MouseEvent
        false,
        false,
        null,
        null,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null,
        // DOM Level 3
        0,
        // PointerEvent
        0,
        0,
        0,
        0,
        0,
        0,
        '',
        0,
        false,
        // event instance
        '',
        null,
        null,
        0,
        0,
        0,
        0,
        function() {},
        false
    ];

    var HAS_SVG_INSTANCE = (typeof SVGElementInstance !== 'undefined');

    var eventFactory = scope.eventFactory;

    // set of recognizers to run for the currently handled event
    var currentGestures;

    /**
     * This module is for normalizing events. Mouse and Touch events will be
     * collected here, and fire PointerEvents that have the same semantics, no
     * matter the source.
     * Events fired:
     *   - pointerdown: a pointing is added
     *   - pointerup: a pointer is removed
     *   - pointermove: a pointer is moved
     *   - pointerover: a pointer crosses into an element
     *   - pointerout: a pointer leaves an element
     *   - pointercancel: a pointer will no longer generate events
     */
    var dispatcher = {
        IS_IOS: false,
        pointermap: new scope.PointerMap(),
        requiredGestures: new scope.PointerMap(),
        eventMap: Object.create(null),
        // Scope objects for native events.
        // This exists for ease of testing.
        eventSources: Object.create(null),
        eventSourceList: [],
        gestures: [],
        // map gesture event -> {listeners: int, index: gestures[int]}
        dependencyMap: {
            // make sure down and up are in the map to trigger "register"
            down: {
                listeners: 0,
                index: -1
            },
            up: {
                listeners: 0,
                index: -1
            }
        },
        gestureQueue: [],
        /**
         * Add a new event source that will generate pointer events.
         *
         * `inSource` must contain an array of event names named `events`, and
         * functions with the names specified in the `events` array.
         * @param {string} name A name for the event source
         * @param {Object} source A new source of platform events.
         */
        registerSource: function(name, source) {
            var s = source;
            var newEvents = s.events;
            if (newEvents) {
                newEvents.forEach(function(e) {
                    if (s[e]) {
                        this.eventMap[e] = s[e].bind(s);
                    }
                }, this);
                this.eventSources[name] = s;
                this.eventSourceList.push(s);
            }
        },
        registerGesture: function(name, source) {
            var obj = Object.create(null);
            obj.listeners = 0;
            obj.index = this.gestures.length;
            for (var i = 0, g; i < source.exposes.length; i++) {
                g = source.exposes[i].toLowerCase();
                this.dependencyMap[g] = obj;
            }
            this.gestures.push(source);
        },
        register: function(element, initial) {
            var l = this.eventSourceList.length;
            for (var i = 0, es;
                (i < l) && (es = this.eventSourceList[i]); i++) {
                // call eventsource register
                es.register.call(es, element, initial);
            }
        },
        unregister: function(element) {
            var l = this.eventSourceList.length;
            for (var i = 0, es;
                (i < l) && (es = this.eventSourceList[i]); i++) {
                // call eventsource register
                es.unregister.call(es, element);
            }
        },
        // EVENTS
        down: function(inEvent) {
            this.requiredGestures.set(inEvent.pointerId, currentGestures);
            this.fireEvent('down', inEvent);
        },
        move: function(inEvent) {
            // pipe move events into gesture queue directly
            inEvent.type = 'move';
            this.fillGestureQueue(inEvent);
        },
        up: function(inEvent) {
            this.fireEvent('up', inEvent);
            this.requiredGestures.delete(inEvent.pointerId);
        },
        cancel: function(inEvent) {
            inEvent.tapPrevented = true;
            this.fireEvent('up', inEvent);
            this.requiredGestures.delete(inEvent.pointerId);
        },
        addGestureDependency: function(node, currentGestures) {
            var gesturesWanted = node._pgEvents;
            if (gesturesWanted && currentGestures) {
                var gk = Object.keys(gesturesWanted);
                for (var i = 0, r, ri, g; i < gk.length; i++) {
                    // gesture
                    g = gk[i];
                    if (gesturesWanted[g] > 0) {
                        // lookup gesture recognizer
                        r = this.dependencyMap[g];
                        // recognizer index
                        ri = r ? r.index : -1;
                        currentGestures[ri] = true;
                    }
                }
            }
        },
        // LISTENER LOGIC
        eventHandler: function(inEvent) {
            // This is used to prevent multiple dispatch of events from
            // platform events. This can happen when two elements in different scopes
            // are set up to create pointer events, which is relevant to Shadow DOM.

            var type = inEvent.type;

            // only generate the list of desired events on "down"
            if (type === 'touchstart' || type === 'mousedown' || type === 'pointerdown' || type === 'MSPointerDown') {
                if (!inEvent._handledByPG) {
                    currentGestures = {};
                }

                // in IOS mode, there is only a listener on the document, so this is not re-entrant
                if (this.IS_IOS) {
                    var ev = inEvent;
                    if (type === 'touchstart') {
                        var ct = inEvent.changedTouches[0];
                        // set up a fake event to give to the path builder
                        ev = {
                            target: inEvent.target,
                            clientX: ct.clientX,
                            clientY: ct.clientY,
                            path: inEvent.path
                        };
                    }
                    // use event path if available, otherwise build a path from target finding
                    var nodes = inEvent.path || scope.targetFinding.path(ev);
                    for (var i = 0, n; i < nodes.length; i++) {
                        n = nodes[i];
                        this.addGestureDependency(n, currentGestures);
                    }
                } else {
                    this.addGestureDependency(inEvent.currentTarget, currentGestures);
                }
            }

            if (inEvent._handledByPG) {
                return;
            }
            var fn = this.eventMap && this.eventMap[type];
            if (fn) {
                fn(inEvent);
            }
            inEvent._handledByPG = true;
        },
        // set up event listeners
        listen: function(target, events) {
            for (var i = 0, l = events.length, e;
                (i < l) && (e = events[i]); i++) {
                this.addEvent(target, e);
            }
        },
        // remove event listeners
        unlisten: function(target, events) {
            for (var i = 0, l = events.length, e;
                (i < l) && (e = events[i]); i++) {
                this.removeEvent(target, e);
            }
        },
        addEvent: function(target, eventName) {
            target.addEventListener(eventName, this.boundHandler);
        },
        removeEvent: function(target, eventName) {
            target.removeEventListener(eventName, this.boundHandler);
        },
        // EVENT CREATION AND TRACKING
        /**
         * Creates a new Event of type `inType`, based on the information in
         * `inEvent`.
         *
         * @param {string} inType A string representing the type of event to create
         * @param {Event} inEvent A platform event with a target
         * @return {Event} A PointerEvent of type `inType`
         */
        makeEvent: function(inType, inEvent) {
            var e = eventFactory.makePointerEvent(inType, inEvent);
            e.preventDefault = inEvent.preventDefault;
            e.tapPrevented = inEvent.tapPrevented;
            e._target = e._target || inEvent.target;
            return e;
        },
        // make and dispatch an event in one call
        fireEvent: function(inType, inEvent) {
            var e = this.makeEvent(inType, inEvent);
            return this.dispatchEvent(e);
        },
        /**
         * Returns a snapshot of inEvent, with writable properties.
         *
         * @param {Event} inEvent An event that contains properties to copy.
         * @return {Object} An object containing shallow copies of `inEvent`'s
         *    properties.
         */
        cloneEvent: function(inEvent) {
            var eventCopy = Object.create(null),
                p;
            for (var i = 0; i < CLONE_PROPS.length; i++) {
                p = CLONE_PROPS[i];
                eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];
                // Work around SVGInstanceElement shadow tree
                // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
                // This is the behavior implemented by Firefox.
                if (p === 'target' || p === 'relatedTarget') {
                    if (HAS_SVG_INSTANCE && eventCopy[p] instanceof SVGElementInstance) {
                        eventCopy[p] = eventCopy[p].correspondingUseElement;
                    }
                }
            }
            // keep the semantics of preventDefault
            eventCopy.preventDefault = function() {
                inEvent.preventDefault();
            };
            return eventCopy;
        },
        /**
         * Dispatches the event to its target.
         *
         * @param {Event} inEvent The event to be dispatched.
         * @return {Boolean} True if an event handler returns true, false otherwise.
         */
        dispatchEvent: function(inEvent) {
            var t = inEvent._target;
            if (t) {
                t.dispatchEvent(inEvent);
                // clone the event for the gesture system to process
                // clone after dispatch to pick up gesture prevention code
                var clone = this.cloneEvent(inEvent);
                clone.target = t;
                this.fillGestureQueue(clone);
            }
        },
        gestureTrigger: function() {
            // process the gesture queue
            for (var i = 0, e, rg; i < this.gestureQueue.length; i++) {
                e = this.gestureQueue[i];
                rg = e._requiredGestures;
                if (rg) {
                    for (var j = 0, g, fn; j < this.gestures.length; j++) {
                        // only run recognizer if an element in the source event's path is listening for those gestures
                        if (rg[j]) {
                            g = this.gestures[j];
                            fn = g[e.type];
                            if (fn) {
                                fn.call(g, e);
                            }
                        }
                    }
                }
            }
            this.gestureQueue.length = 0;
        },
        fillGestureQueue: function(ev) {
            // only trigger the gesture queue once
            if (!this.gestureQueue.length) {
                requestAnimationFrame(this.boundGestureTrigger);
            }
            ev._requiredGestures = this.requiredGestures.get(ev.pointerId);
            this.gestureQueue.push(ev);
        }
    };
    dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);
    dispatcher.boundGestureTrigger = dispatcher.gestureTrigger.bind(dispatcher);
    scope.dispatcher = dispatcher;

    /**
     * Listen for `gesture` on `node` with the `handler` function
     *
     * If `handler` is the first listener for `gesture`, the underlying gesture recognizer is then enabled.
     *
     * @param {Element} node
     * @param {string} gesture
     * @return Boolean `gesture` is a valid gesture
     */
    scope.activateGesture = function(node, gesture) {
        var g = gesture.toLowerCase();
        var dep = dispatcher.dependencyMap[g];
        if (dep) {
            var recognizer = dispatcher.gestures[dep.index];
            if (!node._pgListeners) {
                dispatcher.register(node);
                node._pgListeners = 0;
            }
            // TODO(dfreedm): re-evaluate bookkeeping to avoid using attributes
            if (recognizer) {
                var touchAction = recognizer.defaultActions && recognizer.defaultActions[g];
                var actionNode;
                switch (node.nodeType) {
                    case Node.ELEMENT_NODE:
                        actionNode = node;
                        break;
                    case Node.DOCUMENT_FRAGMENT_NODE:
                        actionNode = node.host;
                        break;
                    default:
                        actionNode = null;
                        break;
                }
                if (touchAction && actionNode && !actionNode.hasAttribute('touch-action')) {
                    actionNode.setAttribute('touch-action', touchAction);
                }
            }
            if (!node._pgEvents) {
                node._pgEvents = {};
            }
            node._pgEvents[g] = (node._pgEvents[g] || 0) + 1;
            node._pgListeners++;
        }
        return Boolean(dep);
    };

    /**
     *
     * Listen for `gesture` from `node` with `handler` function.
     *
     * @param {Element} node
     * @param {string} gesture
     * @param {Function} handler
     * @param {Boolean} capture
     */
    scope.addEventListener = function(node, gesture, handler, capture) {
        if (handler) {
            scope.activateGesture(node, gesture);
            node.addEventListener(gesture, handler, capture);
        }
    };

    /**
     * Tears down the gesture configuration for `node`
     *
     * If `handler` is the last listener for `gesture`, the underlying gesture recognizer is disabled.
     *
     * @param {Element} node
     * @param {string} gesture
     * @return Boolean `gesture` is a valid gesture
     */
    scope.deactivateGesture = function(node, gesture) {
        var g = gesture.toLowerCase();
        var dep = dispatcher.dependencyMap[g];
        if (dep) {
            if (node._pgListeners > 0) {
                node._pgListeners--;
            }
            if (node._pgListeners === 0) {
                dispatcher.unregister(node);
            }
            if (node._pgEvents) {
                if (node._pgEvents[g] > 0) {
                    node._pgEvents[g]--;
                } else {
                    node._pgEvents[g] = 0;
                }
            }
        }
        return Boolean(dep);
    };

    /**
     * Stop listening for `gesture` from `node` with `handler` function.
     *
     * @param {Element} node
     * @param {string} gesture
     * @param {Function} handler
     * @param {Boolean} capture
     */
    scope.removeEventListener = function(node, gesture, handler, capture) {
        if (handler) {
            scope.deactivateGesture(node, gesture);
            node.removeEventListener(gesture, handler, capture);
        }
    };
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    // radius around touchend that swallows mouse events
    var DEDUP_DIST = 25;

    var WHICH_TO_BUTTONS = [0, 1, 4, 2];

    var currentButtons = 0;

    var FIREFOX_LINUX = /Linux.*Firefox\//i;

    var HAS_BUTTONS = (function() {
        // firefox on linux returns spec-incorrect values for mouseup.buttons
        // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.buttons#See_also
        // https://codereview.chromium.org/727593003/#msg16
        if (FIREFOX_LINUX.test(navigator.userAgent)) {
            return false;
        }
        try {
            return new MouseEvent('test', {
                buttons: 1
            }).buttons === 1;
        } catch (e) {
            return false;
        }
    })();

    // handler block for native mouse events
    var mouseEvents = {
        POINTER_ID: 1,
        POINTER_TYPE: 'mouse',
        events: [
            'mousedown',
            'mousemove',
            'mouseup'
        ],
        exposes: [
            'down',
            'up',
            'move'
        ],
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        lastTouches: [],
        // collide with the global mouse listener
        isEventSimulatedFromTouch: function(inEvent) {
            var lts = this.lastTouches;
            var x = inEvent.clientX,
                y = inEvent.clientY;
            for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
                // simulated mouse events will be swallowed near a primary touchend
                var dx = Math.abs(x - t.x),
                    dy = Math.abs(y - t.y);
                if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
                    return true;
                }
            }
        },
        prepareEvent: function(inEvent) {
            var e = dispatcher.cloneEvent(inEvent);
            e.pointerId = this.POINTER_ID;
            e.isPrimary = true;
            e.pointerType = this.POINTER_TYPE;
            e._source = 'mouse';
            if (!HAS_BUTTONS) {
                var type = inEvent.type;
                var bit = WHICH_TO_BUTTONS[inEvent.which] || 0;
                if (type === 'mousedown') {
                    currentButtons |= bit;
                } else if (type === 'mouseup') {
                    currentButtons &= ~bit;
                }
                e.buttons = currentButtons;
            }
            return e;
        },
        mousedown: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var p = pointermap.has(this.POINTER_ID);
                var e = this.prepareEvent(inEvent);
                e.target = scope.findTarget(inEvent);
                pointermap.set(this.POINTER_ID, e.target);
                dispatcher.down(e);
            }
        },
        mousemove: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var target = pointermap.get(this.POINTER_ID);
                if (target) {
                    var e = this.prepareEvent(inEvent);
                    e.target = target;
                    // handle case where we missed a mouseup
                    if ((HAS_BUTTONS ? e.buttons : e.which) === 0) {
                        if (!HAS_BUTTONS) {
                            currentButtons = e.buttons = 0;
                        }
                        dispatcher.cancel(e);
                        this.cleanupMouse(e.buttons);
                    } else {
                        dispatcher.move(e);
                    }
                }
            }
        },
        mouseup: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var e = this.prepareEvent(inEvent);
                e.relatedTarget = scope.findTarget(inEvent);
                e.target = pointermap.get(this.POINTER_ID);
                dispatcher.up(e);
                this.cleanupMouse(e.buttons);
            }
        },
        cleanupMouse: function(buttons) {
            if (buttons === 0) {
                pointermap.delete(this.POINTER_ID);
            }
        }
    };

    scope.mouseEvents = mouseEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var allShadows = scope.targetFinding.allShadows.bind(scope.targetFinding);
    var pointermap = dispatcher.pointermap;
    var touchMap = Array.prototype.map.call.bind(Array.prototype.map);
    // This should be long enough to ignore compat mouse events made by touch
    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DIST = 25;
    var CLICK_COUNT_TIMEOUT = 200;
    var HYSTERESIS = 20;
    var ATTRIB = 'touch-action';
    // TODO(dfreedm): disable until http://crbug.com/399765 is resolved
    // var HAS_TOUCH_ACTION = ATTRIB in document.head.style;
    var HAS_TOUCH_ACTION = false;

    // handler block for native touch events
    var touchEvents = {
        IS_IOS: false,
        events: [
            'touchstart',
            'touchmove',
            'touchend',
            'touchcancel'
        ],
        exposes: [
            'down',
            'up',
            'move'
        ],
        register: function(target, initial) {
            if (this.IS_IOS ? initial : !initial) {
                dispatcher.listen(target, this.events);
            }
        },
        unregister: function(target) {
            if (!this.IS_IOS) {
                dispatcher.unlisten(target, this.events);
            }
        },
        scrollTypes: {
            EMITTER: 'none',
            XSCROLLER: 'pan-x',
            YSCROLLER: 'pan-y',
        },
        touchActionToScrollType: function(touchAction) {
            var t = touchAction;
            var st = this.scrollTypes;
            if (t === st.EMITTER) {
                return 'none';
            } else if (t === st.XSCROLLER) {
                return 'X';
            } else if (t === st.YSCROLLER) {
                return 'Y';
            } else {
                return 'XY';
            }
        },
        POINTER_TYPE: 'touch',
        firstTouch: null,
        isPrimaryTouch: function(inTouch) {
            return this.firstTouch === inTouch.identifier;
        },
        setPrimaryTouch: function(inTouch) {
            // set primary touch if there no pointers, or the only pointer is the mouse
            if (pointermap.pointers() === 0 || (pointermap.pointers() === 1 && pointermap.has(1))) {
                this.firstTouch = inTouch.identifier;
                this.firstXY = {
                    X: inTouch.clientX,
                    Y: inTouch.clientY
                };
                this.firstTarget = inTouch.target;
                this.scrolling = null;
                this.cancelResetClickCount();
            }
        },
        removePrimaryPointer: function(inPointer) {
            if (inPointer.isPrimary) {
                this.firstTouch = null;
                this.firstXY = null;
                this.resetClickCount();
            }
        },
        clickCount: 0,
        resetId: null,
        resetClickCount: function() {
            var fn = function() {
                this.clickCount = 0;
                this.resetId = null;
            }.bind(this);
            this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
        },
        cancelResetClickCount: function() {
            if (this.resetId) {
                clearTimeout(this.resetId);
            }
        },
        typeToButtons: function(type) {
            var ret = 0;
            if (type === 'touchstart' || type === 'touchmove') {
                ret = 1;
            }
            return ret;
        },
        findTarget: function(touch, id) {
            if (this.currentTouchEvent.type === 'touchstart') {
                if (this.isPrimaryTouch(touch)) {
                    var fastPath = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        path: this.currentTouchEvent.path,
                        target: this.currentTouchEvent.target
                    };
                    return scope.findTarget(fastPath);
                } else {
                    return scope.findTarget(touch);
                }
            }
            // reuse target we found in touchstart
            return pointermap.get(id);
        },
        touchToPointer: function(inTouch) {
            var cte = this.currentTouchEvent;
            var e = dispatcher.cloneEvent(inTouch);
            // Spec specifies that pointerId 1 is reserved for Mouse.
            // Touch identifiers can start at 0.
            // Add 2 to the touch identifier for compatibility.
            var id = e.pointerId = inTouch.identifier + 2;
            e.target = this.findTarget(inTouch, id);
            e.bubbles = true;
            e.cancelable = true;
            e.detail = this.clickCount;
            e.buttons = this.typeToButtons(cte.type);
            e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
            e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
            e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
            e.isPrimary = this.isPrimaryTouch(inTouch);
            e.pointerType = this.POINTER_TYPE;
            e._source = 'touch';
            // forward touch preventDefaults
            var self = this;
            e.preventDefault = function() {
                self.scrolling = false;
                self.firstXY = null;
                cte.preventDefault();
            };
            return e;
        },
        processTouches: function(inEvent, inFunction) {
            var tl = inEvent.changedTouches;
            this.currentTouchEvent = inEvent;
            for (var i = 0, t, p; i < tl.length; i++) {
                t = tl[i];
                p = this.touchToPointer(t);
                if (inEvent.type === 'touchstart') {
                    pointermap.set(p.pointerId, p.target);
                }
                if (pointermap.has(p.pointerId)) {
                    inFunction.call(this, p);
                }
                if (inEvent.type === 'touchend' || inEvent._cancel) {
                    this.cleanUpPointer(p);
                }
            }
        },
        // For single axis scrollers, determines whether the element should emit
        // pointer events or behave as a scroller
        shouldScroll: function(inEvent) {
            if (this.firstXY) {
                var ret;
                var touchAction = scope.targetFinding.findTouchAction(inEvent);
                var scrollAxis = this.touchActionToScrollType(touchAction);
                if (scrollAxis === 'none') {
                    // this element is a touch-action: none, should never scroll
                    ret = false;
                } else if (scrollAxis === 'XY') {
                    // this element should always scroll
                    ret = true;
                } else {
                    var t = inEvent.changedTouches[0];
                    // check the intended scroll axis, and other axis
                    var a = scrollAxis;
                    var oa = scrollAxis === 'Y' ? 'X' : 'Y';
                    var da = Math.abs(t['client' + a] - this.firstXY[a]);
                    var doa = Math.abs(t['client' + oa] - this.firstXY[oa]);
                    // if delta in the scroll axis > delta other axis, scroll instead of
                    // making events
                    ret = da >= doa;
                }
                return ret;
            }
        },
        findTouch: function(inTL, inId) {
            for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
                if (t.identifier === inId) {
                    return true;
                }
            }
        },
        // In some instances, a touchstart can happen without a touchend. This
        // leaves the pointermap in a broken state.
        // Therefore, on every touchstart, we remove the touches that did not fire a
        // touchend event.
        // To keep state globally consistent, we fire a
        // pointercancel for this "abandoned" touch
        vacuumTouches: function(inEvent) {
            var tl = inEvent.touches;
            // pointermap.pointers() should be < tl.length here, as the touchstart has not
            // been processed yet.
            if (pointermap.pointers() >= tl.length) {
                var d = [];
                pointermap.forEach(function(value, key) {
                    // Never remove pointerId == 1, which is mouse.
                    // Touch identifiers are 2 smaller than their pointerId, which is the
                    // index in pointermap.
                    if (key !== 1 && !this.findTouch(tl, key - 2)) {
                        var p = value;
                        d.push(p);
                    }
                }, this);
                d.forEach(function(p) {
                    this.cancel(p);
                    pointermap.delete(p.pointerId);
                }, this);
            }
        },
        touchstart: function(inEvent) {
            this.vacuumTouches(inEvent);
            this.setPrimaryTouch(inEvent.changedTouches[0]);
            this.dedupSynthMouse(inEvent);
            if (!this.scrolling) {
                this.clickCount++;
                this.processTouches(inEvent, this.down);
            }
        },
        down: function(inPointer) {
            dispatcher.down(inPointer);
        },
        touchmove: function(inEvent) {
            if (HAS_TOUCH_ACTION) {
                // touchevent.cancelable == false is sent when the page is scrolling under native Touch Action in Chrome 36
                // https://groups.google.com/a/chromium.org/d/msg/input-dev/wHnyukcYBcA/b9kmtwM1jJQJ
                if (inEvent.cancelable) {
                    this.processTouches(inEvent, this.move);
                }
            } else {
                if (!this.scrolling) {
                    if (this.scrolling === null && this.shouldScroll(inEvent)) {
                        this.scrolling = true;
                    } else {
                        this.scrolling = false;
                        inEvent.preventDefault();
                        this.processTouches(inEvent, this.move);
                    }
                } else if (this.firstXY) {
                    var t = inEvent.changedTouches[0];
                    var dx = t.clientX - this.firstXY.X;
                    var dy = t.clientY - this.firstXY.Y;
                    var dd = Math.sqrt(dx * dx + dy * dy);
                    if (dd >= HYSTERESIS) {
                        this.touchcancel(inEvent);
                        this.scrolling = true;
                        this.firstXY = null;
                    }
                }
            }
        },
        move: function(inPointer) {
            dispatcher.move(inPointer);
        },
        touchend: function(inEvent) {
            this.dedupSynthMouse(inEvent);
            this.processTouches(inEvent, this.up);
        },
        up: function(inPointer) {
            inPointer.relatedTarget = scope.findTarget(inPointer);
            dispatcher.up(inPointer);
        },
        cancel: function(inPointer) {
            dispatcher.cancel(inPointer);
        },
        touchcancel: function(inEvent) {
            inEvent._cancel = true;
            this.processTouches(inEvent, this.cancel);
        },
        cleanUpPointer: function(inPointer) {
            pointermap['delete'](inPointer.pointerId);
            this.removePrimaryPointer(inPointer);
        },
        // prevent synth mouse events from creating pointer events
        dedupSynthMouse: function(inEvent) {
            var lts = scope.mouseEvents.lastTouches;
            var t = inEvent.changedTouches[0];
            // only the primary finger will synth mouse events
            if (this.isPrimaryTouch(t)) {
                // remember x/y of last touch
                var lt = {
                    x: t.clientX,
                    y: t.clientY
                };
                lts.push(lt);
                var fn = (function(lts, lt) {
                    var i = lts.indexOf(lt);
                    if (i > -1) {
                        lts.splice(i, 1);
                    }
                }).bind(null, lts, lt);
                setTimeout(fn, DEDUP_TIMEOUT);
            }
        }
    };

    // prevent "ghost clicks" that come from elements that were removed in a touch handler
    var STOP_PROP_FN = Event.prototype.stopImmediatePropagation || Event.prototype.stopPropagation;
    document.addEventListener('click', function(ev) {
        var x = ev.clientX,
            y = ev.clientY;
        // check if a click is within DEDUP_DIST px radius of the touchstart
        var closeTo = function(touch) {
            var dx = Math.abs(x - touch.x),
                dy = Math.abs(y - touch.y);
            return (dx <= DEDUP_DIST && dy <= DEDUP_DIST);
        };
        // if click coordinates are close to touch coordinates, assume the click came from a touch
        var wasTouched = scope.mouseEvents.lastTouches.some(closeTo);
        // if the click came from touch, and the touchstart target is not in the path of the click event,
        // then the touchstart target was probably removed, and the click should be "busted"
        var path = scope.targetFinding.path(ev);
        if (wasTouched) {
            for (var i = 0; i < path.length; i++) {
                if (path[i] === touchEvents.firstTarget) {
                    return;
                }
            }
            ev.preventDefault();
            STOP_PROP_FN.call(ev);
        }
    }, true);

    scope.touchEvents = touchEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    var HAS_BITMAP_TYPE = window.MSPointerEvent && typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number';
    var msEvents = {
        events: [
            'MSPointerDown',
            'MSPointerMove',
            'MSPointerUp',
            'MSPointerCancel',
        ],
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        POINTER_TYPES: [
            '',
            'unavailable',
            'touch',
            'pen',
            'mouse'
        ],
        prepareEvent: function(inEvent) {
            var e = inEvent;
            e = dispatcher.cloneEvent(inEvent);
            if (HAS_BITMAP_TYPE) {
                e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
            }
            e._source = 'ms';
            return e;
        },
        cleanup: function(id) {
            pointermap['delete'](id);
        },
        MSPointerDown: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.target = scope.findTarget(inEvent);
            pointermap.set(inEvent.pointerId, e.target);
            dispatcher.down(e);
        },
        MSPointerMove: function(inEvent) {
            var target = pointermap.get(inEvent.pointerId);
            if (target) {
                var e = this.prepareEvent(inEvent);
                e.target = target;
                dispatcher.move(e);
            }
        },
        MSPointerUp: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.up(e);
            this.cleanup(inEvent.pointerId);
        },
        MSPointerCancel: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.cancel(e);
            this.cleanup(inEvent.pointerId);
        }
    };

    scope.msEvents = msEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    var pointerEvents = {
        events: [
            'pointerdown',
            'pointermove',
            'pointerup',
            'pointercancel'
        ],
        prepareEvent: function(inEvent) {
            var e = dispatcher.cloneEvent(inEvent);
            e._source = 'pointer';
            return e;
        },
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        cleanup: function(id) {
            pointermap['delete'](id);
        },
        pointerdown: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.target = scope.findTarget(inEvent);
            pointermap.set(e.pointerId, e.target);
            dispatcher.down(e);
        },
        pointermove: function(inEvent) {
            var target = pointermap.get(inEvent.pointerId);
            if (target) {
                var e = this.prepareEvent(inEvent);
                e.target = target;
                dispatcher.move(e);
            }
        },
        pointerup: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.up(e);
            this.cleanup(inEvent.pointerId);
        },
        pointercancel: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.cancel(e);
            this.cleanup(inEvent.pointerId);
        }
    };

    scope.pointerEvents = pointerEvents;
})(exports);

/**
 * This module contains the handlers for native platform events.
 * From here, the dispatcher is called to create unified pointer events.
 * Included are touch events (v1), mouse events, and MSPointerEvents.
 */
(function(scope) {

    var dispatcher = scope.dispatcher;
    var nav = window.navigator;

    if (window.PointerEvent) {
        dispatcher.registerSource('pointer', scope.pointerEvents);
    } else if (nav.msPointerEnabled) {
        dispatcher.registerSource('ms', scope.msEvents);
    } else {
        dispatcher.registerSource('mouse', scope.mouseEvents);
        if (window.ontouchstart !== undefined) {
            dispatcher.registerSource('touch', scope.touchEvents);
        }
    }

    // Work around iOS bugs https://bugs.webkit.org/show_bug.cgi?id=135628 and https://bugs.webkit.org/show_bug.cgi?id=136506
    var ua = navigator.userAgent;
    var IS_IOS = ua.match(/iPad|iPhone|iPod/) && 'ontouchstart' in window;

    dispatcher.IS_IOS = IS_IOS;
    scope.touchEvents.IS_IOS = IS_IOS;

    dispatcher.register(document, true);
})(exports);

/**
 * This event denotes the beginning of a series of tracking events.
 *
 * @module PointerGestures
 * @submodule Events
 * @class trackstart
 */
/**
 * Pixels moved in the x direction since trackstart.
 * @type Number
 * @property dx
 */
/**
 * Pixes moved in the y direction since trackstart.
 * @type Number
 * @property dy
 */
/**
 * Pixels moved in the x direction since the last track.
 * @type Number
 * @property ddx
 */
/**
 * Pixles moved in the y direction since the last track.
 * @type Number
 * @property ddy
 */
/**
 * The clientX position of the track gesture.
 * @type Number
 * @property clientX
 */
/**
 * The clientY position of the track gesture.
 * @type Number
 * @property clientY
 */
/**
 * The pageX position of the track gesture.
 * @type Number
 * @property pageX
 */
/**
 * The pageY position of the track gesture.
 * @type Number
 * @property pageY
 */
/**
 * The screenX position of the track gesture.
 * @type Number
 * @property screenX
 */
/**
 * The screenY position of the track gesture.
 * @type Number
 * @property screenY
 */
/**
 * The last x axis direction of the pointer.
 * @type Number
 * @property xDirection
 */
/**
 * The last y axis direction of the pointer.
 * @type Number
 * @property yDirection
 */
/**
 * A shared object between all tracking events.
 * @type Object
 * @property trackInfo
 */
/**
 * The element currently under the pointer.
 * @type Element
 * @property relatedTarget
 */
/**
 * The type of pointer that make the track gesture.
 * @type String
 * @property pointerType
 */
/**
 *
 * This event fires for all pointer movement being tracked.
 *
 * @class track
 * @extends trackstart
 */
/**
 * This event fires when the pointer is no longer being tracked.
 *
 * @class trackend
 * @extends trackstart
 */

(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var track = {
        events: [
            'down',
            'move',
            'up',
        ],
        exposes: [
            'trackstart',
            'track',
            'trackx',
            'tracky',
            'trackend'
        ],
        defaultActions: {
            'track': 'none',
            'trackx': 'pan-y',
            'tracky': 'pan-x'
        },
        WIGGLE_THRESHOLD: 4,
        clampDir: function(inDelta) {
            return inDelta > 0 ? 1 : -1;
        },
        calcPositionDelta: function(inA, inB) {
            var x = 0,
                y = 0;
            if (inA && inB) {
                x = inB.pageX - inA.pageX;
                y = inB.pageY - inA.pageY;
            }
            return {
                x: x,
                y: y
            };
        },
        fireTrack: function(inType, inEvent, inTrackingData) {
            var t = inTrackingData;
            var d = this.calcPositionDelta(t.downEvent, inEvent);
            var dd = this.calcPositionDelta(t.lastMoveEvent, inEvent);
            if (dd.x) {
                t.xDirection = this.clampDir(dd.x);
            } else if (inType === 'trackx') {
                return;
            }
            if (dd.y) {
                t.yDirection = this.clampDir(dd.y);
            } else if (inType === 'tracky') {
                return;
            }
            var gestureProto = {
                bubbles: true,
                cancelable: true,
                trackInfo: t.trackInfo,
                relatedTarget: inEvent.relatedTarget,
                pointerType: inEvent.pointerType,
                pointerId: inEvent.pointerId,
                _source: 'track'
            };
            if (inType !== 'tracky') {
                gestureProto.x = inEvent.x;
                gestureProto.dx = d.x;
                gestureProto.ddx = dd.x;
                gestureProto.clientX = inEvent.clientX;
                gestureProto.pageX = inEvent.pageX;
                gestureProto.screenX = inEvent.screenX;
                gestureProto.xDirection = t.xDirection;
            }
            if (inType !== 'trackx') {
                gestureProto.dy = d.y;
                gestureProto.ddy = dd.y;
                gestureProto.y = inEvent.y;
                gestureProto.clientY = inEvent.clientY;
                gestureProto.pageY = inEvent.pageY;
                gestureProto.screenY = inEvent.screenY;
                gestureProto.yDirection = t.yDirection;
            }
            var e = eventFactory.makeGestureEvent(inType, gestureProto);
            t.downTarget.dispatchEvent(e);
        },
        down: function(inEvent) {
            if (inEvent.isPrimary && (inEvent.pointerType === 'mouse' ? inEvent.buttons === 1 : true)) {
                var p = {
                    downEvent: inEvent,
                    downTarget: inEvent.target,
                    trackInfo: {},
                    lastMoveEvent: null,
                    xDirection: 0,
                    yDirection: 0,
                    tracking: false
                };
                pointermap.set(inEvent.pointerId, p);
            }
        },
        move: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            if (p) {
                if (!p.tracking) {
                    var d = this.calcPositionDelta(p.downEvent, inEvent);
                    var move = d.x * d.x + d.y * d.y;
                    // start tracking only if finger moves more than WIGGLE_THRESHOLD
                    if (move > this.WIGGLE_THRESHOLD) {
                        p.tracking = true;
                        p.lastMoveEvent = p.downEvent;
                        this.fireTrack('trackstart', inEvent, p);
                    }
                }
                if (p.tracking) {
                    this.fireTrack('track', inEvent, p);
                    this.fireTrack('trackx', inEvent, p);
                    this.fireTrack('tracky', inEvent, p);
                }
                p.lastMoveEvent = inEvent;
            }
        },
        up: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            if (p) {
                if (p.tracking) {
                    this.fireTrack('trackend', inEvent, p);
                }
                pointermap.delete(inEvent.pointerId);
            }
        }
    };
    dispatcher.registerGesture('track', track);
})(exports);

/**
 * This event is fired when a pointer is held down for 200ms.
 *
 * @module PointerGestures
 * @submodule Events
 * @class hold
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * Screen X axis position of the held pointer
 * @type Number
 * @property clientX
 */
/**
 * Screen Y axis position of the held pointer
 * @type Number
 * @property clientY
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * This event is fired every 200ms while a pointer is held down.
 *
 * @class holdpulse
 * @extends hold
 */
/**
 * Milliseconds pointer has been held down.
 * @type Number
 * @property holdTime
 */
/**
 * This event is fired when a held pointer is released or moved.
 *
 * @class release
 */

(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var hold = {
        // wait at least HOLD_DELAY ms between hold and pulse events
        HOLD_DELAY: 200,
        // pointer can move WIGGLE_THRESHOLD pixels before not counting as a hold
        WIGGLE_THRESHOLD: 16,
        events: [
            'down',
            'move',
            'up',
        ],
        exposes: [
            'hold',
            'holdpulse',
            'release'
        ],
        heldPointer: null,
        holdJob: null,
        pulse: function() {
            var hold = Date.now() - this.heldPointer.timeStamp;
            var type = this.held ? 'holdpulse' : 'hold';
            this.fireHold(type, hold);
            this.held = true;
        },
        cancel: function() {
            clearInterval(this.holdJob);
            if (this.held) {
                this.fireHold('release');
            }
            this.held = false;
            this.heldPointer = null;
            this.target = null;
            this.holdJob = null;
        },
        down: function(inEvent) {
            if (inEvent.isPrimary && !this.heldPointer) {
                this.heldPointer = inEvent;
                this.target = inEvent.target;
                this.holdJob = setInterval(this.pulse.bind(this), this.HOLD_DELAY);
            }
        },
        up: function(inEvent) {
            if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
                this.cancel();
            }
        },
        move: function(inEvent) {
            if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
                var x = inEvent.clientX - this.heldPointer.clientX;
                var y = inEvent.clientY - this.heldPointer.clientY;
                if ((x * x + y * y) > this.WIGGLE_THRESHOLD) {
                    this.cancel();
                }
            }
        },
        fireHold: function(inType, inHoldTime) {
            var p = {
                bubbles: true,
                cancelable: true,
                pointerType: this.heldPointer.pointerType,
                pointerId: this.heldPointer.pointerId,
                x: this.heldPointer.clientX,
                y: this.heldPointer.clientY,
                _source: 'hold'
            };
            if (inHoldTime) {
                p.holdTime = inHoldTime;
            }
            var e = eventFactory.makeGestureEvent(inType, p);
            this.target.dispatchEvent(e);
        }
    };
    dispatcher.registerGesture('hold', hold);
})(exports);

/**
 * This event is fired when a pointer quickly goes down and up, and is used to
 * denote activation.
 *
 * Any gesture event can prevent the tap event from being created by calling
 * `event.preventTap`.
 *
 * Any pointer event can prevent the tap by setting the `tapPrevented` property
 * on itself.
 *
 * @module PointerGestures
 * @submodule Events
 * @class tap
 */
/**
 * X axis position of the tap.
 * @property x
 * @type Number
 */
/**
 * Y axis position of the tap.
 * @property y
 * @type Number
 */
/**
 * Type of the pointer that made the tap.
 * @property pointerType
 * @type String
 */
(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var tap = {
        events: [
            'down',
            'up'
        ],
        exposes: [
            'tap'
        ],
        down: function(inEvent) {
            if (inEvent.isPrimary && !inEvent.tapPrevented) {
                pointermap.set(inEvent.pointerId, {
                    target: inEvent.target,
                    buttons: inEvent.buttons,
                    x: inEvent.clientX,
                    y: inEvent.clientY
                });
            }
        },
        shouldTap: function(e, downState) {
            var tap = true;
            if (e.pointerType === 'mouse') {
                // only allow left click to tap for mouse
                tap = (e.buttons ^ 1) && (downState.buttons & 1);
            }
            return tap && !e.tapPrevented;
        },
        up: function(inEvent) {
            var start = pointermap.get(inEvent.pointerId);
            if (start && this.shouldTap(inEvent, start)) {
                // up.relatedTarget is target currently under finger
                var t = scope.targetFinding.LCA(start.target, inEvent.relatedTarget);
                if (t) {
                    var e = eventFactory.makeGestureEvent('tap', {
                        bubbles: true,
                        cancelable: true,
                        x: inEvent.clientX,
                        y: inEvent.clientY,
                        detail: inEvent.detail,
                        pointerType: inEvent.pointerType,
                        pointerId: inEvent.pointerId,
                        altKey: inEvent.altKey,
                        ctrlKey: inEvent.ctrlKey,
                        metaKey: inEvent.metaKey,
                        shiftKey: inEvent.shiftKey,
                        _source: 'tap'
                    });
                    t.dispatchEvent(e);
                }
            }
            pointermap.delete(inEvent.pointerId);
        }
    };
    // patch eventFactory to remove id from tap's pointermap for preventTap calls
    eventFactory.preventTap = function(e) {
        return function() {
            e.tapPrevented = true;
            pointermap.delete(e.pointerId);
        };
    };
    dispatcher.registerGesture('tap', tap);
})(exports);

/*
 * Basic strategy: find the farthest apart points, use as diameter of circle
 * react to size change and rotation of the chord
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class pinch
 */
/**
 * Scale of the pinch zoom gesture
 * @property scale
 * @type Number
 */
/**
 * Center X position of pointers causing pinch
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing pinch
 * @property centerY
 * @type Number
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class rotate
 */
/**
 * Angle (in degrees) of rotation. Measured from starting positions of pointers.
 * @property angle
 * @type Number
 */
/**
 * Center X position of pointers causing rotation
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing rotation
 * @property centerY
 * @type Number
 */
(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var RAD_TO_DEG = 180 / Math.PI;
    var pinch = {
        events: [
            'down',
            'up',
            'move',
            'cancel'
        ],
        exposes: [
            'pinchstart',
            'pinch',
            'pinchend',
            'rotate'
        ],
        defaultActions: {
            'pinch': 'none',
            'rotate': 'none'
        },
        reference: {},
        down: function(inEvent) {
            pointermap.set(inEvent.pointerId, inEvent);
            if (pointermap.pointers() == 2) {
                var points = this.calcChord();
                var angle = this.calcAngle(points);
                this.reference = {
                    angle: angle,
                    diameter: points.diameter,
                    target: scope.targetFinding.LCA(points.a.target, points.b.target)
                };

                this.firePinch('pinchstart', points.diameter, points);
            }
        },
        up: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            var num = pointermap.pointers();
            if (p) {
                if (num === 2) {
                    // fire 'pinchend' before deleting pointer
                    var points = this.calcChord();
                    this.firePinch('pinchend', points.diameter, points);
                }
                pointermap.delete(inEvent.pointerId);
            }
        },
        move: function(inEvent) {
            if (pointermap.has(inEvent.pointerId)) {
                pointermap.set(inEvent.pointerId, inEvent);
                if (pointermap.pointers() > 1) {
                    this.calcPinchRotate();
                }
            }
        },
        cancel: function(inEvent) {
            this.up(inEvent);
        },
        firePinch: function(type, diameter, points) {
            var zoom = diameter / this.reference.diameter;
            var e = eventFactory.makeGestureEvent(type, {
                bubbles: true,
                cancelable: true,
                scale: zoom,
                centerX: points.center.x,
                centerY: points.center.y,
                _source: 'pinch'
            });
            this.reference.target.dispatchEvent(e);
        },
        fireRotate: function(angle, points) {
            var diff = Math.round((angle - this.reference.angle) % 360);
            var e = eventFactory.makeGestureEvent('rotate', {
                bubbles: true,
                cancelable: true,
                angle: diff,
                centerX: points.center.x,
                centerY: points.center.y,
                _source: 'pinch'
            });
            this.reference.target.dispatchEvent(e);
        },
        calcPinchRotate: function() {
            var points = this.calcChord();
            var diameter = points.diameter;
            var angle = this.calcAngle(points);
            if (diameter != this.reference.diameter) {
                this.firePinch('pinch', diameter, points);
            }
            if (angle != this.reference.angle) {
                this.fireRotate(angle, points);
            }
        },
        calcChord: function() {
            var pointers = [];
            pointermap.forEach(function(p) {
                pointers.push(p);
            });
            var dist = 0;
            // start with at least two pointers
            var points = {
                a: pointers[0],
                b: pointers[1]
            };
            var x, y, d;
            for (var i = 0; i < pointers.length; i++) {
                var a = pointers[i];
                for (var j = i + 1; j < pointers.length; j++) {
                    var b = pointers[j];
                    x = Math.abs(a.clientX - b.clientX);
                    y = Math.abs(a.clientY - b.clientY);
                    d = x + y;
                    if (d > dist) {
                        dist = d;
                        points = {
                            a: a,
                            b: b
                        };
                    }
                }
            }
            x = Math.abs(points.a.clientX + points.b.clientX) / 2;
            y = Math.abs(points.a.clientY + points.b.clientY) / 2;
            points.center = {
                x: x,
                y: y
            };
            points.diameter = dist;
            return points;
        },
        calcAngle: function(points) {
            var x = points.a.clientX - points.b.clientX;
            var y = points.a.clientY - points.b.clientY;
            return (360 + Math.atan2(y, x) * RAD_TO_DEG) % 360;
        }
    };
    dispatcher.registerGesture('pinch', pinch);
})(exports);
},{}],9:[function(require,module,exports){
'use strict';

var Base = require('extend-me').Base;

var DataNodeBase = Base.extend('DataNodeBase', {

    isNullObject: false,

    INDENT: '   ', // 3 spaces

    initialize: function(key) {
        this.label = key;
        this.data = ['']; // TODO: Why is this first element needed?
        this.index = []; // TODO: formerly rowIndex
        this.hasChildren = false; // TODO: Where/how is this used?
        this.depth = 0;
        this.height = 1;
        this.expanded = false;
    },

    getValue: function(x) {
        return this.data[x];
    },

    prune: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    computeDepthString: function() {
        return Array(this.depth + 1).join(this.INDENT) + '  ' + this.label;
    },

    computeHeight: function() {
        return 1;
    },

    getIndex: function() { // TODO: formerly getAllRowIndexes
        return this.index;
    },

    computeAggregates: function(aggregator) {
        var index = this.getIndex();

        if (index.length) {
            var groupsOffset = Number(aggregator.hasGroups());

            // redimension the data
            var data = this.data;
            data.length = groupsOffset + aggregator.aggregates.length;

            var sorter = aggregator.sorterInstance;
            sorter.index = index;

            aggregator.aggregates.forEach(function(aggregate, i) {
                data[groupsOffset + i] = aggregate(sorter);
            });
        }
    },

    buildView: function(aggregator) {
        aggregator.addView(this);
    },

    toggleExpansionState: function() { /* aggregator */
        //do nothing by default
    }

});

//DataNodeBase.prototype.applyAggregates = DataNodeBase.prototype.computeAggregates;

module.exports = DataNodeBase;
},{"extend-me":3}],10:[function(require,module,exports){
'use strict';

var Map = require('./util/Mappy');
var DataNodeBase = require('./DataNodeBase');

var expandedMap = {
    true: '\u25be', // ''
    false: '\u25b8' // ''
};

var DataNodeGroup = DataNodeBase.extend('DataNodeGroup', {

    extendable: true,

    initialize: function(key) {
        this.children = new Map();
    },

    prune: function(depth) {
        this.depth = depth;
        this.children = this.children.values; // TODO: why?
        this.children.forEach(function(child) {
            child.prune(depth + 1);
        });
        this.data[0] = this.computeDepthString();
    },

    computeDepthString: function() {
        return Array(this.depth + 1).join(this.INDENT) +
            expandedMap[this.expanded] + ' ' +
            this.label;
    },

    getIndex: function() {
        if (this.index.length === 0) {
            this.index = this.computeIndex();
        }
        return this.index;
    },

    computeIndex: function() { // TODO: formerly computerAllRowIndexes
        var result = [];
        result.append = append;
        this.children.forEach(function(child) {
            result.append(child.getIndex());
        });
        return result;
    },

    toggleExpansionState: function(aggregator) { /* aggregator */
        this.expanded = !this.expanded;
        this.data[0] = this.computeDepthString();
        if (this.expanded) {
            this.computeAggregates(aggregator);
        }
    },

    computeAggregates: function(aggregator) {
        DataNodeBase.prototype.computeAggregates.call(this, aggregator); // call base class's version
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.computeAggregates(aggregator);
            });
        }
    },

    buildView: function(aggregator) {
        aggregator.view.push(this);
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.buildView(aggregator);
            });
        }
    },

    computeHeight: function() {
        var height = 1;

        if (this.expanded) {
            this.children.forEach(function(child) {
                height = height + child.computeHeight();
            });
        }

        return (this.height = height);
    }

});

/**
 * @summary Array mixin to append another array to end of `this` one.
 * @desc Appends in place, unlike `this.concat()` which creates a new array.
 * Uses less memory than concat, important when `appendix` is huge.
 * > CAUTION: Mutates `this` array!
 * @param {Array} appendix
 * @returns {Array} Reference to `this` (for convenience)
 */
function append(appendix) {
    this.splice.bind(this, this.length, 0).apply(this, appendix);
    return this;
}

module.exports = DataNodeGroup;
},{"./DataNodeBase":9,"./util/Mappy":21}],11:[function(require,module,exports){
'use strict';

var DataNodeBase = require('./DataNodeBase');

var DataNodeLeaf = DataNodeBase.extend('DataNodeLeaf', {

    prune: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    getIndex: function() {
        return this.index;
    },

    buildView: function(aggregator) {
        aggregator.addView(this);
    },

    computeHeight: function() {
        return 1;
    }

});

module.exports = DataNodeLeaf;
},{"./DataNodeBase":9}],12:[function(require,module,exports){
'use strict';

var DataNodeGroup = require('./DataNodeGroup');

var DataNodeTree = DataNodeGroup.extend('DataNodeTree', {

    initialize: function(key) {
        this.height = 0;
        this.expanded = true;
    },

    prune: function() {
        this.children = this.children.values;
        this.children.forEach(function(child) {
            child.prune(0);
        });
    },

    buildView: function(aggregator) {
        this.children.forEach(function(child) {
            child.buildView(aggregator);
        });
    },

    computeHeight: function() {
        var height = 1;

        this.children.forEach(function(child) {
            height = height + child.computeHeight();
        });

        return (this.height = height);
    }

});

module.exports = DataNodeTree;
},{"./DataNodeGroup":10}],13:[function(require,module,exports){
'use strict';

var headerify = require('./util/headerify');

function DataSource(data, fields) {
    this.fields = fields || computeFieldNames(data[0]);
    this.data = data;
}

DataSource.prototype = {
    constructor: DataSource.prototype.constructor, // preserve constructor

    isNullObject: false,

    getRow: function(y) {
        return this.data[y];
    },

    getValue: function(x, y) {
        var row = this.getRow(y);
        if (!row) {
            return null;
        }
        return row[this.fields[x]];
    },

    setValue: function(x, y, value) {
        this.getRow(y)[this.fields[x]] = value;
    },

    getRowCount: function() {
        return this.data.length;
    },

    getColumnCount: function() {
        return this.getFields().length;
    },

    getFields: function() {
        return this.fields;
    },

    getHeaders: function() {
        return (
            this.headers = this.headers ||
            this.getDefaultHeaders().map(function(each) {
                return headerify(each);
            })
        );
    },

    getDefaultHeaders: function() {
        return this.getFields();
    },

    setFields: function(fields) {
        this.fields = fields;
    },

    setHeaders: function(headers) {
        if (!(headers instanceof Array)) {
            error('setHeaders', 'param #1 `headers` not array');
        }
        this.headers = headers;
    },

    getGrandTotals: function() {
        //nothing here
        return;
    },

    setData: function(arrayOfUniformObjects) {
        this.data = arrayOfUniformObjects;
    }
};

function error(methodName, message) {
    throw new Error('DataSource.' + methodName + ': ' + message);
}

function computeFieldNames(object) {
    if (!object) {
        return [];
    }
    var fields = [].concat(Object.getOwnPropertyNames(object).filter(function(e) {
        return e.substr(0, 2) !== '__';
    }));
    return fields;
}

module.exports = DataSource;
},{"./util/headerify":23}],14:[function(require,module,exports){
'use strict';

var _ = require('object-iterators');

var DataSourceSorter = require('./DataSourceSorter');
var DataNodeTree = require('./DataNodeTree');
var DataNodeGroup = require('./DataNodeGroup');
var DataNodeLeaf = require('./DataNodeLeaf');
var headerify = require('./util/headerify');

//?[t,c,b,a]
// t is a dataSource,
// a is a dictionary of aggregates,  columnName:function
// b is a dictionary of groupbys, columnName:sourceColumnName
// c is a list of constraints,

function DataSourceAggregator(dataSource) {
    this.dataSource = dataSource;
    this.tree = new DataNodeTree('Totals');
    this.index = [];
    this.aggregates = [];
    this.headers = [];
    this.groupBys = [];
    this.view = [];
    this.sorterInstance = {};
    this.presortGroups = true;
    this.lastAggregate = {};
    this.setAggregates({});
}

DataSourceAggregator.prototype = {
    constructor: DataSourceAggregator.prototype.constructor, // preserve constructor

    isNullObject: false,

    setAggregates: function(aggregations) {
        this.lastAggregate = aggregations;
        this.clearAggregations();
        this.headers.length = 0;

        if (this.hasGroups()) {
            this.headers.push('Tree');
        }

        var self = this;
        _(aggregations).each(function(aggregation, key) {
            self.addAggregate(key, aggregation);
        });
    },

    addAggregate: function(label, func) {
        this.headers.push(headerify(label));
        this.aggregates.push(func);
    },

    setGroupBys: function(columnIndexArray) {
        var groupBys = this.groupBys;
        groupBys.length = 0;
        columnIndexArray.forEach(function(columnIndex) {
            groupBys.push(columnIndex);
        });
        this.setAggregates(this.lastAggregate);
    },

    addGroupBy: function(index) {
        this.groupBys.push(index);
    },

    hasGroups: function() {
        return !!this.groupBys.length;
    },

    hasAggregates: function() {
        return !!this.aggregates.length;
    },

    apply: function() {
        this.buildGroupTree();
    },

    clearGroups: function() {
        this.groupBys.length = 0;
    },

    clearAggregations: function() {
        this.aggregates.length = 0;
        this.headers.length = 0;
    },

    buildGroupTree: function() {
        var groupBys = this.groupBys,
            leafDepth = groupBys.length - 1,
            source = this.dataSource,
            rowCount = source.getRowCount(),
            tree = this.tree = new DataNodeTree('Totals');

        // first sort data
        if (this.presortGroups) {
            groupBys.reverse().forEach(function(groupBy) {
                source = new DataSourceSorter(source);
                source.sortOn(groupBy);
            });
        }

        for (var r = 0; r < rowCount; r++) {
            var path = tree;

            groupBys.forEach(function(g, c) { // eslint-disable-line no-loop-func
                var key = source.getValue(g, r),
                    terminalNode = (c === leafDepth),
                    Constructor = terminalNode ? DataNodeLeaf : DataNodeGroup,
                    ifAbsentFunc = createNode.bind(this, Constructor);
                path = path.children.getIfAbsent(key, ifAbsentFunc);
            });

            path.index.push(r);
        }

        this.sorterInstance = new DataSourceSorter(source);
        tree.prune();
        tree.computeAggregates(this);
        this.buildView();
    },

    addView: function(dataNode) {
        this.view.push(dataNode);
    },

    buildView: function() {
        this.view.length = 0;
        this.tree.computeHeight();
        this.tree.buildView(this);
    },

    viewMakesSense: function() {
        return this.hasAggregates();
    },

    getValue: function(x, y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getValue(x, y);
        }
        var row = this.view[y];
        if (!row) {
            return null;
        }
        return row.getValue(x); // TODO: what kind of object is row... ? should it be unfiltred?
    },

    setValue: function(x, y, value) {
        if (!this.viewMakesSense()) {
            return this.dataSource.setValue(x, y, value);
        }
    },

    getColumnCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getColumnCount();
        }
        return this.getHeaders().length;
    },

    getRowCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRowCount();
        }
        return this.view.length; //header column
    },

    click: function(y) {
        var group = this.view[y];
        group.toggleExpansionState(this);
        this.buildView();
    },

    getHeaders: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getHeaders();
        }
        return this.headers; // TODO: Views override dataSource headers with their own headers?
    },

    setHeaders: function(headers) {
        this.dataSource.setHeaders(headers);
    },

    getFields: function() {
        return this.dataSource.getFields();
    },

    setFields: function(fields) {
        return this.dataSource.setFields(fields);
    },

    getGrandTotals: function() {
        var view = this.tree;
        return [view.data];
    },

    getRow: function(y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRow(y);
        }

        var rollups = this.view[y];

        return rollups ? rollups : this.tree;
    },

    setData: function(arrayOfUniformObjects) {
        this.dataSource.setData(arrayOfUniformObjects);
        this.apply();
    }
};

function createNode(DataNodeConstructor, key, map) {
    var value = new DataNodeConstructor(key);
    map.set(key, value);
    return value;
}

module.exports = DataSourceAggregator;
},{"./DataNodeGroup":10,"./DataNodeLeaf":11,"./DataNodeTree":12,"./DataSourceSorter":18,"./util/headerify":23,"object-iterators":28}],15:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

var DataSourceFilter = DataSourceIndexed.extend('DataSourceFilter', {

    initialize: function() {
        this.filters = [];
    },

    add: function(columnIndex, filter) {
        filter.columnIndex = columnIndex;
        this.filters.push(filter);
    },

    clearAll: function() {
        this.filters.length = 0;
        this.clearIndex();
    },

    applyAll: function() {
        if (!this.filters.length) {
            this.clearIndex();
        } else {
            this.buildIndex(applyFilters);
        }
    },

    getRowCount: function() {
        return this.filters.length ? this.index.length : this.dataSource.getRowCount();
    },

    aliases: {
        set: 'add'
    }
});

function applyFilters(r, rowObject) { // called in context from .buildIndex()
    var self = this;

    if (Array.prototype.find) {
        // double negative here means "no filter fails" (i.e., row passes all filters)
        return !this.filters.find(function(filter) {
            return !filter(self.dataSource.getValue(filter.columnIndex, r), rowObject, r);
        });
    } else {
        return this.filters.reduce(function(isFiltered, filter) {
            return isFiltered && filter(self.dataSource.getValue(filter.columnIndex, r), rowObject, r);
        }, true);
    }
}

module.exports = DataSourceFilter;

},{"./DataSourceIndexed":17}],16:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

var DataSourceGlobalFilter = DataSourceIndexed.extend('DataSourceGlobalFilter', {

    set: function(filter) {
        this.filter = filter;
    },

    clear: function() {
        delete this.filter;
        this.clearIndex();
    },

    apply: function() {
        if (!this.filter) {
            this.clearIndex();
        } else {
            this.buildIndex(applyFilter);
        }
    },

    getRowCount: function() {
        return this.filter ? this.index.length : this.dataSource.getRowCount();
    }
});

function applyFilter(r, rowObject) { // called in context from .buildIndex()
    var self = this;
    return this.getFields().find(function(columnIndex) {
        var cellValue = self.dataSource.getValue(columnIndex, r);
        return self.filter(cellValue, rowObject, r);
    });
}

module.exports = DataSourceGlobalFilter;
},{"./DataSourceIndexed":17}],17:[function(require,module,exports){
'use strict';

var Base = require('extend-me').Base;

var DataSourceIndexed = Base.extend('DataSourceIndexed', {

    isNullObject: false,

    initialize: function(dataSource) {
        this.dataSource = dataSource;
        this.index = [];
    },

    transposeY: function(y) {
        return this.index.length ? this.index[y] : y;
    },

    getRow: function(y) {
        return this.dataSource.getRow(this.transposeY(y));
    },

    getValue: function(x, y) {
        return this.dataSource.getValue(x, this.transposeY(y));
    },

    setValue: function(x, y, value) {
        this.dataSource.setValue(x, this.transposeY(y), value);
    },

    getRowCount: function() {
        return this.index.length || this.dataSource.getRowCount();
    },

    getColumnCount: function() {
        return this.dataSource.getColumnCount();
    },

    getFields: function() {
        return this.dataSource.getFields();
    },

    setFields: function(fields) {
        return this.dataSource.setFields(fields);
    },

    getDefaultHeaders: function() {
        return this.dataSource.getFields();
    },

    setHeaders: function(headers) {
        return this.dataSource.setHeaders(headers);
    },

    getHeaders: function() {
        return this.dataSource.getHeaders();
    },

    getGrandTotals: function() {
        return this.dataSource.getGrandTotals();
    },

    setData: function(arrayOfUniformObjects) {
        return this.dataSource.setData(arrayOfUniformObjects);
    },

    clearIndex: function() {
        this.index.length = 0;
    },

    buildIndex: function(predicate) {
        var rowCount = this.dataSource.getRowCount(),
            index = this.index;

        index.length = 0;

        for (var r = 0; r < rowCount; r++) {
            if (!predicate || predicate.call(this, r, this.dataSource.getRow(r))) {
                index.push(r);
            }
        }

        return index;
    }

});

module.exports = DataSourceIndexed;

},{"extend-me":3}],18:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var stableSort = require('./util/stableSort');

var DataSourceSorter = DataSourceIndexed.extend('DataSourceSorter', {
    initialize: function() {
        this.descendingSort = false; // TODO: this does not seem to be in use
    },

    sortOn: function(colIdx, direction) {
        switch (direction) {
            case 0:
                this.clearIndex();
                break;

            case undefined:
            case 1:
            case -1:
                var self = this; // for use in getValue
                stableSort.sort(this.buildIndex(), getValue, direction);
                break;
        }

        function getValue(rowIdx) {
            return valOrFuncCall(self.dataSource.getValue(colIdx, rowIdx));
        }
    }
});

function valOrFuncCall(valOrFunc) {
    return typeof valOrFunc === 'function' ? valOrFunc() : valOrFunc;
}

module.exports = DataSourceSorter;
},{"./DataSourceIndexed":17,"./util/stableSort":24}],19:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var DataSourceSorter = require('./DataSourceSorter');

var DataSourceSorterComposite = DataSourceIndexed.extend('DataSourceSorterComposite', {
    initialize: function() {
        this.sorts = [];
        this.last = this.dataSource;
    },

    // Caveats regarding this.sorts:
    // 1. Columns should be uniquely represented (i.e., no repeats with same columnIndex)
    // 2. Columns should be added low- to high-order (i.e., most grouped columns come last)
    sortOn: function(columnIndex, direction) {
        this.sorts.push([columnIndex, direction]);
    },

    applySorts: function() {
        var each = this.dataSource;

        this.sorts.forEach(function(sort) {
            each = new DataSourceSorter(each);
            each.sortOn.apply(each, sort);
        });

        this.last = each;
    },

    clearSorts: function() {
        this.sorts.length = 0;
        this.last = this.dataSource;
    },

    getValue: function(x, y) {
        return this.last.getValue(x, y);
    },

    setValue: function(x, y, value) {
        this.last.setValue(x, y, value);
    }
});

module.exports = DataSourceSorterComposite;
},{"./DataSourceIndexed":17,"./DataSourceSorter":18}],20:[function(require,module,exports){
'use strict';

module.exports = {
    JSDataSource: require('./DataSource'),
    DataSourceSorter: require('./DataSourceSorter'),
    DataSourceSorterComposite: require('./DataSourceSorterComposite'),
    DataSourceFilter: require('./DataSourceFilter'),
    DataSourceGlobalFilter: require('./DataSourceGlobalFilter'),
    DataSourceAggregator: require('./DataSourceAggregator'),
    util: {
        aggregations: require('./util/aggregations')
    }
};
},{"./DataSource":13,"./DataSourceAggregator":14,"./DataSourceFilter":15,"./DataSourceGlobalFilter":16,"./DataSourceSorter":18,"./DataSourceSorterComposite":19,"./util/aggregations":22}],21:[function(require,module,exports){
'use strict';

function Mappy() {
    this.keys = [];
    this.data = {};
    this.values = [];
}

Mappy.prototype = {

    constructor: Mappy.prototype.constructor, // preserve constructor

    set: function(key, value) {
        var hashCode = hash(key);
        if (!(hashCode in this.data)) {
            this.keys.push(key);
            this.values.push(value);
        }
        this.data[hashCode] = value;
    },

    get: function(key) {
        var hashCode = hash(key);
        return this.data[hashCode];
    },

    getIfAbsent: function(key, ifAbsentFunc) {
        var value = this.get(key);
        if (value === undefined) {
            value = ifAbsentFunc(key, this);
        }
        return value;
    },

    size: function() {
        return this.keys.length;
    },

    clear: function() {
        this.keys.length = 0;
        // TODO: Is there a reason why this.values is not being truncated here as well?
        this.data = {};
    },

    delete: function(key) {
        var hashCode = hash(key);
        if (this.data[hashCode] !== undefined) {
            var index = betterIndexOf(this.keys, key);
            this.keys.splice(index, 1);
            this.values.splice(index, 1);
            delete this.data[hashCode];
        }
    },

    forEach: function(func) {
        var keys = this.keys,
            self = this;
        keys.forEach(function(key) {
            var value = self.get(key);
            func(value, key, self);
        });
    },

    map: function(func) {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;
        keys.forEach(function(key) {
            var value = self.get(key),
                transformed = func(value, key, self);
            newMap.set(key, transformed);
        });
        return newMap;
    },

    copy: function() {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;
        keys.forEach(function(key) {
            var value = self.get(key);
            newMap.set(key, value);
        });
        return newMap;
    }

};

var OID_PREFIX = '.~.#%_'; //this should be something we never will see at the beginning of a string
var counter = 0;

function hash(key) {
    var typeOf = typeof key;

    switch (typeOf) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'symbol':
            return OID_PREFIX + typeOf + '_' + key;

        case 'undefined':
            return OID_PREFIX + 'undefined';

        case 'object':
            // TODO: what about handling null (special case of object)?
        case 'function':
            return (key.___finhash = key.___finhash || OID_PREFIX + counter++); // eslint-disable-line
    }
}

// Object.is polyfill, courtesy of @WebReflection
var is = Object.is || function(a, b) {
    return a === b ? a !== 0 || 1 / a == 1 / b : a != a && b != b; // eslint-disable-line
};

// More reliable indexOf, courtesy of @WebReflection
function betterIndexOf(arr, value) {
    if (value != value || value === 0) { // eslint-disable-line
        for (var i = arr.length; i-- && !is(arr[i], value);) { // eslint-disable-line
        }
    } else {
        i = [].indexOf.call(arr, value);
    }
    return i;
}

module.exports = Mappy;
},{}],22:[function(require,module,exports){
'use strict';

function count(group) {
    return group.getRowCount();
}

function sum(columnIndex, group) {
    var r = group.getRowCount(),
        n = 0;

    while (r--) {
        n += group.getValue(columnIndex, r);
    }

    return n;
}

function minmax(columnIndex, method, n, group) {
    var r = group.getRowCount();

    while (r--) {
        n = method(n, group.getValue(columnIndex, r));
    }

    return n;
}

function avg(columnIndex, group) {
    return sum(columnIndex, group) / group.getRowCount();
}

function first(columnIndex, group) {
    return group.getValue(columnIndex, 0);
}

function last(columnIndex, group) {
    return group.getValue(columnIndex, group.getRowCount() - 1);
}

function stddev(columnIndex, group) {
    var rows = group.getRowCount(),
        mean = avg(columnIndex, group);

    for (var dev, r = rows, variance = 0; r--; variance += dev * dev) {
        dev = group.getValue(columnIndex, r) - mean;
    }

    return Math.sqrt(variance / rows);
}

module.exports = {
    count: function(columnIndex) {
        return count;
    },
    sum: function(columnIndex) {
        return sum.bind(this, columnIndex);
    },
    min: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.min, Infinity);
    },
    max: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.max, -Infinity);
    },
    avg: function(columnIndex) {
        return avg.bind(this, columnIndex);
    },
    first: function(columnIndex) {
        return first.bind(this, columnIndex);
    },
    last: function(columnIndex) {
        return last.bind(this, columnIndex);
    },
    stddev: function(columnIndex) {
        return stddev.bind(this, columnIndex);
    }
};
},{}],23:[function(require,module,exports){
'use strict';

function headerify(string) {
    return (/[a-z]/.test(string) ? string : string.toLowerCase())
        .replace(/[\s\-_]*([^\s\-_])([^\s\-_]+)/g, replacer)
        .replace(/[A-Z]/g, ' $&')
        .trim();
}

function replacer(a, b, c) {
    return b.toUpperCase() + c;
}

module.exports = headerify;
},{}],24:[function(require,module,exports){
'use strict';

function stabilize(comparator, descending, arr1, arr2) { // eslint-disable-line no-shadow
    var x = arr1[0];
    var y = arr2[0];

    if (x === y) {
        x = descending ? arr2[1] : arr1[1];
        y = descending ? arr1[1] : arr2[1];
    } else {
        if (y === null) {
            return -1;
        }
        if (x === null) {
            return 1;
        }
    }

    return comparator(x, y);
}

function ascendingNumbers(x, y) {
    return x - y;
}

function descendingNumbers(x, y) {
    return y - x;
}

function ascendingAllOthers(x, y) {
    return x < y ? -1 : 1;
}

function descendingAllOthers(x, y) {
    return y < x ? -1 : 1;
}

function ascending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? ascendingNumbers : ascendingAllOthers, false);
}

function descending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? descendingNumbers : descendingAllOthers, true);
}

function sort(index, getValue, direction) {

    var compare, i;

    // apply defaults
    if (direction === undefined) {
        direction = 1;
    }

    if (index.length) { // something to do
        switch (direction) {
            case 0:
                return; // bail: nothing to sort

            case undefined: // eslint-disable-line no-fallthrough
                direction = 1;
            case 1:
                compare = ascending(typeof getValue(0));
                break;

            case -1:
                compare = descending(typeof getValue(0));
                break;
        }

        // set up the sort.....
        var tmp = new Array(index.length);

        // add the index for "stability"
        for (i = 0; i < index.length; i++) {
            tmp[i] = [getValue(i), i];
        }

        // do the actual sort
        tmp.sort(compare);

        // copy the sorted values into our index vector
        for (i = 0; i < index.length; i++) {
            index[i] = tmp[i][1];
        }
    }

}

exports.sort = sort;
},{}],25:[function(require,module,exports){
// list-dragon node module
// https://github.com/openfin/list-dragon

'use strict';

/* eslint-env node, browser */

(function (module) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See notes at bottom of this file.

    var format = window.templex || require('templex');

    var REVERT_TO_STYLESHEET_VALUE = null;  // null removes the style

    var body, transform, timer, scrollVelocity;

    /* inject:css */
    (function(){var a="div.dragon-list{position:relative;background-color:#fff}div.dragon-list>div,div.dragon-list>ul{position:absolute;left:0;right:0}div.dragon-list>div{text-align:center;background-color:#00796b;color:#fff;box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);overflow:hidden;white-space:nowrap}div.dragon-list>ul{overflow-y:auto;bottom:0;margin:0;padding:0;box-shadow:0 1px 3px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.24)}div.dragon-list>ul>li,li.dragon-pop{white-space:nowrap;list-style-type:none;border:0 solid #f4f4f4;border-bottom:1px solid #e0e0e0;cursor:move;transition:border-top-width .2s}div.dragon-list>ul>li:last-child{height:0;border-bottom:none}li.dragon-pop{position:fixed;background-color:#fff;border:1px solid #e0e0e0;left:0;top:0;overflow-x:hidden;box-shadow:rgba(0,0,0,.188235) 0 10px 20px,rgba(0,0,0,.227451) 0 6px 6px}",b=document.createElement("style"),head=document.head||document.getElementsByTagName("head")[0];b.type="text/css";if(b.styleSheet)b.styleSheet.cssText=a;else b.appendChild(document.createTextNode(a));head.insertBefore(b,head.firstChild)})();
    /* endinject */

    /**
     * @constructor ListDragon
     *
     * @desc This object services a set of item lists that allow dragging and dropping items within and between lists in a set.
     *
     * Two strategies are supported:
     *
     * 1. Supply your own HTML markup and let the API build the item models for you.
     *    To use this strategy, script your HTML and provide one of these:
     *    * an array of all the list item (`<li>`) tags
     *    * a CSS selector that points to all the list item tags
     * 2. Supply your own item models and let the API build the HTML markup for you.
     *    To use this strategy, provide an array of model lists.
     *
     * The new ListDragon object's `modelLists` property references the array of model lists the API constructed for you in strategy #1 or the array of model lists you supplied for strategy #2.
     *
     * After the user performs a successful drag-and-drop operation, the position of the model references within the `modelLists` array is rearranged. (The models themselves are the original objects as supplied in the model lists; they are not rebuilt or altered in any way. Just the references to them are moved around.)
     *
     * @param {string|Element[]|modelListType[]} selectorOrModelLists - You must supply one of the items in **bold** below:
     *
     * 1. _For strategy #1 above (API creates models from supplied elements):_ All the list item (`<li>`) DOM elements of all the lists you want the new object to manage, as either:
     *    1. **A CSS selector;** _or_
     *    2. **An array of DOM elements**
     * 2. _For strategy #2 above (API creates elements from supplied models):_ **An array of model lists,** each of which is in one of the following forms:
     *    1. An array of item models (with various option properties hanging off of it); _and/or_
     *    2. A {@link modelListType} object with those same various option properties including the required `models` property containing that same array of item models.
     *
     * In either case (2.1 or 2.2), each element of such arrays of item models may take the form of:
     * * A string primitive; _or_
     * * A {@link itemModelType} object with a various option properties including the required `label` property containing a string primitive.
     *
     * Regarding these string primitives, each is either:
     * * A string to be displayed in the list item; _or_
     * * A format string with other property values merged in, the result of which is to be displayed in the list item.
     *
     * @param {object} [options={}] - There are no formal options, but you can supply "global" template variables here, representing the "outer scope," after first searching each model and then each model list.
     */
    function ListDragon(selectorOrModelLists, options) {

        if (!(this instanceof ListDragon)) {
            throw error('Not called with "new" keyword.');
        }

        var self = this, modelLists, items;

        options = options || {};

        if (typeof selectorOrModelLists === 'string') {
            items = toArray(document.querySelectorAll(selectorOrModelLists));
            modelLists = createModelListsFromListElements(items);
        } else if (selectorOrModelLists[0] instanceof Element) {
            items = toArray(selectorOrModelLists);
            modelLists = createModelListsFromListElements(items);
        } else {
            // param is array of model lists
            // build new <ul> element(s) for each list and put in `.modelLists`;
            // fill `.items` array with <li> elements from these new <ul> elements
            items = [];
            modelLists = createListElementsFromModelLists(selectorOrModelLists, options);
            modelLists.forEach(function (list) {
                items = items.concat(toArray(list.element.querySelectorAll('li')));
            });
        }

        items.forEach(function (itemElement, index) {
            var item = (itemElement !== itemElement.parentElement.lastElementChild)
                ? self.addEvt(itemElement, 'mousedown', itemElement, true)
                : { element: itemElement };

            /* `item.model` not currently needed so commented out here.
             * (Originally used for rebuilding modelLists for final
             * reporting, modelLists are now spliced on every successful
             * drag-and-drop operation so they're always up to date.)

             var origin = this.itemCoordinates(itemElement);
             item.model = this.modelLists[origin.list].models[origin.item];

             */

            items[index] = item;
        });

        body = body || document.getElementsByTagName('body')[0];

        transform = 'transform' in items[0].element.style
            ? 'transform' // Chrome 45 and Firefox 40
            : '-webkit-transform'; // Safari 8

        // set up the new object
        this.modelLists = modelLists;
        this.items = items;
        this.bindings = {};
        this.callback = {};

    }

    ListDragon.prototype = {

        addEvt: function (target, type, listener, doNotBind) {
            var binding = {
                handler: handlers[type].bind(target, this),
                element: listener || window
            };

            if (!doNotBind) {
                this.bindings[type] = binding;
            }

            binding.element.addEventListener(type, binding.handler);

            return binding;
        },

        removeEvt: function (type) {
            var binding = this.bindings[type];
            delete this.bindings[type];
            binding.element.removeEventListener(type, binding.handler);
        },

        removeAllEventListeners: function () {
            // remove drag & drop events (mousemove, mouseup, and transitionend)
            for (var type in this.bindings) {
                var binding = this.bindings[type];
                binding.element.removeEventListener(type, binding.handler);
            }
            // remove the mousedown events from all list items
            this.items.forEach(function (item) {
                if (item.handler) {
                    item.element.removeEventListener('mousedown', item.handler);
                }
            });
        },

        pointInListRects: function (point) {
            return this.modelLists.find(function (modelList) {
                var rect = modelList.element.getBoundingClientRect();

                rect = {
                    left:   window.scrollX + rect.left,
                    top:    window.scrollY + rect.top,
                    right:  window.scrollX + rect.right,
                    bottom: window.scrollY + rect.bottom,
                    width:  rect.width,
                    height: rect.height
                };

                modelList.rect = rect;

                if (pointInRect(point, rect)) {
                    modelList.rect = rect;
                    return true; // found
                } else {
                    return false;
                }
            });
        },

        pointInItemRects: function (point, except1, except2) {
            return this.items.find(function (item) {
                var element = item.element;
                return (
                    element !== except1 &&
                    element !== except2 &&
                    pointInRect(point, item.rect)
                );
            });
        },

        // get positions of all list items in page coords (normalized for window and list scrolling)
        getAllItemBoundingRects: function () {
            var modelLists = this.modelLists, height;
            this.items.forEach(function (item) {
                var itemElement = item.element,
                    listElement = itemElement.parentElement,
                    list = modelLists.find(function (list) { return list.element === listElement; });

                if (
                    // omitted: default to true
                    list.isDropTarget === undefined ||

                    // function: use return value
                    typeof list.isDropTarget === 'function' && list.isDropTarget() ||

                    // otherwise: use truthiness of given value
                    list.isDropTarget
                ) {
                    var rect = itemElement.getBoundingClientRect(),
                        bottom = rect.bottom;

                    if (itemElement === listElement.lastElementChild) {
                        bottom = listElement.getBoundingClientRect().bottom;
                        if (bottom < rect.top) {
                            bottom = rect.top + (height || 50);
                        }
                    } else {
                        height = rect.height;
                    }

                    rect = {
                        left:   window.scrollX + rect.left,
                        right:  window.scrollX + rect.right,
                        top:    window.scrollY + rect.top    + listElement.scrollTop,
                        bottom: window.scrollY + bottom + listElement.scrollTop
                    };

                    item.rect = rect;
                }
            });
        },

        reinsert: function (target) {
            var style = target.style;
            style.width = style[transform] = style.transition = REVERT_TO_STYLESHEET_VALUE;

            target.classList.remove('dragon-pop');

            this.drop.style.transitionDuration = '0s';
            this.drop.style.borderTopWidth = REVERT_TO_STYLESHEET_VALUE;
            this.drop.parentElement.insertBefore(target, this.drop);

            delete this.drop;
        },

        // return an object { item: <item index within list>, list: <list index within list of lists> }
        itemCoordinates: function (item) {
            var listElement = item.parentElement,
                coords = { item: 0 };

            while ((item = item.previousElementSibling)) {
                ++coords.item;
            }

            this.modelLists.find(function (list, index) {
                coords.list = index;
                return list.element === listElement; // stop when we find the one we belong to
            });

            return coords;
        }

    };

    var handlers = {
        mousedown: function (dragon, evt) {

            evt.stopPropagation();
            evt.preventDefault();  //prevents user selection of rendered nodes during drag

            if (dragon.drop) {
                return;
            }

            var rect = this.getBoundingClientRect();

            dragon.rect = rect = {
                left:   Math.round(rect.left - 1),
                top:    Math.round(rect.top - 1),
                right:  Math.round(rect.right),
                bottom: Math.round(rect.bottom),
                width:  Math.round(rect.width),
                height: Math.round(rect.height)
            };

            dragon.pin = {
                x: window.scrollX + evt.clientX,
                y: window.scrollY + evt.clientY
            };

            dragon.origin = dragon.itemCoordinates(this);

            if (dragon.callback.grabbed) {
                dragon.callback.grabbed.call(this, dragon);
            }

            dragon.getAllItemBoundingRects();

            dragon.drop = this.nextElementSibling;
            dragon.drop.style.transitionDuration = '0s';
            dragon.drop.style.borderTopWidth = rect.height + 'px';

            this.style.width = rect.width + 'px';
            this.style.transitionDuration = '0s';
            this.style[transform] = translate(
                rect.left - window.scrollX,
                rect.top  - window.scrollY
            );
            this.classList.add('dragon-pop');
            this.style.zIndex = window.getComputedStyle(dragon.modelLists[0].container.parentElement).zIndex;

            body.appendChild(this);

            rect.left   += window.scrollX;
            rect.top    += window.scrollY;
            rect.right  += window.scrollX;
            rect.bottom += window.scrollY;

            dragon.addEvt(this, 'mousemove');
            dragon.addEvt(this, 'mouseup');
        },

        mousemove: function (dragon, evt) {
            dragon.drop.style.transition = REVERT_TO_STYLESHEET_VALUE;

            var hoverList = dragon.pointInListRects({ x: evt.clientX, y: evt.clientY }) || dragon.mostRecentHoverList;

            if (hoverList) {
                var dx = evt.clientX - dragon.pin.x,
                    dy = evt.clientY - dragon.pin.y;

                dragon.mostRecentHoverList = hoverList;

                var maxScrollY = hoverList.element.scrollHeight - hoverList.rect.height,
                    y = evt.clientY + window.scrollY,
                    magnitude;

                if (maxScrollY > 0) {
                    // list is scrollable (is taller than rect)
                    if (hoverList.element.scrollTop > 0 && (magnitude = y - (hoverList.rect.top + 5)) < 0) {
                        // mouse near or above top and list is not scrolled to top yet
                        resetAutoScrollTimer(magnitude, 0, hoverList.element);
                    } else if (hoverList.element.scrollTop < maxScrollY && (magnitude = y - (hoverList.rect.bottom - 1 - 5)) > 0) {
                        // mouse near or below bottom and list not scrolled to bottom yet
                        resetAutoScrollTimer(magnitude, maxScrollY, hoverList.element);
                    } else {
                        // mouse inside
                        resetAutoScrollTimer();
                    }
                }

                var other = dragon.pointInItemRects({
                    x: evt.clientX,
                    y: dragon.rect.bottom + window.scrollY + dy + hoverList.element.scrollTop
                }, this, dragon.drop);

                this.style[transform] = translate(
                    dragon.rect.left - window.scrollX + dx,
                    dragon.rect.top - window.scrollY + dy
                );

                if (other) {
                    var element = other.element;
                    element.style.transition = REVERT_TO_STYLESHEET_VALUE;
                    element.style.borderTopWidth = dragon.drop.style.borderTopWidth;
                    dragon.drop.style.borderTopWidth = null;
                    dragon.drop = element;
                }
            }
        },

        mouseup: function (dragon, evt) {
            resetAutoScrollTimer();
            dragon.removeEvt('mousemove');
            dragon.removeEvt('mouseup');

            evt.stopPropagation();

            var newRect = this.getBoundingClientRect();

            if (
                window.scrollX + newRect.left === dragon.rect.left &&
                window.scrollY + newRect.top === dragon.rect.top
            ) {
                dragon.reinsert(this);
            } else {
                var dropRect = dragon.drop.getBoundingClientRect();

                dragon.addEvt(this, 'transitionend', this);
                this.style.transitionDuration = REVERT_TO_STYLESHEET_VALUE; //reverts to 200ms
                this.style.transitionProperty = transform;
                this.style[transform] = translate(
                    dropRect.left - window.scrollX,
                    dropRect.top - window.scrollY
                );
            }
        },

        transitionend: function (dragon, evt) {
            if (evt.propertyName === transform) {
                dragon.removeEvt('transitionend');
                dragon.reinsert(this);

                this.style.transitionProperty = REVERT_TO_STYLESHEET_VALUE; //reverts to border-top-width

                var model = dragon.modelLists[dragon.origin.list].splice(dragon.origin.item, 1)[0];
                var destination = dragon.itemCoordinates(this);
                dragon.modelLists[destination.list].splice(destination.item, 0, model);

                if (dragon.callback.dropped) {
                    dragon.callback.dropped.call(this, dragon);
                }
            }
        }
    };

    function resetAutoScrollTimer(magnitude, limit, element) {
        if (!magnitude) {
            clearInterval(timer);
            scrollVelocity = 0;
        } else {
            var changeDirection =
                scrollVelocity  <  0 && magnitude  >= 0 ||
                scrollVelocity === 0 && magnitude !== 0 ||
                scrollVelocity  >  0 && magnitude  <= 0;
            scrollVelocity = magnitude > 0 ? Math.min(50, magnitude) : Math.max(-50, magnitude);
            if (changeDirection) {
                clearInterval(timer);
                timer = setInterval(function (limit) {
                    var scrollTop = element.scrollTop + scrollVelocity;
                    if (scrollVelocity < 0 && scrollTop < limit || scrollVelocity > 0 && scrollTop > limit) {
                        element.scrollTop = limit;
                        clearInterval(timer);
                    } else {
                        element.scrollTop = scrollTop;
                    }
                }, 125);
            }
        }
    }

    function toArray(arrayLikeObject) {
        return Array.prototype.slice.call(arrayLikeObject);
    }

    function pointInRect(point, rect) {
        return rect.top <= point.y && point.y <= rect.bottom
            && rect.left <= point.x && point.x <= rect.right;
    }

    function translate(left, top) {
        return 'translate('
            + Math.floor(left + window.scrollX) + 'px,'
            + Math.floor(top + window.scrollY) + 'px)';
    }

    function htmlEncode(string) {
        var textNode = document.createTextNode(string);

        return document
            .createElement('a')
            .appendChild(textNode)
            .parentNode
            .innerHTML;
    }

    /**
     * Creates `<ul>...</ul>` elements and inserts them into an `element` property on each model.
     * @param {object} modelLists
     * @returns `modelLists`
     */
    function createListElementsFromModelLists(modelLists, options) {
        var templateLabel = options.label || '{label}';

        modelLists.forEach(function (modelList, listIndex) {
            var listLabel = modelList.label || templateLabel,
                listHtmlEncode = modelList.htmlEncode !== undefined && modelList.htmlEncode || options.htmlEncode,
                container = document.createElement('div'),
                listElement = document.createElement('ul');

            if (modelList.models) {
                Object.keys(modelList).forEach(function (key) {
                    if (key !== 'models') {
                        modelList.models[key] = modelList[key];
                    }
                });
                modelLists[listIndex] = modelList = modelList.models;
            } else if (modelList instanceof Array) {
                modelList.models = modelList; // point to self
            } else {
                throw error('List [{1}] not an array of models (with or without additional properties) OR ' +
                    'an object (with a `models` property containing an array of models).', listIndex);
            }

            modelList.forEach(function (model) {
                var modelLabel = model.label || listLabel,
                    modelHtmlEncode = model.htmlEncode !== undefined && model.htmlEncode || listHtmlEncode,
                    modelObject = typeof model === 'object' ? model : { label: model},
                    label = format.call([modelObject, modelList, options], modelLabel),
                    itemElement = document.createElement('li');

                itemElement.innerHTML = modelHtmlEncode ? htmlEncode(label) : label;

                listElement.appendChild(itemElement);
            });

            // append the final "fencepost" item -- drop target at bottom of list after all items
            var itemElement = document.createElement('li');
            itemElement.innerHTML = '&nbsp;';
            listElement.appendChild(itemElement);

            // append header to container
            if (modelList.title) {
                var header = document.createElement('div');
                header.innerHTML = listHtmlEncode ? htmlEncode(modelList.title) : modelList.title;
                container.appendChild(header);
            }

            container.appendChild(listElement);
            container.className = modelList.cssClassNames || options.cssClassNames || 'dragon-list';
            modelList.element = listElement;
            modelList.container = container;
        });

        return modelLists;
    }

    /**
     * Create a `.modelLists` array with these <li> elements' parent <ul> elements
     * @param {Element[]} listItemElements
     * @returns {Array}
     */
    function createModelListsFromListElements(listItemElements) {
        var modelLists = [];

        listItemElements.forEach(function (itemElement) {
            var listElement = itemElement.parentElement,
                container = listElement.parentElement,
                models = [];
            if (!modelLists.find(function (list) { return list.element === listElement; })) {
                toArray(listElement.querySelectorAll('li')).forEach(function (itemElement) {
                    if (itemElement !== listElement.lastElementChild) {
                        models.push(itemElement.innerHTML);
                    }
                });
                models.element = listElement;
                models.container = container;
                modelLists.push(models);
            }
        });

        return modelLists;
    }

    function error() {
        return 'list-dragon: ' + format.apply(this, Array.prototype.slice.call(arguments));
    }

    // this interface consists solely of the prototypal object constructor
    module.exports = ListDragon;

})(
    typeof module === 'object' && module || (window.ListDragon = {}),
    typeof module === 'object' && module.exports || (window.ListDragon.exports = {})
) || (
    typeof module === 'object' || (window.ListDragon = window.ListDragon.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.ListDragon`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `window` object undefined, we're in NodeJs so assume there is a `module` object with an `exports` property
 * 2. If `window` object defined, we're in browser
 * 2.a. If `module` object predefined, use it
 * 2.b. If `module` object undefined, create a `ListDragon` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will execute:
 * 1. If `window` object undefined, then we're in NodeJs so we're done
 * 2. If `window` object defined, then we're in browser
 * 2.a. If `module` object predefined, we're done; results are in `moudule.exports`
 * 2.b. If `module` object undefined, redefine`ListDragon` to be the `ListDragon.exports` object
 */

},{"templex":31}],26:[function(require,module,exports){
;(function () { // closure for web browsers

if (typeof module === 'object' && module.exports) {
  module.exports = LRUCache
} else {
  // just set the global for non-node platforms.
  this.LRUCache = LRUCache
}

function hOP (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key)
}

function naiveLength () { return 1 }

var didTypeWarning = false
function typeCheckKey(key) {
  if (!didTypeWarning && typeof key !== 'string' && typeof key !== 'number') {
    didTypeWarning = true
    console.error(new TypeError("LRU: key must be a string or number. Almost certainly a bug! " + typeof key).stack)
  }
}

function LRUCache (options) {
  if (!(this instanceof LRUCache))
    return new LRUCache(options)

  if (typeof options === 'number')
    options = { max: options }

  if (!options)
    options = {}

  this._max = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!this._max || !(typeof this._max === "number") || this._max <= 0 )
    this._max = Infinity

  this._lengthCalculator = options.length || naiveLength
  if (typeof this._lengthCalculator !== "function")
    this._lengthCalculator = naiveLength

  this._allowStale = options.stale || false
  this._maxAge = options.maxAge || null
  this._dispose = options.dispose
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, "max",
  { set : function (mL) {
      if (!mL || !(typeof mL === "number") || mL <= 0 ) mL = Infinity
      this._max = mL
      if (this._length > this._max) trim(this)
    }
  , get : function () { return this._max }
  , enumerable : true
  })

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, "lengthCalculator",
  { set : function (lC) {
      if (typeof lC !== "function") {
        this._lengthCalculator = naiveLength
        this._length = this._itemCount
        for (var key in this._cache) {
          this._cache[key].length = 1
        }
      } else {
        this._lengthCalculator = lC
        this._length = 0
        for (var key in this._cache) {
          this._cache[key].length = this._lengthCalculator(this._cache[key].value)
          this._length += this._cache[key].length
        }
      }

      if (this._length > this._max) trim(this)
    }
  , get : function () { return this._lengthCalculator }
  , enumerable : true
  })

Object.defineProperty(LRUCache.prototype, "length",
  { get : function () { return this._length }
  , enumerable : true
  })


Object.defineProperty(LRUCache.prototype, "itemCount",
  { get : function () { return this._itemCount }
  , enumerable : true
  })

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  var i = 0
  var itemCount = this._itemCount

  for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {
    i++
    var hit = this._lruList[k]
    if (isStale(this, hit)) {
      del(this, hit)
      if (!this._allowStale) hit = undefined
    }
    if (hit) {
      fn.call(thisp, hit.value, hit.key, this)
    }
  }
}

LRUCache.prototype.keys = function () {
  var keys = new Array(this._itemCount)
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    keys[i++] = hit.key
  }
  return keys
}

LRUCache.prototype.values = function () {
  var values = new Array(this._itemCount)
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    values[i++] = hit.value
  }
  return values
}

LRUCache.prototype.reset = function () {
  if (this._dispose && this._cache) {
    for (var k in this._cache) {
      this._dispose(k, this._cache[k].value)
    }
  }

  this._cache = Object.create(null) // hash of items by key
  this._lruList = Object.create(null) // list of items in order of use recency
  this._mru = 0 // most recently used
  this._lru = 0 // least recently used
  this._length = 0 // number of items in the list
  this._itemCount = 0
}

LRUCache.prototype.dump = function () {
  var arr = []
  var i = 0

  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    if (!isStale(this, hit)) {
      //Do not store staled hits
      ++i
      arr.push({
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      });
    }
  }
  //arr has the most read first
  return arr
}

LRUCache.prototype.dumpLru = function () {
  return this._lruList
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this._maxAge
  typeCheckKey(key)

  var now = maxAge ? Date.now() : 0
  var len = this._lengthCalculator(value)

  if (hOP(this._cache, key)) {
    if (len > this._max) {
      del(this, this._cache[key])
      return false
    }
    // dispose of the old one before overwriting
    if (this._dispose)
      this._dispose(key, this._cache[key].value)

    this._cache[key].now = now
    this._cache[key].maxAge = maxAge
    this._cache[key].value = value
    this._length += (len - this._cache[key].length)
    this._cache[key].length = len
    this.get(key)

    if (this._length > this._max)
      trim(this)

    return true
  }

  var hit = new Entry(key, value, this._mru++, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this._max) {
    if (this._dispose) this._dispose(key, value)
    return false
  }

  this._length += hit.length
  this._lruList[hit.lu] = this._cache[key] = hit
  this._itemCount ++

  if (this._length > this._max)
    trim(this)

  return true
}

LRUCache.prototype.has = function (key) {
  typeCheckKey(key)
  if (!hOP(this._cache, key)) return false
  var hit = this._cache[key]
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  typeCheckKey(key)
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  typeCheckKey(key)
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var hit = this._lruList[this._lru]
  del(this, hit)
  return hit || null
}

LRUCache.prototype.del = function (key) {
  typeCheckKey(key)
  del(this, this._cache[key])
}

LRUCache.prototype.load = function (arr) {
  //reset the cache
  this.reset();

  var now = Date.now()
  //A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l-- ) {
    var hit = arr[l]
    typeCheckKey(hit.k)
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      //the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      //dont add already expired items
      if (maxAge > 0) this.set(hit.k, hit.v, maxAge)
    }
  }
}

function get (self, key, doUse) {
  typeCheckKey(key)
  var hit = self._cache[key]
  if (hit) {
    if (isStale(self, hit)) {
      del(self, hit)
      if (!self._allowStale) hit = undefined
    } else {
      if (doUse) use(self, hit)
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale(self, hit) {
  if (!hit || (!hit.maxAge && !self._maxAge)) return false
  var stale = false;
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self._maxAge && (diff > self._maxAge)
  }
  return stale;
}

function use (self, hit) {
  shiftLU(self, hit)
  hit.lu = self._mru ++
  self._lruList[hit.lu] = hit
}

function trim (self) {
  while (self._lru < self._mru && self._length > self._max)
    del(self, self._lruList[self._lru])
}

function shiftLU (self, hit) {
  delete self._lruList[ hit.lu ]
  while (self._lru < self._mru && !self._lruList[self._lru]) self._lru ++
}

function del (self, hit) {
  if (hit) {
    if (self._dispose) self._dispose(hit.key, hit.value)
    self._length -= hit.length
    self._itemCount --
    delete self._cache[ hit.key ]
    shiftLU(self, hit)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, lu, length, now, maxAge) {
  this.key = key
  this.value = value
  this.lu = lu
  this.length = length
  this.now = now
  if (maxAge) this.maxAge = maxAge
}

})()

},{}],27:[function(require,module,exports){
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache (global, factory) {
  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory); // AMD
  } else {
    global.Mustache = {};
    factory(Mustache); // script, wsh, asp
  }
}(this, function mustacheFactory (mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill (object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction (object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr (obj) {
    return isArray(obj) ? 'array' : typeof obj;
  }

  function escapeRegExp (string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty (obj, propName) {
    return obj != null && typeof obj === 'object' && (propName in obj);
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp (re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace (string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;'
  };

  function escapeHtml (string) {
    return String(string).replace(/[&<>"'\/]/g, function fromEntityMap (s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate (template, tags) {
    if (!template)
      return [];

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace () {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags (tagsToCompile) {
      if (typeof tagsToCompile === 'string')
        tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push([ 'text', chr, start, start + 1 ]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n')
            stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe))
        break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe))
        throw new Error('Unclosed tag at ' + scanner.pos);

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens (tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens (tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
      case '#':
      case '^':
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case '/':
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner (string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos () {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan (re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0)
      return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil (re) {
    var index = this.tail.search(re), match;

    switch (index) {
    case -1:
      match = this.tail;
      this.tail = '';
      break;
    case 0:
      match = '';
      break;
    default:
      match = this.tail.substring(0, index);
      this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context (view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup (name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, names, index, lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           **/
          while (value != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit)
          break;

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value))
      value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer () {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache () {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse (template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null)
      tokens = cache[template] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function render (template, view, partials) {
    var tokens = this.parse(template);
    var context = (view instanceof Context) ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context);
      else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined)
        buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender (template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null)
      return this.renderTokens(this.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };

  Writer.prototype.escapedValue = function escapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue (token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '2.2.0';
  mustache.tags = [ '{{', '}}' ];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function render (template, view, partials) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' +
                          'but "' + typeStr(template) + '" was given as the first ' +
                          'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html (template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

}));

},{}],28:[function(require,module,exports){
/* object-iterators.js - Mini Underscore library
 * by Jonathan Eiten
 *
 * The methods below operate on objects (but not arrays) similarly
 * to Underscore (http://underscorejs.org/#collections).
 *
 * Recommended usage:
 *
 *    var _ = require('object-iterators');
 */

'use strict';

/**
 * @constructor
 * @summary Wrap an object for one method.
 * @Desc Note that the `new` keyword is not necessary.
 * @param {object|null|undefined} object - `null` or `undefined` is treated as an empty plain object.
 * @return {Wrapper} The wrapped object.
 */
function Wrapper(object) {
    if (object instanceof Wrapper) {
        return object;
    }
    if (!(this instanceof Wrapper)) {
        return new Wrapper(object);
    }
    this.originalValue = object;
    this.o = object || {};
}

/**
 * @name Wrapper.chain
 * @summary Wrap an object for a chain of methods.
 * @Desc Calls the constructor `Wrapper()` and modifies the wrapper for chaining.
 * @param {object} object
 * @return {Wrapper} The wrapped object.
 */
Wrapper.chain = function (object) {
    var wrapped = Wrapper(object); // eslint-disable-line new-cap
    wrapped.chaining = true;
    return wrapped;
};

Wrapper.prototype = {
    /**
     * Unwrap an object wrapped with {@link Wrapper.chain|Wrapper.chain()}.
     * @return {object|null|undefined} The value originally wrapped by the constructor.
     * @memberOf Wrapper.prototype
     */
    value: function () {
        return this.originalValue;
    },

    /**
     * @desc Mimics Underscore's [each](http://underscorejs.org/#each) method: Iterate over the members of the wrapped object, calling `iteratee()` with each.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is undefined; an `.each` loop cannot be broken out of (use {@link Wrapper#find|.find} instead).
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {Wrapper} The wrapped object for chaining.
     * @memberOf Wrapper.prototype
     */
    each: function (iteratee, context) {
        var o = this.o;
        context = context || o;
        Object.keys(o).forEach(function (key) {
            iteratee.call(context, o[key], key, o);
        });
        return this;
    },

    /**
     * @desc Mimics Underscore's [find](http://underscorejs.org/#find) method: Look through each member of the wrapped object, returning the first one that passes a truth test (predicate), or `undefined` if no value passes the test. The function returns the value of the first acceptable member, and doesn't necessarily traverse the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The found property's value.
     * @memberOf Wrapper.prototype
     */
    find: function (predicate, context) {
        var o = this.o;
        context = context || o;
        var result = Object.keys(o).find(function (key) {
            return predicate.call(context, o[key], key, o);
        });
        return result === undefined ? undefined : o[result];
    },

    /**
     * @desc Mimics Underscore's [reduce](http://underscorejs.org/#reduce) method: Boil down the values of all the members of the wrapped object into a single value. `memo` is the initial state of the reduction, and each successive step of it should be returned by `iteratee()`.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with four arguments: `(memo, value, key, object)`. The return value of this function becomes the new value of `memo` for the next iteration.
     * @param {*} [memo] - If no memo is passed to the initial invocation of reduce, the iteratee is not invoked on the first element of the list. The first element is instead passed as the memo in the invocation of the iteratee on the next element in the list.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The value of `memo` "reduced" as per `iteratee`.
     * @memberOf Wrapper.prototype
     */
    reduce: function (iteratee, memo, context) {
        var o = this.o;
        context = context || o;
        Object.keys(o).forEach(function (key, idx) {
            memo = (!idx && memo === undefined) ? o[key] : iteratee.call(context, memo, o[key], key, o);
        });
        return memo;
    },

    /**
     * @desc Mimics Underscore's [extend](http://underscorejs.org/#extend) method: Copy all of the properties in each of the `source` object parameter(s) over to the (wrapped) destination object (thus mutating it). It's in-order, so the properties of the last `source` object will override properties with the same name in previous arguments or in the destination object.
     * > This method copies own members as well as members inherited from prototype chain.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extend: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            if (object) {
                for (var key in object) {
                    o[key] = object[key];
                }
            }
        });
        return this.chaining ? this : o;
    },

    /**
     * @desc Mimics Underscore's [extendOwn](http://underscorejs.org/#extendOwn) method: Like {@link Wrapper#extend|extend}, but only copies its "own" properties over to the destination object.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extendOwn: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            Wrapper(object).each(function (val, key) { // eslint-disable-line new-cap
                o[key] = val;
            });
        });
        return this.chaining ? this : o;
    }
};

module.exports = Wrapper;

},{}],29:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

/* [ONCE CALLING CODE IS UPDATED AND TESTED, REMOVE THIS COMMENT + ALL LINES CONTAINING "Formerly..."]
 * This module rectangular.js differs from predecessor fin-rectangle.js as follows:
 * 1. Instead of creating Polymer component `fin-rectangles`, now does one of following:
 *  a. If object `exports` exists: Adds object as new property `exports.rectangular`
 *     thus supporting Node as well as file bundling by Browserify.
 *  b. If object `exports` does not exist: Adds object as new property
 *     `window.fin.rectangular` (first creating object `window.fin` if necessary)
 *     thus supporting client-side inclusion via <script> tag.
 * 2. File was reorganized to use prototypal inheritance so:
 *  a. change 'rectangles.point.create(' to 'new rectangular.Point('
 *  b. change 'rectangles.rectangle.create(' to 'new rectangular.Rectangle('
 * 3. Change all instances of 'ThanEqualTo' to 'ThanOrEqualTo'
 * 4. Change all invocations of Rectangle.top, .left, .bottom, .right, .width,
 *    .height, and .area to getter references by removing the invocation operator
 *    (i.e., the parentheses).
 */

(function(module, exports) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See https://github.com/joneit/mnm.

    /**
     * Creates a new read-only property and attaches it to the provided context.
     * @private
     * @param {string} name - Name for new property.
     * @param {*} [value] - Value of new property.
     */
    function addReadOnlyProperty(name, value) {
        Object.defineProperty(this, name, {
            value: value,
            writable: false,
            enumerable: true,
            configurable: false
        });
    }

    /**
     * @constructor Point
     *
     * @desc This object represents a single point in an abstract 2-dimensional matrix.
     *
     * The unit of measure is typically pixels.
     * (If used to model computer graphics, vertical coordinates are typically measured downwards
     * from the top of the window. This convention however is not inherent in this object.)
     *
     * Note: This object should be instantiated with the `new` keyword.
     *
     * @param {number} x - the new point's `x` property
     * @param {number} y - the new point's `y` property
     */
    function Point(x, y) {

        /**
         * @name x
         * @type {number}
         * @summary This point's horizontal coordinate.
         * @desc Created upon instantiation by the {@link Point|constructor}.
         * @memberOf Point.prototype
         * @abstract
         */
        addReadOnlyProperty.call(this, 'x', Number(x) || 0);

        /**
         * @name y
         * @type {number}
         * @summary This point's vertical coordinate.
         * @desc Created upon instantiation by the {@link Point|constructor}.
         * @memberOf Point.prototype
         * @abstract
         */
        addReadOnlyProperty.call(this, 'y', Number(y) || 0);

    }

    Point.prototype = {

        /**
         * @returns {Point} A new point which is this point's position increased by coordinates of given `point`.
         * @param {Point} Offset - Horizontal and vertical values to add to this point's coordinates.
         * @memberOf Point.prototype
         */
        plus: function(offset) {
            return new Point(
                this.x + offset.x,
                this.y + offset.y
            );
        },

        /**
         * @returns {Point} A new point which is this point's position increased by given offsets.
         * @param {number} [offsetX=0] - Value to add to this point's horizontal coordinate.
         * @param {number} [offsetY=0] - Value to add to this point's horizontal coordinate.
         * @memberOf Point.prototype
         */
        plusXY: function(offsetX, offsetY) {
            return new Point(
                this.x + (offsetX || 0),
                this.y + (offsetY || 0)
            );
        },

        /**
         * @returns {Point} A new point which is this point's position decreased by coordinates of given `point`.
         * @param {Point} offset - Horizontal and vertical values to subtract from this point's coordinates.
         * @memberOf Point.prototype
         */
        minus: function(offset) {
            return new Point(
                this.x - offset.x,
                this.y - offset.y
            );
        },

        /**
         * @returns {Point} A new `Point` positioned to least x and least y of this point and given `point`.
         * @param {Point} point - A point to compare to this point.
         * @memberOf Point.prototype
         */
        min: function(point) {
            return new Point(
                Math.min(this.x, point.x),
                Math.min(this.y, point.y)
            );
        },

        /**
         * @returns {Point} A new `Point` positioned to greatest x and greatest y of this point and given `point`.
         * @param {Point} point - A point to compare to this point.
         * @memberOf Point.prototype
         */
        max: function(point) {
            return new Point(
                Math.max(this.x, point.x),
                Math.max(this.y, point.y)
            );
        },

        /**
         * @returns {number} Distance between given `point` and this point using Pythagorean Theorem formula.
         * @param {Point} point - A point from which to compute the distance to this point.
         * @memberOf Point.prototype
         */
        distance: function(point) {
            var deltaX = point.x - this.x,
                deltaY = point.y - this.y;

            return Math.sqrt(
                deltaX * deltaX +
                deltaY * deltaY
            );
        },

        /**
         * _(Formerly: `equal`.)_
         * @returns {boolean} `true` iff _both_ coordinates of this point are exactly equal to those of given `point`.
         * @param {Point} point - A point to compare to this point.
         * @memberOf Point.prototype
         */
        equals: function(point) {
            var result = false;

            if (point) {
                result =
                    this.x === point.x &&
                    this.y === point.y;
            }

            return result;
        },

        /**
         * @returns {boolean} `true` iff _both_ coordinates of this point are greater than those of given `point`.
         * @param {Point} point - A point to compare to this point
         * @memberOf Point.prototype
         */
        greaterThan: function(point) {
            return (
                this.x > point.x &&
                this.y > point.y
            );
        },

        /**
         * @returns {boolean} `true` iff _both_ coordinates of this point are less than those of given `point`.
         * @param {Point} point - A point to compare to this point
         * @memberOf Point.prototype
         */
        lessThan: function(point) {
            return (
                this.x < point.x &&
                this.y < point.y
            );
        },

        /**
         * _(Formerly `greaterThanEqualTo`.)_
         * @returns {boolean} `true` iff _both_ coordinates of this point are greater than or equal to those of given `point`.
         * @param {Point} point - A point to compare to this point
         * @memberOf Point.prototype
         */
        greaterThanOrEqualTo: function(point) {
            return (
                this.x >= point.x &&
                this.y >= point.y
            );
        },

        /**
         * _(Formerly `lessThanEqualTo`.)_
         * @returns {boolean} `true` iff _both_ coordinates of this point are less than or equal to those of given `point`.
         * @param {Point} point - A point to compare to this point.
         * @memberOf Point.prototype
         */
        lessThanOrEqualTo: function(point) {
            return (
                this.x <= point.x &&
                this.y <= point.y
            );
        },

        /**
         * _(Formerly `isContainedWithinRectangle`.)_
         * @param rect {Rectangle} - Rectangle to test this point against.
         * @returns {boolean} `true` iff this point is within given `rect`.
         * @memberOf Point.prototype
         */
        within: function(rect) {
            var minX = rect.origin.x,
                maxX = minX + rect.extent.x;
            var minY = rect.origin.y,
                maxY = minY + rect.extent.y;

            if (rect.extent.x < 0) {
                minX = maxX;
                maxX = rect.origin.x;
            }

            if (rect.extent.y < 0) {
                minY = maxY;
                maxY = rect.origin.y;
            }

            return (
                minX <= this.x && this.x < maxX &&
                minY <= this.y && this.y < maxY
            );
        }
    };

    Point.prototype.EQ = Point.prototype.equals;
    Point.prototype.GT = Point.prototype.greaterThan;
    Point.prototype.LT = Point.prototype.lessThan;
    Point.prototype.GE = Point.prototype.greaterThanOrEqualTo;
    Point.prototype.LE = Point.prototype.lessThanOrEqualTo;


    /**
     * @constructor Rectangle
     *
     * @desc This object represents a rectangular area within an abstract 2-dimensional matrix.
     *
     * The unit of measure is typically pixels.
     * (If used to model computer graphics, vertical coordinates are typically measured downwards
     * from the top of the window. This convention however is not inherent in this object.)
     *
     * Normally, the `x` and `y` parameters to the constructor describe the upper left corner of the rect.
     * However, negative values of `width` and `height` will be added to the given `x` and `y`. That is,
     * a negative value of the `width` parameter will extend the rect to the left of the given `x` and
     * a negative value of the `height` parameter will extend the rect above the given `y`.
     * In any case, after instantiation the following are guaranteed to always be true:
     * * The `extent`, `width`, and `height` properties _always_ give positive values.
     * * The `origin`, `top`, and `left` properties _always_ reflect the upper left corner.
     * * The `corner`, `bottom`, and `right` properties _always_ reflect the lower right corner.
     *
     * Note: This object should be instantiated with the `new` keyword.
     *
     * @param {number} [x=0] - Horizontal coordinate of some corner of the rect.
     * @param {number} [y=0] - Vertical coordinate of some corner of the rect.
     * @param {number} [width=0] - Width of the new rect. May be negative (see above).
     * @param {number} [height=0] - Height of the new rect. May be negative (see above).
     */
    function Rectangle(x, y, width, height) {

        x = Number(x) || 0;
        y = Number(y) || 0;
        width = Number(width) || 0;
        height = Number(height) || 0;

        if (width < 0) {
            x += width;
            width = -width;
        }

        if (height < 0) {
            y += height;
            height = -height;
        }

        /**
         * @name origin
         * @type {Point}
         * @summary Upper left corner of this rect.
         * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
         * @memberOf Rectangle.prototype
         * @abstract
         */
        addReadOnlyProperty.call(this, 'origin', new Point(x, y));

        /**
         * @name extent
         * @type {Point}
         * @summary this rect's width and height.
         * @desc Unlike the other `Point` properties, `extent` is not a global coordinate pair; rather it consists of a _width_ (`x`, always positive) and a _height_ (`y`, always positive).
         *
         * This object might be more legitimately typed as something like `Area` with properties `width` and `height`; however we wanted it to be able to use it efficiently with a point's `plus` and `minus` methods (that is, without those methods having to check and branch on the type of its parameter).
         *
         * Created upon instantiation by the {@linkplain Rectangle|constructor}.
         * @see The {@link Rectangle#corner|corner} method.
         * @memberOf Rectangle.prototype
         * @abstract
         */
        addReadOnlyProperty.call(this, 'extent', new Point(width, height));

        /**
         * @name corner
         * @type {Point}
         * @summary Lower right corner of this rect.
         * @desc This is a calculated value created upon instantiation by the {@linkplain Rectangle|constructor}. It is `origin` offset by `extent`.
         *
         * **Note:** These coordinates actually point to the pixel one below and one to the right of the rect's actual lower right pixel.
         * @memberOf Rectangle.prototype
         * @abstract
         */
        addReadOnlyProperty.call(this, 'corner', new Point(x + width, y + height));

        /**
         * @name center
         * @type {Point}
         * @summary Center of this rect.
         * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
         * @memberOf Rectangle.prototype
         * @abstract
         */
        addReadOnlyProperty.call(this, 'center', new Point(x + (width / 2), y + (height / 2)));

    }

    Rectangle.prototype = {

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Minimum vertical coordinate of this rect.
         * @memberOf Rectangle.prototype
         */
        get top() {
            return this.origin.y;
        },

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Minimum horizontal coordinate of this rect.
         * @memberOf Rectangle.prototype
         */
        get left() {
            return this.origin.x;
        },

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Maximum vertical coordinate of this rect + 1.
         * @memberOf Rectangle.prototype
         */
        get bottom() {
            return this.corner.y;
        },

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Maximum horizontal coordinate of this rect + 1.
         * @memberOf Rectangle.prototype
         */
        get right() {
            return this.corner.x;
        },

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Width of this rect (always positive).
         * @memberOf Rectangle.prototype
         */
        get width() {
            return this.extent.x;
        },

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Height of this rect (always positive).
         * @memberOf Rectangle.prototype
         */
        get height() {
            return this.extent.y;
        },

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Area of this rect.
         * @memberOf Rectangle.prototype
         */
        get area() {
            return this.width * this.height;
        },

        /**
         * @returns {Rectangle} A copy of this rect but with horizontal position reset to given `x` and no width.
         * @param {number} x - Horizontal coordinate of the new rect.
         * @memberOf Rectangle.prototype
         */
        flattenXAt: function(x) {
            return new Rectangle(x, this.origin.y, 0, this.extent.y);
        },

        /**
         * @returns {Rectangle} A copy of this rect but with vertical position reset to given `y` and no height.
         * @param {number} y - Vertical coordinate of the new rect.
         * @memberOf Rectangle.prototype
         */
        flattenYAt: function(y) {
            return new Rectangle(this.origin.x, y, this.extent.x, 0);
        },

        /**
         * @returns {boolean} `true` iff given `point` entirely contained within this rect.
         * @param {Point} pointOrRect - The point or rect to test for containment.
         * @memberOf Rectangle.prototype
         */
        contains: function(pointOrRect) {
            return pointOrRect.within(this);
        },

        /**
         * _(Formerly `isContainedWithinRectangle`.)_
         * @returns {boolean} `true` iff `this` rect is entirely contained within given `rect`.
         * @param {Rectangle} rect - Rectangle to test against this rect.
         * @memberOf Rectangle.prototype
         */
        within: function(rect) {
            return (
                rect.origin.lessThanOrEqualTo(this.origin) &&
                rect.corner.greaterThanOrEqualTo(this.corner)
            );
        },

        /**
         * _(Formerly: `insetBy`.)_
         * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
         * @param {number} padding - Amount by which to increase (+) or decrease (-) this rect
         * @see The {@link Rectangle#shrinkBy|shrinkBy} method.
         * @memberOf Rectangle.prototype
         */
        growBy: function(padding) {
            return new Rectangle(
                this.origin.x + padding,
                this.origin.y + padding,
                this.extent.x - padding - padding,
                this.extent.y - padding - padding);
        },

        /**
         * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
         * @param {number} padding - Amount by which to decrease (+) or increase (-) this rect.
         * @see The {@link Rectangle#growBy|growBy} method.
         * @memberOf Rectangle.prototype
         */
        shrinkBy: function(padding) {
            return this.growBy(-padding);
        },

        /**
         * @returns {Rectangle} Bounding rect that contains both this rect and the given `rect`.
         * @param {Rectangle} rect - The rectangle to union with this rect.
         * @memberOf Rectangle.prototype
         */
        union: function(rect) {
            var origin = this.origin.min(rect.origin),
                corner = this.corner.max(rect.corner),
                extent = corner.minus(origin);

            return new Rectangle(
                origin.x, origin.y,
                extent.x, extent.y
            );
        },

        /**
         * iterate over all points within this rect, invoking `iteratee` for each.
         * @param {function(number,number)} iteratee - Function to call for each point.
         * Bound to `context` when given; otherwise it is bound to this rect.
         * Each invocation of `iteratee` is called with two arguments:
         * the horizontal and vertical coordinates of the point.
         * @param {object} [context=this] - Context to bind to `iteratee` (when not `this`).
         * @memberOf Rectangle.prototype
         */
        forEach: function(iteratee, context) {
            context = context || this;
            for (var x = this.origin.x, x2 = this.corner.x; x < x2; x++) {
                for (var y = this.origin.y, y2 = this.corner.y; y < y2; y++) {
                    iteratee.call(context, x, y);
                }
            }
        },

        /**
         * @returns {Rectangle} One of:
         * * _If this rect intersects with the given `rect`:_
         *      a new rect representing that intersection.
         * * _If it doesn't intersect and `ifNoneAction` defined:_
         *      result of calling `ifNoneAction`.
         * * _If it doesn't intersect and `ifNoneAction` undefined:_
         *      `null`.
         * @param {Rectangle} rect - The rectangle to intersect with this rect.
         * @param {function(Rectangle)} [ifNoneAction] - When no intersection, invoke and return result.
         * Bound to `context` when given; otherwise bound to this rect.
         * Invoked with `rect` as sole parameter.
         * @param {object} [context=this] - Context to bind to `ifNoneAction` (when not `this`).
         * @memberOf Rectangle.prototype
         */
        intersect: function(rect, ifNoneAction, context) {
            var result = null,
                origin = this.origin.max(rect.origin),
                corner = this.corner.min(rect.corner),
                extent = corner.minus(origin);

            if (extent.x > 0 && extent.y > 0) {
                result = new Rectangle(
                    origin.x, origin.y,
                    extent.x, extent.y
                );
            } else if (typeof ifNoneAction === 'function') {
                result = ifNoneAction.call(context || this, rect);
            }

            return result;
        },

        /**
         * @returns {boolean} `true` iff this rect overlaps with given `rect`.
         * @param {Rectangle} rect - The rectangle to intersect with this rect.
         * @memberOf Rectangle.prototype
         */
        intersects: function(rect) {
            return (
                rect.corner.x > this.origin.x &&
                rect.corner.y > this.origin.y &&
                rect.origin.x < this.corner.x &&
                rect.origin.y < this.corner.y
            );
        }
    };

    // Interface
    exports.Point = Point;
    exports.Rectangle = Rectangle;
})(
    typeof module === 'object' && module || (window.rectangular = {}),
    typeof module === 'object' && module.exports || (window.rectangular.exports = {})
) || (
    typeof module === 'object' || (window.rectangular = window.rectangular.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.rectangular`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `window` object undefined, we're in NodeJs so assume there is a `module` object with an `exports` property
 * 2. If `window` object defined, we're in browser
 * 2.a. If `module` object predefined, use it
 * 2.b. If `module` object undefined, create a `rectangular` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will execute:
 * 1. If `window` object undefined, then we're in NodeJs so we're done
 * 2. If `window` object defined, then we're in browser
 * 2.a. If `module` object predefined, we're done; results are in `moudule.exports`
 * 2.b. If `module` object undefined, redefine`rectangular` to be the `rectangular.exports` object
 */

},{}],30:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

(function (module) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See https://github.com/joneit/mnm.

    /**
     * @constructor RangeSelectionModel
     *
     * @desc This object models selection of "cells" within an abstract single-dimensional matrix.
     *
     * Disjoint selections can be built with calls to the following methods:
     * * {@link RangeSelectionModel#select|select(start, stop)} - Add a range to the matrix.
     * * {@link RangeSelectionModel#deselect|deselect(start, stop)} - Remove a range from the matrix.
     *
     * Two more methods are available:
     * * Test a cell to see if it {@link RangeSelectionModel#isSelected|isSelected(cell)}
     * * {@link RangeSelectionModel#clear|clear()} the matrix
     *
     * Internally, the selection is run-length-encoded. It is therefore a "sparse" matrix
     * with undefined bounds. A single data property called `selection` is an array that
     * contains all the "runs" (ranges) of selected cells albeit in no particular order.
     * This property should not normally need to be accessed directly.
     *
     * Note: This object should be instantiated with the `new` keyword.
     *
     * @returns {RangeSelectionModel} Self (i.e., `this` object).
     */
    function RangeSelectionModel() {
        /**
         * @name selection
         * @type {Array.Array.number}
         * @summary Unordered list of runs.
         * @desc A "run" is defined as an Array(2) where:
         * * element [0] is the beginning of the run
         * * element [1] is the end of the run (inclusive) and is always >= element [0]
         * The order of the runs within is undefined.
         * @memberOf RangeSelectionModel.prototype
         * @abstract
         */
        this.selection = [];

        //we need to be able to go back in time
        //the states field
        this.states = [];

        //clone and store my current state
        //so we can unwind changes if need be
        this.storeState = function () {
            var sels = this.selection;
            var state = [];
            var copy;
            for (var i = 0; i < sels.length; i++) {
                copy = [].concat(sels[i]);
                state.push(copy);
            }
            this.states.push(state);
        };
    }

    RangeSelectionModel.prototype = {

        /**
         * @summary Add a contiguous run of points to the selection.
         * @desc Insert a new run into `this.selection`.
         * The new run will be merged with overlapping and adjacent runs.
         *
         * The two parameters may be given in either order.
         * The start and stop elements in the resulting run will however always be ordered.
         * (However, note that the order of the runs within `this.selection` is itself always unordered.)
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        select: function (start, stop) {
            this.storeState();
            var run = makeRun(start, stop);
            var splicer = [0, 1];
            this.selection.forEach(function (each) {
                if (overlaps(each, run) || abuts(each, run)) {
                    run = merge(each, run);
                } else {
                    splicer.push(each);
                }
            });
            splicer.push(run);
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Remove a contiguous run of points from the selection.
         * @desc Truncate and/or remove run(s) from `this.selection`.
         * Removing part of existing runs will (correctly) shorten them or break them into two fragments.
         *
         * The two parameters may be given in either order.
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        deselect: function (start, stop) {
            var run = makeRun(start, stop);
            var splicer = [0, 0];
            this.selection.forEach(function (each) {
                if (overlaps(each, run)) {
                    var pieces = subtract(each, run);
                    splicer = splicer.concat(pieces);
                } else {
                    splicer.push(each);
                }
            });
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Empties `this.selection`, effectively removing all runs.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        clear: function () {
            this.states.length = 0;
            this.selection.length = 0;
            return this;
        },

        clearMostRecentSelection: function () {
            if (this.states.length === 0) {
                return;
            }
            this.selection = this.states.pop();
        },

        /**
         * @summary Determines if the given `cell` is selected.
         * @returns {boolean} `true` iff given `cell` is within any of the runs in `this.selection`.
         * @param {number} cell - The cell to test for inclusion in the selection.
         * @memberOf RangeSelectionModel.prototype
         */
        isSelected: function (cell) {
            return this.selection.some(function (each) {
                return each[0] <= cell && cell <= each[1];
            });
        },

        isEmpty: function (){
            return this.selection.length === 0;
        },

        /**
         * @summary Return the indexes that are selected.
         * @desc Return the indexes that are selected.
         * @returns {Array.Array.number}
         * @memberOf RangeSelectionModel.prototype
         */
        getSelections: function (){
            var result = [];
            this.selection.forEach(function (each) {
                for (var i = each[0]; i <= each[1]; i++) {
                    result.push(i);
                }
            });
            result.sort(function (a, b){
                return a - b;
            });
            return result;
        }

    };

    /**
     * @private
     * @summary Preps `start` and `stop` params into order array
     * @function makeRun
     * @desc Utility function called by both `select()` and `deselect()`.
     * @param {number|number[]} start - Start of run. if array, `start` and `stop` are taken from first two elements.
     * @param {number} [stop=start] - End of run (inclusive).
     */
    function makeRun(start, stop) {
        return (
            start instanceof Array
                ? makeRun.apply(this, start) // extract params from given array
                : stop === undefined
                ? [ start, start ] // single param is a run that stops where it starts
                : start <= stop
                ? [ start, stop ]
                : [ stop, start ] // reverse descending params into ascending order
        );
    }

    /**
     * @private
     * @function overlaps
     * @returns {boolean} `true` iff `run1` overlaps `run2`
     * @summary Comparison operator that determines if given runs overlap with one another.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Overlap is defined to include the case where one run completely contains the other.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function overlaps(run1, run2) {
        return (
            run1[0] <= run2[0] && run2[0] <= run1[1] || // run2's start is within run1 OR...
            run1[0] <= run2[1] && run2[1] <= run1[1] || // run2's stop is within run1 OR...
            run2[0] <  run1[0] && run1[1] <  run2[1]    // run2 completely contains run1
        );
    }

    /**
     * @private
     * @function abuts
     * @summary Comparison operator that determines if given runs are consecutive with one another.
     * @returns {boolean} `true` iff `run1` is consecutive with `run2`
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function abuts(run1, run2) {
        return (
            run1[1] === run2[0] - 1 || // run1's top immediately precedes run2's start OR...
            run2[1] === run1[0] - 1    // run2's top immediately precedes run1's start
        );
    }

    /**
     * @private
     * @function subtract
     * @summary Operator that subtracts one run from another.
     * @returns {Array.Array.number} The remaining pieces of `minuend` after removing `subtrahend`.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * This function _does not assumes_ that `overlap()` has already been called with the same runs and has returned `true`.
     *
     * Returned array contains 0, 1, or 2 runs which are the portion(s) of `minuend` that do _not_ include `subtrahend`.
     *
     * Caveat: This operator is *not* commutative.
     * @param {number[]} minuend - a run from which to "subtract" `subtrahend`
     * @param {number[]} subtrahend - a run to "subtracted" from `minuend`
     */
    function subtract(minuend, subtrahend) {
        var m0 = minuend[0];
        var m1 = minuend[1];
        var s0 = subtrahend[0];
        var s1 = subtrahend[1];
        var result = [];

        if (s0 <= m0 && s1 < m1) {
            //subtrahend extends before minuend: return remaining piece of `minuend`
            result.push([s1 + 1, m1]);
        } else if (s0 > m0 && s1 >= m1) {
            //subtrahend extends after minuend: return remaining piece of `minuend`
            result.push([m0, s0 - 1]);
        } else if (m0 < s0 && s1 < m1) {
            //completely inside: return 2 smaller pieces resulting from the hole
            result.push([m0, s0 - 1]);
            result.push([s1 + 1, m1]);
        } else if (s1 < m0 || s0 > m1) {
            // completely outside: return `minuend` untouched
            result.push(minuend);
        }

        //else subtrahend must completely overlap minuend so return no pieces

        return result;
    }


    // Local utility functions

    /**
     * @private
     * @function merge
     * @summary Operator that merges given runs.
     * @returns {number[]} A single merged run.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * The runs are assumed to be overlapping or adjacent to one another.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - a run to merge with `run2`
     * @param {number[]} run2 - a run to merge with `run1`
     */
    function merge(run1, run2) {
        var min = Math.min(Math.min.apply(Math, run1), Math.min.apply(Math, run2));
        var max = Math.max(Math.max.apply(Math, run1), Math.max.apply(Math, run2));
        return [min, max];
    }

    // Interface
    module.exports = RangeSelectionModel;
})(
    typeof module === 'object' && module || (window.RangeSelectionModel = {}),
    typeof module === 'object' && module.exports || (window.RangeSelectionModel.exports = {})
) || (
    typeof module === 'object' || (window.RangeSelectionModel = window.RangeSelectionModel.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.RangeSelectionModel`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `window` object undefined, we're in NodeJs so assume there is a `module` object with an `exports` property
 * 2. If `window` object defined, we're in browser
 * 2.a. If `module` object predefined, use it
 * 2.b. If `module` object undefined, create a `RangeSelectionModel` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will execute:
 * 1. If `window` object undefined, then we're in NodeJs so we're done
 * 2. If `window` object defined, then we're in browser
 * 2.a. If `module` object predefined, we're done; results are in `moudule.exports`
 * 2.b. If `module` object undefined, redefine`RangeSelectionModel` to be the `RangeSelectionModel.exports` object
 */

},{}],31:[function(require,module,exports){
// templex node module
// https://github.com/joneit/templex

/* eslint-env node, browser */ //to allow refs to `window` in IIFE's call's actual params

(function (module, exports) { // eslint-disable-line no-unused-expressions, no-unused-vars

    // This closure supports NodeJS-less client side includes with <script> tags. See notes at bottom of this file.

    /**
     * Merges values of execution context properties named in template by {prop1},
     * {prop2}, etc., or any javascript expression incorporating such prop names.
     * The context always includes the global object. In addition you can specify a single
     * context or an array of contexts to search (in the order given) before finally
     * searching the global context.
     *
     * Merge expressions consisting of simple numeric terms, such as {0}, {1}, etc., deref
     * the first context given, which is assumed to be an array. As a convenience feature,
     * if additional args are given after `template`, `arguments` is unshifted onto the context
     * array, thus making first additional arg available as {1}, second as {2}, etc., as in
     * `templex('Hello, {1}!', 'World')`. ({0} is the template so consider this to be 1-based.)
     *
     * If you prefer something other than braces, redefine `templex.regexp`.
     *
     * See tests for examples.
     *
     * @param {string} template
     * @param {...string} [args]
     */
    function templex(template) {
        var contexts = this instanceof Array ? this : [this];
        if (arguments.length > 1) { contexts.unshift(arguments); }
        return template.replace(templex.regexp, templex.merger.bind(contexts));
    }

    templex.regexp = /\{(.*?)\}/g;

    templex.with = function (i, s) {
        return 'with(this[' + i + ']){' + s + '}';
    };

    templex.cache = [];

    templex.deref = function (key) {
        if (!(this.length in templex.cache)) {
            var code = 'return eval(expr)';

            for (var i = 0; i < this.length; ++i) {
                code = templex.with(i, code);
            }

            templex.cache[this.length] = eval('(function(expr){' + code + '})'); // eslint-disable-line no-eval
        }
        return templex.cache[this.length].call(this, key);
    };

    templex.merger = function (match, key) {
        // Advanced features: Context can be a list of contexts which are searched in order.
        var replacement;

        try {
            replacement = isNaN(key) ? templex.deref.call(this, key) : this[0][key];
        } catch (e) {
            replacement = '{' + key + '}';
        }

        return replacement;
    };

    // this interface consists solely of the templex function object
    module.exports = templex;

})(
    typeof module === 'object' && module || (window.templex = {}),
    typeof module === 'object' && module.exports || (window.templex.exports = {})
) || (
    typeof module === 'object' || (window.templex = window.templex.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.templex`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `module` object defined, we're in NodeJs so assume there is a `module` object with an `exports` object
 * 2. If `module` object undefined, we're in browser so define a `window.templex` object with an `exports` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will always execute:
 * 1. If `module` object defined, then we're in NodeJs so we're done
 * 2. If `module` object undefined, then we're in browser so redefine`window.templex` as its `exports` object
 */

},{}],32:[function(require,module,exports){
'use strict';

var Base = require('extend-me').Base;

/** @constructor
 * @desc Instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
 *
 * See {@link CellProvider#initialize|initialize} which is called by the constructor.
 */
var CellProvider = Base.extend('CellProvider', {

    /**
     * @summary Constructor logic
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     * @memberOf CellProvider.prototype
     */
    initialize: function() {
        this.cellCache = {};
        this.initializeCells();
    },

    /**
     * @desc replace this function in on your instance of cellProvider
     * @returns cell
     * @param {object} config - an object with everything you might need for renderering a cell
     * @memberOf CellProvider.prototype
     */
    getCell: function(config) {
        var cell = this.cellCache.simpleCellRenderer;
        cell.config = config;
        return cell;
    },

    /**
     * @desc replace this function in on your instance of cellProvider
     * @returns cell
     * @param {object} config - an object with everything you might need for renderering a cell
     * @memberOf CellProvider.prototype
     */
    getColumnHeaderCell: function(config) {
        var cell = this.cellCache.simpleCellRenderer;
        cell.config = config;
        return cell;
    },

    /**
     * @desc replace this function in on your instance of cellProvider
     * @returns cell
     * @param {object} config - an object with everything you might need for renderering a cell
     * @memberOf CellProvider.prototype
     */
    getRowHeaderCell: function(config) {
        var cell = this.cellCache.simpleCellRenderer;
        cell.config = config;
        return cell;
    },

    paintButton: function(gc, config) {
        var val = config.value;
        var c = config.x;
        var r = config.y;
        var bounds = config.bounds;
        var x = bounds.x + 2;
        var y = bounds.y + 2;
        var width = bounds.width - 3;
        var height = bounds.height - 3;
        var radius = height / 2;
        var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        if (config.mouseDown) {
            arcGradient.addColorStop(0, '#B5CBED');
            arcGradient.addColorStop(1, '#4d74ea');
        } else {
            arcGradient.addColorStop(0, '#ffffff');
            arcGradient.addColorStop(1, '#aaaaaa');
        }
        gc.fillStyle = arcGradient;
        gc.strokeStyle = '#000000';
        roundRect(gc, x, y, width, height, radius, arcGradient, true);

        var ox = (width - config.getTextWidth(gc, val)) / 2;
        var oy = (height - config.getTextHeight(gc.font).descent) / 2;

        if (gc.textBaseline !== 'middle') {
            gc.textBaseline = 'middle';
        }

        gc.fillStyle = '#000000';

        config.backgroundColor = 'rgba(0,0,0,0)';
        gc.fillText(val, x + ox, y + oy);

        //identify that we are a button
        config.buttonCells[c + ',' + r] = true;
    },

    /**
     * @summary The default cell rendering function for rendering a vanilla cell.
     * @desc Great care has been taken in crafting this function as it needs to perform extremely fast. Reads on the gc object are expensive but not quite as expensive as writes to it. We do our best to avoid writes, then avoid reads. Clipping bounds are not set here as this is also an expensive operation. Instead, we truncate overflowing text and content by filling a rectangle with background color column by column instead of cell by cell.  This column by column fill happens higher up on the stack in a calling function from fin-hypergrid-renderer.  Take note we do not do cell by cell border renderering as that is expensive.  Instead we render many fewer gridlines after all cells are rendered.
     * @param {CanvasGraphicsContext} gc - the "pen" in the mvc model, we issue drawing commands to
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {boolean} isLink - is this a hyperlink cell
     * @memberOf CellProvider.prototype
     */
    defaultCellPaint: function(gc, config) {
        var val = config.value,
            x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height,
            wrapHeaders = config.headerTextWrapping,
            leftPadding = 2, //TODO: fix this
            isHeader = config.y === 0;

        var leftIcon, rightIcon, centerIcon, ixoffset, iyoffset;

        //setting gc properties are expensive, lets not do it unnecessarily

        if (val && val.constructor === Array) {
            leftIcon = val[0];
            rightIcon = val[2];
            val = val[1];
            if (typeof val === 'object') { // must be an image
                centerIcon = val;
                val = null;
            }
            if (leftIcon && leftIcon.nodeName !== 'IMG') {
                leftIcon = null;
            }
            if (rightIcon && rightIcon.nodeName !== 'IMG') {
                rightIcon = null;
            }
            if (centerIcon && centerIcon.nodeName !== 'IMG') {
                centerIcon = null;
            }
        }

        val = valueOrFunctionExecute(config, val);

        if (gc.font !== config.font) {
            gc.font = config.font;
        }
        if (gc.textAlign !== 'left') {
            gc.textAlign = 'left';
        }
        if (gc.textBaseline !== 'middle') {
            gc.textBaseline = 'middle';
        }

        //fill background only if our bgColor is populated or we are a selected cell
        if (config.backgroundColor || config.isSelected) {
            gc.fillStyle = valueOrFunctionExecute(config, config.isSelected ? config.backgroundSelectionColor : config.backgroundColor);
            gc.fillRect(x, y, width, height);
        }

        //draw text
        var theColor = valueOrFunctionExecute(config, config.isSelected ? config.foregroundSelectionColor : config.color);
        if (gc.fillStyle !== theColor) {
            gc.fillStyle = theColor;
            gc.strokeStyle = theColor;
        }

        if (isHeader && wrapHeaders) {
            this.renderMultiLineText(x, y, height, width, gc, config, val);
        } else {
            this.renderSingleLineText(x, y, height, width, gc, config, val);
        }

        if (config.isInCurrentSelectionRectangle) {
            gc.fillStyle = 'rgba(0, 0, 0, 0.2)';
            gc.fillRect(x, y, width, height);
        }
        var iconWidth = 0;
        if (leftIcon) {
            iyoffset = Math.round((height - leftIcon.height) / 2);
            gc.drawImage(leftIcon, x + leftPadding, y + iyoffset);
            iconWidth = Math.max(leftIcon.width + 2);
        }
        if (rightIcon) {
            iyoffset = Math.round((height - rightIcon.height) / 2);
            ixoffset = 0; //Math.round((halignOffset - rightIcon.width) / 2);
            gc.drawImage(rightIcon, x + width - ixoffset - rightIcon.width, y + iyoffset);
            iconWidth = Math.max(rightIcon.width + 2);
        }
        if (centerIcon) {
            iyoffset = Math.round((height - centerIcon.height) / 2);
            ixoffset = Math.round((width - centerIcon.width) / 2);
            gc.drawImage(centerIcon, x + width - ixoffset - centerIcon.width, y + iyoffset);
            iconWidth = Math.max(centerIcon.width + 2);
        }
        if (config.cellBorderThickness) {
            gc.beginPath();
            gc.rect(x, y, width, height);
            gc.lineWidth = config.cellBorderThickness;
            gc.strokeStyle = config.cellBorderStyle;

            // animate the dashed line a bit here for fun

            gc.stroke();
            gc.closePath();
        }
        config.minWidth = config.minWidth + 2 * (iconWidth);
    },

    renderMultiLineText: function(x, y, height, width, gc, config, val) {
        var lines = fitText(gc, config, val, width);
        if (lines.length === 1) {
            return this.renderSingleLineText(x, y, height, width, gc, config, squeeze(val));
        }

        var colHEdgeOffset = config.cellPadding,
            halignOffset = 0,
            valignOffset = config.voffset,
            halign = config.halign,
            textHeight = config.getTextHeight(config.font).height;

        switch (halign) {
            case 'right':
                halignOffset = width - colHEdgeOffset;
                break;
            case 'center':
                halignOffset = width / 2;
                break;
            case 'left':
                halignOffset = colHEdgeOffset;
                break;
        }

        var hMin = 0, vMin = Math.ceil(textHeight / 2);

        valignOffset += Math.ceil((height - (lines.length - 1) * textHeight) / 2);

        halignOffset = Math.max(hMin, halignOffset);
        valignOffset = Math.max(vMin, valignOffset);

        gc.save(); // define a clipping region for cell
        gc.moveTo(x, y);
        gc.lineTo(x + width, y);
        gc.lineTo(x + width, y + height);
        gc.lineTo(x, y + height);
        gc.lineTo(x, y);
        gc.closePath();
        gc.clip();

        gc.textAlign = halign;

        for (var i = 0; i < lines.length; i++) {
            gc.fillText(lines[i], x + halignOffset, y + valignOffset + (i * textHeight));
        }

        gc.restore(); // discard clipping region
    },

    renderSingleLineText: function(x, y, height, width, gc, config, val) {
        var colHEdgeOffset = config.cellPadding,
            halignOffset = 0,
            valignOffset = config.voffset,
            halign = config.halign,
            isColumnHovered = config.isColumnHovered,
            isRowHovered = config.isRowHovered,
            isLink = isLink || false;

        var fontMetrics = config.getTextHeight(config.font);
        var textWidth = config.getTextWidth(gc, val);

        //we must set this in order to compute the minimum width
        //for column autosizing purposes
        config.minWidth = textWidth + (2 * colHEdgeOffset);

        switch (halign) {
            case 'right':
                //textWidth = config.getTextWidth(gc, config.value);
                halignOffset = width - colHEdgeOffset - textWidth;
                break;
            case 'center':
                //textWidth = config.getTextWidth(gc, config.value);
                halignOffset = (width - textWidth) / 2;
                break;
            case 'left':
                halignOffset = colHEdgeOffset;
                break;
        }

        halignOffset = Math.max(0, halignOffset);
        valignOffset = valignOffset + Math.ceil(height / 2);

        if (val !== null) {
            gc.fillText(val, x + halignOffset, y + valignOffset);
        }

        if (isColumnHovered && isRowHovered) {
            gc.beginPath();
            if (isLink) {
                underline(config, gc, val, x + halignOffset, y + valignOffset + Math.floor(fontMetrics.height / 2), 1);
                gc.stroke();
            }
            gc.closePath();
        }
    },

    /**
     * @param {CanvasGraphicsContext} gc - the "pen" in the mvc model, we issue drawing commands to
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {boolean} isLink - is this a hyperlink cell
     * @memberOf CellProvider.prototype
     * @desc emersons paint function for a slider button. currently the user cannot interact with it
     */
    paintSlider: function(gc, x, y, width, height) {
        // gc.strokeStyle = 'white';
        // var val = this.config.value;
        // var radius = height / 2;
        // var offset = width * val;
        // var bgColor = this.config.isSelected ? this.config.bgSelColor : '#333333';
        // var btnGradient = gc.createLinearGradient(x, y, x, y + height);
        // btnGradient.addColorStop(0, bgColor);
        // btnGradient.addColorStop(1, '#666666');
        // var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        // arcGradient.addColorStop(0, '#aaaaaa');
        // arcGradient.addColorStop(1, '#777777');
        // gc.fillStyle = btnGradient;
        // roundRect(gc, x, y, width, height, radius, btnGradient);
        // if (val < 1.0) {
        //     gc.fillStyle = arcGradient;
        // } else {
        //     gc.fillStyle = '#eeeeee';
        // }
        // gc.beginPath();
        // gc.arc(x + Math.max(offset - radius, radius), y + radius, radius, 0, 2 * Math.PI);
        // gc.fill();
        // gc.closePath();
        // this.config.minWidth = 100;
    },

    /**
     * @desc A simple implementation of a sparkline, because it's a barchart we've changed the name ;).
     * @param {CanvasGraphicsContext} gc - the "pen" in the mvc model, we issue drawing commands to
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {boolean} isLink - is this a hyperlink cell
     * @memberOf CellProvider.prototype
     */
    paintSparkbar: function(gc, x, y, width, height) {
        gc.beginPath();
        var val = this.config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;
        var fgColor = this.config.isSelected ? this.config.fgSelColor : this.config.fgColor;
        if (this.config.bgColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.bgSelColor : this.config.bgColor;
            gc.fillRect(x, y, width, height);
        }
        gc.fillStyle = fgColor;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            gc.fillRect(x + 5, y + height - barheight, eWidth * 0.6666, barheight);
            x = x + eWidth;
        }
        gc.closePath();
        this.config.minWidth = count * 10;

    },

    /**
     * @desc A simple implementation of a sparkline.  see [Edward Tufte sparkline](http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR)
     * @param {CanvasGraphicsContext} gc - the "pen" in the mvc model, we issue drawing commands to
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {boolean} isLink - is this a hyperlink cell
     * @memberOf CellProvider.prototype
     */
    paintSparkline: function(gc, x, y, width, height) {
        gc.beginPath();
        var val = this.config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;

        var fgColor = this.config.isSelected ? this.config.fgSelColor : this.config.fgColor;
        if (this.config.bgColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.bgSelColor : this.config.bgColor;
            gc.fillRect(x, y, width, height);
        }
        gc.strokeStyle = fgColor;
        gc.fillStyle = fgColor;
        gc.beginPath();
        var prev;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            if (!prev) {
                prev = barheight;
            }
            gc.lineTo(x + 5, y + height - barheight);
            gc.arc(x + 5, y + height - barheight, 1, 0, 2 * Math.PI, false);
            x = x + eWidth;
        }
        this.config.minWidth = count * 10;
        gc.stroke();
        gc.closePath();
    },

    /**
     * @desc A simple implementation of a tree cell renderer for use mainly with the qtree.
     * @param {CanvasGraphicsContext} gc - the "pen" in the mvc model, we issue drawing commands to
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {boolean} isLink - is this a hyperlink cell
     * @memberOf CellProvider.prototype
     */
    treeCellRenderer: function(gc, x, y, width, height) {
        var val = this.config.value.data;
        var indent = this.config.value.indent;
        var icon = this.config.value.icon;

        //fill background only if our bgColor is populated or we are a selected cell
        if (this.config.bgColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.bgSelColor : this.config.bgColor;
            gc.fillRect(x, y, width, height);
        }

        if (!val || !val.length) {
            return;
        }
        var valignOffset = Math.ceil(height / 2);

        gc.fillStyle = this.config.isSelected ? this.config.fgSelColor : this.config.fgColor;
        gc.fillText(icon + val, x + indent, y + valignOffset);

        var textWidth = this.config.getTextWidth(gc, icon + val);
        var minWidth = x + indent + textWidth + 10;
        this.config.minWidth = minWidth;
    },

    /**
     * @desc An empty implementation of a cell renderer, see [the null object pattern](http://c2.com/cgi/wiki?NullObject).
     * @param {CanvasGraphicsContext} gc - the "pen" in the mvc model, we issue drawing commands to
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @memberOf CellProvider.prototype
     * @param {boolean} isLink - is this a hyperlink cell
     */
    emptyCellRenderer: function(gc, x, y, width, height) {},

    /**
     * @memberOf CellProvider.prototype
     * @private
     */
    initializeCells: function() {
        var self = this;
        this.cellCache.simpleCellRenderer = {
            paint: this.defaultCellPaint,
            renderSingleLineText: this.renderSingleLineText,
            renderMultiLineText: this.renderMultiLineText
        };
        this.cellCache.sliderCellRenderer = {
            paint: this.paintSlider
        };
        this.cellCache.sparkbarCellRenderer = {
            paint: this.paintSparkbar
        };
        this.cellCache.sparklineCellRenderer = {
            paint: this.paintSparkline
        };
        this.cellCache.treeCellRenderer = {
            paint: this.treeCellRenderer
        };
        this.cellCache.emptyCellRenderer = {
            paint: this.emptyCellRenderer
        };
        this.cellCache.buttonRenderer = {
            paint: this.paintButton,
            //defaultCellPaint: this.defaultCellPaint
        };
        this.cellCache.linkCellRenderer = {
            paint: function(gc, x, y, width, height) {
                self.config = this.config;
                self.defaultCellPaint(gc, x, y, width, height, true);
            }
        };
    }
});

function valueOrFunctionExecute(config, valueOrFunction) {
    var isFunction = (((typeof valueOrFunction)[0]) === 'f');
    var result = isFunction ? valueOrFunction(config) : valueOrFunction;
    if (!result && result !== 0) {
        return '';
    }
    return result;
}

function underline(config, gc, text, x, y, thickness) {
    var width = config.getTextWidth(gc, text);

    switch (gc.textAlign) {
        case 'center':
            x -= (width / 2);
            break;
        case 'right':
            x -= width;
            break;
    }

    //gc.beginPath();
    gc.lineWidth = thickness;
    gc.moveTo(x + 0.5, y + 0.5);
    gc.lineTo(x + width + 0.5, y + 0.5);
}

function findLines(gc, config, words, width) {

    if (words.length === 1) {
        return words;
    }

    // starting with just the first word
    var stillFits, line = [words.shift()];
    while (
        // so lone as line still fits within current column
    (stillFits = config.getTextWidth(gc, line.join(' ')) < width)
        // AND there are more words available
    && words.length
        ) {
        // add another word to end of line and retest
        line.push(words.shift());
    }

    if (
        !stillFits // if line is now too long
        && line.length > 1 // AND is multiple words
    ) {
        words.unshift(line.pop()); // back off by (i.e., remove) one word
    }

    line = [line.join(' ')];

    if (words.length) { // if there's anything left
        line = line.concat(findLines(gc, config, words, width)); // break it up as well
    }

    return line;
}

function fitText(gc, config, string, width) {
    return findLines(gc, config, squeeze(string).split(' '), width);
}

// trim string; then reduce all runs of multiple spaces to a single space
function squeeze(string) {
    return string.toString().trim().replace(/\s\s+/g, ' ');
}

function roundRect(gc, x, y, width, height, radius, fill, stroke) {

    if (!stroke) {
        stroke = true;
    }
    if (!radius) {
        radius = 5;
    }
    gc.beginPath();
    gc.moveTo(x + radius, y);
    gc.lineTo(x + width - radius, y);
    gc.quadraticCurveTo(x + width, y, x + width, y + radius);
    gc.lineTo(x + width, y + height - radius);
    gc.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    gc.lineTo(x + radius, y + height);
    gc.quadraticCurveTo(x, y + height, x, y + height - radius);
    gc.lineTo(x, y + radius);
    gc.quadraticCurveTo(x, y, x + radius, y);
    gc.closePath();
    if (stroke) {
        gc.stroke();
    }
    if (fill) {
        gc.fill();
    }
    gc.closePath();
}

module.exports = CellProvider;

},{"extend-me":3}],33:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var extend = require('extend-me');
var FinBar = require('finbars');
var Canvas = require('fincanvas');
var Point = require('rectangular').Point;
var Rectangle = require('rectangular').Rectangle;
var LRUCache = require('lru-cache');
var _ = require('object-iterators');

var Renderer = require('./Renderer');
var SelectionModel = require('./SelectionModel');
var addStylesheet = require('./stylesheets');

var globalCellEditors = {},
    propertiesInitialized = false,
    textWidthCache = new LRUCache(2000),
    defaults = defaultProperties(),
    polymerTheme = Object.create(defaults),
    globalProperties = Object.create(polymerTheme);

/**
 * @constructor
 * @param {string|Element} div - CSS selector or Element
 * @param {string} behaviorName - name of a behavior consstructor from ./behaviors
 */
function Hypergrid(div, behaviorFactory) {

    extend.debug = true;

    installPolyfills();

    var self = this;

    this.div = (typeof div === 'string') ? document.querySelector(div) : div;

    addStylesheet('grid');

    this.lastEdgeSelection = [0, 0];

    this.lnfProperties = Object.create(globalProperties);

    this.isWebkit = navigator.userAgent.toLowerCase().indexOf('webkit') > -1;
    this.selectionModel = new SelectionModel();
    this.selectionModel.getGrid = function() {
        return self;
    };
    this.cellEditors = Object.create(globalCellEditors);
    this.renderOverridesCache = {};

    this.behavior = behaviorFactory(this);

    //prevent the default context menu for appearing
    this.div.oncontextmenu = function(event) {
        event.preventDefault();
        return false;
    };

    this.clearMouseDown();
    this.dragExtent = new Point(0, 0);
    this.numRows = 0;
    this.numColumns = 0;

    //install any plugins
    this.pluginsDo(function(each) {
        if (each.installOn) {
            each.installOn(self);
        }
    });

    //initialize our various pieces
    this.initRenderer();
    this.initCanvas();
    this.initScrollbars();
    this.initGlobalCellEditors();

    this.checkScrollbarVisibility();
    //Register a listener for the copy event so we can copy our selected region to the pastebuffer if conditions are right.
    document.body.addEventListener('copy', function(evt) {
        self.checkClipboardCopy(evt);
    });
    this.getCanvas().resize();
    //this.computeCellsBounds();
}

Hypergrid.prototype = {
    constructor: Hypergrid.prototype.constructor,

    /**
     *
     * A null object behavior serves as a place holder.
     * @type {object}
     * @memberOf Hypergrid.prototype
     */
    behavior: null,

    /**
     * Cached result of if we are running in webkit.
     * @type {boolean}
     * @memberOf Hypergrid.prototype
     */
    isWebkit: true,

    /**
     * The pixel location of an initial mousedown click, either for editing a cell or for dragging a selection.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */
    mouseDown: [],

    /**
     * The extent from the mousedown point during a drag operation.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */

    dragExtent: null,

    /**
     * A float value between 0.0 - 1.0 of the vertical scroll position.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    vScrollValue: 0,

    /**
     * A float value between 0.0 - 1.0 of the horizontal scroll position.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    hScrollValue: 0,

    /**
     * @property {window.fin.rectangular} rectangular - Namespace for Point and Rectangle "classes" (constructors).
     * @memberOf Hypergrid.prototype
     */
    rectangular: null,

    /**
     * @property {fin-hypergrid-selection-model} selectionModel - A [fin-hypergrid-selection-model](module-._selection-model.html) instance.
     * @memberOf Hypergrid.prototype
     */
    selectionModel: null,

    /**
     * @property {fin-hypergrid-cell-editor} cellEditor - The current instance of [fin-hypergrid-cell-editor](module-cell-editors_base.html).
     * @memberOf Hypergrid.prototype
     */
    cellEditor: null,

    /**
     * @property {fin-vampire-bar} sbHScroller - An instance of [fin-vampire-bar](http://datamadic.github.io/fin-vampire-bar/components/fin-vampire-bar/).
     * @memberOf Hypergrid.prototype
     */
    sbHScroller: null,

    /**
     * @property {fin-vampire-bar} sbVScroller - An instance of [fin-vampire-bar](http://datamadic.github.io/fin-vampire-bar/components/fin-vampire-bar/).
     * @memberOf Hypergrid.prototype
     */
    sbVScroller: null,

    /**
     * The previous value of sbVScrollVal.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    sbPrevVScrollValue: null,

    /**
     * The previous value of sbHScrollValue.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    sbPrevHScrollValue: null,

    /**
     * The cache of singleton cellEditors.
     * @type {object}
     * @memberOf Hypergrid.prototype
     */
    cellEditors: null,

    /**
     * is the short term memory of what column I might be dragging around
     * @type {object}
     * @memberOf Hypergrid.prototype
     */

    renderOverridesCache: {},

    /**
     * The pixel location of the current hovered cell.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */
    hoverCell: null,

    scrollingNow: false,

    lastEdgeSelection: null,

    /**
     * @memberOf Hypergrid.prototype
    clear out the LRU cache of text widths
     */
    setAttribute: function(attribute, value) {
        this.div.setAttribute(attribute, value);
    },

    /**
     * @memberOf Hypergrid.prototype
    clear out all state and data of the grid
     */
    reset: function() {
        var self = this;
        this.lastEdgeSelection = [0, 0];
        this.lnfProperties = Object.create(globalProperties);
        this.selectionModel = new SelectionModel();
        this.selectionModel.getGrid = function() {
            return self;
        };
        this.cellEditors = Object.create(globalCellEditors);
        this.renderOverridesCache = {};
        this.clearMouseDown();
        this.dragExtent = new Point(0, 0);

        this.numRows = 0;
        this.numColumns = 0;

        this.vScrollValue = 0;
        this.hScrollValue = 0;

        this.cellEditor = null;

        this.sbPrevVScrollValue = null;
        this.sbPrevHScrollValue = null;

        this.hoverCell = null;
        this.scrollingNow = false;
        this.lastEdgeSelection = [0, 0];

        this.getBehavior().reset();
        this.getRenderer().reset();
        this.getCanvas().resize();
        this.behaviorChanged();
    },

    resetTextWidthCache: function() {
        textWidthCache = new LRUCache(2000);
    },

    getProperties: function() {
        return this.getPrivateState();
    },

    _getProperties: function() {
        return this.lnfProperties;
    },

    computeCellsBounds: function() {
        var renderer = this.getRenderer();
        if (!renderer) {
            return;
        }
        renderer.computeCellsBounds();
    },

    initCellEditor: function(cellEditor) {
        var divCellEditor = document.createElement('div');
        this.div.appendChild(divCellEditor);

        globalCellEditors[cellEditor.alias] = cellEditor;
    },

    initGlobalCellEditors: function() {
        if (!propertiesInitialized) {
            propertiesInitialized = true;

            buildPolymerTheme();

            var cellEditors = [
                'Textfield',
                'Choice',
                //'Combo',
                'Color',
                'Date',
                'Slider',
                'Spinner'
            ];

            var self = this;
            cellEditors.forEach(function(name) {
                self.initCellEditor(new Hypergrid.cellEditors[name]);
            });
        }
    },

    toggleColumnPicker: function() {
        this.getBehavior().toggleColumnPicker();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The pointer is over the given cell.
     * @param {number} x - The x cell coordinate.
     * @param {number} y - The y cell coordinate.
     */
    isHovered: function(x, y) {
        var p = this.getHoverCell();
        if (!p) {
            return false;
        }
        return p.x === x && p.y === y;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns boolean} The pointer is hovering over the given column.
     * @param {number} x - The horizontal cell coordinate.
     */
    isColumnHovered: function(x) {
        var p = this.getHoverCell();
        if (!p) {
            return false;
        }
        return p.x === x;
    },

    isRowResizeable: function() {
        return this.resolveProperty('rowResize');
    },

    /**
     *
     *
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The pointer is hovering over the row `y`.
     * @param {number} y - The vertical cell coordinate.
     */
    isRowHovered: function(y) {
        var p = this.getHoverCell();
        if (!p) {
            return false;
        }
        return p.y === y;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Point} The cell over which the cursor is hovering.
     */
    getHoverCell: function() {
        return this.hoverCell;
    },


    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the cell under the cursor.
     * @param {Point} point
     */
    setHoverCell: function(point) {
        var me = this.hoverCell;
        var newPoint = new Point(point.x, point.y);
        if (me && me.equals(newPoint)) {
            return;
        }
        this.hoverCell = newPoint;
        this.fireSyntheticOnCellEnterEvent(newPoint);
        this.repaint();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for all hypergrids in this process.
     * @param {object} properties - A simple properties hash.
     */
    addGlobalProperties: function(properties) {
        //we check for existence to avoid race condition in initialization
        if (!globalProperties) {
            var self = this;
            setTimeout(function() {
                self.addGlobalProperties(properties);
            }, 10);
        } else {
            this._addGlobalProperties(properties);
        }

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for all hypergrids in this process.
     * @param {object} properties - A simple properties hash.
     * @private
     */
    _addGlobalProperties: function(properties) {
        _(properties).each(function(property, key) {
            globalProperties[key] = property;
        });
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for this hypergrid only.
     * @param {object} properties - A simple properties hash.
     */
    addProperties: function(moreProperties) {
        var properties = this.getProperties();
        _(moreProperties).each(function(property, key) {
            properties[key] = moreProperties[key];
        });
        this.refreshProperties();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Utility function to push out properties if we change them.
     * @param {object} properties - An object of various key value pairs.
     */

    refreshProperties: function() {
        // this.canvas = this.shadowRoot.querySelector('fin-canvas');
        //this.canvas = new Canvas(this.divCanvas, this.renderer); //TODO: Do we really need to be recreating it here?
        this.checkScrollbarVisibility();
        this.getBehavior().defaultRowHeight = null;
        if (this.isColumnAutosizing()) {
            this.getBehavior().autosizeAllColumns();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} The state object for remembering our state.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    getPrivateState: function() {
        return this.getBehavior().getPrivateState();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the state object to return to the given user configuration.
     * @param {object} state - A memento object.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    setState: function(state) {
        var self = this;
        this.getBehavior().setState(state);
        setTimeout(function() {
            self.behaviorChanged();
            self.synchronizeScrollingBoundries();
        }, 100);
    },

    getState: function() {
        return this.getBehavior().getState();
    },
    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} The initial mouse position on a mouse down event for cell editing or a drag operation.
     * @memberOf Hypergrid.prototype
     */
    getMouseDown: function() {
        var last = this.mouseDown.length - 1;
        if (last < 0) {
            return null;
        }
        return this.mouseDown[last];
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Remove the last item from the mouse down stack.
     */
    popMouseDown: function() {
        if (this.mouseDown.length === 0) {
            return;
        }
        this.mouseDown.length = this.mouseDown.length - 1;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Empty out the mouse down stack.
     */
    clearMouseDown: function() {
        this.mouseDown = [new Point(-1, -1)];
        this.dragExtent = null;
    },

    /**
     * @memberOf Hypergrid.prototype
     set the mouse point that initated a cell edit or drag operation
     *
     * @param {Point} point
     */
    setMouseDown: function(point) {
        this.mouseDown.push(point);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Point} The extent point of the current drag selection rectangle.
     */
    getDragExtent: function() {
        return this.dragExtent;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Sets the extent point of the current drag selection operation.
     * @param {Point} point
     */
    setDragExtent: function(point) {
        this.dragExtent = point;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Iterate over the plugins invoking the given function with each.
     * @todo We need a new plugin mechanism!
     * @param {function} func - The function to invoke on all the plugins.
     */
    pluginsDo: function(func) {
        //TODO: We need a new plugin mechanism!
        //var userPlugins = this.children.array();
        //var pluginsTag = this.shadowRoot.querySelector('fin-plugins');
        //
        //var plugins = userPlugins;
        //if (pluginsTag) {
        //    var systemPlugins = pluginsTag.children.array();
        //    plugins = systemPlugins.concat(plugins);
        //}
        //
        //plugins.forEach(function(plugin) {
        //    func(plugin);
        //});
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The CellProvider is accessed through Hypergrid because Hypergrid is the mediator and should have ultimate control on where it comes from. The default is to delegate through the behavior object.
     * @returns {fin-hypergrid-cell-provider}
     */
    getCellProvider: function() {
        var provider = this.getBehavior().getCellProvider();
        return provider;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc This function is a callback from the HypergridRenderer sub-component. It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        this.updateRenderedSizes();
        if (this.cellEditor) {
            this.cellEditor.gridRenderedNotification();
        }
        this.checkColumnAutosizing();
        this.fireSyntheticGridRenderedEvent();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The grid has just been rendered, make sure the column widths are optimal.
     */
    checkColumnAutosizing: function() {
        var behavior = this.getBehavior();
        behavior.autoSizeRowNumberColumn();
        if (this.isColumnAutosizing()) {
            behavior.checkColumnAutosizing(false);
        }
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Notify the GridBehavior how many rows and columns we just rendered.
     */
    updateRenderedSizes: function() {
        var behavior = this.getBehavior();
        //add one to each of these values as we want also to include
        //the columns and rows that are partially visible
        behavior.setRenderedColumnCount(this.getVisibleColumns() + 1);
        behavior.setRenderedRowCount(this.getVisibleRows() + 1);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Conditionally copy to clipboard.
     * @desc If we have focus, copy our current selection data to the system clipboard.
     * @param {event} event - The copy system event.
     */
    checkClipboardCopy: function(event) {
        if (!this.hasFocus()) {
            return;
        }
        event.preventDefault();
        var csvData = this.getSelectionAsTSV();
        event.clipboardData.setData('text/plain', csvData);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have any selections.
     */
    hasSelections: function() {
        if (!this.getSelectionModel) {
            return; // were not fully initialized yet
        }
        return this.getSelectionModel().hasSelections();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {string} Tab separated value string from the selection and our data.
     */
    getSelectionAsTSV: function() {
        var sm = this.getSelectionModel();
        if (sm.hasSelections()) {
            var selections = this.getSelectionMatrix();
            selections = selections[selections.length - 1];
            return this.getMatrixSelectionAsTSV(selections);
        } else if (sm.hasRowSelections()) {
            return this.getMatrixSelectionAsTSV(this.getRowSelectionMatrix());
        } else if (sm.hasColumnSelections()) {
            return this.getMatrixSelectionAsTSV(this.getColumnSelectionMatrix());
        }
    },

    getMatrixSelectionAsTSV: function(selections) {
        //only use the data from the last selection
        if (selections.length) {
            var width = selections.length,
                height = selections[0].length,
                area = width * height,
                collector = [];

            //disallow if selection is too big
            if (area > 20000) {
                alert('selection size is too big to copy to the paste buffer'); // eslint-disable-line no-alert
                return '';
            }

            for (var h = 0; h < height; h++) {
                for (var w = 0; w < width; w++) {
                    collector.push(selections[w][h]);
                    if (w < width) {
                        collector.push('\t');
                    }
                }
                if (h < height) {
                    collector.push('\n');
                }
            }

            var result = collector.join('');

            return result;
        }
        return '';
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have focus.
     */
    hasFocus: function() {
        return this.getCanvas().hasFocus();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear all the selections.
     */
    clearSelections: function() {
        this.getSelectionModel().clear();
        this.clearMouseDown();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent selection.
     */
    clearMostRecentSelection: function() {
        this.getSelectionModel().clearMostRecentSelection();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent column selection.
     */
    clearMostRecentColumnSelection: function() {
        this.getSelectionModel().clearMostRecentColumnSelection();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent row selection.
     */
    clearMostRecentRowSelection: function() {
        this.getSelectionModel().clearMostRecentRowSelection();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Select given region.
     * @param {number} ox - origin x
     * @param {number} oy - origin y
     * @param {number} ex - extent x
     * @param {number} ex - extent y
     */
    select: function(ox, oy, ex, ey) {
        if (ox < 0 || oy < 0) {
            //we don't select negative area
            //also this means there is no origin mouse down for a selection rect
            return;
        }
        this.getSelectionModel().select(ox, oy, ex, ey);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} Given point is selected.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    isSelected: function(x, y) {
        return this.getSelectionModel().isSelected(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given column is selected anywhere in the entire table.
     * @param {number} col - The column index.
     */
    isCellSelectedInRow: function(col) {
        var selectionModel = this.getSelectionModel();
        var isSelected = selectionModel.isCellSelectedInRow(col);
        return isSelected;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given row is selected anywhere in the entire table.
     * @param {number} row - The row index.
     */
    isCellSelectedInColumn: function(row) {
        var selectionModel = this.getSelectionModel();
        var isSelected = selectionModel.isCellSelectedInColumn(row);
        return isSelected;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {fin-hypergrid-selection-model} The selection model.
     */
    getSelectionModel: function() {
        return this.selectionModel;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Behavior} The behavior (model).
     */
    getBehavior: function() {
        return this.behavior;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set the Behavior (model) object for this grid control.
     * @desc This can be done dynamically.
     * @param {Behavior} The behavior (model).
     */
    setBehavior: function(newBehavior) {

        this.behavior = newBehavior;
        this.behavior.setGrid(this);

        this.behavior.changed = this.behaviorChanged.bind(this);
        this.behavior.shapeChanged = this.behaviorShapeChanged.bind(this);
        this.behavior.stateChanged = this.behaviorStateChanged.bind(this);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc I've been notified that the behavior has changed.
     */
    behaviorChanged: function() {
        if (this.numColumns !== this.getColumnCount() || this.numRows !== this.getRowCount()) {
            this.numColumns = this.getColumnCount();
            this.numRows = this.getRowCount();
            this.behaviorShapeChanged();
        }
        this.computeCellsBounds();
        this.repaint();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Rectangle} My bounds.
     */
    getBounds: function() {
        var renderer = this.getRenderer();
        if (!renderer) {
            return;
        }
        return renderer.getBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {string} The value of a lnf property.
     * @param {string} key - A look-and-feel key.
     */
    resolveProperty: function(key) {
        return this.getProperties()[key];
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorShapeChanged: function() {
        this.synchronizeScrollingBoundries();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorStateChanged: function() {
        this.getRenderer().computeCellsBounds();
        this.repaint();
    },

    repaint: function() {
        var now = this.resolveProperty('repaintImmediately');
        var canvas = this.getCanvas();
        if (canvas) {
            if (now === true) {
                canvas.paintNow();
            } else {
                canvas.repaint();
            }
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Paint immediately in this microtask.
     */
    paintNow: function() {
        var canvas = this.getCanvas();
        canvas.paintNow();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} In HiDPI mode (has an attribute as such).
     */
    useHiDPI: function() {
        return this.resolveProperty('useHiDPI') !== false;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize drawing surface.
     * @private
     */
    initCanvas: function() {

        var self = this;

        var divCanvas = this.divCanvas = document.createElement('div');
        this.div.appendChild(divCanvas);
        this.canvas = new Canvas(divCanvas, this.renderer);

        var style = divCanvas.style;
        style.position = 'absolute';
        style.top = 0;
        style.right = '-200px';
        //leave room for the vertical scrollbar
        //style.marginRight = '15px';
        style.bottom = 0;
        //leave room for the horizontal scrollbar
        //style.marginBottom = '15px';
        style.left = 0;

        this.canvas.resizeNotification = function() {
            self.resized();
        };

        this.addFinEventListener('fin-canvas-mousemove', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseMove(mouseEvent);
        });

        this.addFinEventListener('fin-canvas-mousedown', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.keys = e.detail.keys;
            mouseEvent.primitiveEvent = e;
            self.mouseDownState = mouseEvent;
            self.delegateMouseDown(mouseEvent);
            self.fireSyntheticMouseDownEvent(mouseEvent);
            self.repaint();
        });


        // this.addFinEventListener('fin-canvas-click', function(e) {
        //     if (self.resolveProperty('readOnly')) {
        //         return;
        //     }
        //     //self.stopEditing();
        //     var mouse = e.detail.mouse;
        //     var mouseEvent = self.getGridCellFromMousePoint(mouse);
        //     mouseEvent.primitiveEvent = e;
        //     self.fireSyntheticClickEvent(mouseEvent);
        // });

        this.addFinEventListener('fin-canvas-mouseup', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.dragging = false;
            if (self.isScrollingNow()) {
                self.setScrollingNow(false);
            }
            if (self.columnDragAutoScrolling) {
                self.columnDragAutoScrolling = false;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseUp(mouseEvent);
            if (self.mouseDownState) {
                self.fireSyntheticButtonPressedEvent(self.mouseDownState);
            }
            self.mouseDownState = null;
            self.fireSyntheticMouseUpEvent(mouseEvent);
        });

        this.addFinEventListener('fin-canvas-tap', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var tapEvent = self.getGridCellFromMousePoint(mouse);
            tapEvent.primitiveEvent = e;
            tapEvent.keys = e.detail.keys;
            self.fireSyntheticClickEvent(tapEvent);
            self.delegateTap(tapEvent);
        });

        this.addFinEventListener('fin-canvas-drag', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.dragging = true;
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseDrag(mouseEvent);
        });

        this.addFinEventListener('fin-canvas-keydown', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.fireSyntheticKeydownEvent(e);
            self.delegateKeyDown(e);
        });

        this.addFinEventListener('fin-canvas-keyup', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.fireSyntheticKeyupEvent(e);
            self.delegateKeyUp(e);
        });

        this.addFinEventListener('fin-canvas-track', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            if (self.dragging) {
                return;
            }
            var primEvent = e.detail.primitiveEvent;
            if (Math.abs(primEvent.dy) > Math.abs(primEvent.dx)) {
                if (primEvent.yDirection > 0) {
                    self.scrollVBy(-2);
                } else if (primEvent.yDirection < -0) {
                    self.scrollVBy(2);
                }
            } else {
                if (primEvent.xDirection > 0) {
                    self.scrollHBy(-1);
                } else if (primEvent.xDirection < -0) {
                    self.scrollHBy(1);
                }
            }
        });

        // this.addFinEventListener('fin-canvas-holdpulse', function(e) {
        //     console.log('holdpulse');
        //     if (self.resolveProperty('readOnly')) {
        //         return;
        //     }
        //     var mouse = e.detail.mouse;
        //     var mouseEvent = self.getGridCellFromMousePoint(mouse);
        //     mouseEvent.primitiveEvent = e;
        //     self.delegateHoldPulse(mouseEvent);
        // });

        this.addFinEventListener('fin-canvas-dblclick', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.fireSyntheticDoubleClickEvent(mouseEvent, e);
            self.delegateDoubleClick(mouseEvent);
        });

        this.addFinEventListener('fin-canvas-wheelmoved', function(e) {
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateWheelMoved(mouseEvent);
        });

        this.addFinEventListener('fin-canvas-mouseout', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateMouseExit(mouseEvent);
        });


        this.addFinEventListener('fin-canvas-context-menu', function(e) {
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateContextMenu(mouseEvent);
        });

        this.div.removeAttribute('tabindex');

    },

    convertViewPointToDataPoint: function(viewPoint) {
        return this.getBehavior().convertViewPointToDataPoint(viewPoint);
    },

    convertDataPointToViewPoint: function(dataPoint) {
        return this.getBehavior().convertDataPointToViewPoint(dataPoint);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Add an event listener to me.
     * @param {string} eventName - The type of event we are interested in.
     * @param {function} callback - The event handler.
     */
    addFinEventListener: function(eventName, callback) {
        this.canvas.addEventListener(eventName, callback);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set for `scrollingNow` field.
     * @param {boolean} isItNow - The type of event we are interested in.
     */
    setScrollingNow: function(isItNow) {
        this.scrollingNow = isItNow;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The `scrollingNow` field.
     */
    isScrollingNow: function() {
        return this.scrollingNow;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The index of the column divider under the mouse coordinates.
     * @param {MouseEvent} mouseEvent - The event to interogate.
     */
    overColumnDivider: function(mouseEvent) {
        var x = mouseEvent.primitiveEvent.detail.mouse.x;
        var whichCol = this.getRenderer().overColumnDivider(x);
        return whichCol;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The index of the row divider under the mouse coordinates.
     * @param {MouseEvent} mouseEvent - The event to interogate.
     */
    overRowDivider: function(mouseEvent) {
        var y = mouseEvent.primitiveEvent.detail.mouse.y;
        var which = this.getRenderer().overRowDivider(y);
        return which;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Switch the cursor for the grid.
     * @param {string} cursorName - A well know cursor name.
     * @see [cursor names](http://www.javascripter.net/faq/stylesc.htm)
     */
    beCursor: function(cursorName) {
        if (!cursorName) {
            cursorName = 'default';
        }
        this.div.style.cursor = cursorName;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate the wheel moved event to the behavior.
     * @param {Event} event - The pertinent event.
     */
    delegateWheelMoved: function(event) {
        var behavior = this.getBehavior();
        behavior.onWheelMoved(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateMouseExit: function(event) {
        var behavior = this.getBehavior();
        behavior.handleMouseExit(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateContextMenu: function(event) {
        var behavior = this.getBehavior();
        behavior.onContextMenu(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseMove to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseMove: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.onMouseMove(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mousedown to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDown: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.handleMouseDown(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mouseup to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseUp: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.onMouseUp(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate tap to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateTap: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.onTap(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mouseDrag to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDrag: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.onMouseDrag(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc We've been doubleclicked on. Delegate through the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateDoubleClick: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.onDoubleClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate holdpulse through the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateHoldPulse: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.onHoldPulse(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyDown: function(event) {
        var behavior = this.getBehavior();
        behavior.onKeyDown(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyUp: function(event) {
        var behavior = this.getBehavior();
        behavior.onKeyUp(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Shut down the current cell editor.
     */
    stopEditing: function() {
        if (this.cellEditor) {
            if (this.cellEditor.stopEditing) {
                this.cellEditor.stopEditing();
            }
            this.cellEditor = null;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Register a cell editor.
     * @desc This is typically called from within a cell-editor's `installOn` method, when it is being initialized as a plugin.
     * @param {string} alias - The name/id of the cell editor.
     * @param {fin-hypergrid-cell-editor-base} cellEditor - see [fin-hypergrid-cell-editor-base](module-cell-editors_base.html)
     */
    registerCellEditor: function(alias, cellEditor) {
        this.cellEditors[alias] = cellEditor;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Rectangle} The pixel coordinates of just the center 'main" data area.
     */
    getDataBounds: function() {
        var colDNDHackWidth = 200; //this was a hack to help with column dnd, need to factor this into a shared variable
        //var behavior = this.getBehavior();
        var b = this.canvas.bounds;

        //var x = this.getRowNumbersWidth();
        // var y = behavior.getFixedRowsHeight() + 2;

        var result = new Rectangle(0, 0, b.origin.x + b.extent.x - colDNDHackWidth, b.origin.y + b.extent.y);
        return result;
    },

    getRowNumbersWidth: function() {
        if (this.isShowRowNumbers()) {
            return this.getRenderer().getRowNumbersWidth();
        } else {
            return 0;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Canvas} Our fin-canvas instance.
     */
    getCanvas: function() {
        return this.canvas;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Open the given cell-editor at the provided model coordinates.
     * @param {string} cellEditor - The specific cell editor to use.
     * @param {Point} coordinates - The pixel locaiton of the cell to edit at.
     */
    editAt: function(cellEditor, coordinates) {

        this.cellEditor = cellEditor;

        var cell = coordinates.gridCell;

        var x = cell.x;
        var y = cell.y;

        if (x < 0 || y < 0) {
            return;
        }

        var editPoint = new Point(x, y);
        this.setMouseDown(editPoint);
        this.setDragExtent(new Point(0, 0));

        if (!cellEditor.isAdded) {
            cellEditor.isAdded = true;
            this.div.appendChild(cellEditor.getInput());
        }
        cellEditor.grid = this;
        cellEditor.beginEditAt(editPoint);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given column is fully visible.
     * @param {number} columnIndex - The column index in question.
     */
    isColumnVisible: function(columnIndex) {
        var isVisible = this.getRenderer().isColumnVisible(columnIndex);
        return isVisible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given row is fully visible.
     * @param {number} rowIndex - The row index in question.
     */
    isDataRowVisible: function(rowIndex) {
        var isVisible = this.getRenderer().isRowVisible(rowIndex);
        return isVisible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given cell is fully is visible.
     * @param {number} columnIndex - The column index in question.
     * @param {number} rowIndex - The row index in question.
     */
    isDataVisible: function(columnIndex, rowIndex) {
        var isVisible = this.isDataRowVisible(rowIndex) && this.isColumnVisible(columnIndex);
        return isVisible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll in the `offsetX` direction if column index `colIndex` is not visible.
     * @param {number} colIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     */
    insureModelColIsVisible: function(colIndex, offsetX) {
        //-1 because we want only fully visible columns, don't include partially
        //visible columns
        var maxCols = this.getColumnCount() - 1;
        var indexToCheck = colIndex;

        if (offsetX > 0) {
            indexToCheck++;
        }

        if (!this.isColumnVisible(indexToCheck) || colIndex === maxCols) {
            //the scroll position is the leftmost column {
            this.scrollBy(offsetX, 0);
            return true;
        }
        return false;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll in the offsetY direction if column index c is not visible.
     * @param {number} rowIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     */
    insureModelRowIsVisible: function(rowIndex, offsetY) {
        //-1 because we want only fully visible rows, don't include partially
        //viewable rows
        var maxRows = this.getRowCount() - 1;
        var indexToCheck = rowIndex;

        if (offsetY > 0) {
            indexToCheck++;
        }

        if (!this.isDataRowVisible(indexToCheck) || rowIndex === maxRows) {
            //the scroll position is the topmost row
            this.scrollBy(0, offsetY);
            return true;
        }
        return false;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll horizontal and vertically by the provided offsets.
     * @param {number} offsetX - Scroll in the x direction this much.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollBy: function(offsetX, offsetY) {
        this.scrollHBy(offsetX);
        this.scrollVBy(offsetY);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll vertically by the provided offset.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollVBy: function(offsetY) {
        var max = this.sbVScroller.range.max;
        var oldValue = this.getVScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetY));
        if (newValue === oldValue) {
            return;
        }
        this.setVScrollValue(newValue);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll horizontally by the provided offset.
     * @param {number} offsetX - Scroll in the x direction this much.
     */
    scrollHBy: function(offsetX) {
        var max = this.sbHScroller.range.max;
        var oldValue = this.getHScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetX));
        if (newValue === oldValue) {
            return;
        }
        this.setHScrollValue(newValue);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Answer which data cell is under a pixel value mouse point.
     * @param {mousePoint} mouse - The mouse point to interrogate.
     */

    getGridCellFromMousePoint: function(mouse) {
        var cell = this.getRenderer().getGridCellFromMousePoint(mouse);
        return cell;
    },

    /**
     * @returns {Rectangle} The pixel based bounds rectangle given a data cell point.
     * @param {Point} cell - The pixel location of the mouse.
     * @memberOf Hypergrid.prototype
     */
    getBoundsOfCell: function(cell) {
        var b = this.getRenderer().getBoundsOfCell(cell);

        //we need to convert this to a proper rectangle
        var newBounds = new Rectangle(b.x, b.y, b.width, b.height);
        return newBounds;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc This is called by the fin-canvas when a resize occurs.
     */
    resized: function() {
        this.synchronizeScrollingBoundries();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A click event occured.
     * @desc Determine the cell and delegate to the behavior (model).
     * @param {MouseEvent} event - The mouse event to interrogate.
     */
    cellClicked: function(event) {
        var cell = event.gridCell;
        var colCount = this.getColumnCount();
        var rowCount = this.getRowCount();

        //click occured in background area
        if (cell.x > colCount || cell.y > rowCount) {
            return;
        }

        //var behavior = this.getBehavior();
        var hovered = this.getHoverCell();
        var sy = this.getVScrollValue();
        var x = hovered.x;
        // if (hovered.x > -1) {
        //     x = behavior.translateColumnIndex(hovered.x + this.getHScrollValue());
        // }
        if (hovered.y < 0) {
            sy = 0;
        }
        hovered = new Point(x, hovered.y + sy);
        this.getBehavior().cellClicked(hovered, event);
    },

    setTotalsValueNotification: function(x, y, value) {
        this.fireSyntheticSetTotalsValue(x, y, value);
    },

    fireSyntheticSetTotalsValue: function(x, y, value) {
        var clickEvent = new CustomEvent('fin-set-totals-value', {
            detail: {
                x: x,
                y: y,
                value: value
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyUpEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-key-up', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent
            },

        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyDownEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-key-down', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent
            },

        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyPressEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-key-press', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent
            },

        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorDataChangeEvent: function(inputControl, oldValue, newValue) {
        var clickEvent = new CustomEvent('fin-editor-data-change', {
            detail: {
                input: inputControl,
                oldValue: oldValue,
                newValue: newValue
            },
            cancelable: true
        });
        return this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-row-selection-changed` event.
     */
    fireSyntheticRowSelectionChangedEvent: function() {
        var selectionEvent = new CustomEvent('fin-row-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.getSelectionModel().getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },

    fireSyntheticColumnSelectionChangedEvent: function() {
        var selectionEvent = new CustomEvent('fin-column-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.getSelectionModel().getSelections()
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and dispatch a `fin-selection-changed` event.
     */
    selectionChanged: function() {
        var selectedRows = this.getSelectedRows();
        var selectionEvent = new CustomEvent('fin-selection-changed', {
            detail: {
                rows: selectedRows,
                columns: this.getSelectedColumns(),
                selections: this.getSelectionModel().getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },


    getRowSelection: function() {
        var c, column, self = this,
            selectedRowIndexes = this.getSelectionModel().getSelectedRows(),
            numCols = this.getColumnCount(),
            result = {};

        function setValue(selectedRowIndex, r) {
            column[r] = valueOrFunctionExecute(self.getValue(c, selectedRowIndex));
        }

        for (c = 0; c < numCols; c++) {
            column = new Array(selectedRowIndexes.length);
            result[this.getField(c)] = column;
            selectedRowIndexes.forEach(setValue);
        }

        return result;
    },

    getRowSelectionMatrix: function() {
        var c, self = this,
            selectedRowIndexes = this.getSelectionModel().getSelectedRows(),
            numCols = this.getColumnCount(),
            result = new Array(numCols);

        function getValue(selectedRowIndex, r) {
            result[c][r] = valueOrFunctionExecute(self.getValue(c, selectedRowIndex));
        }

        for (c = 0; c < numCols; c++) {
            result[c] = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(getValue);
        }

        return result;
    },

    getColumnSelectionMatrix: function() {
        var selectedColumnIndexes = this.getSelectedColumns();
        var numRows = this.getRowCount();
        var result = new Array(selectedColumnIndexes.length);
        var self = this;
        selectedColumnIndexes.forEach(function(selectedColumnIndex, c) {
            result[c] = new Array(numRows);
            for (var r = 0; r < numRows; r++) {
                result[c][r] = valueOrFunctionExecute(self.getValue(selectedColumnIndex, r));
            }
        });
        return result;
    },

    getColumnSelection: function() {
        var selectedColumnIndexes = this.getSelectedColumns();
        var result = {};
        var rowCount = this.getRowCount();
        var self = this;
        selectedColumnIndexes.forEach(function(selectedColumnIndex) {
            var column = new Array(rowCount);
            result[self.getField(selectedColumnIndex)] = column;
            for (var r = 0; r < rowCount; r++) {
                column[r] = valueOrFunctionExecute(self.getValue(selectedColumnIndex, r));
            }
        });
        return result;
    },

    getSelection: function() {
        var self = this;
        var selections = this.getSelections();
        var result = new Array(selections.length);
        selections.forEach(function(selectionRect, i) {
            result[i] = self._getSelection(selectionRect);
        });
        return result;
    },

    _getSelection: function(rect) {
        rect = normalizeRect(rect);
        var colCount = rect.extent.x + 1;
        var rowCount = rect.extent.y + 1;
        var ox = rect.origin.x;
        var oy = rect.origin.y;
        var result = {};
        var r;
        for (var c = 0; c < colCount; c++) {
            var column = new Array(rowCount);
            result[this.getField(c + ox)] = column;
            for (r = 0; r < rowCount; r++) {
                column[r] = valueOrFunctionExecute(this.getValue(ox + c, oy + r));
            }
        }
        return result;
    },

    getSelectionMatrix: function() {
        var self = this;
        var selections = this.getSelections();
        var result = new Array(selections.length);
        selections.forEach(function(selectionRect, i) {
            result[i] = self._getSelectionMatrix(selectionRect);
        });
        return result;
    },

    _getSelectionMatrix: function(rect) {
        rect = normalizeRect(rect);
        var colCount = rect.extent.x + 1;
        var rowCount = rect.extent.y + 1;
        var ox = rect.origin.x;
        var oy = rect.origin.y;
        var result = [];
        for (var c = 0; c < colCount; c++) {
            var column = new Array(rowCount);
            result[c] = column;
            for (var r = 0; r < rowCount; r++) {
                column[r] = valueOrFunctionExecute(this.getValue(ox + c, oy + r));
            }
        }
        return result;
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-context-menu` event
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticContextMenuEvent: function(e) {
        e.gridCell = this.convertViewPointToDataPoint(e.gridCell);
        var event = new CustomEvent('fin-context-menu', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.getSelectionModel().getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    fireSyntheticMouseUpEvent: function(e) {
        var event = new CustomEvent('fin-mouseup', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.getSelectionModel().getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    fireSyntheticMouseDownEvent: function(e) {
        var event = new CustomEvent('fin-mousedown', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.getSelectionModel().getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    isViewableButton: function(c, r) {
        return this.getRenderer().isViewableButton(c, r);
    },

    fireSyntheticButtonPressedEvent: function(evt) {
        var dataCell = evt.dataCell;
        var gridCell = evt.gridCell;
        if (!this.isViewableButton(dataCell.x, dataCell.y)) {
            return;
        }
        var event = new CustomEvent('fin-button-pressed', {
            detail: {
                gridCell: gridCell
            }
        });
        this.canvas.dispatchEvent(event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-keydown` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeydownEvent: function(keyEvent) {
        var clickEvent = new CustomEvent('fin-keydown', {
            detail: keyEvent.detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-keyup` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeyupEvent: function(keyEvent) {
        var clickEvent = new CustomEvent('fin-keyup', {
            detail: keyEvent.detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-enter` event
     * @param {Point} cell - The pixel location of the cell in which the click event occurred.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellEnterEvent: function(cell) {
        var detail = {
            gridCell: cell,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-cell-enter', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticGroupsChangedEvent: function(groups) {
        var detail = {
            groups: groups,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-groups-changed', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-exit` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellExitEvent: function(cell) {
        var detail = {
            gridCell: cell,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-cell-exit', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-click` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticClickEvent: function(mouseEvent) {
        var cell = mouseEvent.gridCell;
        var detail = {
            gridCell: cell,
            mousePoint: mouseEvent.mousePoint,
            keys: mouseEvent.keys,
            primitiveEvent: mouseEvent,
            time: Date.now(),
            grid: this
        };
        this.getBehavior().enhanceDoubleClickEvent(detail);
        var clickEvent = new CustomEvent('fin-click', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-double-click` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticDoubleClickEvent: function(mouseEvent) {
        var cell = mouseEvent.gridCell;
        var behavior = this.getBehavior();
        var detail = {
            gridCell: cell,
            mousePoint: mouseEvent.mousePoint,
            time: Date.now(),
            grid: this
        };
        behavior.enhanceDoubleClickEvent(mouseEvent);
        var clickEvent = new CustomEvent('fin-double-click', {
            detail: detail
        });
        behavior.cellDoubleClicked(cell, mouseEvent);
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a rendered event.
     */
    fireSyntheticGridRenderedEvent: function() {
        var event = new CustomEvent('fin-grid-rendered', {
            detail: {
                source: this,
                time: Date.now()
            }
        });
        if (this.canvas) {
            this.canvas.dispatchEvent(event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a scroll event.
     * @param {string} type - Should be either `fin-scroll-x` or `fin-scroll-y`.
     * @param {number} oldValue - The old scroll value.
     * @param {number} newValue - The new scroll value.
     */
    fireScrollEvent: function(type, oldValue, newValue) {
        var event = new CustomEvent(type, {
            detail: {
                oldValue: oldValue,
                value: newValue,
                time: Date.now()
            }
        });
        this.canvas.dispatchEvent(event);

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the vertical scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setVScrollValue: function(y) {
        y = Math.round(y);
        var max = this.sbVScroller.range.max;
        y = Math.min(max, Math.max(0, y));
        var self = this;
        if (y === this.vScrollValue) {
            return;
        }
        this.getBehavior()._setScrollPositionY(y);
        var oldY = this.vScrollValue;
        this.vScrollValue = y;
        this.scrollValueChangedNotification();
        setTimeout(function() {
            // self.sbVRangeAdapter.subjectChanged();
            self.fireScrollEvent('fin-scroll-y', oldY, y);
        });
    },

    /**
     * @memberOf Hypergrid.prototype
     * @return {number} The vertical scroll value.
     */
    getVScrollValue: function() {
        return this.vScrollValue;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the horizontal scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setHScrollValue: function(x) {
        x = Math.round(x);
        var max = this.sbHScroller.range.max;
        x = Math.min(max, Math.max(0, x));
        var self = this;
        if (x === this.hScrollValue) {
            return;
        }
        this.getBehavior()._setScrollPositionX(x);
        var oldX = this.hScrollValue;
        this.hScrollValue = x;
        this.scrollValueChangedNotification();
        setTimeout(function() {
            //self.sbHRangeAdapter.subjectChanged();
            self.fireScrollEvent('fin-scroll-x', oldX, x);
        });
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns The vertical scroll value.
     */
    getHScrollValue: function() {
        return this.hScrollValue;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Request input focus.
     */
    takeFocus: function() {
        if (this.isEditing()) {
            this.stopEditing();
        } else {
            this.getCanvas().takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Request focus for our cell editor.
     */
    editorTakeFocus: function() {
        if (this.cellEditor) {
            return this.cellEditor.takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have a currently active cell editor.
     */
    isEditing: function() {
        if (this.cellEditor) {
            return this.cellEditor.isEditing;
        }
        return false;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Initialize the scroll bars.
     */
    initScrollbars: function() {

        var self = this;

        var horzBar = new FinBar({
            orientation: 'horizontal',
            onchange: self.setHScrollValue.bind(self),
            cssStylesheetReferenceElement: this.div
        });

        var vertBar = new FinBar({
            orientation: 'vertical',
            onchange: self.setVScrollValue.bind(self),
            paging: {
                up: self.pageUp.bind(self),
                down: self.pageDown.bind(self)
            }
        });

        this.sbHScroller = horzBar;
        this.sbVScroller = vertBar;

        var hPrefix = this.resolveProperty('hScrollbarClassPrefix');
        var vPrefix = this.resolveProperty('vScrollbarClassPrefix');

        if (hPrefix && hPrefix !== '') {
            this.sbHScroller.classPrefix = hPrefix;
        }

        if (vPrefix && vPrefix !== '') {
            this.sbVScroller.classPrefix = vPrefix;
        }

        this.div.appendChild(horzBar.bar);
        this.div.appendChild(vertBar.bar);

        this.resizeScrollbars();

    },

    resizeScrollbars: function() {
        this.sbHScroller.shortenBy(this.sbVScroller).resize();
        //this.sbVScroller.shortenBy(this.sbHScroller);
        this.sbVScroller.resize();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll values have changed, we've been notified.
     */
    setVScrollbarValues: function(max) {
        this.sbVScroller.range = {
            min: 0,
            max: max
        };
    },

    setHScrollbarValues: function(max) {
        this.sbHScroller.range = {
            min: 0,
            max: max
        };
    },

    scrollValueChangedNotification: function() {

        if (this.hScrollValue === this.sbPrevHScrollValue && this.vScrollValue === this.sbPrevVScrollValue) {
            return;
        }

        this.sbPrevHScrollValue = this.hScrollValue;
        this.sbPrevVScrollValue = this.vScrollValue;

        if (this.cellEditor) {
            this.cellEditor.scrollValueChangedNotification();
        }

        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Get data value at given cell.
     * @desc Delegates to the behavior.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     * @param {*} value
     */
    getValue: function(x, y) {
        return this.getBehavior().getValue(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set a data value into the behavior (model) at the given point
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    setValue: function(x, y, value) {
        this.getBehavior().setValue(x, y, value);
    },

    getColumnAlignment: function(c) {
        return this.getBehavior().getColumnAlignment(c);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The data dimensions have changed, or our pixel boundries have changed.
     * Adjust the scrollbar properties as necessary.
     */
    synchronizeScrollingBoundries: function() {
        //327/664
        var behavior = this.getBehavior();

        var numFixedColumns = this.getFixedColumnCount();
        var numFixedRows = this.getFixedRowCount();

        var numColumns = this.getColumnCount();
        var numRows = this.getRowCount();

        var bounds = this.getBounds();
        if (!bounds) {
            return;
        }
        var scrollableHeight = bounds.height - behavior.getFixedRowsMaxHeight() - 15; //5px padding at bottom and right side
        var scrollableWidth = (bounds.width - 200) - behavior.getFixedColumnsMaxWidth() - 15;

        var lastPageColumnCount = 0;
        var columnsWidth = 0;
        for (; lastPageColumnCount < numColumns; lastPageColumnCount++) {
            var eachWidth = this.getColumnWidth(numColumns - lastPageColumnCount - 1);
            columnsWidth = columnsWidth + eachWidth;
            if (columnsWidth > scrollableWidth) {
                break;
            }
        }

        var lastPageRowCount = 0;
        var rowsHeight = 0;
        for (; lastPageRowCount < numRows; lastPageRowCount++) {
            var eachHeight = this.getRowHeight(numRows - lastPageRowCount - 1);
            rowsHeight = rowsHeight + eachHeight;
            if (rowsHeight > scrollableHeight) {
                break;
            }
        }

        var hMax = 1 + Math.max(0, numColumns - numFixedColumns - lastPageColumnCount);
        this.setHScrollbarValues(hMax);

        var vMax = Math.max(0, numRows - numFixedRows - lastPageRowCount);
        this.setVScrollbarValues(vMax);

        this.setHScrollValue(Math.min(this.getHScrollValue(), hMax));
        this.setVScrollValue(Math.min(this.getVScrollValue(), vMax));

        //this.getCanvas().resize();
        this.computeCellsBounds();
        this.repaint();

        this.resizeScrollbars();

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Note that "viewable rows" includes any partially viewable rows.
     * @returns {number} The number of viewable rows.
     */
    getVisibleRows: function() {
        return this.getRenderer().getVisibleRows();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Note that "viewable columns" includes any partially viewable columns.
     * @returns {number} The number of viewable columns.
     */
    getVisibleColumns: function() {
        return this.getRenderer().getVisibleColumns();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize the renderer sub-component.
     */
    initRenderer: function() {
        this.renderer = new Renderer(this);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Renderer} sub-component
     */
    getRenderer: function() {
        return this.renderer;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     */
    getColumnWidth: function(columnIndex) {
        return this.getBehavior().getColumnWidth(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     * @param {number} columnWidth - The width in pixels.
     */
    setColumnWidth: function(columnIndex, columnWidth) {
        this.stopEditing();
        this.getBehavior().setColumnWidth(columnIndex, columnWidth);
    },

    getColumnEdge: function(c) {
        return this.getBehavior().getColumnEdge(c, this.getRenderer());
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The total width of all the fixed columns.
     */
    getFixedColumnsWidth: function() {
        return this.getBehavior().getFixedColumnsWidth();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The height of the given row
     * @param {number} rowIndex - The untranslated fixed column index.
     */
    getRowHeight: function(rowIndex) {
        return this.getBehavior().getRowHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the height of the given row.
     * @param {number} rowIndex - The row index.
     * @param {number} rowHeight - The width in pixels.
     */
    setRowHeight: function(rowIndex, rowHeight) {
        this.stopEditing();
        this.getBehavior().setRowHeight(rowIndex, rowHeight);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The total fixed rows height
     */
    getFixedRowsHeight: function() {
        return this.getBehavior().getFixedRowsHeight();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.getBehavior().getColumnCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of fixed rows.
     */
    getRowCount: function() {
        return this.getBehavior().getRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.getBehavior().getFixedColumnCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.getBehavior().getFixedRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary The top left area has been clicked on
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    topLeftClicked: function(mouse) {
        this.getBehavior().topLeftClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A fixed row has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    rowHeaderClicked: function(mouse) {
        this.getBehavior().rowHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A fixed column has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    columnHeaderClicked: function(mouse) {
        this.getBehavior().columnHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc An edit event has occurred. Activate the editor.
     * @param {event} event - The event details.
     */
    _activateEditor: function(event) {
        var gridCell = event.gridCell;
        this.activateEditor(gridCell.x, gridCell.y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Activate the editor at the given coordinates.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     */
    activateEditor: function(x, y) {
        if (!this.isEditable() && !this.isFilterRow(y)) {
            return;
        }
        var editor = this.getCellEditorAt(x, y);
        if (!editor) {
            return;
        }
        var point = editor.editorPoint;
        if (editor) {
            if (point.x === x && point.y === y && editor.isEditing) {
                return; //we're already open at this location
            } else if (this.isEditing()) {
                this.stopEditing(); //other editor is open, close it first
            }
            event.gridCell = {
                x: x,
                y: y
            };
            this.editAt(editor, event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Get the cell editor.
     * @desc Delegates to the behavior.
     * @returns The cell editor at the given coordinates.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     */
    getCellEditorAt: function(x, y) {
        return this.getBehavior().getCellEditorAt(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Toggle HiDPI support.
     * @desc HiDPI support is now *on* by default.
     * > There used to be a bug in Chrome that caused severe slow down on bit blit of large images, so this HiDPI needed to be optional.
     */
    toggleHiDPI: function() {
        if (this.useHiDPI()) {
            this.removeAttribute('hidpi');
        } else {
            this.setAttribute('hidpi', null);
        }
        this.canvas.resize();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} Te HiDPI ratio.
     */
    getHiDPI: function(ctx) {
        if (window.devicePixelRatio && this.useHiDPI()) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                ctx.mozBackingStorePixelRatio ||
                ctx.msBackingStorePixelRatio ||
                ctx.oBackingStorePixelRatio ||
                ctx.backingStorePixelRatio || 1;

            var ratio = devicePixelRatio / backingStoreRatio;
            return ratio;
        } else {
            return 1;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The width of the given (recently rendered) column.
     * @param {number} colIndex - The column index.
     */
    getRenderedWidth: function(colIndex) {
        return this.renderer.getRenderedWidth(colIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The height of the given (recently rendered) row.
     * @param {number} rowIndex - Tthe row index.
     */
    getRenderedHeight: function(rowIndex) {
        return this.renderer.getRenderedHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {CellEditor} The cell editor at alias "name" (a sub-component).
     * @param {string} name
     */
    resolveCellEditor: function(name) {
        return this.cellEditors[name];
    },

    /**
     * @memberOf Hypergrid.prototype
    update the cursor under the hover cell
     */
    updateCursor: function() {
        var translate = this.getBehavior();
        var cursor = translate.getCursorAt(-1, -1);
        var hoverCell = this.getHoverCell();
        if (hoverCell && hoverCell.x > -1 && hoverCell.y > -1) {
            var x = hoverCell.x + this.getHScrollValue();
            cursor = translate.getCursorAt(x, hoverCell.y + this.getVScrollValue());
        }
        this.beCursor(cursor);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Repaint the given cell.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     */
    repaintCell: function(x, y) {
        this.getRenderer().repaintCell(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The user is currently dragging a column to reorder it.
     */
    isDraggingColumn: function() {
        return !!this.renderOverridesCache.dragger;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll up one full page.
     * @returns {number}
     */
    pageUp: function() {
        var rowNum = this.getRenderer().getPageUpRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll down one full page.
     * @returns {number}
     */
    pageDown: function() {
        var rowNum = this.getRenderer().getPageDownRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Not yet implemented.
     */
    pageLeft: function() {
        console.log('page left');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Not yet implemented.
     */
    pageRight: function() {
        console.log('page right');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object[]} Objects with the values that were just rendered.
     */
    getRenderedData: function() {
        // assumes one row of headers
        var behavior = this.getBehavior(),
            renderer = this.getRenderer(),
            colCount = this.getColumnCount(),
            rowCount = renderer.getVisibleRows(),
            headers = new Array(colCount),
            results = new Array(rowCount),
            row;

        headers.forEach(function(header, c) {
            headers[c] = behavior.getColumnId(c, 0);
        });

        results.forEach(function(result, r) {
            row = results[r] = {
                hierarchy: behavior.getFixedColumnValue(0, r)
            };
            headers.forEach(function(field, c) {
                row[field] = behavior.getValue(c, r);
            });
        });

        return results;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} An object that represents the currently selection row.
     */
    getSelectedRow: function() {
        var sels = this.getSelectionModel().getSelections();
        if (sels.length) {
            var behavior = this.getBehavior(),
                colCount = this.getColumnCount(),
                topRow = sels[0].origin.y,
                row = {
                    //hierarchy: behavior.getFixedColumnValue(0, topRow)
                };

            for (var c = 0; c < colCount; c++) {
                row[behavior.getColumnId(c, 0)] = behavior.getValue(c, topRow);
            }

            return row;
        }
    },

    fireRequestCellEdit: function(cell, value) {
        var clickEvent = new CustomEvent('fin-request-cell-edit', {
            cancelable: true,
            detail: {
                value: value,
                gridCell: cell,
                time: Date.now()
            }
        });
        return this.canvas.dispatchEvent(clickEvent); //I wasn't cancelled
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a fin-before-cell-edit event.
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} value - The current value.
     */
    fireBeforeCellEdit: function(cell, oldValue, newValue, control) {
        var clickEvent = new CustomEvent('fin-before-cell-edit', {
            cancelable: true,
            detail: {
                oldValue: oldValue,
                newValue: newValue,
                gridCell: cell,
                time: Date.now(),
                input: control
            }
        });
        var proceed = this.canvas.dispatchEvent(clickEvent);
        return proceed; //I wasn't cancelled
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Renderer} sub-component
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} oldValue - The old value.
     * @param {Object} newValue - The new value.
     */
    fireAfterCellEdit: function(cell, oldValue, newValue, control) {
        var clickEvent = new CustomEvent('fin-after-cell-edit', {
            detail: {
                newValue: newValue,
                oldValue: oldValue,
                gridCell: cell,
                time: Date.now(),
                input: control
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Autosize the column at colIndex for best fit.
     * @param {number} colIndex - The column index to modify at
     */
    autosizeColumn: function(colIndex) {
        var column = this.getBehavior().getColumn(colIndex);
        column.checkColumnAutosizing(true);
        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Enable/disable if this component can receive the focus.
     * @param {boolean} - canReceiveFocus
     */
    setFocusable: function(canReceiveFocus) {
        this.getCanvas().setFocusable(canReceiveFocus);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of columns that were just rendered
     */
    getVisibleColumnsCount: function() {
        return this.getRenderer().getVisibleColumnsCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of rows that were just rendered
     */
    getVisibleRowsCount: function() {
        return this.getRenderer().getVisibleRowsCount();
    },

    /**
     * @memberOf Hypergrid.prototype
    update the size of the grid
     *
     * #### returns: integer
     */
    updateSize: function() {
        this.canvas.checksize();
    },


    /**
     * @memberOf Hypergrid.prototype
     * @desc Stop the global repainting flag thread.
     */
    stopPaintThread: function() {
        this.canvas.stopPaintThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Stop the global resize check flag thread.
     */
    stopResizeThread: function() {
        this.canvas.stopResizeThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Restart the global resize check flag thread.
     */
    restartResizeThread: function() {
        this.canvas.restartResizeThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Restart the global repainting check flag thread.
     */
    restartPaintThread: function() {
        this.canvas.restartPaintThread();
    },

    swapColumns: function(source, target) {
        this.getBehavior().swapColumns(source, target);
    },

    endDragColumnNotification: function() {
        this.getBehavior().endDragColumnNotification();
    },

    getFixedColumnsMaxWidth: function() {
        return this.getBehavior().getFixedColumnsMaxWidth();
    },

    isMouseDownInHeaderArea: function() {
        var numHeaderColumns = this.getHeaderColumnCount();
        var numHeaderRows = this.getHeaderRowCount();
        var mouseDown = this.getMouseDown();
        return mouseDown.x < numHeaderColumns || mouseDown.y < numHeaderRows;
    },

    isHeaderWrapping: function() {
        return this.resolveProperty('headerTextWrapping');
    },

    _getBoundsOfCell: function(x, y) {
        var bounds = this.getRenderer()._getBoundsOfCell(x, y);
        return bounds;
    },

    getColumnProperties: function(columnIndex) {
        var properties = this.getBehavior().getColumnProperties(columnIndex);
        return properties;
    },

    setColumnProperties: function(columnIndex, properties) {
        this.getBehavior().setColumnProperties(columnIndex, properties);
    },

    moveSingleSelect: function(x, y) {
        this.getBehavior().moveSingleSelect(this, x, y);
    },

    selectCell: function(x, y) {
        this.getSelectionModel().clear();
        this.getSelectionModel().select(x, y, 0, 0);
    },

    getHeaderColumnCount: function() {
        return this.getBehavior().getHeaderColumnCount();
    },

    toggleSort: function(x, keys) {
        this.stopEditing();
        var behavior = this.getBehavior();
        var self = this;
        behavior.toggleSort(x, keys);

        setTimeout(function() {
            self.synchronizeScrollingBoundries();
            //self.behaviorChanged();
            if (self.isColumnAutosizing()) {
                behavior.autosizeAllColumns();
            }
            self.repaint();
        }, 10);
    },

    toggleSelectColumn: function(x, keys) {
        keys = keys || [];
        var model = this.getSelectionModel();
        var alreadySelected = model.isColumnSelected(x);
        var hasCTRL = keys.indexOf('CTRL') > -1;
        var hasSHIFT = keys.indexOf('SHIFT') > -1;
        if (!hasCTRL && !hasSHIFT) {
            model.clear();
            if (!alreadySelected) {
                model.selectColumn(x);
            }
        } else {
            if (hasCTRL) {
                if (alreadySelected) {
                    model.deselectColumn(x);
                } else {
                    model.selectColumn(x);
                }
            }
            if (hasSHIFT) {
                model.clear();
                model.selectColumn(this.lastEdgeSelection[0], x);
            }
        }
        if (!alreadySelected && !hasSHIFT) {
            this.lastEdgeSelection[0] = x;
        }
        this.repaint();
        this.fireSyntheticColumnSelectionChangedEvent();
    },

    toggleSelectRow: function(y, keys) {

        //we can select the totals rows if they exist,
        //but not rows above that
        var selectionEdge = this.getFilterRowIndex() + 1;
        if (y < selectionEdge) {
            return;
        }

        keys = keys || [];

        var isSingleRowSelection = this.isSingleRowSelectionMode();
        var model = this.getSelectionModel();
        var alreadySelected = model.isRowSelected(y);
        var hasCTRL = keys.indexOf('CTRL') > -1;
        var hasSHIFT = keys.indexOf('SHIFT') > -1;

        if (!hasCTRL && !hasSHIFT) {
            model.clear();
            if (!alreadySelected) {
                model.selectRow(y);
            }
        } else {
            if (hasCTRL) {
                if (alreadySelected) {
                    model.deselectRow(y);
                } else {
                    if (isSingleRowSelection) {
                        model.clearRowSelection();
                    }
                    model.selectRow(y);
                }
            }
            if (hasSHIFT) {
                model.clear();
                model.selectRow(this.lastEdgeSelection[1], y);
            }
        }
        if (!alreadySelected && !hasSHIFT) {
            this.lastEdgeSelection[1] = y;
        }
        this.repaint();
    },

    selectViewportCell: function(x, y) {
        var headerRowCount = this.getHeaderRowCount();
        var renderer = this.getRenderer();
        var realX = renderer.getVisibleColumns()[x];
        var realY = renderer.getVisibleRows()[y];
        this.clearSelections();
        this.select(realX, realY + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(realX, realY + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToViewportCell: function(x, y) {
        var selections = this.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var headerRowCount = this.getHeaderRowCount();
        var renderer = this.getRenderer();
        var realX = renderer.getVisibleColumns()[x];
        var realY = renderer.getVisibleRows()[y] + headerRowCount;
        var selection = selections[0];
        var origin = selection.origin;
        this.setDragExtent(this.newPoint(realX - origin.x, realY - origin.y));
        this.select(origin.x, origin.y, realX - origin.x, realY - origin.y);
        this.repaint();
    },

    selectFinalCellOfCurrentRow: function() {
        var x = this.getColumnCount() - 1;
        var y = this.getSelectedRows()[0];
        var headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.scrollBy(this.getColumnCount(), 0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFinalCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var selection = selections[0];
        var origin = selection.origin;
        var extent = selection.extent;
        var columnCount = this.getColumnCount();
        this.scrollBy(columnCount, 0);

        this.clearSelections();
        this.select(origin.x, origin.y, columnCount - origin.x - 1, extent.y);

        this.repaint();
    },

    selectFirstCellOfCurrentRow: function() {
        var x = 0;
        var y = this.getSelectedRows()[0];
        var headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.setHScrollValue(0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFirstCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var selection = selections[0];
        var origin = selection.origin;
        var extent = selection.extent;
        this.clearSelections();
        this.select(origin.x, origin.y, -origin.x, extent.y);
        this.setHScrollValue(0);
        this.repaint();
    },

    selectFinalCell: function() {
        this.selectCell(this.getColumnCount() - 1, this.getRowCount() - 1);
        this.scrollBy(this.getColumnCount(), this.getRowCount());
        this.repaint();
    },

    selectToFinalCell: function() {

        var selections = this.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var selection = selections[0];
        var origin = selection.origin;
        var columnCount = this.getColumnCount();
        var rowCount = this.getRowCount();

        this.clearSelections();
        this.select(origin.x, origin.y, columnCount - origin.x - 1, rowCount - origin.y - 1);
        this.scrollBy(columnCount, rowCount);
        this.repaint();
    },

    isShowRowNumbers: function() {
        return this.resolveProperty('showRowNumbers');
    },
    isEditable: function() {
        return this.resolveProperty('editable') === true;
    },
    isShowFilterRow: function() {
        return this.resolveProperty('showFilterRow');
    },
    isShowHeaderRow: function() {
        return this.resolveProperty('showHeaderRow');
    },
    getHeaderRowCount: function() {
        return this.getBehavior().getHeaderRowCount();
    },
    isFilterRow: function(y) {
        return y === this.getFilterRowIndex();
    },
    getFilterRowIndex: function() {
        if (!this.isShowFilterRow()) {
            return -1;
        }
        if (this.isShowHeaderRow()) {
            return 1;
        } else {
            return 0;
        }
    },
    setGroups: function(arrayOfColumnIndexes) {
        this.getBehavior().setGroups(arrayOfColumnIndexes);
    },
    filterClicked: function(event) {
        this.activateEditor(event.gridCell.x, event.gridCell.y);
    },
    hasHierarchyColumn: function() {
        return this.getBehavior().hasHierarchyColumn();
    },
    isHierarchyColumn: function(x) {
        if (!this.hasHierarchyColumn()) {
            return false;
        }
        return x === 0;
    },
    checkScrollbarVisibility: function() {
        // var hoverClassOver = this.resolveProperty('scrollbarHoverOver');
        // var hoverClassOff = this.resolveProperty('scrollbarHoverOff');

        // if (hoverClassOff === 'visible') {
        //     this.sbHScroller.classList.remove(hoverClassOver);
        //     this.sbVScroller.classList.remove(hoverClassOff);
        //     this.sbHScroller.classList.add('visible');
        //     this.sbVScroller.classList.add('visible');
        // }
    },
    isColumnOrRowSelected: function() {
        return this.getSelectionModel().isColumnOrRowSelected();
    },
    selectColumn: function(x1, x2) {
        this.getSelectionModel().selectColumn(x1, x2);
    },
    selectRow: function(y1, y2) {
        if (this.isSingleRowSelectionMode()) {
            this.getSelectionModel().clearRowSelection();
            y1 = y2;
        } else {
            y2 = y2 || y1;
        }
        var min = Math.min(y1, y2);
        var max = Math.max(y1, y2);
        var selectionEdge = this.getFilterRowIndex() + 1;
        if (min < selectionEdge) {
            return;
        }
        this.getSelectionModel().selectRow(min, max);
    },
    isRowSelected: function(r) {
        return this.getSelectionModel().isRowSelected(r);
    },
    isColumnSelected: function(c) {
        return this.getSelectionModel().isColumnSelected(c);
    },
    lookupFeature: function(key) {
        return this.getBehavior().lookupFeature(key);
    },
    getRow: function(y) {
        return this.getBehavior().getRow(y);
    },
    getFieldName: function(index) {
        return this.getBehavior().getFieldName(index);
    },

    getColumnIndex: function(fieldName) {
        return this.getBehavior().getColumnIndex(fieldName);
    },
    isCellSelection: function() {
        return this.resolveProperty('cellSelection') === true;
    },
    isRowSelection: function() {
        return this.resolveProperty('rowSelection') === true;
    },
    isColumnSelection: function() {
        return this.resolveProperty('columnSelection') === true;
    },
    getComputedRow: function(y) {
        return this.getBehavior().getComputedRow(y);
    },
    isColumnAutosizing: function() {
        return this.resolveProperty('columnAutosizing') === true;
    },
    setGlobalFilter: function(string) {
        this.getBehavior().setGlobalFilter(string);
    },
    selectRowsFromCells: function() {
        var sm = this.getSelectionModel();
        if (this.isSingleRowSelectionMode()) {
            var last = sm.getLastSelection();
            if (!last) {
                sm.clearRowSelection();
            } else {
                this.selectRow(null, last.corner.y);
            }
        } else {
            sm.selectRowsFromCells();
        }
    },
    selectColumnsFromCells: function() {
        this.getSelectionModel().selectColumnsFromCells();
    },
    getSelectedRows: function() {
        return this.getBehavior().getSelectedRows();
    },
    getSelectedColumns: function() {
        return this.getBehavior().getSelectedColumns();
    },
    getSelections: function() {
        return this.getBehavior().getSelections();
    },
    getLastSelectionType: function() {
        return this.getSelectionModel().getLastSelectionType();
    },
    isCellSelected: function(x, y) {
        return this.getSelectionModel().isCellSelected(x, y);
    },
    isInCurrentSelectionRectangle: function(x, y) {
        return this.getSelectionModel().isInCurrentSelectionRectangle(x, y);
    },
    selectAllRows: function() {
        this.getSelectionModel().selectAllRows();
    },
    areAllRowsSelected: function() {
        return this.getSelectionModel().areAllRowsSelected();
    },
    toggleSelectAllRows: function() {
        if (this.areAllRowsSelected()) {
            this.getSelectionModel().clear();
        } else {
            this.selectAllRows();
        }
        this.repaint();
    },
    getField: function(x) {
        return this.getBehavior().getField(x);
    },
    isSingleRowSelectionMode: function() {
        return this.resolveProperty('singleRowSelectionMode');
    },
    newPoint: function(x, y) {
        return new Point(x, y);
    },
    newRectangle: function(x, y, width, height) {
        return new Rectangle(x, y, width, height);
    }
};

function getTextWidth(gc, string) {
    if (string === null || string === undefined) {
        return 0;
    }
    string = string + '';
    if (string.length === 0) {
        return 0;
    }
    var key = gc.font + string;
    var width = textWidthCache.get(key);
    if (!width) {
        width = gc.measureText(string).width;
        textWidthCache.set(key, width);
    }
    return width;
}

function getTextHeight(font) {

    var result = getTextHeight.fontData[font];
    if (result) {
        return result;
    }
    result = {};
    var text = document.createElement('span');
    text.textContent = 'Hg';
    text.style.font = font;

    var block = document.createElement('div');
    block.style.display = 'inline-block';
    block.style.width = '1px';
    block.style.height = '0px';

    var div = document.createElement('div');
    div.appendChild(text);
    div.appendChild(block);

    div.style.position = 'absolute';
    document.body.appendChild(div);

    try {

        block.style.verticalAlign = 'baseline';

        var blockRect = block.getBoundingClientRect();
        var textRect = text.getBoundingClientRect();

        result.ascent = blockRect.top - textRect.top;

        block.style.verticalAlign = 'bottom';
        result.height = blockRect.top - textRect.top;

        result.descent = result.height - result.ascent;

    } finally {
        document.body.removeChild(div);
    }
    if (result.height !== 0) {
        getTextHeight.fontData[font] = result;
    }
    return result;
}
getTextHeight.fontData = {};

function defaultProperties() {
    var properties = {
        //these are for the theme
        font: '13px Tahoma, Geneva, sans-serif',
        color: 'rgb(25, 25, 25)',
        backgroundColor: 'rgb(241, 241, 241)',
        foregroundSelectionColor: 'rgb(25, 25, 25)',
        backgroundSelectionColor: 'rgb(183, 219, 255)',

        columnHeaderFont: '12px Tahoma, Geneva, sans-serif',
        columnHeaderColor: 'rgb(25, 25, 25)',
        columnHeaderBackgroundColor: 'rgb(223, 227, 232)',
        columnHeaderForegroundSelectionColor: 'rgb(25, 25, 25)',
        columnHeaderBackgroundSelectionColor: 'rgb(255, 220, 97)',
        columnHeaderForegroundColumnSelectionColor: 'rgb(25, 25, 25)',
        columnHeaderBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',

        rowHeaderFont: '12px Tahoma, Geneva, sans-serif',
        rowHeaderColor: 'rgb(25, 25, 25)',
        rowHeaderBackgroundColor: 'rgb(223, 227, 232)',
        rowHeaderForegroundSelectionColor: 'rgb(25, 25, 25)',
        rowHeaderBackgroundSelectionColor: 'rgb(255, 220, 97)',
        rowHeaderForegroundRowSelectionColor: 'rgb(25, 25, 25)',
        rowHeaderBackgroundRowSelectionColor: 'rgb(255, 180, 0)',

        filterFont: '12px Tahoma, Geneva, sans-serif',
        filterColor: 'rgb(25, 25, 25)',
        filterBackgroundColor: 'white',
        filterForegroundSelectionColor: 'rgb(25, 25, 25)',
        filterBackgroundSelectionColor: 'rgb(255, 220, 97)',
        filterCellBorderStyle: 'rgba(0,0,0,0.8)',
        filterCellBorderThickness: '0.4',

        treeColumnFont: '12px Tahoma, Geneva, sans-serif',
        treeColumnColor: 'rgb(25, 25, 25)',
        treeColumnBackgroundColor: 'rgb(223, 227, 232)',
        treeColumnForegroundSelectionColor: 'rgb(25, 25, 25)',
        treeColumnBackgroundSelectionColor: 'rgb(255, 220, 97)',
        treeColumnForegroundColumnSelectionColor: 'rgb(25, 25, 25)',
        treeColumnBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',

        backgroundColor2: 'rgb(201, 201, 201)',
        voffset: 0,
        scrollbarHoverOver: 'visible',
        scrollbarHoverOff: 'hidden',
        scrollingEnabled: true,
        vScrollbarClassPrefix: '',
        hScrollbarClassPrefix: '',

        //these used to be in the constants element
        fixedRowAlign: 'center',
        fixedColAlign: 'center',
        cellPadding: 5,
        gridLinesH: true,
        gridLinesV: true,
        lineColor: 'rgb(199, 199, 199)',
        lineWidth: 0.4,

        defaultRowHeight: 15,
        defaultColumnWidth: 100,

        //for immediate painting, set these values to 0, true respectively
        repaintIntervalRate: 60,
        repaintImmediately: false,

        //enable or disable double buffering
        useBitBlit: false,

        useHiDPI: true,
        editorActivationKeys: ['alt', 'esc'],
        readOnly: false,

        //inhertied by cell renderers
        getTextWidth: getTextWidth,
        getTextHeight: getTextHeight,

        fixedColumnCount: 0,
        fixedRowCount: 0,
        headerColumnCount: 0,

        showRowNumbers: true,
        showHeaderRow: true,
        showFilterRow: true,

        cellSelection: true,
        columnSelection: true,
        rowSelection: true,
        singleRowSelectionMode: true,

        columnAutosizing: true,
        headerTextWrapping: false,
        rowResize: false

    };
    return properties;
}

function normalizeRect(rect) {
    var o = rect.origin;
    var c = rect.corner;

    var ox = Math.min(o.x, c.x);
    var oy = Math.min(o.y, c.y);

    var cx = Math.max(o.x, c.x);
    var cy = Math.max(o.y, c.y);

    var result = new Rectangle(ox, oy, cx - ox, cy - oy);

    return result;
}

function buildPolymerTheme() {
    clearObjectProperties(polymerTheme);
    var pb = document.createElement('paper-button');

    pb.style.display = 'none';
    pb.setAttribute('disabled', true);
    document.body.appendChild(pb);
    var p = window.getComputedStyle(pb);

    var section = document.createElement('section');
    section.style.display = 'none';
    section.setAttribute('hero', true);
    document.body.appendChild(section);

    var h = window.getComputedStyle(document.querySelector('html'));
    var hb = window.getComputedStyle(document.querySelector('html, body'));
    var s = window.getComputedStyle(section);

    polymerTheme.columnHeaderBackgroundColor = p.color;
    polymerTheme.rowHeaderBackgroundColor = p.color;
    polymerTheme.topLeftBackgroundColor = p.color;
    polymerTheme.lineColor = p.backgroundColor;

    polymerTheme.backgroundColor2 = hb.backgroundColor;

    polymerTheme.color = h.color;
    polymerTheme.fontFamily = h.fontFamily;
    polymerTheme.backgroundColor = s.backgroundColor;

    pb.setAttribute('disabled', false);
    pb.setAttribute('secondary', true);
    pb.setAttribute('raised', true);
    p = window.getComputedStyle(pb);

    polymerTheme.columnHeaderColor = p.color;
    polymerTheme.rowHeaderColor = p.color;
    polymerTheme.topLeftColor = p.color;


    polymerTheme.backgroundSelectionColor = p.backgroundColor;
    polymerTheme.foregroundSelectionColor = p.color;

    pb.setAttribute('secondary', false);
    pb.setAttribute('warning', true);

    polymerTheme.columnHeaderForegroundSelectionColor = p.color;
    polymerTheme.columnHeaderBackgroundSelectionColor = p.backgroundColor;
    polymerTheme.rowHeaderForegroundSelectionColor = p.color;
    polymerTheme.fixedColumnBackgroundSelectionColor = p.backgroundColor;

    //check if there is actually a theme loaded if not, clear out all bogus values
    //from my cache
    if (polymerTheme.columnHeaderBackgroundSelectionColor === 'rgba(0, 0, 0, 0)' ||
        polymerTheme.lineColor === 'transparent') {
        clearObjectProperties(polymerTheme);
    }

    document.body.removeChild(pb);
    document.body.removeChild(section);
}

function clearObjectProperties(obj) {
    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            delete obj[prop];
        }
    }
}

function valueOrFunctionExecute(valueOrFunction) {
    var result = typeof valueOrFunction === 'function' ? valueOrFunction() : valueOrFunction;
    return result || result === 0 ? result : '';
}

function installPolyfills() {
    if (!Array.prototype.find) {
        Array.prototype.find = function(predicate) { // eslint-disable-line no-extend-native
            if (this === null) {
                throw new TypeError('Array.prototype.find called on null or undefined');
            }
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var list = Object(this);
            var length = list.length >>> 0;
            var thisArg = arguments[1];
            var value;

            for (var i = 0; i < length; i++) {
                value = list[i];
                if (predicate.call(thisArg, value, i, list)) {
                    return value;
                }
            }
            return undefined;
        };
    }
}

module.exports = Hypergrid;

},{"./Renderer":34,"./SelectionModel":35,"./stylesheets":72,"extend-me":3,"finbars":4,"fincanvas":5,"lru-cache":26,"object-iterators":28,"rectangular":29}],34:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var _ = require('object-iterators');
var Base = require('extend-me').Base;

/**
 * @constructor
 * @desc fin-hypergrid-renderer is the canvas enabled top level sub component that handles the renderering of the Grid.
 *
 * It relies on two other external subprojects
 *
 * 1. fin-canvas: a wrapper to provide a simpler interface to the HTML5 canvas component
 * 2. rectangular: a small npm module providing Point and Rectangle objects
 *
 * The fin-hypergrid-renderer is in a unique position to provide critical functionality to the fin-hypergrid in a hightly performant manner.
 * Because it MUST iterate over all the visible cells it can store various bits of information that can be encapsulated as a service for consumption by the fin-hypergrid component.
 *
 * Instances of this object have basically four main functions.
 *
 * 1. render fixed row headers
 * 2. render fixed col headers
 * 3. render main data cells
 * 4. render grid lines
 *
 * Same parameters as {@link Renderer#initialize|initialize}, which is called by this constructor.
 *
 */
var Renderer = Base.extend('Renderer', {

    //the shared single item "pooled" cell object for drawing each cell
    cell: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    },

    scrollHeight: 0,

    viewHeight: 0,

    reset: function() {
        this.bounds = {
            width:0,
            height:0
        };
        this.columnEdges = [];
        this.columnEdgesIndexMap = {};
        this.renderedColumnMinWidths = [];
        this.renderedHeight = 0;
        this.rowEdges = [];
        this.rowEdgesIndexMap = {};
        this.visibleColumns = [];
        this.visibleRows = [];
        this.insertionBounds = [];
    },

    /**
     * @summary Constructor logic
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     * @memberOf Renderer.prototype
     */
    initialize: function(grid) {
        this.grid = grid;
        this.bounds = {
            width:0,
            height:0
        };
        this.columnEdges = [];
        this.columnEdgesIndexMap = {};
        this.renderedColumnMinWidths = [];
        this.renderedHeight = 0;
        this.rowEdges = [];
        this.rowEdgesIndexMap = {};
        this.visibleColumns = [];
        this.visibleRows = [];
        this.insertionBounds = [];
    },

    //this function computes the grid coordinates used for extremely fast iteration over
    //painting the grid cells. this function is very fast, for thousand rows X 100 columns
    //on a modest machine taking usually 0ms and no more that 3 ms.
    computeCellsBounds: function() {

        //var startTime = Date.now();

        var grid = this.getGrid();
        var scrollTop = this.getScrollTop();
        var scrollLeft = this.getScrollLeft();

        var numColumns = this.getColumnCount();
        var numFixedColumns = this.getFixedColumnCount();

        var numRows = this.getRowCount();
        var numFixedRows = this.getFixedRowCount();

        var bounds = this.getBounds();
        var viewWidth = bounds.width;

        //we must be in bootstrap
        if (viewWidth === 0) {
            //viewWidth = grid.sbHScroller.getClientRects()[0].width;
            viewWidth = grid.canvas.width;
        }
        var viewHeight = bounds.height;

        var x, y, c, r, vx, vy, width, height;

        this.getColumnEdges().length = 0;
        this.rowEdges.length = 0;

        this.columnEdges[0] = 0;
        this.rowEdges[0] = 0;
        this.scrollHeight = 0;

        this.visibleColumns.length = 0;
        this.visibleRows.length = 0;
        this.columnEdgesIndexMap = {};
        this.rowEdgesIndexMap = {};

        this.insertionBounds = [];
        var insertionBoundsCursor = 0;
        var previousInsertionBoundsCursorValue = 0;

        x = 0;
        var start = 0;
        var firstVX, lastVX;
        var firstVY, lastVY;
        if (grid.isShowRowNumbers()) {
            start--;
            this.columnEdges[-1] = -1;
        }
        for (c = start; c < numColumns; c++) {
            vx = c;
            if (c >= numFixedColumns) {
                vx = vx + scrollLeft;
                if (firstVX === undefined) {
                    firstVX = vx;
                }
                lastVX = vx;
            }
            if (x > viewWidth || numColumns <= vx) {
                break;
            }
            width = this.getColumnWidth(vx);
            x = x + width;
            this.columnEdges[c + 1] = Math.round(x);
            this.visibleColumns[c] = vx;
            this.columnEdgesIndexMap[vx] = c;

            insertionBoundsCursor = insertionBoundsCursor + Math.round(width / 2) + previousInsertionBoundsCursorValue;
            this.insertionBounds.push(insertionBoundsCursor);
            previousInsertionBoundsCursorValue = Math.round(width / 2);
        }

        y = 0;
        for (r = 0; r < numRows; r++) {
            vy = r;
            if (r >= numFixedRows) {
                vy = vy + scrollTop;
                if (firstVY === undefined) {
                    firstVY = vy;
                }
                lastVY = vy;
            }
            if (y > viewHeight || numRows <= vy) {
                break;
            }
            height = this.getRowHeight(vy);
            y = y + height;
            this.rowEdges[r + 1] = Math.round(y);
            this.visibleRows[r] = vy;
            this.rowEdgesIndexMap[vy] = r;
        }
        this.viewHeight = viewHeight;
        this.dataWindow = grid.newRectangle(firstVX, firstVY, lastVX - firstVX, lastVY - firstVY);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {Object} a property value at a key, delegates to the grid
     */
    resolveProperty: function(key) {
        return this.getGrid().resolveProperty(key);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {Hypergrid} grid
     */
    getGrid: function() {
        return this.grid;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Notify the fin-hypergrid everytime we've repainted.
     * @desc This is the entry point from fin-canvas.
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    _paint: function(gc) {
        if (this.grid) {
            this.renderGrid(gc);
            this.getGrid().gridRenderedNotification();
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Answer how many rows we rendered
     */
    getVisibleRowsCount: function() {
        return this.visibleRows.length - 1;
    },

    getVisibleScrollHeight: function() {
        var grid = this.getGrid(),
            frh = grid.getFixedRowsHeight();

        return this.viewHeight - frh;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number[]} Rows we just rendered.
     */
    getVisibleRows: function() {
        return this.visibleRows;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Numer of columns we just rendered.
     */
    getVisibleColumnsCount: function() {
        return this.visibleColumns.length - 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Columns we just rendered.
     */
    getVisibleColumns: function() {
        return this.visibleColumns;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The column index whne the mouseEvent coordinates are over a column divider.
     */
    overColumnDivider: function(x) {
        x = Math.round(x);
        var edges = this.getColumnEdges();
        var whichCol = edges.indexOf(x - 1);
        if (whichCol < 0) {
            whichCol = edges.indexOf(x);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x - 2);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x + 1);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x - 3);
        }

        return whichCol;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row index when the mouseEvent coordinates are over a row divider.
     */
    overRowDivider: function(y) {
        y = Math.round(y);
        var which = this.rowEdges.indexOf(y + 1);
        if (which < 0) {
            which = this.rowEdges.indexOf(y);
        }
        if (which < 0) {
            which = this.rowEdges.indexOf(y - 1);
        }
        return which;
    },

    /**
     * @memberOf Renderer.prototype
     * @param {Point} cell
     * @returns {Rectangle} Bounding rect of the given `cell`.
     */
    getBoundsOfCell: function(cell) {
        return this._getBoundsOfCell(cell.x, cell.y);
    },

    /**
     * @memberOf Renderer.prototype
     * @param {number} c - The horizontal coordinate.
     * @param {number} r - The vertical coordinate.
     * @returns {Rectangle} Bounding rect of cell with the given coordinates.
     */
    _getBoundsOfCell: function(c, r) {
        var xOutside = false;
        var yOutside = false;
        var columnEdges = this.getColumnEdges();
        var rowEdges = this.getRowEdges();

        var x = this.columnEdgesIndexMap[c];
        var y = this.rowEdgesIndexMap[r];
        if (x === undefined) {
            x = this.columnEdgesIndexMap[c - 1];
            xOutside = true;
        }

        if (y === undefined) {
            y = this.rowEdgesIndexMap[r - 1];
            yOutside = true;
        }

        var ox = columnEdges[x],
            oy = rowEdges[y],
            cx = columnEdges[x + 1],
            cy = rowEdges[y + 1],
            ex = cx - ox,
            ey = cy - oy;

        var cell = this.cell;
        cell.x = xOutside ? cx : ox;
        cell.y = yOutside ? cy : oy;
        cell.width = xOutside ? 0 : ex;
        cell.height = yOutside ? 0 : ey;

        return cell;

    },

    /**
     * @memberOf Renderer.prototype
     * @desc answer the column index under the coordinate at pixelX
     * @param {number} pixelX - The horizontal coordinate.
     * @returns {number} The column index under the coordinate at pixelX.
     */
    getColumnFromPixelX: function(pixelX) {
        var width = 0;
        var grid = this.getGrid();
        var fixedColumnCount = this.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();
        var c;
        var edges = this.getColumnEdges();
        for (c = 1; c < edges.length - 1; c++) {
            width = edges[c] - (edges[c] - edges[c - 1]) / 2;
            if (pixelX < width) {
                if (c > fixedColumnCount) {
                    c = c + scrollLeft;
                }
                return c - 1;
            }
        }
        if (c > fixedColumnCount) {
            c = c + scrollLeft;
        }
        return c - 1;
    },


    /**
     * @memberOf Renderer.prototype
     * @desc Answer specific data cell coordinates given mouse coordinates in pixels.
     * @param {Point} point
     * @returns {Point} Cell coordinates
     */
    getGridCellFromMousePoint: function(point) {

        var grid = this.getGrid();
        var behavior = grid.getBehavior();
        var width = 0;
        var height = 0;
        var x, y, c, r;
        var previous = 0;
        var columnEdges = this.getColumnEdges();
        var fixedColumnCount = this.getFixedColumnCount(); // + gridSize;
        var fixedRowCount = this.getFixedRowCount();

        // var fixedColumnCount = this.getFixedColumnCount();
        // var fixedRowCount = this.getFixedRowCount();
        var scrollX = this.getScrollLeft();
        var scrollY = this.getScrollTop();

        for (c = 0; c < columnEdges.length; c++) {
            width = columnEdges[c];
            if (point.x < width) {
                x = Math.max(0, point.x - previous - 2);
                break;
            }
            previous = width;
        }
        c--;
        previous = 0;
        for (r = 0; r < this.rowEdges.length; r++) {
            height = this.rowEdges[r];
            if (point.y < height) {
                y = Math.max(0, point.y - previous - 2);
                break;
            }
            previous = height;
        }
        r--;
        if (point.x < 0) {
            c = -1;
        }
        if (point.y < 0) {
            r = -1;
        }

        var viewPoint = grid.newPoint(c, r);

        //compensate if we are scrolled
        if (c >= fixedColumnCount) {
            c = c + scrollX;
        }
        if (r >= fixedRowCount) {
            r = r + scrollY;
        }

        var translatedIndex = -1;

        var column = behavior.getColumn(c);
        if (column) {
            translatedIndex = column.index;
        }

        return {
            gridCell: grid.newPoint(c, r),
            mousePoint: grid.newPoint(x, y),
            viewPoint: viewPoint,
            dataCell: grid.newPoint(translatedIndex, r),
        };
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a column is visible.
     * @param {number} colIndex - the column index*
     * @returns {boolean} The given column is fully visible.
     */
    isColumnVisible: function(colIndex) {
        var isVisible = this.visibleColumns.indexOf(colIndex) !== -1;
        return isVisible;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The width x coordinate of the last rendered column
     */
    getFinalVisableColumnBoundry: function() {
        var isMaxX = this.isLastColumnVisible();
        var chop = isMaxX ? 2 : 1;
        var colWall = this.getColumnEdges()[this.getColumnEdges().length - chop];
        var result = Math.min(colWall, this.getBounds().width - 200);
        return result;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines visibility of a row.
     * @param {number} rowIndex - the row index
     * @returns {boolean} The given row is fully visible.
     */
    isRowVisible: function(rowIndex) {
        var isVisible = this.visibleRows.indexOf(rowIndex) !== -1;
        return isVisible;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a cell is selected.
     * @param {number} x - the x cell coordinate
     * @param {number} y - the y cell coordinate*
     * @returns {boolean} The given cell is fully visible.
     */
    isSelected: function(x, y) {
        return this.getGrid().isSelected(x, y);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc This is the main forking of the renderering task.
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    renderGrid: function(gc) {
        gc.beginPath();

        this.paintCells(gc);
        this.paintGridlines(gc);
        //this.blankOutOverflow(gc); // no longer needed
        this.renderOverrides(gc);
        this.renderFocusCell(gc);
        gc.closePath();
    },

    focusLineStep: [
        [5, 5],
        [0, 1, 5, 4],
        [0, 2, 5, 3],
        [0, 3, 5, 2],
        [0, 4, 5, 1],
        [0, 5, 5, 0],
        [1, 5, 4, 0],
        [2, 5, 3, 0],
        [3, 5, 2, 0],
        [4, 5, 1, 0]
    ],

    renderFocusCell: function(gc) {
        gc.beginPath();
        this._renderFocusCell(gc);
        gc.closePath();
    },

    _renderFocusCell: function(gc) {

        var grid = this.getGrid();
        var selections = grid.getSelectionModel().getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var selection = selections[selections.length - 1];
        var mouseDown = selection.origin;
        if (mouseDown.x === -1) {
            //no selected area, lets exit
            return;
        }

        var visibleColumns = this.getVisibleColumns();
        var visibleRows = this.getVisibleRows();
        var lastVisibleColumn = visibleColumns[visibleColumns.length - 1];
        var lastVisibleRow = visibleRows[visibleRows.length - 1];

        var extent = selection.extent;

        var dpOX = Math.min(mouseDown.x, mouseDown.x + extent.x);
        var dpOY = Math.min(mouseDown.y, mouseDown.y + extent.y);

        //lets check if our selection rectangle is scrolled outside of the visible area
        if (dpOX > lastVisibleColumn) {
            return; //the top of our rectangle is below visible
        }
        if (dpOY > lastVisibleRow) {
            return; //the left of our rectangle is to the right of being visible
        }

        var dpEX = Math.max(mouseDown.x, mouseDown.x + extent.x) + 1;
        dpEX = Math.min(dpEX, 1 + lastVisibleColumn);

        var dpEY = Math.max(mouseDown.y, mouseDown.y + extent.y) + 1;
        dpEY = Math.min(dpEY, 1 + lastVisibleRow);

        var o = this._getBoundsOfCell(dpOX, dpOY);
        var ox = Math.round((o.x === undefined) ? grid.getFixedColumnsWidth() : o.x);
        var oy = Math.round((o.y === undefined) ? grid.getFixedRowsHeight() : o.y);
        // var ow = o.width;
        // var oh = o.height;
        var e = this._getBoundsOfCell(dpEX, dpEY);
        var ex = Math.round((e.x === undefined) ? grid.getFixedColumnsWidth() : e.x);
        var ey = Math.round((e.y === undefined) ? grid.getFixedRowsHeight() : e.y);
        // var ew = e.width;
        // var eh = e.height;
        var x = Math.min(ox, ex);
        var y = Math.min(oy, ey);
        var width = 1 + ex - ox;
        var height = 1 + ey - oy;
        if (x === ex) {
            width = ox - ex;
        }
        if (y === ey) {
            height = oy - ey;
        }
        if (width * height < 1) {
            //if we are only a skinny line, don't render anything
            return;
        }

        gc.rect(x, y, width, height);
        gc.fillStyle = 'rgba(0, 0, 0, 0.2)';
        gc.fill();
        gc.lineWidth = 1;
        gc.strokeStyle = 'black';

        // animate the dashed line a bit here for fun

        gc.stroke();

        //gc.rect(x, y, width, height);

        //gc.strokeStyle = 'white';

        // animate the dashed line a bit here for fun
        //gc.setLineDash(this.focusLineStep[Math.floor(10 * (Date.now() / 300 % 1)) % this.focusLineStep.length]);

        gc.stroke();
    },


    /**
     * @memberOf Renderer.prototype
     * @desc Paint the background color over the overflow from the final column paint
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    blankOutOverflow: function(gc) {
        var isMaxX = this.isLastColumnVisible();
        var chop = isMaxX ? 1 : 0;
        var x = this.getColumnEdges()[this.getColumnEdges().length - chop];
        var bounds = this.getBounds();
        var width = bounds.width - 200 - x;
        var height = bounds.height;
        gc.fillStyle = this.resolveProperty('backgroundColor2');
        gc.fillRect(x + 1, 0, width, height);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc iterate the renderering overrides and manifest each
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    renderOverrides: function(gc) {
        var grid = this.getGrid();
        var cache = grid.renderOverridesCache;
        for (var key in cache) {
            if (cache.hasOwnProperty(key)) {
                var override = cache[key];
                if (override) {
                    this.renderOverride(gc, override);
                }
            }
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @desc copy each overrides specified area to it's target and blank out the source area
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     * @param {OverrideObject} override - an object with details contain an area and a target context
     */
    renderOverride: function(gc, override) {
        //lets blank out the drag row
        var hdpiRatio = override.hdpiratio;
        //var edges = this.getColumnEdges();
        var startX = override.startX; //hdpiRatio * edges[override.columnIndex];
        var width = override.width + 1;
        var height = override.height;
        var targetCTX = override.ctx;
        var imgData = gc.getImageData(startX, 0, Math.round(width * hdpiRatio), Math.round(height * hdpiRatio));
        targetCTX.putImageData(imgData, 0, 0);
        gc.fillStyle = this.resolveProperty('backgroundColor2');
        gc.fillRect(Math.round(startX / hdpiRatio), 0, width, height);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} mouse is currently over cell x, y
     * @param {number} offsetX - x coordinate
     * @param {number} offsetY - y coordinate
     */
    isHovered: function(x, y) {
        return this.getGrid().isHovered(x, y);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} mouse is currently over row y
     * @param {number} offsetY - y coordinate
     */
    isRowHovered: function(y) {
        return this.getGrid().isRowHovered(y);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} mouse is currently over column x
     * @param {number} offsetX - x coordinate
     */
    isColumnHovered: function(x) {
        return this.getGrid().isColumnHovered(x);
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Smart render the main cells.
     * @desc We snapshot the context to insure against its pollution.
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    paintCells: function(gc) {
        try {
            gc.save();
            this._paintCells(gc);
        } catch (e) {
            console.error(e);
        } finally {
            gc.restore();
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @param {number} colIndex
     * @returns {boolean} The given column within the fixed row area is selected.
     */
    isCellSelectedInRow: function(colIndex) {
        return this.getGrid().isCellSelectedInRow(colIndex);
    },

    /**
     * @memberOf Renderer.prototype
     * @param {number} rowIndex
     * @returns {boolean} The given row within the fixed column area is selected.
     */
    isCellSelectedInColumn: function(rowIndex) {
        return this.getGrid().isCellSelectedInColumn(rowIndex);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current vertical scroll value.
     */
    getScrollTop: function() {
        var st = this.getGrid().getVScrollValue();
        return st;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current horizontal scroll value.
     */
    getScrollLeft: function() {
        var st = this.getGrid().getHScrollValue();
        return st;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {Behavior}
     */
    getBehavior: function() {
        return this.getGrid().getBehavior();
    },

    getColumnEdges: function() {
        return this.columnEdges;
    },

    getRowEdges: function() {
        return this.rowEdges;
    },
    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row height of the row at index rowIndex
     * @param {number} rowIndex
     */
    getRowHeight: function(rowIndex) {
        var height = this.getBehavior().getRowHeight(rowIndex);
        return height;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The columnWidth of the column at index columnIndex
     * @param {number} columnIndex
     */
    getColumnWidth: function(columnIndex) {
        var width = this.getGrid().getColumnWidth(columnIndex);
        return width;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} The last col was rendered (is visible)
     */
    isLastColumnVisible: function() {
        var lastColumnIndex = this.getColumnCount() - 1;
        var isMax = this.visibleColumns.indexOf(lastColumnIndex) !== -1;
        return isMax;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered column width at index
     */
    getRenderedWidth: function(index) {
        return this.getColumnEdges()[index];
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered row height at index
     */
    getRenderedHeight: function(index) {
        return this.rowEdges[index];
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {fin-canvas} my [fin-canvas](https://github.com/stevewirts/fin-canvas)
     */
    getCanvas: function() {
        return this.getGrid().getCanvas();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} User is currently dragging a column for reordering.
     */
    isDraggingColumn: function() {
        return this.getGrid().isDraggingColumn();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page up.
     */
    getPageUpRow: function() {
        var behavior = this.getBehavior();
        var scrollHeight = this.getVisibleScrollHeight();
        var headerRows = this.getGrid().getFixedRowCount();
        var top = this.dataWindow.origin.y - headerRows;
        var scanHeight = 0;
        while (scanHeight < scrollHeight && top > -1) {
            scanHeight = scanHeight + behavior.getRowHeight(top);
            top--;
        }
        return top + 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page down.
     */
    getPageDownRow: function() {
        var headerRows = this.getGrid().getFixedRowCount();
        var rowNum = this.dataWindow.corner.y - headerRows - 1;
        return rowNum;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.getGrid().getColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of rows.
     */
    getRowCount: function() {
        return this.getGrid().getRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.getGrid().getFixedColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.getGrid().getFixedRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of header rows.
     */
    getHeaderRowCount: function() {
        return this.getGrid().getHeaderRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of header columns.
     */
    getHeaderColumnCount: function() {
        return this.getGrid().getHeaderColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @desc Dumb render the fixed columns along the left side.
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    _paintCells: function(gc) {
        var x, y, c, r = 0;

        var columnEdges = this.getColumnEdges();
        var rowEdges = this.rowEdges;
        this.buttonCells = {};
        var visibleCols = this.getVisibleColumns();
        var visibleRows = this.getVisibleRows();

        var width = columnEdges[columnEdges.length - 1];
        var height = rowEdges[rowEdges.length - 1];

        gc.moveTo(0, 0);
        gc.rect(0, 0, width, height);
        gc.stroke();
        gc.clip();

        var loopLength = visibleCols.length;
        var loopStart = 0;

        if (this.getGrid().isShowRowNumbers()) {
            //loopLength++;
            loopStart--;
        }

        for (x = loopStart; x < loopLength; x++) {
            c = visibleCols[x];
            this.renderedColumnMinWidths[c] = 0;
            for (y = 0; y < visibleRows.length; y++) {
                r = visibleRows[y];
                this._paintCell(gc, c, r);
            }
        }

        setNumberColumnWidth(gc, this.getBehavior(), this.getGrid().getRowCount());
    },

    /**
     * @memberOf Renderer.prototype
     * @desc We opted to not paint borders for each cell as that was extremely expensive. Instead we draw gridlines here. Also we record the widths and heights for later.
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    paintGridlines: function(gc) {
        var x, y, c, r = 0;

        var colWidths = this.getColumnEdges();
        var rowHeights = this.rowEdges;

        var viewWidth = colWidths[colWidths.length - 1];
        var viewHeight = rowHeights[rowHeights.length - 1];

        var drawThemH = this.resolveProperty('gridLinesH');
        var drawThemV = this.resolveProperty('gridLinesV');
        var lineColor = this.resolveProperty('lineColor');

        gc.beginPath();
        gc.strokeStyle = lineColor;
        gc.lineWidth = this.resolveProperty('lineWidth');
        gc.moveTo(0, 0);

        if (drawThemV) {
            for (c = 0; c < colWidths.length + 1; c++) {
                x = colWidths[c] + 0.5;
                gc.moveTo(x, 0);
                gc.lineTo(x, viewHeight);
            }
        }

        if (drawThemH) {
            for (r = 0; r < rowHeights.length; r++) {
                y = rowHeights[r] + 0.5;
                gc.moveTo(0, y);
                gc.lineTo(viewWidth, y);
            }
        }
        gc.stroke();
        gc.closePath();
    },

    /**
     * @memberOf Renderer.prototype
     * @param {CanvasRenderingContext2D} gc
     * @param x
     * @param y
     */
    paintCell: function(gc, x, y) {
        gc.moveTo(0, 0);

        var c = this.getVisibleColumns()[x],
            r = this.getVisibleRows()[y];

        if (c) { //something is being viewed at at the moment (otherwise returns undefined)
            this._paintCell(gc, c, r);
        }
    },

    _paintCell: function(gc, c, r) {

        var grid = this.getGrid();
        var behavior = this.getBehavior();
        var baseProperties = behavior.getColumnProperties(c);

        if (baseProperties.isNull) {
            return;
        }

        var columnProperties = baseProperties;
        var headerRowCount = behavior.getHeaderRowCount();
        //var headerColumnCount = behavior.getHeaderColumnCount();

        var isShowRowNumbers = grid.isShowRowNumbers();
        var isHeaderRow = r < headerRowCount;
        //var isHeaderColumn = c < headerColumnCount;
        var isFilterRow = grid.isFilterRow(r);
        var isHierarchyColumn = grid.isHierarchyColumn(c);
        var isRowSelected = grid.isRowSelected(r);
        var isColumnSelected = grid.isColumnSelected(c);
        var isCellSelected = grid.isCellSelected(c, r);
        var isCellSelectedInColumn = grid.isCellSelectedInColumn(c);
        var isCellSelectedInRow = grid.isCellSelectedInRow(r);
        var areAllRowsSelected = grid.areAllRowsSelected();

        var cellProperties;

        if ((isShowRowNumbers && c === -1) || isHierarchyColumn) {
            if (isRowSelected) {
                baseProperties = baseProperties.rowHeaderRowSelection;
                cellProperties = Object.create(baseProperties);
                cellProperties.isSelected = true;
            } else {
                baseProperties = baseProperties.rowHeader;
                cellProperties = Object.create(baseProperties);
                cellProperties.isSelected = isCellSelectedInRow;
            }
            cellProperties.isUserDataArea = false;
        } else if (isHeaderRow) {
            if (isFilterRow) {
                baseProperties = baseProperties.filterProperties;
                cellProperties = Object.create(baseProperties);
                cellProperties.isSelected = false;
            } else if (isColumnSelected) {
                baseProperties = baseProperties.columnHeaderColumnSelection;
                cellProperties = Object.create(baseProperties);
                cellProperties.isSelected = true;
            } else {
                baseProperties = baseProperties.columnHeader;
                cellProperties = Object.create(baseProperties);
                cellProperties.isSelected = isCellSelectedInColumn;
            }
            cellProperties.isUserDataArea = false;
        } else if (isHierarchyColumn) {
            baseProperties = baseProperties.rowHeader;
            cellProperties = Object.create(baseProperties);
            cellProperties.isSelected = isCellSelectedInRow;
        } else {
            cellProperties = Object.create(baseProperties);
            cellProperties.isSelected = isCellSelected || isRowSelected || isColumnSelected;
            cellProperties.isUserDataArea = true;
        }

        var rowNum = r - headerRowCount + 1;

        if (c === -1) {
            var checkedImage = isRowSelected ? 'checked' : 'unchecked';
            cellProperties.value = isHeaderRow ? '' : [behavior.getImage(checkedImage), rowNum, null];
            if (r === 0) {
                checkedImage = areAllRowsSelected ? 'checked' : 'unchecked';
                cellProperties.value = [behavior.getImage(checkedImage), '', null];
            } else if (isFilterRow) {
                cellProperties.value = [behavior.getImage('filter-off'), '', null];
            }
            cellProperties.halign = 'right';
        } else {
            cellProperties.value = grid.getValue(c, r);
            cellProperties.halign = grid.getColumnAlignment(c);
        }
        cellProperties.isColumnHovered = this.isRowHovered(c, r);
        cellProperties.isRowHovered = this.isColumnHovered(c, r);
        cellProperties.bounds = this._getBoundsOfCell(c, r);
        cellProperties.isCellSelected = isCellSelected;
        cellProperties.isRowSelected = isRowSelected;
        cellProperties.isColumnSelected = isColumnSelected;
        cellProperties.isInCurrentSelectionRectangle = grid.isInCurrentSelectionRectangle(c, r);

        var mouseDownState = grid.mouseDownState;
        if (mouseDownState) {
            var point = mouseDownState.gridCell;
            cellProperties.mouseDown = point.x === c && point.y === r;
        }

        cellProperties.x = c;
        cellProperties.y = r;

        behavior.cellPropertiesPrePaintNotification(cellProperties);

        var cell = behavior.getCellRenderer(cellProperties, c, r);
        var overrides = behavior.getCellProperties(c, r);

        //declarative cell properties
        _(cellProperties).extendOwn(overrides);

        //allow the renderer to identify itself if it's a button
        cellProperties.buttonCells = this.buttonCells;

        cell.paint(gc, cellProperties);

        this.renderedColumnMinWidths[c] = Math.max(cellProperties.minWidth || 0, this.renderedColumnMinWidths[c]);
        columnProperties.preferredWidth = this.renderedColumnMinWidths[c];
    },

    isViewableButton: function(c, r) {
        var key = c + ',' + r;
        return this.buttonCells[key] === true;
    },

    getRowNumbersWidth: function() {
        var colEdges = this.getColumnEdges();
        if (colEdges.length === 0) {
            return 0;
        }
        return colEdges[0];
    },

    startAnimator: function() {
        var animate;
        var self = this;
        animate = function() {
            self.animate();
            requestAnimationFrame(animate);
        };
        requestAnimationFrame(animate);
    },

    animate: function() {
        var ctx = this.getCanvas().canvasCTX;
        ctx.beginPath();
        ctx.save();
        this.renderFocusCell(ctx);
        ctx.restore();
        ctx.closePath();
    },

    getBounds: function() {
        return this.bounds;
    },

    setBounds: function(bounds) {
        return (this.bounds = bounds);
    }

});

function setNumberColumnWidth(gc, behavior, maxRow) {
    var columnProperties = behavior.getColumnProperties(-1),
        cellProperties = columnProperties.rowHeader,
        icon = behavior.getImage('checked');

    gc.font = cellProperties.font;

    columnProperties.preferredWidth = icon.width + 7 + cellProperties.getTextWidth(gc, maxRow + 1);
}

module.exports = Renderer;

},{"extend-me":3,"object-iterators":28}],35:[function(require,module,exports){
'use strict';

var RangeSelectionModel = require('sparse-boolean-array');

/**
 *
 * @constructor
 * @desc We represent selections as a list of rectangles because large areas can be represented and tested against quickly with a minimal amount of memory usage. Also we need to maintain the selection rectangles flattened counter parts so we can test for single dimension contains. This is how we know to highlight the fixed regions on the edges of the grid.
 */

function SelectionModel() {

    /**
     * @name selections
     * @type {Rectangle[]}
     * @summary The selection rectangles.
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.selections = [];

    /**
     * @name flattenedX
     * @type {Rectangle[]}
     * @summary The selection rectangles flattened in the horizontal direction (no width).
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.flattenedX = [];

    /**
     * @name flattenedY
     * @type {Rectangle[]}
     * @summary The selection rectangles flattened in the vertical direction (no height).
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.flattenedY = [];

    /**
     * @name rowSelectionModel
     * @type {RangeSelectionModel}
     * @summary The selection rectangles.
     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.rowSelectionModel = new RangeSelectionModel();

    /**
     * @name columnSelectionModel
     * @type {RangeSelectionModel}
     * @summary The selection rectangles.
     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.columnSelectionModel = new RangeSelectionModel();

    this.setLastSelectionType('');
}

SelectionModel.prototype = {

    /**
     * @type {boolean}
     * @memberOf SelectionModel.prototype
     */
    allRowsSelected: false,

    /**
     * @memberOf SelectionModel.prototype
     * @desc getter for the [fin-hypergrid](module-._fin-hypergrid.html)
     * #### returns: fin-hypergrid
     */
    getGrid: function() {
        return null;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelection: function() {
        var sels = this.selections;
        var sel = sels[sels.length - 1];
        return sel;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelectionType: function() {
        return this.lastSelectionType;
    },

    /**
     * @param type
     * @memberOf SelectionModel.prototype
     */
    setLastSelectionType: function(type) {
        this.lastSelectionType = type;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @description Select the region described by the given coordinates.
     *
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     */
    select: function(ox, oy, ex, ey) {
        var newSelection = this.getGrid().newRectangle(ox, oy, ex, ey);
        this.selections.push(newSelection);
        this.flattenedX.push(newSelection.flattenXAt(0));
        this.flattenedY.push(newSelection.flattenYAt(0));
        this.setLastSelectionType('cell');
        this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     */
    toggleSelect: function(ox, oy, ex, ey) {

        var selected, index;

        selected = this.selections.find(function(selection, idx) {
            index = idx;
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });

        if (selected) {
            this.selections.splice(index, 1);
            this.flattenedX.splice(index, 1);
            this.flattenedY.splice(index, 1);
            this.getGrid().selectionChanged();
        } else {
            this.select(ox, oy, ex, ey);
        }
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc Remove the last selection that was created.
     */
    clearMostRecentSelection: function() {
        this.allRowsSelected = false;
        this.selections.length = Math.max(0, this.selections.length - 1);
        this.flattenedX.length = Math.max(0, this.flattenedX.length - 1);
        this.flattenedY.length = Math.max(0, this.flattenedY.length - 1);
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentColumnSelection: function() {
        this.columnSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentRowSelection: function() {
        this.rowSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearRowSelection: function() {
        this.rowSelectionModel.clear();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelections: function() {
        return this.selections;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean} There are active selection(s).
     */
    hasSelections: function() {
        return this.selections.length !== 0;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasRowSelections: function() {
        return !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasColumnSelections: function() {
        return !this.columnSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @return {boolean} Selection covers a specific column.
     * @param {number} y
     */
    isCellSelectedInRow: function(y) {
        return this._isCellSelected(this.flattenedX, 0, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns Selection covers a specific row.
     * @param {number} x
     */
    isCellSelectedInColumn: function(x) {
        return this._isCellSelected(this.flattenedY, x, 0);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @summary Selection query function.
     * @returns {boolean} The given cell is selected (part of an active selection).
     * @param {Rectangle[]} selections - Selection rectangles to search through.
     * @param {number} x
     * @param {number} y
     */
    isSelected: function(x, y) {
        return (
            this.isColumnSelected(x) ||
            this.isRowSelected(y) ||
            this._isCellSelected(this.selections, x, y)
        );
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isCellSelected: function(x, y) {
        return this._isCellSelected(this.selections, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param selections
     * @param x
     * @param y
     * @returns {boolean}
     * @private
     */
    _isCellSelected: function(selections, x, y) {
        var self = this;
        return !!selections.find(function(selection) {
            return self.rectangleContains(selection, x, y);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc empty out all our state
     *
     */
    clear: function() {
        this.allRowsSelected = false;
        this.selections.length = 0;
        this.flattenedX.length = 0;
        this.flattenedY.length = 0;
        this.rowSelectionModel.clear();
        this.columnSelectionModel.clear();
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     * @returns {boolean}
     */
    isRectangleSelected: function(ox, oy, ex, ey) {
        return !!this.selections.find(function(selection) {
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @returns {*}
     */
    isColumnSelected: function(x) {
        return this.columnSelectionModel.isSelected(x);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y
     * @returns {boolean|*}
     */
    isRowSelected: function(y) {
        return this.allRowsSelected || this.rowSelectionModel.isSelected(y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    selectColumn: function(x1, x2) {
        this.columnSelectionModel.select(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    selectAllRows: function() {
        this.clear();
        this.allRowsSelected = true;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    areAllRowsSelected: function() {
        return this.allRowsSelected;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    selectRow: function(y1, y2) {
        this.rowSelectionModel.select(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    deselectColumn: function(x1, x2) {
        this.columnSelectionModel.deselect(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    deselectRow: function(y1, y2) {
        this.rowSelectionModel.deselect(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelectedRows: function() {
        if (this.areAllRowsSelected()) {
            var grid = this.getGrid();
            var headerRows = grid.getHeaderRowCount();
            var rowCount = grid.getRowCount() - headerRows;
            var result = new Array(rowCount);
            for (var i = 0; i < rowCount; i++) {
                result[i] = i + headerRows;
            }
            return result;
        }
        return this.rowSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*|Array.Array.number}
     */
    getSelectedColumns: function() {
        return this.columnSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
     isColumnOrRowSelected: function() {
        return !this.columnSelectionModel.isEmpty() || !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {Array}
     */
    getFlattenedYs: function() {
        var result = [];
        var set = {};
        this.selections.forEach(function(selection) {
            var top = selection.origin.y;
            var size = selection.extent.y + 1;
            for (var r = 0; r < size; r++) {
                var ti = r + top;
                if (!set[ti]) {
                    result.push(ti);
                    set[ti] = true;
                }
            }
        });
        result.sort(function(x, y) {
            return x - y;
        });
        return result;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectRowsFromCells: function(offset) {
        offset = offset || 0;

        var sm = this.rowSelectionModel;
        this.allRowsSelected = false;
        sm.clear();

        this.selections.forEach(function(selection) {
            var top = selection.origin.y,
                size = selection.extent.y;
            sm.select(top + offset, top + size + offset);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectColumnsFromCells: function(offset) {
        offset = offset || 0;

        var sm = this.columnSelectionModel;
        sm.clear();

        this.selections.forEach(function(selection) {
            var left = selection.origin.x;
            var size = selection.extent.x;
            sm.select(left + offset, left + size + offset);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isInCurrentSelectionRectangle: function(x, y) {
        var last = this.selections[this.selections.length - 1];
        return last && this.rectangleContains(last, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param rect
     * @param x
     * @param y
     * @returns {boolean}
     */
    rectangleContains: function(rect, x, y) { //TODO: explore why this works and contains on rectanglular does not
        var minX = rect.origin.x;
        var minY = rect.origin.y;
        var maxX = minX + rect.extent.x;
        var maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        var result =
            x >= minX &&
            y >= minY &&
            x <= maxX &&
            y <= maxY;

        return result;
    }
};

module.exports = SelectionModel;

},{"sparse-boolean-array":30}],36:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');
var Base = require('extend-me').Base;

var Column = require('./Column');
var images = require('./images');
var CellProvider = require('../CellProvider');

var noExportProperties = [
    'columnHeader',
    'columnHeaderColumnSelection',
    'filterProperties',
    'rowHeader',
    'rowHeaderRowSelection',
    'rowNumbersProperties',
    'treeColumnProperties',
    'treeColumnPropertiesColumnSelection',
];

/**
 * @constructor
 * @desc This is the base class for creating behaviors.  a behavior can be thought of as a model++.
it contains all code/data that's necessary for easily implementing a virtual data source and it's manipulation/analytics
 */
var Behavior = Base.extend('Behavior', {

    /**
     * @desc this is the callback for the plugin pattern of nested tags
     * @param {Hypergrid} grid
     * @memberOf Behavior.prototype
     */
    initialize: function(grid) { //formerly installOn
        grid.setBehavior(this);
        this.initializeFeatureChain(grid);

        this.getDataModel();
        this.cellProvider = this.createCellProvider();
        this.renderedColumnCount = 30;
        this.renderedRowCount = 60;
        this.dataUpdates = {}; //for overriding with edit values;
    },

    /**
     * @desc create the feature chain - this is the [chain of responsibility](http://c2.com/cgi/wiki?ChainOfResponsibilityPattern) pattern.
     * @param {Hypergrid} grid
     * @memberOf Behavior.prototype
     */
    initializeFeatureChain: function(grid) {
        var self = this;
        this.features.forEach(function(FeatureConstructor) {
            self.setNextFeature(new FeatureConstructor);
        });

        this.featureChain.initializeOn(grid);
    },

    features: [], // in case implementing class has no features TODO: Will this ever happen?

    /**
     * memento for the user configured visual properties of the table
     * @type {object}
     * @memberOf Behavior.prototype
     */
    tableState: null,

    /**
     * @type {Hypergrid}
     * @memberOf Behavior.prototype
     */
    grid: null,

    /**
     * list of default cell editor names
     * @type {string[]}
     * @memberOf Behavior.prototype
     */
    editorTypes: ['choice', 'textfield', 'color', 'slider', 'spinner', 'date'],

    /**
     * controller chain of command
     * @type {object}
     * @memberOf Behavior.prototype
     */
    featureChain: null,

    dataModel: null,
    baseModel: null,

    scrollPositionX: 0,
    scrollPositionY: 0,

    featureMap: {},
    allColumns: [],
    columns: [],

    reset: function() {

        this.cellProvider = this.createCellProvider();
        this.renderedColumnCount = 30;
        this.renderedRowCount = 60;
        this.dataUpdates = {}; //for overriding with edit values;
        this.clearColumns();
        this.clearState();
        this.getDataModel().reset();
        this.createColumns();
    },

    clearColumns: function() {
        this.columns = [];
        this.allColumns = [];
        this.columns[-1] = this.newColumn(-1, '');
        this.columns[-2] = this.newColumn(-2, 'Tree');
        this.allColumns[-1] = this.columns[-1];
        this.allColumns[-2] = this.columns[-2];
    },

    getColumn: function(x) {
        return this.columns[x];
    },

    getColumnId: function(x) {
        return this.getColumn(x).label;
    },

    newColumn: function(index, label) {
        var properties = this.createColumnProperties();
        this.getPrivateState().columnProperties[index] = properties;
        return new Column(this, index, label);
    },

    addColumn: function(index, label) {
        var column = this.newColumn(index, label);
        this.columns.push(column);
        this.allColumns.push(column);
        return column;
    },

    createColumns: function() {
        //concrete implementation here
    },

    createColumnProperties: function() {
        var tableState = this.getPrivateState();
        var properties = Object.create(tableState);

        properties.rowNumbersProperties = Object.create(properties, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.rowHeader = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.rowHeaderFont;
                },
                set: function(value) {
                    this.rowHeaderFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.rowHeaderColor;
                },
                set: function(value) {
                    this.rowHeaderColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.columnHeader = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.columnHeaderFont;
                },
                set: function(value) {
                    this.columnHeaderFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.columnHeaderColor;
                },
                set: function(value) {
                    this.columnHeaderColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.columnHeaderColumnSelection = Object.create(properties.columnHeader, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundColumnSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundColumnSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundColumnSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundColumnSelectionColor = value;
                }
            }
        });

        properties.rowHeaderRowSelection = Object.create(properties.rowHeader, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundRowSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderForegroundRowSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundRowSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundRowSelectionColor = value;
                }
            }
        });

        properties.filterProperties = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.filterFont;
                },
                set: function(value) {
                    this.filterFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.filterColor;
                },
                set: function(value) {
                    this.filterColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.filterBackgroundColor;
                },
                set: function(value) {
                    this.filterBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.filterForegroundSelectionColor;
                },
                set: function(value) {
                    this.filterForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.filterBackgroundSelectionColor;
                },
                set: function(value) {
                    this.filterBackgroundSelectionColor = value;
                }
            },
            cellBorderStyle: {
                configurable: true,
                get: function() {
                    return this.filterCellBorderStyle;
                },
                set: function(value) {
                    this.filterCellBorderStyle = value;
                }
            },
            cellBorderThickness: {
                configurable: true,
                get: function() {
                    return this.filterCellBorderThickness;
                },
                set: function(value) {
                    this.filterCellBorderThickness = value;
                }
            }
        });

        properties.treeColumnProperties = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.treeColumnFont;
                },
                set: function(value) {
                    this.treeColumnFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.treeColumnColor;
                },
                set: function(value) {
                    this.treeColumnColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnForegroundSelectionColor;
                },
                set: function(value) {
                    this.treeColumnForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundSelectionColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundSelectionColor = value;
                }
            }
        });

        properties.treeColumnPropertiesColumnSelection = Object.create(properties.treeColumnProperties, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnForegroundColumnSelectionColor;
                },
                set: function(value) {
                    this.treeColumnForegroundColumnSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundColumnSelectionColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundColumnSelectionColor = value;
                }
            }
        });

        return properties;
    },

    getColumnWidth: function(x) {
        var col = this.getColumn(x);
        if (!col) {
            return this.resolveProperty('defaultColumnWidth');
        }
        var width = col.getWidth();
        return width;
    },

    setColumnWidth: function(x, width) {
        this.getColumn(x).setWidth(width);
        this.stateChanged();
    },

    getDataModel: function() {
        if (this.dataModel === null) {
            var dataModel = this.getDefaultDataModel();
            this.setDataModel(dataModel);
        }
        return this.dataModel;
    },

    getCellRenderer: function(config, x, y) {
        return this.getColumn(x).getCellRenderer(config, y);
    },

    setDataModel: function(newDataModel) {
        this.dataModel = newDataModel;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc utility function to empty an object of its members
     * @param {object} obj - the object to empty
     * @param {boolean} [exportProps]
     * * `undefined` (omitted) - delete *all* properties
     * * **falsy** - delete *only* the export properties
     * * **truthy** - delete all properties *except* the export properties
     */
    clearObjectProperties: function(obj, exportProps) {
        for (var key in obj) {
            if (
                obj.hasOwnProperty(key) && (
                    exportProps === undefined ||
                    !exportProps && noExportProperties.indexOf(key) >= 0 ||
                    exportProps && noExportProperties.indexOf(key) < 0
                )
            ) {
                delete obj[key];
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc getter for a [Memento](http://c2.com/cgi/wiki?MementoPattern) Object
     * @returns {object}
     */
    getPrivateState: function() {
        if (!this.tableState) {
            this.tableState = this.getDefaultState();
        }
        return this.tableState;
    },

    //this is effectively a clone, with certain things removed....
    getState: function() {
        var copy = JSON.parse(JSON.stringify(this.getPrivateState()));
        this.clearObjectProperties(copy.columnProperties, true);
        return copy;
    },
    /**
     * @memberOf Behavior.prototype
     * @desc clear all table state
     */
    clearState: function() {
        this.tableState = null;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {object} Newly created default empty tablestate.
     */
    getDefaultState: function() {
        var tableProperties = this.getGrid()._getProperties();
        var state = Object.create(tableProperties);

        _(state).extendOwn({
            rowHeights: {},
            cellProperties: {},
            columnProperties: []
        });

        return state;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Restore this table to a previous state.
     * See the [memento pattern](http://c2.com/cgi/wiki?MementoPattern).
     * @param {Object} memento - an encapsulated representation of table state
     */
    setState: function(memento) {

        //we don't want to clobber the column properties completely
        if (!memento.columnIndexes) {
            var fields = this.getFields();
            memento.columnIndexes = [];
            for (var i = 0; i < fields.length; i++) {
                memento.columnIndexes[i] = i;
            }
        }
        var colProperties = memento.columnProperties;
        delete memento.columnProperties;
        this.tableState = null;
        var state = this.getPrivateState();
        this.createColumns();
        this.setColumnOrder(memento.columnIndexes);
        _(state).extendOwn(memento);
        this.setAllColumnProperties(colProperties);
        memento.columnProperties = colProperties;
        //memento.columnProperties = colProperties;

        // this.getDataModel().setState(memento);
        // var self = this;
        // requestAnimationFrame(function() {
        //     self.applySorts();
        //     self.changed();
        //     self.stateChanged();
        // });

        //just to be close/ it's easier on the eyes
        this.setColumnWidth(-1, 24.193359375);
        this.getDataModel().applyState();
    },

    setAllColumnProperties: function(properties) {
        properties = properties || [];
        for (var i = 0; i < properties.length; i++) {
            var current = this.getPrivateState().columnProperties[i];
            this.clearObjectProperties(current, false);
            _(current).extendOwn(properties[i]);
        }
    },

    setColumnOrder: function(indexes) {
        if (!indexes) {
            this.columns.length = 0;
            return;
        }
        this.columns.length = indexes.length;
        for (var i = 0; i < indexes.length; i++) {
            this.columns[i] = this.allColumns[indexes[i]];
        }
    },

    applySorts: function() {
        //if I have sorts, apply them now//
    },

    /**
     * @memberOf Behavior.prototype
     * @desc fetch the value for a property key
     * @returns {*} The value of the given property.
     * @param {string} key - a property name
     */
    resolveProperty: function(key) {
        return this.grid.resolveProperty(key);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc A specific cell was clicked; you've been notified.
     * @param {Point} cell - point of cell coordinates
     * @param {Object} event - all event information
     */
    cellClicked: function(cell, event) {
        this.getDataModel().cellClicked(cell, event);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc A specific cell was le double-clicked; you've been notified.
     * @param {Point} cell - point of cell coordinates
     * @param {Object} event - all event information
     */
    cellDoubleClicked: function(cell, event) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc add nextFeature to me If I don't have a next node, otherwise pass it along
     * @param {Feature}
     */
    setNextFeature: function(nextFeature) {
        this.featureMap[nextFeature.alias] = nextFeature;
        if (this.featureChain) {
            this.featureChain.setNext(nextFeature);
        } else {
            this.featureChain = nextFeature;
        }
    },

    lookupFeature: function(key) {
        return this.featureMap[key];
    },

    /**
     * @memberOf Behavior.prototype
     * @desc getter for the cell provider
     * @return {CellProvider}
     */
    getCellProvider: function() {
        return this.cellProvider;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc setter for the hypergrid
     * @param {Hypergrid} grid
     */
    setGrid: function(finGrid) {
        this.grid = finGrid;
        this.getDataModel().setGrid(finGrid);
        this.clearColumns();
    },

    /**
     * @memberOf Behavior.prototype
     * @returns: {Hypergrid} The hypergrid to which this behavior is attached.
     * @param {type} varname - descripton
     */
    getGrid: function() {
        return this.grid;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc You can override this function and substitute your own cell provider.
     * @return {CellProvider}
     */
    createCellProvider: function() {
        return new CellProvider();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc First check to see if something was overridden.
     * @return {*} The value at `x,y` for the top left section of the hypergrid.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     */
    getValue: function(x, y) {
        var column = this.getColumn(x);
        if (!column) {
            return undefined;
        }
        return column.getValue(y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @return The data.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     * @param {Object} value - the value to use
     */
    setValue: function(x, y, value) {
        var column = this.getColumn(x);
        if (!column) {
            return;
        }
        return column.setValue(y, value);
    },

    getDataValue: function(x, y) {
        return this.getDataModel().getValue(x, y);
    },

    setDataValue: function(x, y, value) {
        this.getDataModel().setValue(x, y, value);
    },
    /**
     * @memberOf Behavior.prototype
     * @desc First checks to see if something was overridden.
     * @return {*} The value at x,y for the top left section of the hypergrid.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     */
    getCellProperties: function(x, y) {
        var col = this.getColumn(x);
        return col.getCellProperties(y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     * @param {Object} value - the value to use
     */
    setCellProperties: function(x, y, value) {
        var col = this.getColumn(x);
        if (col) {
            col.setCellProperties(y, value);
        }
    },
    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of rows in the hypergrid.
     */
    getRowCount: function() {
        return this.getDataModel().getRowCount();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The height in pixels of the fixed rows area  of the hypergrid.
     */
    getFixedRowsHeight: function() {
        var count = this.getFixedRowCount();
        var total = 0;
        for (var i = 0; i < count; i++) {
            total = total + this.getRowHeight(i);
        }
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The height in pixels of a specific row in the hypergrid.
     * @param {number} rowNum - row index of interest
     */
    getRowHeight: function(rowNum) {
        var tableState = this.getPrivateState();
        if (tableState.rowHeights) {
            var override = tableState.rowHeights[rowNum];
            if (override) {
                return override;
            }
        }
        return this.getDefaultRowHeight();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The value is lazily initialized and comes from the properties mechanism for '`defaultRowHeight`', which should be ~20px.
     * @returns {number} The row height in pixels.
     */
    getDefaultRowHeight: function() {
        if (!this.defaultRowHeight) {
            this.defaultRowHeight = this.resolveProperty('defaultRowHeight');
        }
        return this.defaultRowHeight;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the pixel height of a specific row
     * @param {number} rowNum - the row index of interest
     * @param {number} height - pixel height
     */
    setRowHeight: function(rowNum, height) {
        var tableState = this.getPrivateState();
        tableState.rowHeights[rowNum] = Math.max(5, height);
        this.stateChanged();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc This will allow 'floating' fixed rows.
     * @return {number} The maximum height of the fixed rows area in the hypergrid.
     */
    getFixedRowsMaxHeight: function() {
        return this.getFixedRowsHeight();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The width of the fixed column area in the hypergrid.
     */
    getFixedColumnsWidth: function() {
        var count = this.getFixedColumnCount();
        var total = 0;
        if (this.getGrid().isShowRowNumbers()) {
            total = this.getColumnWidth(-1);
        }
        for (var i = 0; i < count; i++) {
            total = total + this.getColumnWidth(i);
        }
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc This exists to support "floating" columns.
     * @return {number} The total width of the fixed columns area.
     */
    getFixedColumnsMaxWidth: function() {
        var width = this.getFixedColumnsWidth();
        return width;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the scroll position in vertical dimension and notify listeners.
     * @param {number} y - the new y value
     */
    _setScrollPositionY: function(y) {
        this.setScrollPositionY(y);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the scroll position in horizontal dimension and notify listeners.
     * @param {number} x - the new x value
     */
    _setScrollPositionX: function(x) {
        this.setScrollPositionX(x);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of columns just rendered, including partially rendered columns.
     * @param {number} count - how many columns were just rendered
     */
    setRenderedColumnCount: function(count) {
        this.renderedColumnCount = count;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of rows just rendered, including partially rendered rows.
     * @param {number} count - how many rows were just rendered
     */
    setRenderedRowCount: function(count) {
        this.renderedRowCount = count;
    },


    /**
     * @memberOf Behavior.prototype
     * @desc The fixed row area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedRowClicked: function(grid, mouse) {
        var x = this.translateColumnIndex(this.getScrollPositionX() + mouse.gridCell.x - this.getFixedColumnCount());
        var translatedPoint = this.grid.newPoint(x, mouse.gridCell.y);
        mouse.gridCell = translatedPoint;
        this.fixedRowClicked(grid, mouse);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The fixed column area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedColumnClicked: function(grid, mouse) {
        var translatedPoint = this.grid.newPoint(mouse.gridCell.x, this.getScrollPositionY() + mouse.gridCell.y - this.getFixedRowCount());
        mouse.gridCell = translatedPoint;
        this.fixedColumnClicked(grid, mouse);
    },

    moveSingleSelect: function(grid, x, y) {
        if (this.featureChain) {
            this.featureChain.moveSingleSelect(grid, x, y);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate setting the cursor up the feature chain of responsibility
     * @param {Hypergrid} grid
     */
    setCursor: function(grid) {
        grid.updateCursor();
        this.featureChain.setCursor(grid);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse move to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseMove: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseMove(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onTap: function(grid, event) {

        if (this.featureChain) {
            this.featureChain.handleTap(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onContextMenu: function(grid, event) {
        var proceed = grid.fireSyntheticContextMenuEvent(event);
        if (proceed && this.featureChain) {
            this.featureChain.handleContextMenu(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling wheel moved to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onWheelMoved: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleWheelMoved(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse drag to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseDrag: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDrag(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling key down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling key up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onDoubleClick: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleDoubleClick(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling hold pulse to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onHoldPulse: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleHoldPulse(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    toggleColumnPicker: function() {
        if (this.featureChain) {
            this.featureChain.toggleColumnPicker(this.getGrid());
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse exit to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseExit(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is replaced by the grid on initialization and serves as the callback
     */
    changed: function() {},

    /**
     * @memberOf Behavior.prototype
     * @desc this function is replaced by the grid on initialization and serves as the callback
     */
    shapeChanged: function() {},

    /**
     * @memberOf Behavior.prototype
     * @return {boolean} Can re-order columns.
     */
    isColumnReorderable: function() {
        return true;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {Object} The properties for a specific column. These are used if no cell properties are specified.
     * @param {index} columnIndex - the column index of interest
     */
    getColumnProperties: function(columnIndex) {
        var col = this.columns[columnIndex];
        if (!col) {
            return {
                isNull: true
            };
        }
        var properties = col.getProperties(); //TODO: returns `null` on Hypergrid.reset();
        if (!properties) {
            return {
                isNull: true
            };
        }
        return properties;
    },
    setColumnProperties: function(columnIndex, properties) {
        var columnProperties = this.getColumnProperties(columnIndex);
        _(columnProperties).extendOwn(properties);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {strings[]} Labels to use for the column picker.
     */
    getColumnDescriptors: function() {
        //assumes there is one row....
        this.insureColumnIndexesAreInitialized();
        var tableState = this.getPrivateState();
        var columnCount = tableState.columnIndexes.length;
        var labels = [];
        for (var i = 0; i < columnCount; i++) {
            var id = tableState.columnIndexes[i];
            labels.push({
                id: id,
                label: this.getHeader(id),
                field: this.getField(id)
            });
        }
        return labels;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string} The field at `colIndex`.
     * @param {number} colIndex - the column index of interest
     */
    getField: function(colIndex) {
        if (colIndex === -1) {
            return 'tree';
        }
        var col = this.getColumn(colIndex);
        return col.getField();
    },
    /**
     * @memberOf Behavior.prototype
     * @return {string} The column heading at `colIndex'.
     * @param {number} colIndex - the column index of interest
     */
    getHeader: function(colIndex) {
        if (colIndex === -1) {
            return 'Tree';
        }
        var col = this.getColumn(colIndex);
        return col.getHeader();
    },
    /**
     * @memberOf Behavior.prototype
     * @desc this is called by the column editor post closing; rebuild the column order indexes
     * @param {Array} list - list of column objects from the column editor
     */
    setColumnDescriptors: function(lists) {
        //assumes there is one row....
        var visible = lists.visible;
        var tableState = this.getPrivateState();

        var columnCount = visible.length;
        var indexes = [];
        var i;
        for (i = 0; i < columnCount; i++) {
            indexes.push(visible[i].id);
        }
        tableState.columnIndexes = indexes;
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string[]} All the currently hidden column header labels.
     */
    getHiddenColumnDescriptors: function() {
        var tableState = this.getPrivateState();
        var indexes = tableState.columnIndexes;
        var labels = [];
        var columnCount = this.getColumnCount();
        for (var i = 0; i < columnCount; i++) {
            if (indexes.indexOf(i) === -1) {
                labels.push({
                    id: i,
                    label: this.getHeader(i),
                    field: this.getField(i)
                });
            }
        }
        return labels;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc hide columns that are specified by their indexes
     * @param {Array} arrayOfIndexes - an array of column indexes to hide
     */
    hideColumns: function(arrayOfIndexes) {
        var tableState = this.getPrivateState();
        var order = tableState.columnIndexes;
        for (var i = 0; i < arrayOfIndexes.length; i++) {
            var each = arrayOfIndexes[i];
            if (order.indexOf(each) !== -1) {
                order.splice(order.indexOf(each), 1);
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @return {integer} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        var tableState = this.getPrivateState();
        return tableState.fixedColumnCount || 0;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the number of fixed columns
     * @param {number} numberOfFixedColumns - the integer count of how many columns to be fixed
     */
    setFixedColumnCount: function(numberOfFixedColumns) {
        var tableState = this.getPrivateState();
        tableState.fixedColumnCount = numberOfFixedColumns;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {integer} The number of fixed rows.
     */
    getFixedRowCount: function() {
        if (!this.tableState) {
            return 0;
        }
        var usersSize = this.tableState.fixedRowCount || 0;
        var headers = this.getGrid().getHeaderRowCount();
        var total = usersSize + headers;
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the number of rows that are fixed
     * @param {number} numberOfFixedRows - the count of rows to be set fixed
     */
    setFixedRowCount: function(numberOfFixedRows) {
        this.tableState.fixedRowCount = numberOfFixedRows;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of fixed rows.
     */
    getHeaderRowCount: function() {
        var grid = this.getGrid();
        var header = grid.isShowHeaderRow() ? 1 : 0;
        var filter = grid.isShowFilterRow() ? 1 : 0;
        var totals = this.getTopTotals().length;
        var count = header + filter + totals;
        return count;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the number of rows that are fixed
     * @param {number} numberOfFixedRows - the count of rows to be set fixed
     */
    setHeaderRowCount: function(numberOfHeaderRows) {
        this.tableState.headerRowCount = numberOfHeaderRows;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of fixed rows.
     */
    getHeaderColumnCount: function() {
        var grid = this.getGrid();
        var count = grid.resolveProperty('headerColumnCount');
        return count;
    },

    /**
     * @memberOf Behavior.prototype
     * @param {number} The number of fixed rows.
     */
    setHeaderColumnCount: function(numberOfHeaderColumns) {
        this.tableState.headerColumnCount = numberOfHeaderColumns;
    },
    /**
     * @memberOf Behavior.prototype
     * @desc build and open the editor within the container div argument
     * @return {boolean} `false` prevents editor from opening
     * @param {HTMLDivElement} div - the containing div element
     */
    openEditor: function(div) {
        var container = document.createElement('div');

        var hidden = document.createElement('fin-hypergrid-dnd-list');
        var visible = document.createElement('fin-hypergrid-dnd-list');

        container.appendChild(hidden);
        container.appendChild(visible);

        this.beColumnStyle(hidden.style);
        hidden.title = 'hidden columns';
        hidden.list = this.getHiddenColumnDescriptors();

        this.beColumnStyle(visible.style);
        visible.style.left = '50%';
        visible.title = 'visible columns';
        visible.list = this.getColumnDescriptors();

        div.lists = {
            hidden: hidden.list,
            visible: visible.list
        };
        div.appendChild(container);
        return true;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc the editor is requesting close; deal with the edits
     * @return `true`
     * @param {HTMLDivElement} div - the containing div element
     */
    closeEditor: function(div) {
        var lists = div.lists;
        this.setColumnDescriptors(lists);
        return true;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc a dnd column has just been dropped, we've been notified
     */
    endDragColumnNotification: function() {},

    /**
     * @memberOf Behavior.prototype
     * @desc bind column editor appropriate css values to arg style
     * @param {HTMLStyleElement} style - the style object to enhance
     */
    beColumnStyle: function(style) {
        style.top = '5%';
        style.position = 'absolute';
        style.width = '50%';
        style.height = '100%';
        style.whiteSpace = 'nowrap';
    },

    /**
     * @memberOf Behavior.prototype
     * @return {null} the cursor at a specific x,y coordinate
     * @param {number} x - the x coordinate
     * @param {number} y - the y coordinate
     */
    getCursorAt: function(x, y) {
        return null;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The total number of columns.
     */
    getColumnCount: function() {
        return this.columns.length;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string} - The column alignment at column `x`, which is one of `'left'`, `'center'` , or `'right'`.
     * @param {number} x - the column index of interest
     */
    getColumnAlignment: function(x) {
        return 'center';
    },

    /**
     * @memberOf Behavior.prototype
     * @desc quietly set the scroll position in the horizontal dimension
     * @param {number} x - the position in pixels
     */
    setScrollPositionX: function(x) {
        this.scrollPositionX = x;
    },

    getScrollPositionX: function() {
        return this.scrollPositionX;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc quietly set the scroll position in the horizontal dimension
     * @param {number} y - the position in pixels
     */
    setScrollPositionY: function(y) {
        this.scrollPositionY = y;
    },

    getScrollPositionY: function() {
        return this.scrollPositionY;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {cellEditor} Cell editor for coordinate `x,y`.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     */
    getCellEditorAt: function(x, y) {
        return this.getColumn(x).getCellEditorAt(x, y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc fixed row has been clicked, you've been notified
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    toggleSort: function(x, keys) {
        this.getColumn(x).toggleSort(keys);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {boolean} `true` if we should highlight on hover
     * @param {boolean} isColumnHovered - the column is hovered or not
     * @param {boolean} isRowHovered - the row is hovered or not
     */
    highlightCellOnHover: function(isColumnHovered, isRowHovered) {
        return isColumnHovered && isRowHovered;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {HTMLImageElement}
     * @param {string} key - an image alias
     */
    getImage: function(key) {
        return images[key];
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the image for a specific alias
     * @param {string} key - an image alias
     * @param {HTMLImageElement} image - the image to cache
     */
    setImage: function(key, image) {
        images[key] = image;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellPropertiesPrePaintNotification: function(cellProperties) {
        var row = this.getRow(cellProperties.y);
        var columnId = this.getHeader(cellProperties.x);
        cellProperties.row = row;
        cellProperties.columnId = columnId;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a fixed row cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedRowPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a fixed column cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedColumnPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a top left cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellTopLeftPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function enhance the double click event just before it's broadcast to listeners
     * @param {Object} event - event to enhance
     */
    enhanceDoubleClickEvent: function(event) {},

    /**
     * @memberOf Behavior.prototype
     * @desc swap src and tar columns
     * @param {number} src - column index
     * @param {number} tar - column index
     */
    swapColumns: function(source, target) {
        var columns = this.columns;
        var tmp = columns[source];
        columns[source] = columns[target];
        columns[target] = tmp;
        this.changed();
    },

    getColumnEdge: function(c, renderer) {
        return this.getDataModel().getColumnEdge(c, renderer);
    },

    setTotalsValue: function(x, y, value) {
        this.getGrid().setTotalsValueNotification(x, y, value);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {object} The object at y index.
     * @param {number} y - the row index of interest
     */
    getRow: function(y) {
        return this.getDataModel().getRow(y);
    },

    convertViewPointToDataPoint: function(viewPoint) {
        var newX = this.getColumn(viewPoint.x);
        var newPoint = this.getGrid().newPoint(newX, viewPoint.y);
        return newPoint;
    },

    setGroups: function(arrayOfColumnIndexes) {
        this.getDataModel().setGroups(arrayOfColumnIndexes);
        this.createColumns();
        this.changed();
    },

    setAggregates: function(mapOfKeysToFunctions) {
        var self = this;
        this.getDataModel().setAggregates(mapOfKeysToFunctions);
        this.createColumns();
        setTimeout(function() {
            self.changed();
        }, 100);
    },

    hasHierarchyColumn: function() {
        return false;
    },

    getRowContextFunction: function(selectedRows) {
        return function() {
            return null;
        };
    },

    getSelectionMatrixFunction: function(selectedRows) {
        return function() {
            return null;
        };
    },

    getFieldName: function(index) {
        return this.getFields()[index];
    },

    getColumnIndex: function(fieldName) {
        return this.getFields().indexOf(fieldName);
    },

    getComputedRow: function(y) {
        return this.getDataModel().getComputedRow(y);
    },

    autosizeAllColumns: function() {
        this.checkColumnAutosizing(true);
        this.changed();
    },

    checkColumnAutosizing: function(force) {
        force = force === true;
        this.allColumns[-1].checkColumnAutosizing(true);
        this.allColumns[-2].checkColumnAutosizing(force);
        this.allColumns.forEach(function(column) {
            column.checkColumnAutosizing(force);
        });
    },

    autoSizeRowNumberColumn: function() {
        this.allColumns[-1].checkColumnAutosizing(true);
    },

    setGlobalFilter: function(string) {
        this.getDataModel().setGlobalFilter(string);
    },

    getSelectedRows: function() {
        return this.getGrid().getSelectionModel().getSelectedRows();
    },

    getSelectedColumns: function() {
        return this.getGrid().getSelectionModel().getSelectedColumns();
    },

    getSelections: function() {
        return this.getGrid().getSelectionModel().getSelections();
    }

});

module.exports = Behavior;

},{"../CellProvider":32,"./Column":37,"./images":41,"extend-me":3,"object-iterators":28}],37:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

function Column(behavior, index, label) {
    this.behavior = behavior;
    this.dataModel = behavior.getDataModel();
    this.index = index;
    this.label = label;
}

Column.prototype = {
    constructor: Column.prototype.constructor,

    getValue: function(y) {
        return this.dataModel.getValue(this.index, y);
    },

    setValue: function(y, value) {
        return this.dataModel.setValue(this.index, y, value);
    },

    getWidth: function() {
        var properties = this.getProperties();
        if (properties) {
            var override = properties.width;
            if (override) {
                return override;
            }
        }
        return this.behavior.resolveProperty('defaultColumnWidth');
    },

    setWidth: function(width) {
        this.getProperties().width = Math.max(5, width);
    },

    getCellRenderer: function(config, y) {
        return this.dataModel.getCellRenderer(config, this.index, y);
    },

    getCellProperties: function(y) {
        return this.behavior.getPrivateState().cellProperties[this.index + ',' + y];
    },

    setCellProperties: function(y, value) {
        this.behavior.getPrivateState().cellProperties[this.index + ',' + y] = value;
    },

    checkColumnAutosizing: function(force) {
        var properties = this.getProperties();
        var a, b, d;
        if (properties) {
            a = properties.width;
            b = properties.preferredWidth || properties.width;
            d = properties.columnAutosized && !force;
            if (a !== b || !d) {
                properties.width = !d ? b : Math.max(a, b);
                properties.columnAutosized = !isNaN(properties.width);
            }
        }
    },

    getProperties: function() {
        return this.behavior.getPrivateState().columnProperties[this.index];
    },

    setProperties: function(properties) {
        var current = this.behavior.getPrivateState().columnProperties[this.index];
        this.clearObjectProperties(current, false);
        _(current).extendOwn(properties);
    },

    toggleSort: function(keys) {
        this.dataModel.toggleSort(this.index, keys);
    },

    getCellEditorAt: function(x, y) {
        return this.behavior.getCellEditorAt(this.index, y);
    },

    getHeader: function() {
        return this.label;
    },

    getField: function() {
        return this.dataModel.getFields()[this.index];
    }
};

module.exports = Column;

},{"object-iterators":28}],38:[function(require,module,exports){
'use strict';

function DataModelDecorator(grid, component) {
    this.setComponent(component);
    this.setGrid(grid);
}

DataModelDecorator.prototype = {
    constructor: DataModelDecorator.prototype.constructor,

    component: null,
    grid: null,

    getGrid: function() {
        return this.grid;
    },

    setGrid: function(newGrid) {
        this.grid = newGrid;
        this.getComponent().setGrid(newGrid);
    },

    getBehavior: function() {
        return this.getGrid().getBehavior();
    },

    changed: function() {
        this.getBehavior().changed();
    },

    getPrivateState: function() {
        return this.getGrid().getPrivateState();
    },

    applyState: function() {

    },

    setComponent: function(newComponent) {
        this.component = newComponent;
    },

    getComponent: function() {
        return this.component;
    },

    setGlobalFilter: function(string) {
        return this.getComponent().setGlobalFilter(string);
    },

    getValue: function(x, y) {
        return this.getComponent().getValue(x, y);
    },

    setValue: function(x, y, value) {
        this.getComponent().setValue(x, y, value);
    },

    getColumnCount: function() {
        return this.getComponent().getColumnCount();
    },

    getRowCount: function() {
        return this.getComponent().getRowCount();
    },

    getCellRenderer: function(config, x, y, untranslatedX, untranslatedY) {
        return this.getComponent().getCellRenderer(config, x, y, untranslatedX, untranslatedY);
    },

    getRowHeight: function(y) {
        return this.getComponent().getRowHeight(y);
    },

    getColumnEdge: function(x, renderer) {
        return this.getComponent().getColumnEdge(x, renderer);
    },

    getColumnWidth: function(x) {
        return this.getComponent().getColumnWidth(x);
    },

    setColumnWidth: function(x, width) {
        this.getComponent().setColumnWidth(x, width);
    },

    toggleSort: function(x, keys) {
        this.getComponent().toggleSort(x, keys);
    },

    getColumnProperties: function(columnIndex) {
        return this.getComponent().getColumnProperties(columnIndex);
    },

    setColumnProperties: function(columnIndex, properties) {
        this.getComponent().setColumnProperties(columnIndex, properties);
    },

    getHeaders: function() {
        return this.getComponent().getHeaders();
    },

    getFields: function() {
        return this.getComponent().getFields();
    },

    setFields: function(fields) {
        this.getComponent().setFields(fields);
    },

    getCellProperties: function(x, y) {
        return this.getComponent().getCellProperties(x, y);
    },

    setCellProperties: function(x, y, value) {
        this.getComponent().setCellProperties(x, y, value);
    },

    getRow: function(y) {
        return this.getComponent().getRow(y);
    },

    setTopTotals: function(nestedArray) {
        this.getComponent().setTopTotals(nestedArray);
    },

    getTopTotals: function() {
        return this.getComponent().getTopTotals();
    },

    setData: function(y) {
        return this.getComponent().setData(y);
    },

    hasHierarchyColumn: function() {
        return this.getComponent().hasHierarchyColumn();
    },

    setHeaders: function(headerLabels) {
        return this.getComponent().setHeaders(headerLabels);
    },

    cellClicked: function(cell, event) {
        return this.getComponent().cellClicked(cell, event);
    },

    getAvailableGroups: function() {
        return this.getComponent().getAvailableGroups();
    },

    getGroups: function() {
        return this.getComponent().getGroups();
    },

    setGroups: function(groups) {
        this.getComponent().setGroups(groups);
    },

    getHiddenColumns: function() {
        return this.getComponent().getHiddenColumns();
    },

    getVisibleColumns: function() {
        return this.getComponent().getVisibleColumns();
    },

    setAggregates: function(aggregates) {
        return this.getComponent().setAggregates(aggregates);
    },

    reset: function() {
        this.getComponent().reset();
    },

    getCellEditorAt: function(x, y) {
        return this.getComponent().getCellEditorAt(x, y);
    }
};

module.exports = DataModelDecorator;

},{}],39:[function(require,module,exports){
'use strict';

var ListDragon = require('list-dragon');

var Behavior = require('./Behavior');
var DataModelDecorator = require('./DataModelDecorator');
var DataModelJSON = require('../dataModels/JSON');
var features = require('../features/index');
var addStylesheet = require('../stylesheets');
var aggregations = require('hyper-analytics').util.aggregations;
//var aggregations = require('../local_node_modules/newanalytics').util.aggregations;
//var aggregations = require('../local_node_modules/finanalytics').aggregations;

/**
 * @name behaviors.JSON
 * @desc > Same parameters as {@link behaviors.JSON#initialize|initialize}, which is called by this constructor.
 * @constructor
 */
var JSON = Behavior.extend('behaviors.JSON', {

    /**
     * @summary Constructor logic, called _after_{@link Behavior#initialize|Behavior.initialize()}.
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     *
     * @param grid - the hypergrid
     * @param {object[]} dataRows - array of uniform data objects
     * @memberOf behaviors.JSON.prototype
     */
    initialize: function(grid, dataRows) {
        this.setData(dataRows);
    },

    features: [
        features.CellSelection,
        features.KeyPaging,
        features.Overlay,
        features.ColumnResizing,
        features.RowResizing,
        features.Filters,
        features.RowSelection,
        features.ColumnSelection,
        features.ColumnMoving,
        features.ColumnSorting,
        features.CellEditing,
        features.CellClick,
        features.OnHover
    ],

    aggregations: aggregations,

    createColumns: function() {
        var dataModel = this.getDataModel();
        var columnCount = dataModel.getColumnCount();
        var headers = dataModel.getHeaders();
        var fields = dataModel.getFields();
        this.clearColumns();
        for (var i = 0; i < columnCount; i++) {
            var header = headers[i];
            var column = this.addColumn(i, header);
            var properties = column.getProperties();
            properties.field = fields[i];
            properties.header = header;
        }
    },

    getDefaultDataModel: function() {
        var model = new DataModelJSON();
        var wrapper = new DataModelDecorator(this.getGrid(), model);
        wrapper.setComponent(model);
        return wrapper;
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the header labels.
     * @param {string[]} headerLabels - The header labels.
     */
    setHeaders: function(headerLabels) {
        this.getDataModel().setHeaders(headerLabels);
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @desc * @returns {string[]} The header labels.
     */
    getHeaders: function() {
        return this.getDataModel().getHeaders();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the fields array.
     * @param {string[]} fieldNames - The field names.
     */
    setFields: function(fieldNames) {
        //were defining the columns based on field names....
        //we must rebuild the column definitions
        this.getDataModel().setFields(fieldNames);
        this.createColumns();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Get the field names.
     * @returns {string[]}
     */
    getFields: function() {
        return this.getDataModel().getFields();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the data field.
     * @param {object[]} objects - An array of uniform objects, each being a row in the grid.
     */
    setData: function(dataRows) {
        this.getDataModel().setData(dataRows);
        this.createColumns();
        var self = this;
        if (this.getGrid().isColumnAutosizing()) {
            setTimeout(function() {
                self.autosizeAllColumns();
            }, 100);
            self.changed();
        } else {
            setTimeout(function() {
                self.allColumns[-1].checkColumnAutosizing(true);
                self.changed();
            });
        }
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Get the data field.
     */
    getData: function() {
        return this.getDataModel().getData();
    },

    getCellEditorAt: function(x, y) {
        var grid = this.getGrid();
        if (grid.isFilterRow(y)) {
            return grid.cellEditors.textfield;
        }
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the totals field.
     * @param {array} nestedArray - array2D of totals data
     */
    setTopTotals: function(nestedArray) {
        this.getDataModel().setTopTotals(nestedArray);
    },

    getTopTotals: function() {
        return this.getDataModel().getTopTotals();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Build the fields and headers from the supplied column definitions.
     * ```javascript
     * myJsonBehavior.setColumns([
     *     { title: 'Stock Name', field: 'short_description' },
     *     { title: 'Status', field: 'trading_phase' },
     *     { title: 'Reference Price', field: 'reference_price' }
     * ]);
     * ```
     * @param {Array} columnDefinitions - an array of objects with fields 'title', and 'field'
     */
    setColumns: function(columnDefinitions) {
        this.getDataModel().setColumns(columnDefinitions);
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Enhance the double-click event just before it's broadcast to listeners.
     * @param {Point} event
     */
    enhanceDoubleClickEvent: function(event) {
        event.row = this.getRow(event.gridCell.y);
    },

    setDataProvider: function(dataProvider) {
        this.getDataModel().setDataProvider(dataProvider);
    },

    hasHierarchyColumn: function() {
        return this.getDataModel().hasHierarchyColumn();
    },

    getColumnAlignment: function(x) {
        if (x === 0 && this.hasHierarchyColumn()) {
            return 'left';
        } else {
            return 'center';
        }
    },

    getRowSelectionMatrix: function(selectedRows) {
        return this.getDataModel().getRowSelectionMatrix(selectedRows);
    },

    getColumnSelectionMatrix: function(selectedColumns) {
        return this.getDataModel().getColumnSelectionMatrix(selectedColumns);
    },

    getSelectionMatrix: function(selections) {
        return this.getDataModel().getSelectionMatrix(selections);
    },

    getRowSelection: function() {
        var selectedRows = this.getSelectedRows();
        return this.getDataModel().getRowSelection(selectedRows);
    },

    getColumnSelection: function() {
        var selectedColumns = this.getSelectedColumns();
        return this.getDataModel().getColumnSelection(selectedColumns);
    },

    getSelection: function() {
        var selections = this.getSelections();
        return this.getDataModel().getSelection(selections);
    },

    openEditor: function(div) {
        if (!this.isColumnReorderable()) {
            return false;
        }

        addStylesheet('dnd', null);

        var groups = { models: this.getGroups(), title: 'Groups' },
            availableGroups = { models: this.getAvailableGroups(), title: 'Available Groups' },
            hiddenColumns = { models: this.getHiddenColumns(), title: 'Hidden Ccolumns' },
            visibleColumns = { models: this.getVisibleColumns(), title: 'Visible Columns'},
            groupLists = new ListDragon([groups, availableGroups]),
            columnLists = new ListDragon([hiddenColumns, visibleColumns]),
            listSets = [groupLists, columnLists];

        listSets.forEach(function(listSet) {
            listSet.modelLists.forEach(function(list) {
                div.appendChild(list.container);
            });
        });

        //attach for later retrieval
        div.lists = {
            group: groups.models,
            availableGroups: availableGroups.models,
            hidden: hiddenColumns.models,
            visible: visibleColumns.models
        };

        return true;
    },
    getGroups: function() {
        return this.getDataModel().getGroups();
    },
    getAvailableGroups: function() {
        return this.getDataModel().getAvailableGroups();
    },
    getHiddenColumns: function() {
        return this.getDataModel().getHiddenColumns();
    },
    getVisibleColumns: function() {
        return this.getDataModel().getVisibleColumns();
    },
    setColumnDescriptors: function(lists) {
        //assumes there is one row....
        var tree = this.columns[0];
        this.columns.length = 0;
        if (tree && tree.label === 'Tree') {
            this.columns.push(tree);
        }
        for (var i = 0; i < lists.visible.length; i++) {
            this.columns.push(lists.visible[i]);
        }

        var groupBys = lists.group.map(function(e) {
            return e.id;
        });
        this.getDataModel().setGroups(groupBys);

        this.changed();
    },

    getSelectedRows: function() {
        var offset = -this.getGrid().getHeaderRowCount();
        var selections = this.getGrid().getSelectionModel().getSelectedRows();
        var result = selections.map(function(each) {
            return each + offset;
        });
        return result;
    },

    getSelectedColumns: function() {
        return this.getGrid().getSelectionModel().getSelectedColumns();
    },

    getSelections: function() {
        return this.getGrid().getSelectionModel().getSelections();
    }

});

module.exports = JSON;

},{"../dataModels/JSON":53,"../features/index":71,"../stylesheets":72,"./Behavior":36,"./DataModelDecorator":38,"hyper-analytics":20,"list-dragon":25}],40:[function(require,module,exports){
'use strict';

var Behavior = require('./Behavior');

var noop = function() {},
    n00p = function() { return 0; };

/**
 * @constructor
 */
var Null = Behavior.extend('Null', {

    //initalize: function(grid, component) {},

    setScrollPositionY: noop,
    setScrollPositionX: noop,
    getColumnCount: n00p,
    getFixedColumnCount: n00p,
    getFixedColumnsWidth: n00p,
    getFixedColumnsMaxWidth: n00p,
    setRenderedWidth: n00p,
    getRowCount: n00p,
    getFixedRowCount: n00p,
    getFixedRowsHeight: n00p,
    getFixedRowsMaxHeight: n00p,
    setRenderedHeight: n00p,
    getCellProvider: noop,
    click: noop,
    doubleClick: noop
});

module.exports = Null;

},{"./Behavior":36}],41:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

var images = require('../../images'); // this index.js is generated by gulp and ignored by git

_(images).each(function(image, key) {
    var element = new Image();
    element.src = 'data:' + image.type + ';base64,' + image.data;
    images[key] = element;
});

module.exports = images;

},{"../../images":1,"object-iterators":28}],42:[function(require,module,exports){
'use strict';

module.exports = {
    Behavior: require('./Behavior'), // abstract base class
    JSON: require('./JSON'),
    Null: require('./Null')
};
},{"./Behavior":36,"./JSON":39,"./Null":40}],43:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var mustache = require('mustache');
var Base = require('extend-me').Base;

/**
 * @constructor
 */
var CellEditor = Base.extend('CellEditor', {

    alias: 'base',

    /**
     * am I currently editing (i.e., between calls to `beginEditAt` and either `stopEditing` or `cancelEditing`)
     * @type {boolean}
     * @default false
     * @memberOf CellEditor.prototype
     */
    isEditing: false,

    /**
     * the point that I am editing at right now
     * @type {Point}
     * @default null
     * @memberOf CellEditor.prototype
     */
    editorPoint: null,

    /**
     * if true, check that the editor is in the right location
     * @type {boolean}
     * @default false
     * @memberOf CellEditor.prototype
     */
    checkEditorPositionFlag: false,

    /**
     * my main input control
     * @type {Element}
     * @default null
     * @memberOf CellEditor.prototype
     */
    input: null,

    /**
     * my instance of hypergrid
     * @type {Hypergrid}
     * @default null
     * @memberOf CellEditor.prototype
     */
    grid: null,

    /**
     * the value before editing
     * @type {type}
     * @default null
     * @memberOf CellEditor.prototype
     */
    initialValue: null,

    /**
     * @memberOf CellEditor.prototype
     * @desc return the behavior (model)
     * @returns {Behavior} The behavior (model).
     */
    getBehavior: function() {
        return this.grid.getBehavior();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc This function is a callback from the fin-hypergrid.   It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        this.checkEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc scroll values have changed, we've been notified
     */
    scrollValueChangedNotification: function() {
        this.setCheckEditorPositionFlag();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc turn on checkEditorPositionFlag boolean field
     */
    setCheckEditorPositionFlag: function() {
        this.checkEditorPositionFlag = true;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc begin editing at location point
     * @param {Point} point - the location to start editing at
     */
    beginEditAt: function(point) {
        this.setEditorPoint(point);
        var model = this.getBehavior();
        var value = model.getValue(point.x, point.y);
        if (value.constructor.name === 'Array') {
            value = value[1]; //it's a nested object
        }
        var proceed = this.grid.fireRequestCellEdit(point, value);
        if (!proceed) {
            //we were cancelled
            return;
        }
        this.initialValue = value;
        this.setEditorValue(value);
        this.isEditing = true;
        this.setCheckEditorPositionFlag();
        this.checkEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc put value into our editor
     * @param {object} value - whatever value we want to edit
     */
    setEditorValue: function(value) {},

    /**
     * @memberOf CellEditor.prototype
     * @desc returns the point at which we are currently editing
     * @returns {Point}
     */
    getEditorPoint: function() {
        return this.editorPoint;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc set the current editor location
     * @param {Point} point - the data location of the current editor
     */
    setEditorPoint: function(point) {
        this.editorPoint = point;
        this.modelPoint = this.getGrid().convertViewPointToDataPoint(point);
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc display the editor
     */
    showEditor: function() {},

    /**
     * @memberOf CellEditor.prototype
     * @desc hide the editor
     */
    hideEditor: function() {},

    /**
     * @memberOf CellEditor.prototype
     * @desc stop editing
     */
    stopEditing: function() {
        if (!this.isEditing) {
            return;
        }
        var proceed = this.getGrid().fireSyntheticEditorDataChangeEvent(this, this.initialValue, this.getEditorValue, this);
        if (!proceed) {
            return;
        }
        this.saveEditorValue();
        this.isEditing = false;
        this.hideEditor();
    },

    cancelEditing: function() {
        if (!this.isEditing) {
            return;
        }
        this.isEditing = false;
        this.hideEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc save the new value into the behavior(model)
     */
    saveEditorValue: function() {
        var point = this.getEditorPoint();
        var value = this.getEditorValue();
        if (value === this.initialValue) {
            return; //data didn't change do nothing
        }
        var continued = this.getGrid().fireBeforeCellEdit(point, this.initialValue, value, this);
        if (!continued) {
            return;
        }
        this.getBehavior().setValue(point.x, point.y, value);
        this.getGrid().fireAfterCellEdit(point, this.initialValue, value, this);
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc return the current editor's value
     */
    getEditorValue: function() {},

    /**
     * @memberOf CellEditor.prototype
     * @desc request focus for my input control
     */
    takeFocus: function() {},

    /**
     * @memberOf CellEditor.prototype
     * @desc move the editor to the current editor point
     */
    _moveEditor: function() {
        var grid = this.getGrid();
        var editorPoint = this.getEditorPoint();
        var cellBounds = grid._getBoundsOfCell(editorPoint.x, editorPoint.y);

        //hack to accomodate bootstrap margin issues...
        var xOffset = grid.div.getBoundingClientRect().left - grid.divCanvas.getBoundingClientRect().left;
        cellBounds.x = cellBounds.x - xOffset;

        this.setBounds(cellBounds);
    },

    moveEditor: function() {
        this._moveEditor();
        this.takeFocus();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc set the bounds of my input control
     * @param {Rectangle} the bounds to move to
     */
    setBounds: function(rectangle) {},

    /**
     * @memberOf CellEditor.prototype
     * @desc check that the editor is in the correct location, and is showing/hidden appropriately
     */
    checkEditor: function() {
        if (!this.checkEditorPositionFlag) {
            return;
        } else {
            this.checkEditorPositionFlag = false;
        }
        if (!this.isEditing) {
            return;
        }
        var editorPoint = this.getEditorPoint();
        if (this.grid.isDataVisible(editorPoint.x, editorPoint.y)) {
            this.moveEditor();
            this.showEditor();
        } else {
            this.hideEditor();
        }
    },

    getGrid: function() {
        return this.grid;
    },

    template: function() {
        /*

         */
    },

    getHTML: function() {
        var string = this.template.toString().split('\n');
        string.shift();
        string.shift();
        string.length = string.length - 2;
        string = string.join('\n').trim();
        return mustache.render(string, this);
    },

    getInput: function() {
        if (!this.input) {
            this.input = this.getDefaultInput();
        }
        return this.input;
    },

    getDefaultInput: function() {
        var div = document.createElement('DIV');
        div.innerHTML = this.getHTML();
        var input = div.firstChild;
        this.initializeInput(input);
        return input;
    },

    updateView: function() {
        var oldGuy = this.getInput();
        var parent = oldGuy.parentNode;
        var newGuy = this.getDefaultInput();
        this.input = newGuy;
        parent.replaceChild(newGuy, oldGuy);
    },

    initializeInput: function(input) {},

    showDropdown: function(element) {
        var event;
        event = document.createEvent('MouseEvents');
        event.initMouseEvent('mousedown', true, true, window);
        element.dispatchEvent(event);
    }

});

module.exports = CellEditor;

},{"extend-me":3,"mustache":27}],44:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Choice = Simple.extend('Choice', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Choice.prototype
     */
    alias: 'choice',

    /**
     * the list of items to pick from
     * @type {Array}
     * @memberOf Choice.prototype
     */
    items: ['a', 'b', 'c'],

    template: function() {
        /*
                <select id="editor">
                    {{#items}}
                        <option value="{{.}}">{{.}}</option>
                    {{/items}}
                </select>
            */
    },

    //no events are fired while the dropdown is open
    //see http://jsfiddle.net/m4tndtu4/6/

    /**
     * @memberOf Choice.prototype
     */
    showEditor: function() {
        var self = this;
        this.input.style.display = 'inline';
        setTimeout(function() {
            self.showDropdown(self.input);
        }, 50);
    },

    /**
     * @memberOf Choice.prototype
     * @param items
     */
    setItems: function(items) {
        this.items = items;
        this.updateView();
    },

    /**
     * @memberOf Choice.prototype
     * @param input
     */
    initializeInput: function(input) {
        var self = this;
        Simple.prototype.initializeInput(input);
        input.onchange = function() {
            self.stopEditing();
        };
    }

});

module.exports = Choice;

},{"./Simple":47}],45:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Color = Simple.extend('Color', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Color.prototype
     */
    alias: 'color',

    template: function() {
        /*
            <input id="editor" type="color">
        */
    }

});

module.exports = Color;

},{"./Simple":47}],46:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Date = Simple.extend('Date', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Date.prototype
     */
    alias: 'date',

    template: function() {
        /*
            <input id="editor" type="date">
        */
    }

});

module.exports = Date;

},{"./Simple":47}],47:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor.js');

/**
 * @constructor
 */
var Simple = CellEditor.extend('Simple', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Simple.prototype
     */
    alias: 'simple',

    /**
     * @memberOf Simple.prototype
     */
    initialize: function() {
        this.editorPoint = {
            x: 0,
            y: 0
        };
    },

    /**
     * @memberOf Simple.prototype
     * @desc  the function to override for initialization
     */
    initializeInput: function(input) {
        var self = this;
        input.addEventListener('keyup', function(e) {
            if (e && (e.keyCode === 13 || e.keyCode === 27 || e.keyCode === 8)) {
                e.preventDefault();
                if (e.keyCode === 8) {
                    self.clearStopEditing();
                } else if (e.keyCode === 27) {
                    self.cancelEditing();
                } else {
                    self.stopEditing();
                }
                self.getGrid().repaint();
                self.getGrid().takeFocus();
            }
            self.getGrid().fireSyntheticEditorKeyUpEvent(self, e);
        });
        input.addEventListener('keydown', function(e) {
            self.getGrid().fireSyntheticEditorKeyDownEvent(self, e);
        });
        input.addEventListener('keypress', function(e) {
            console.log('keypress', e.keyCode);
            self.getGrid().fireSyntheticEditorKeyPressEvent(self, e);
        });
        // input.addEventListener('focusout', function() {
        //     self.stopEditing();
        // });
        // input.addEventListener('blur', function() {
        //     self.stopEditing();
        // });
        input.style.position = 'absolute';
        input.style.display = 'none';
        input.style.border = 'solid 2px black';
        input.style.outline = 0;
        input.style.padding = 0;
        input.style.zIndex = 1000;
        input.style.fontSize = '8pt';
        input.style.boxShadow = 'white 0px 0px 1px 1px';
    },

    /**
     * @memberOf Simple.prototype
     * @returns {object} the current editor's value
     */
    getEditorValue: function() {
        var value = this.getInput().value;
        return value;
    },

    /**
     * @memberOf Simple.prototype
     * @desc save the new value into the behavior(model)
     */
    setEditorValue: function(value) {
        this.getInput().value = value + '';
    },

    clearStopEditing: function() {
        this.setEditorValue('');
        this.stopEditing();
    },

    cancelEditing: function() {
        if (!this.isEditing) {
            return;
        }
        this.getInput().value = null;
        this.isEditing = false;
        this.hideEditor();
    },

    /**
     * @memberOf Simple.prototype
     * @desc display the editor
     */
    showEditor: function() {
        this.getInput().style.display = 'inline';
    },

    /**
     * @memberOf Simple.prototype
     * @desc hide the editor
     */
    hideEditor: function() {
        this.getInput().style.display = 'none';
    },

    /**
     * @memberOf Simple.prototype
     * @desc request focus for my input control
     */
    takeFocus: function() {
        var self = this;
        setTimeout(function() {
            self.input.focus();
            self.selectAll();
        }, 300);
    },

    /**
     * @memberOf Simple.prototype
     * @desc select everything
     */
    selectAll: function() {

    },

    /**
     * @memberOf Simple.prototype
     * @desc how much should I offset my bounds from 0,0
     */
    originOffset: function() {
        return [0, 0];
    },

    /**
     * @memberOf Simple.prototype
     * @desc set the bounds of my input control
     * @param {rectangle} rectangle - the bounds to move to
     */
    setBounds: function(cellBounds) {
        var originOffset = this.originOffset();
        var translation = 'translate('
            + (cellBounds.x - 1 + originOffset[0]) + 'px,'
            + (cellBounds.y - 1 + originOffset[1]) + 'px)';

        var input = this.getInput();

        input.style.boxSizing = 'border-box';

        input.style.webkitTransform = translation;
        input.style.MozTransform = translation;
        input.style.msTransform = translation;
        input.style.OTransform = translation;

        // input.style.left = cellBounds.x + originOffset[0] + 'px';
        // input.style.top = cellBounds.y + originOffset[1] + 'px';

        input.style.width = (cellBounds.width + 2) + 'px';
        input.style.height = (cellBounds.height + 2) + 'px';
        //var xOffset = this.grid.canvas.getBoundingClientRect().left;
    }

});

module.exports = Simple;

},{"./CellEditor.js":43}],48:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Slider = Simple.extend('Slider', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Slider.prototype
     */
    alias: 'slider',

    template: function() {
        /*
            <input id="editor" type="range">
        */
    }

});

module.exports = Slider;

},{"./Simple":47}],49:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Spinner = Simple.extend('Spinner', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Spinner.prototype
     */
    alias: 'spinner',

    template: function() {
        /*
            <input id="editor" type="number">
        */
    }

});

module.exports = Spinner;

},{"./Simple":47}],50:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Textfield = Simple.extend('Textfield', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Textfield.prototype
     */
    alias: 'textfield',

    template: function() {
        /*
            <input id="editor">
        */
    },

    selectAll: function() {
        this.input.setSelectionRange(0, this.input.value.length);
    }
});

module.exports = Textfield;

},{"./Simple":47}],51:[function(require,module,exports){
'use strict';

module.exports = {
    CellEditor: require('./CellEditor'), // abstract base class
    Textfield: require('./Textfield'),
    Choice: require('./Choice'),
    //Combo: require('./Combo'),
    Color: require('./Color'),
    Date: require('./Date'),
    Slider: require('./Slider'),
    Spinner: require('./Spinner')
};
},{"./CellEditor":43,"./Choice":44,"./Color":45,"./Date":46,"./Slider":48,"./Spinner":49,"./Textfield":50}],52:[function(require,module,exports){
'use strict';

var Base = require('extend-me').Base;

var A = 'A'.charCodeAt(0);

/**
 * @constructor
 */
var DataModel = Base.extend('DataModel', {

    next: null,

    grid: null,

    setGrid: function(newGrid) {
        this.grid = newGrid;
    },

    getGrid: function() {
        return this.grid;
    },

    getBehavior: function() {
        return this.getGrid().getBehavior();
    },

    changed: function() {
        this.getBehavior().changed();
    },

    getPrivateState: function() {
        return this.getGrid().getPrivateState();
    },

    applyState: function() {

    },

    alphaFor: function(i) {
        // Name the column headers in A, .., AA, AB, AC, .., AZ format
        // quotient/remainder
        //var quo = Math.floor(col/27);
        var quo = Math.floor(i / 26);
        var rem = i % 26;
        var code = '';
        if (quo > 0) {
            code += this.alpha(quo - 1);
        }
        code += this.alpha(rem);
        return code;
    },

    alpha: function(i) {
        return String.fromCharCode(A + i);
    }

});

module.exports = DataModel;

},{"extend-me":3}],53:[function(require,module,exports){
'use strict';

var analytics = require('hyper-analytics');
//var analytics = require('../local_node_modules/newanalytics');
//var analytics = require('../local_node_modules/finanalytics');
var DataModel = require('./DataModel');

var UPWARDS_BLACK_ARROW = '\u2b06',
    DOWNWARDS_BLACK_ARROW = '\u2b07';

var nullDataSource = {
    isNullObject: function() {
        return true;
    },
    getFields: function() {
        return [];
    },
    getHeaders: function() {
        return [];
    },
    getColumnCount: function() {
        return 0;
    },
    getRowCount: function() {
        return 0;
    },
    getGrandTotals: function() {
        return [];
    },
    hasAggregates: function() {
        return false;
    },
    hasGroups: function() {
        return false;
    },
    getRow: function() {
        return null;
    }
};

/**
 * @name dataModels.JSON
 * @constructor
 */
var JSON = DataModel.extend('dataModels.JSON', {

    //null object pattern for the source object
    source: nullDataSource,

    preglobalfilter: nullDataSource,
    prefilter: nullDataSource,

    presorter: nullDataSource,
    analytics: nullDataSource,
    postfilter: nullDataSource,
    postsorter: nullDataSource,

    topTotals: [],

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasAggregates: function() {
        return this.analytics.hasAggregates();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasGroups: function() {
        return this.analytics.hasGroups();
    },

    getDataSource: function() {
        return this.analytics; //this.hasAggregates() ? this.analytics : this.presorter;
    },

    getFilterSource: function() {
        return this.prefilter; //this.hasAggregates() ? this.postfilter : this.prefilter;
    },

    getSortingSource: function() {
        return this.presorter; //this.hasAggregates() ? this.postsorter : this.presorter;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @returns {*}
     */
    getValue: function(x, y) {
        var hasHierarchyColumn = this.hasHierarchyColumn();
        var grid = this.getGrid();
        var headerRowCount = grid.getHeaderRowCount();
        var value;
        if (hasHierarchyColumn && x === -2) {
            x = 0;
        }
        if (y < headerRowCount) {
            value = this.getHeaderRowValue(x, y);
            return value;
        }
        if (hasHierarchyColumn) {
            y += 1;
        }
        value = this.getDataSource().getValue(x, y - headerRowCount);
        return value;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @returns {*}
     */
    getHeaderRowValue: function(x, y) {
        if (y === undefined) {
            return this.getHeaders()[Math.max(x, 0)];
        }
        var grid = this.getGrid();
        var behavior = grid.getBehavior();
        var isFilterRow = grid.isShowFilterRow();
        var isHeaderRow = grid.isShowHeaderRow();
        var isBoth = isFilterRow && isHeaderRow;
        var topTotalsOffset = (isFilterRow ? 1 : 0) + (isHeaderRow ? 1 : 0);
        if (y >= topTotalsOffset) {
            return this.getTopTotals()[y - topTotalsOffset][x];
        }
        var filter = this.getFilter(x);
        var image = filter.length === 0 ? 'filter-off' : 'filter-on';
        var header, sortString;
        if (isBoth) {
            if (y === 0) {
                header = this.getHeaders()[x];
                sortString = this.getSortImageForColumn(x, true);
                if (sortString) { header = sortString + header; }
                return [null, header, null];
            } else {
                return [null, filter, behavior.getImage(image)];
            }
        } else if (isFilterRow) {
            return [null, filter, behavior.getImage(image)];
        } else {
            header = this.getHeaders()[x];
            sortString = this.getSortImageForColumn(x, true);
            if (sortString) { header = sortString + header; }
            return [null, header, null];
        }
        return '';
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        var hasHierarchyColumn = this.hasHierarchyColumn();
        var grid = this.getGrid();
        var headerRowCount = grid.getHeaderRowCount();
        if (hasHierarchyColumn) {
            if (x === -2) {
                return;
            } else {
                x += 1;
            }
        }
        if (y < headerRowCount) {
            this.setHeaderRowValue(x, y, value);
        } else if (hasHierarchyColumn) {
            y += 1;
        } else {
            this.getDataSource().setValue(x, y - headerRowCount, value);
        }
        this.changed();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     * @returns {*}
     */
    setHeaderRowValue: function(x, y, value) {
        if (value === undefined) {
            return this._setHeader(x, y); // y is really the value
        }
        var grid = this.getGrid();
        var isFilterRow = grid.isShowFilterRow();
        var isHeaderRow = grid.isShowHeaderRow();
        var isBoth = isFilterRow && isHeaderRow;
        var topTotalsOffset = (isFilterRow ? 1 : 0) + (isHeaderRow ? 1 : 0);
        if (y >= topTotalsOffset) {
            this.getTopTotals()[y - topTotalsOffset][x] = value;
        } else if (x === -1) {
            return; // can't change the row numbers
        } else if (isBoth) {
            if (y === 0) {
                return this._setHeader(x, value);
            } else {
                this.setFilter(x, value);
            }
        } else if (isFilterRow) {
            this.setFilter(x, value);
        } else {
            return this._setHeader(x, value);
        }
        return '';
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @returns {*}
     */
    getColumnProperties: function(colIndex) {
        //access directly because we want it ordered
        var column = this.getBehavior().allColumns[colIndex];
        if (column) {
            return column.getProperties();
        }
        return undefined;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @returns {*}
     */
    getFilter: function(colIndex) {
        var columnProperties = this.getColumnProperties(colIndex);
        if (!columnProperties) {
            return '';
        }
        return columnProperties.filter || '';
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param value
     */
    setFilter: function(colIndex, value) {
        var columnProperties = this.getColumnProperties(colIndex);
        columnProperties.filter = value;
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getColumnCount: function() {
        return this.analytics.getColumnCount();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getRowCount: function() {
        var grid = this.getGrid();
        var count = this.getDataSource().getRowCount();
        count += grid.getHeaderRowCount();
        return count;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getHeaders: function() {
        return this.analytics.getHeaders();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} headers
     */
    setHeaders: function(headers) {
        this.getDataSource().setHeaders(headers);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} fields
     */
    setFields: function(fields) {
        this.getDataSource().setFields(fields);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getFields: function() {
        return this.getDataSource().getFields();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {object[]} dataRows
     */
    setData: function(dataRows) {
        this.source = new analytics.JSDataSource(dataRows);
        this.preglobalfilter = new analytics.DataSourceGlobalFilter(this.source);
        this.prefilter = new analytics.DataSourceFilter(this.preglobalfilter);
        this.presorter = new analytics.DataSourceSorterComposite(this.prefilter);
        this.analytics = new analytics.DataSourceAggregator(this.presorter);

        this.applyAnalytics();

        //this.postfilter = new analytics.DataSourceFilter(this.analytics);
        //this.postsorter = new analytics.DataSourceSorterComposite(this.postfilter);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {*}
     */
    getTopTotals: function() {
        if (!this.hasAggregates()) {
            return this.topTotals;
        }
        return this.getDataSource().getGrandTotals();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param nestedArray
     */
    setTopTotals: function(nestedArray) {
        this.topTotals = nestedArray;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param groups
     */
    setGroups: function(groups) {
        this.analytics.setGroupBys(groups);
        this.applyAnalytics();
        this.getGrid().fireSyntheticGroupsChangedEvent(this.getGroups());
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getGroups: function() {
        var headers = this.getHeaders().slice(0);
        var fields = this.getFields().slice(0);
        var groupBys = this.analytics.groupBys;
        var groups = [];
        for (var i = 0; i < groupBys.length; i++) {
            var field = headers[groupBys[i]];
            groups.push({
                id: groupBys[i],
                label: field,
                field: fields
            });
        }
        return groups;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getAvailableGroups: function() {
        var headers = this.source.getHeaders().slice(0);
        var groupBys = this.analytics.groupBys;
        var groups = [];
        for (var i = 0; i < headers.length; i++) {
            if (groupBys.indexOf(i) === -1) {
                var field = headers[i];
                groups.push({
                    id: i,
                    label: field,
                    field: field
                });
            }
        }
        return groups;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getVisibleColumns: function() {
        var items = this.getBehavior().columns;
        items = items.filter(function(each) {
            return each.label !== 'Tree';
        });
        return items;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getHiddenColumns: function() {
        var visible = this.getBehavior().columns;
        var all = this.getBehavior().allColumns;
        var hidden = [];
        for (var i = 0; i < all.length; i++) {
            if (visible.indexOf(all[i]) === -1) {
                hidden.push(all[i]);
            }
        }
        hidden.sort(function(a, b) {
            return a.label < b.label;
        });
        return hidden;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param aggregations
     */
    setAggregates: function(aggregations) {
        this.quietlySetAggregates(aggregations);
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param aggregations
     */
    quietlySetAggregates: function(aggregations) {
        this.analytics.setAggregates(aggregations);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasHierarchyColumn: function() {
        return this.hasAggregates() && this.hasGroups();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyAnalytics: function() {
        this.applyFilters();
        this.applySorts();
        this.applyGroupBysAndAggregations();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyGroupBysAndAggregations: function() {
        if (this.analytics.aggregates.length === 0) {
            this.quietlySetAggregates({});
        }
        this.analytics.apply();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyFilters: function() {
        this.preglobalfilter.apply();
        var colCount = this.getColumnCount();
        var filterSource = this.getFilterSource();
        var groupOffset = this.hasAggregates() ? 1 : 0;
        filterSource.clearAll();
        for (var i = 0; i < colCount; i++) {
            var filterText = this.getFilter(i);
            if (filterText.length > 0) {
                filterSource.add(i - groupOffset, textMatchFilter(filterText));
            }
        }
        filterSource.applyAll();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param keys
     */
    toggleSort: function(colIndex, keys) {
        this.incrementSortState(colIndex, keys);
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param {string[]} keys
     */
    incrementSortState: function(colIndex, keys) {
        colIndex++; //hack to get around 0 index
        var state = this.getPrivateState();
        var hasCTRL = keys.indexOf('CTRL') > -1;
        state.sorts = state.sorts || [];
        var already = state.sorts.indexOf(colIndex);
        if (already === -1) {
            already = state.sorts.indexOf(-1 * colIndex);
        }
        if (already > -1) {
            if (state.sorts[already] > 0) {
                state.sorts[already] = -1 * state.sorts[already];
            } else {
                state.sorts.splice(already, 1);
            }
        } else if (hasCTRL || state.sorts.length === 0) {
            state.sorts.unshift(colIndex);
        } else {
            state.sorts.length = 0;
            state.sorts.unshift(colIndex);
        }
        if (state.sorts.length > 3) {
            state.sorts.length = 3;
        }
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applySorts: function() {
        var sortingSource = this.getSortingSource();
        var sorts = this.getPrivateState().sorts;
        var groupOffset = this.hasAggregates() ? 1 : 0;
        if (!sorts || sorts.length === 0) {
            sortingSource.clearSorts();
        } else {
            for (var i = 0; i < sorts.length; i++) {
                var colIndex = Math.abs(sorts[i]) - 1;
                var type = sorts[i] < 0 ? -1 : 1;
                sortingSource.sortOn(colIndex - groupOffset, type);
            }
        }
        sortingSource.applySorts();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param index
     * @param returnAsString
     * @returns {*}
     */
    getSortImageForColumn: function(index, returnAsString) {
        index++;
        var up = true;
        var sorts = this.getPrivateState().sorts;
        if (!sorts) {
            return null;
        }
        var position = sorts.indexOf(index);
        if (position < 0) {
            position = sorts.indexOf(-1 * index);
            up = false;
        }
        if (position < 0) {
            return null;
        }

        var rank = sorts.length - position;

        if (returnAsString) {
            var arrow = up ? UPWARDS_BLACK_ARROW : DOWNWARDS_BLACK_ARROW;
            return rank + arrow + ' ';
        }

        var name = rank + (up ? '-up' : '-down');
        return this.getBehavior().getImage(name);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param cell
     * @param event
     */
    cellClicked: function(cell, event) {
        if (!this.hasAggregates()) {
            return;
        }
        if (event.gridCell.x !== 0) {
            return; // this wasn't a click on the hierarchy column
        }
        var grid = this.getGrid();
        var headerRowCount = grid.getHeaderRowCount();
        var y = event.gridCell.y - headerRowCount + 1;
        this.analytics.click(y);
        this.changed();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    getRow: function(y) {
        var grid = this.getGrid();
        var headerRowCount = grid.getHeaderRowCount();
        if (y < headerRowCount && !this.hasAggregates()) {
            var topTotals = this.getTopTotals();
            return topTotals[y - (headerRowCount - topTotals.length)];
        }
        return this.getDataSource().getRow(y - headerRowCount);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    buildRow: function(y) {
        var colCount = this.getColumnCount();
        var fields = [].concat(this.getFields());
        var result = {};
        if (this.hasAggregates()) {
            result.tree = this.getValue(-2, y);
            fields.shift();
        }
        for (var i = 0; i < colCount; i++) {
            result[fields[i]] = this.getValue(i, y);
        }
        return result;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    getComputedRow: function(y) {
        var rcf = this.getRowContextFunction([y]);
        var fields = this.getFields();
        var row = {};
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            row[field] = rcf(field)[0];
        }
        return row;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string} fieldName
     * @param {number} y
     * @returns {*}
     */
    getValueByField: function(fieldName, y) {
        var index = this.getFields().indexOf(fieldName);
        if (this.hasAggregates()) {
            y += 1;
        }
        return this.getDataSource().getValue(index, y);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {sring} string
     */
    setGlobalFilter: function(string) {
        if (!string || string.length === 0) {
            this.preglobalfilter.clear();
        } else {
            this.preglobalfilter.set(textMatchFilter(string));
        }
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {object} config
     * @param {number} x
     * @param {number} y
     * @param {number} untranslatedX
     * @param {number} untranslatedY
     * @returns {object}
     */
    getCellRenderer: function(config, x, y, untranslatedX, untranslatedY) {
        var renderer;
        var provider = this.getGrid().getCellProvider();

        config.x = x;
        config.y = y;
        config.untranslatedX = untranslatedX;
        config.untranslatedY = untranslatedY;

        renderer = provider.getCell(config);
        renderer.config = config;

        return renderer;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyState: function() {
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    reset: function() {
        this.setData([]);
    }

});

function valueOrFunctionExecute(valueOrFunction) {
    return typeof valueOrFunction === 'function' ? valueOrFunction() : valueOrFunction;
}

function textMatchFilter(string) {
    return function(each) {
        each = valueOrFunctionExecute(each);
        return (each + '').toLowerCase().search(string.toLowerCase()) > -1;
    };
}

module.exports = JSON;

},{"./DataModel":52,"hyper-analytics":20}],54:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var Hypergrid = require('./Hypergrid');

Hypergrid.behaviors = require('./behaviors/index');
Hypergrid.cellEditors = require('./cellEditors/index');
Hypergrid.features = require('./features/index');

window.fin = {
    Hypergrid: Hypergrid
};

},{"./Hypergrid":33,"./behaviors/index":42,"./cellEditors/index":51,"./features/index":71}],55:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var CellClick = Feature.extend('CellClick', {

    alias: 'CellClick',

    /**
     * @memberOf CellClick.prototype
     * @desc Handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleTap: function(grid, event) {
        var gridCell = event.gridCell;
        var behavior = grid.getBehavior();
        var headerRowCount = behavior.getHeaderRowCount();
        var headerColumnCount = behavior.getHeaderColumnCount();
        if ((gridCell.y >= headerRowCount) &&
            (gridCell.x >= headerColumnCount)) {
            grid.cellClicked(event);
        } else if (this.next) {
            this.next.handleTap(grid, event);
        }
    }
});

module.exports = CellClick;

},{"./Feature.js":63}],56:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var CellEditing = Feature.extend('CellEditing', {

    alias: 'CellEditing',

    /**
     * @memberOf CellEditing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function(grid, event) {
        var behavior = grid.getBehavior();
        var headerRowCount = behavior.getHeaderRowCount();
        var headerColumnCount = behavior.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (gridCell.x >= headerColumnCount && gridCell.y >= headerRowCount) {
            grid._activateEditor(event);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf CellEditing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleHoldPulse: function(grid, event) {
        var behavior = grid.getBehavior();
        var headerRowCount = behavior.getHeaderRowCount();
        var headerColumnCount = behavior.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (gridCell.x >= headerColumnCount && gridCell.y >= headerRowCount) {
            grid._activateEditor(event);
        } else if (this.next) {
            this.next.handleHoldPulse(grid, event);
        }
    }

});

module.exports = CellEditing;

},{"./Feature.js":63}],57:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var CellSelection = Feature.extend('CellSelection', {

    alias: 'CellSelection',

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @memberOf CellSelection.prototype
     */
    currentDrag: null,

    /**
     * the cell coordinates of the where the mouse pointer is during a drag operation
     * @type {Object}
     * @memberOf CellSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbAutoStart: 0,

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var behavior = grid.getBehavior();
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;
        var headerRowCount = behavior.getHeaderRowCount();
        var headerColumnCount = behavior.getHeaderColumnCount();
        var columnCount = behavior.getColumnCount();
        var isOutside = viewCell.x >= columnCount;

        var isHeader = dy < headerRowCount || dx < headerColumnCount;

        if (!grid.isCellSelection() || isRightClick || isHeader || isOutside) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();
            var numFixedRows = grid.getFixedRowCount();

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            var keys = primEvent.detail.keys;
            this.dragging = true;
            this.extendSelection(grid, dCell, keys);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (!grid.isCellSelection() || isRightClick || !this.dragging) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();
            var numFixedRows = grid.getFixedRowCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var command = 'handle' + event.detail.char;
        if (this[command]) {
            this[command].call(this, grid, event.detail);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle a mousedrag selection.
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {

        var behavior = grid.getBehavior();
        var headerRowCount = behavior.getHeaderRowCount();
        var headerColumnCount = behavior.getHeaderColumnCount();
        var x = gridCell.x;
        var y = gridCell.y;
        x = Math.max(headerColumnCount, x);
        y = Math.max(headerRowCount, y);

        var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        //var scrollingNow = grid.isScrollingNow();

        var newX = x - mouseDown.x;
        var newY = y - mouseDown.y;

        if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
            return;
        }

        grid.clearMostRecentSelection();

        grid.select(mouseDown.x, mouseDown.y, newX, newY);
        grid.setDragExtent(grid.newPoint(newX, newY));

        grid.repaint();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {

        if (!grid.isScrollingNow()) {
            return;
        }

        var dragStartedInHeaderArea = grid.isMouseDownInHeaderArea();
        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (!dragStartedInHeaderArea) {
            if (this.currentDrag.x < b.origin.x) {
                xOffset = -1;
            }
            if (this.currentDrag.y < b.origin.y) {
                yOffset = -1;
            }
        }
        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }
        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        var hasCTRL = keys.indexOf('CTRL') !== -1;
        var hasSHIFT = keys.indexOf('SHIFT') !== -1;
        // var scrollTop = grid.getVScrollValue();
        // var scrollLeft = grid.getHScrollValue();

        // var numFixedColumns = 0;//grid.getFixedColumnCount();
        // var numFixedRows = 0;//grid.getFixedRowCount();

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        if (x === mousePoint.x && y === mousePoint.y) {
            grid.clearMostRecentSelection();
            grid.popMouseDown();
            grid.repaint();
            return;
        }

        if (!hasCTRL && !hasSHIFT) {
            grid.clearSelections();
        }

        if (hasSHIFT) {
            grid.clearMostRecentSelection();
            grid.select(mousePoint.x, mousePoint.y, x - mousePoint.x + 1, y - mousePoint.y + 1);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x + 1, y - mousePoint.y));
        } else {
            grid.select(x, y, 0, 0);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, 1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, -1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        this.moveSingleSelect(grid, 0, count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        this.moveSingleSelect(grid, 0, -count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX, offsetY) {

        var maxColumns = grid.getColumnCount() - 1;
        var maxRows = grid.getRowCount() - 1;

        var maxViewableColumns = grid.getVisibleColumns() - 1;
        var maxViewableRows = grid.getVisibleRows() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newX = extent.x + offsetX;
        var newY = extent.y + offsetY;

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));
        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentSelection();
        grid.select(origin.x, origin.y, newX, newY);

        grid.setDragExtent(grid.newPoint(newX, newY));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }
        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX, offsetY) {

        var maxColumns = grid.getColumnCount() - 1;
        var maxRows = grid.getRowCount() - 1;

        var maxViewableColumns = grid.getVisibleColumnsCount() - 1;
        var maxViewableRows = grid.getVisibleRowsCount() - 1;

        var minRows = grid.getHeaderRowCount();
        var minCols = grid.getHeaderColumnCount();

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newX = mouseCorner.x + offsetX;
        var newY = mouseCorner.y + offsetY;

        newX = Math.min(maxColumns, Math.max(minCols, newX));
        newY = Math.min(maxRows, Math.max(minRows, newY));

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelColIsVisible(newX, offsetX)) {
            this.pingAutoScroll();
        }
        if (grid.insureModelRowIsVisible(newY, offsetY)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    }

});

module.exports = CellSelection;

},{"./Feature.js":63}],58:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnAutosizing = Feature.extend('ColumnAutosizing', {

    alias: 'ColumnAutosizing',

    /**
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf ColumnAutosizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        var headerRowCount = grid.getHeaderRowCount();
        //var headerColCount = grid.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (gridCell.y <= headerRowCount) {
            grid.autosizeColumn(gridCell.x);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    }

});

module.exports = ColumnAutosizing;

},{"./Feature.js":63}],59:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

// This feature is responsible for column drag and drop reordering.
// This object is a mess and desperately needs a complete rewrite.....

var Feature = require('./Feature.js');

var columnAnimationTime = 150;
var dragger;
var draggerCTX;
var floatColumn;
var floatColumnCTX;

/**
 * @constructor
 */
var ColumnMoving = Feature.extend('ColumnMoving', {

    alias: 'ColumnMoving',

    /**
     * queue up the animations that need to play so they are done synchronously
     * @type {Array}
     * @memberOf CellMoving.prototype
     */
    floaterAnimationQueue: [],

    /**
     * am I currently auto scrolling right
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingRight: false,

    /**
     * am I currently auto scrolling left
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingLeft: false,

    /**
     * is the drag mechanism currently enabled ("armed")
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragArmed: false,

    /**
     * am I dragging right now
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragging: false,

    /**
     * the column index of the currently dragged column
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragCol: -1,

    /**
     * an offset to position the dragged item from the cursor
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragOffset: 0,

    /**
     * @memberOf CellMoving.prototype
     * @desc give me an opportunity to initialize stuff on the grid
     * @param {Hypergrid} grid
     */
    initializeOn: function(grid) {
        this.isFloatingNow = false;
        this.initializeAnimationSupport(grid);
        if (this.next) {
            this.next.initializeOn(grid);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc initialize animation support on the grid
     * @param {Hypergrid} grid
     */
    initializeAnimationSupport: function(grid) {
        if (!dragger) {
            dragger = document.createElement('canvas');
            dragger.setAttribute('width', '0px');
            dragger.setAttribute('height', '0px');

            document.body.appendChild(dragger);
            draggerCTX = dragger.getContext('2d');
        }
        if (!floatColumn) {
            floatColumn = document.createElement('canvas');
            floatColumn.setAttribute('width', '0px');
            floatColumn.setAttribute('height', '0px');

            document.body.appendChild(floatColumn);
            floatColumnCTX = floatColumn.getContext('2d');
        }

    },

    getCanDragCursorName: function() {
        return '-webkit-grab';
    },

    getDraggingCursorName: function() {
        return '-webkit-grabbing';
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {

        var gridCell = event.gridCell;
        var x;
        //var y;

        var distance = Math.abs(event.primitiveEvent.detail.dragstart.x - event.primitiveEvent.detail.mouse.x);

        if (distance < 10) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
            return;
        }

        if (this.isHeaderRow(grid, event) && this.dragArmed && !this.dragging) {
            this.dragging = true;
            this.dragCol = gridCell.x;
            this.dragOffset = event.mousePoint.x;
            this.detachChain();
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.createDragColumn(grid, x, this.dragCol);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }

        if (this.dragging) {
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.dragColumn(grid, x);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (grid.getBehavior().isColumnReorderable()) {
            if (this.isHeaderRow(grid, event) && event.gridCell.x !== -1) {
                this.dragArmed = true;
                this.cursor = this.getDraggingCursorName();
                grid.clearSelections();
            }
        }
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        //var col = event.gridCell.x;
        if (this.dragging) {
            this.cursor = null;
            //delay here to give other events a chance to be dropped
            var self = this;
            this.endDragColumn(grid);
            setTimeout(function() {
                self.attachChain();
            }, 200);
        }
        this.dragCol = -1;
        this.dragging = false;
        this.dragArmed = false;
        this.cursor = null;
        grid.repaint();

        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {

        if (!this.dragging && event.mousePoint.y < 5 && event.viewPoint.y === 0) {
            this.cursor = this.getCanDragCursorName();
        } else {
            this.cursor = null;
        }

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }

        if (this.isHeaderRow(grid, event) && this.dragging) {
            this.cursor = this.getDraggingCursorName(); //move';
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this is the main event handler that manages the dragging of the column
     * @param {Hypergrid} grid
     * @param {boolean} draggedToTheRight - are we moving to the right
     */
    floatColumnTo: function(grid, draggedToTheRight) {
        this.floatingNow = true;

        var renderer = grid.getRenderer();
        var colEdges = renderer.getColumnEdges();
        //var behavior = grid.getBehavior();
        var scrollLeft = grid.getHScrollValue();
        var floaterIndex = grid.renderOverridesCache.floater.columnIndex;
        var draggerIndex = grid.renderOverridesCache.dragger.columnIndex;
        var hdpiratio = grid.renderOverridesCache.dragger.hdpiratio;

        var draggerStartX;
        var floaterStartX;
        var fixedColumnCount = grid.getFixedColumnCount();
        var draggerWidth = grid.getColumnWidth(draggerIndex);
        var floaterWidth = grid.getColumnWidth(floaterIndex);

        var max = grid.getVisibleColumnsCount();

        var doffset = 0;
        var foffset = 0;

        if (draggerIndex >= fixedColumnCount) {
            doffset = scrollLeft;
        }
        if (floaterIndex >= fixedColumnCount) {
            foffset = scrollLeft;
        }

        if (draggedToTheRight) {
            draggerStartX = colEdges[Math.min(max, draggerIndex - doffset)];
            floaterStartX = colEdges[Math.min(max, floaterIndex - foffset)];

            grid.renderOverridesCache.dragger.startX = (draggerStartX + floaterWidth) * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;

        } else {
            floaterStartX = colEdges[Math.min(max, floaterIndex - foffset)];
            draggerStartX = floaterStartX + draggerWidth;

            grid.renderOverridesCache.dragger.startX = floaterStartX * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;
        }
        grid.swapColumns(draggerIndex, floaterIndex);
        grid.renderOverridesCache.dragger.columnIndex = floaterIndex;
        grid.renderOverridesCache.floater.columnIndex = draggerIndex;


        this.floaterAnimationQueue.unshift(this.doColumnMoveAnimation(grid, floaterStartX, draggerStartX));

        this.doFloaterAnimation(grid);

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the column drag and drop animation
     * @param {Hypergrid} grid
     * @param {number} floaterStartX - the x start coordinate of the column underneath that floats behind the dragged column
     * @param {number} draggerStartX - the x start coordinate of the dragged column
     */
    doColumnMoveAnimation: function(grid, floaterStartX, draggerStartX) {
        var self = this;
        return function() {
            var d = floatColumn;
            d.style.display = 'inline';
            self.setCrossBrowserProperty(d, 'transform', 'translate(' + floaterStartX + 'px, ' + 0 + 'px)');

            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';
            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';

            requestAnimationFrame(function() {
                self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease');
                self.setCrossBrowserProperty(d, 'transform', 'translate(' + draggerStartX + 'px, ' + -2 + 'px)');
            });
            grid.repaint();
            //need to change this to key frames

            setTimeout(function() {
                self.setCrossBrowserProperty(d, 'transition', '');
                grid.renderOverridesCache.floater = null;
                grid.repaint();
                self.doFloaterAnimation(grid);
                requestAnimationFrame(function() {
                    d.style.display = 'none';
                    self.isFloatingNow = false;
                });
            }, columnAnimationTime + 50);
        };
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the floater animation
     * @param {Hypergrid} grid
     */
    doFloaterAnimation: function(grid) {
        if (this.floaterAnimationQueue.length === 0) {
            this.floatingNow = false;
            grid.repaint();
            return;
        }
        var animation = this.floaterAnimationQueue.pop();
        animation();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the float column at columnIndex underneath the dragged column
     * @param {Hypergrid} grid
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createFloatColumn: function(grid, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();

        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = floatColumn;
        var style = d.style;
        var location = grid.div.getBoundingClientRect();

        style.top = (location.top - 2) + 'px';
        style.left = location.left + 'px';
        style.position = 'fixed';

        var hdpiRatio = grid.getHiDPI(floatColumnCTX);

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');
        style.boxShadow = '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)';
        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';
        style.borderTop = '1px solid ' + renderer.resolveProperty('lineColor');
        style.backgroundColor = renderer.resolveProperty('backgroundColor');

        var startX = columnEdges[columnIndex - scrollLeft];
        startX = startX * hdpiRatio;

        floatColumnCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.floater = {
            columnIndex: columnIndex,
            ctx: floatColumnCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        style.zIndex = '4';
        this.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -2 + 'px)');
        style.cursor = this.getDraggingCursorName();
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting cross browser css properties
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setCrossBrowserProperty: function(element, property, value) {
        var uProperty = property[0].toUpperCase() + property.substr(1);
        this.setProp(element, 'webkit' + uProperty, value);
        this.setProp(element, 'Moz' + uProperty, value);
        this.setProp(element, 'ms' + uProperty, value);
        this.setProp(element, 'O' + uProperty, value);
        this.setProp(element, property, value);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting properties on HTMLElements
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setProp: function(element, property, value) {
        if (property in element.style) {
            element.style[property] = value;
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the dragged column at columnIndex above the floated column
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createDragColumn: function(grid, x, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();
        var hdpiRatio = grid.getHiDPI(draggerCTX);
        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = dragger;
        var location = grid.div.getBoundingClientRect();
        var style = d.style;

        style.top = location.top + 'px';
        style.left = location.left + 'px';
        style.position = 'fixed';
        style.opacity = 0.85;
        style.boxShadow = '0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22)';
        //style.zIndex = 100;
        style.borderTop = '1px solid ' + renderer.resolveProperty('lineColor');
        style.backgroundColor = grid.renderer.resolveProperty('backgroundColor');

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');

        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';

        var startX = columnEdges[columnIndex - scrollLeft];
        startX = startX * hdpiRatio;

        draggerCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.dragger = {
            columnIndex: columnIndex,
            ctx: draggerCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, -5px)');
        style.zIndex = '5';
        style.cursor = this.getDraggingCursorName();
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this function is the main dragging logic
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    dragColumn: function(grid, x) {

        //TODO: this function is overly complex, refactor this in to something more reasonable
        var self = this;
        //var renderer = grid.getRenderer();
        //var columnEdges = renderer.getColumnEdges();

        var autoScrollingNow = this.columnDragAutoScrollingRight || this.columnDragAutoScrollingLeft;

        var hdpiRatio = grid.getHiDPI(draggerCTX);

        var dragColumnIndex = grid.renderOverridesCache.dragger.columnIndex;
        var columnWidth = grid.renderOverridesCache.dragger.width;

        var minX = 0; //grid.getFixedColumnsWidth();
        var maxX = grid.renderer.getFinalVisableColumnBoundry() - columnWidth;
        x = Math.min(x, maxX + 15);
        x = Math.max(minX - 15, x);

        //am I at my lower bound
        var atMin = x < minX && dragColumnIndex !== 0;

        //am I at my upper bound
        var atMax = x > maxX;

        var d = dragger;

        this.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + 0 + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, ' + -10 + 'px)');
        requestAnimationFrame(function() {
            d.style.display = 'inline';
        });

        var overCol = grid.renderer.getColumnFromPixelX(x + (d.width / 2 / hdpiRatio));

        if (atMin) {
            overCol = 0;
        }

        if (atMax) {
            overCol = grid.getColumnCount() - 1;
        }

        var doAFloat = dragColumnIndex > overCol;
        doAFloat = doAFloat || (overCol - dragColumnIndex >= 1);

        if (doAFloat && !atMax && !autoScrollingNow) {
            var draggedToTheRight = dragColumnIndex < overCol;
            // if (draggedToTheRight) {
            //     overCol = overCol - 1;
            // }
            if (this.isFloatingNow) {
                return;
            }

            this.isFloatingNow = true;
            this.createFloatColumn(grid, overCol);
            this.floatColumnTo(grid, draggedToTheRight);
        } else {

            if (x < minX - 10) {
                this.checkAutoScrollToLeft(grid, x);
            }
            if (x > minX - 10) {
                this.columnDragAutoScrollingLeft = false;
            }
            //lets check for autoscroll to right if were up against it
            if (atMax || x > maxX + 10) {
                this.checkAutoScrollToRight(grid, x);
                return;
            }
            if (x < maxX + 10) {
                this.columnDragAutoScrollingRight = false;
            }
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the right if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToRight: function(grid, x) {
        if (this.columnDragAutoScrollingRight) {
            return;
        }
        this.columnDragAutoScrollingRight = true;
        this._checkAutoScrollToRight(grid, x);
    },

    _checkAutoScrollToRight: function(grid, x) {
        if (!this.columnDragAutoScrollingRight) {
            return;
        }
        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft > (grid.sbHScrollConfig.rangeStop - 2)) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.scrollBy(1, 0);
        var newIndex = draggedIndex + 1;
        console.log(newIndex, draggedIndex);
        grid.swapColumns(newIndex, draggedIndex);
        grid.renderOverridesCache.dragger.columnIndex = newIndex;

        setTimeout(this._checkAutoScrollToRight.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the left if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToLeft: function(grid, x) {
        if (this.columnDragAutoScrollingLeft) {
            return;
        }
        this.columnDragAutoScrollingLeft = true;
        this._checkAutoScrollToLeft(grid, x);
    },

    _checkAutoScrollToLeft: function(grid, x) {
        if (!this.columnDragAutoScrollingLeft) {
            return;
        }

        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft < 1) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.swapColumns(draggedIndex + scrollLeft, draggedIndex + scrollLeft - 1);
        grid.scrollBy(-1, 0);
        setTimeout(this._checkAutoScrollToLeft.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc a column drag has completed, update data and cleanup
     * @param {Hypergrid} grid
     */
    endDragColumn: function(grid) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        var columnIndex = grid.renderOverridesCache.dragger.columnIndex;

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();
        var self = this;
        var startX = columnEdges[columnIndex - scrollLeft];
        var d = dragger;

        self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');
        self.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -1 + 'px)');
        d.style.boxShadow = '0px 0px 0px #888888';

        setTimeout(function() {
            grid.renderOverridesCache.dragger = null;
            grid.repaint();
            requestAnimationFrame(function() {
                d.style.display = 'none';
                grid.endDragColumnNotification();
            });
        }, columnAnimationTime + 50);

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isHeaderRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y === 0;
        return isFixed;
    }

});

module.exports = ColumnMoving;

},{"./Feature.js":63}],60:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnResizing = Feature.extend('ColumnResizing', {

    alias: 'ColumnResizing',

    /**
     * the index of the column wall were currently dragging
     * @type {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    dragIndex: -2,

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragIndexStartingSize: -1,

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.x;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the grid cell x,y coordinate
     * @returns {number}
     * @param {window.fin.rectangular.Point} gridCell
     */
    getGridCellValue: function(gridCell) {
        return gridCell.y;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the grids x,y scroll value
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getScrollValue: function(grid) {
        return grid.getHScrollValue();
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the width/height of the row/column of interest
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getAreaSize: function(grid, index) {
        return grid.getColumnWidth(index);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc set the width/height of the row/column at index
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     * @param {number} value - the width/height to set to
     */
    setAreaSize: function(grid, index, value) {
        grid.setColumnWidth(index, value);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the recently rendered area's width/height
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getPreviousAbsoluteSize: function(grid, index) {
        return grid.getRenderedWidth(index);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        return grid.overColumnDivider(event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc am I over the column/row area
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedOtherArea: function(grid, event) {
        return this.isFirstFixedRow(grid, event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'col-resize';
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.dragIndex > -2) {
            //var fixedAreaCount = this.getFixedAreaCount(grid);
            //var offset = this.getFixedAreaSize(grid, fixedAreaCount + areaIndex);
            var mouse = this.getMouseValue(event);
            var scrollValue = this.getScrollValue(grid);
            if (this.dragIndex < this.getFixedAreaCount(grid)) {
                scrollValue = 0;
            }
            var previous = this.getPreviousAbsoluteSize(grid, this.dragIndex - scrollValue);
            var distance = mouse - previous;
            this.setAreaSize(grid, this.dragIndex, distance);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the width/height of a specific row/column
     * @param {Hypergrid} grid
     * @param {number} areaIndex - the row/column index of interest
     */
    getSize: function(grid, areaIndex) {
        return this.getAreaSize(grid, areaIndex);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the fixed area rows/columns count
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getOtherFixedAreaCount: function(grid) {
        return grid.getFixedRowCount();
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        var overArea = this.overAreaDivider(grid, event);
        if (isEnabled && overArea > -1 && this.isFirstFixedOtherArea(grid, event)) {
            var scrollValue = this.getScrollValue(grid);
            if (overArea < this.getFixedAreaCount(grid)) {
                scrollValue = 0;
            }
            this.dragIndex = overArea - 1 + scrollValue;
            this.dragStart = this.getMouseValue(event);
            this.dragIndexStartingSize = 0;
            this.detachChain();
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        if (isEnabled && this.dragIndex > -2) {
            this.cursor = null;
            this.dragIndex = -2;

            event.primitiveEvent.stopPropagation();
            //delay here to give other events a chance to be dropped
            var self = this;
            grid.synchronizeScrollingBoundries();
            setTimeout(function() {
                self.attachChain();
            }, 200);
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (this.dragIndex > -2) {
            return;
        }
        this.cursor = null;
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
        this.checkForAreaResizeCursorChange(grid, event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc fill this in
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    checkForAreaResizeCursorChange: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        if (isEnabled && this.overAreaDivider(grid, event) > -1 && this.isFirstFixedOtherArea(grid, event)) {
            this.cursor = this.getCursorName();
        } else {
            this.cursor = null;
        }

    },

    /**
     * @param {Hypergrid} grid
     * @returns {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    getFixedAreaCount: function(grid) {
        var count = grid.getFixedColumnCount() + (grid.isShowRowNumbers() ? 1 : 0) + (grid.hasHierarchyColumn() ? 1 : 0);
        return count;
    },

    /**
     * @param {Hypergrid} grid
     * @param event
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        var hasCursor = this.overAreaDivider(grid, event) > -1; //this.cursor !== null;
        var headerRowCount = grid.getHeaderRowCount();
        //var headerColCount = grid.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (isEnabled && hasCursor && (gridCell.y <= headerRowCount)) {
            grid.autosizeColumn(gridCell.x - 1);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @param {Hypergrid} grid
     * @returns {boolean}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    isEnabled: function(grid) {
        return true;
    }

});

module.exports = ColumnResizing;

},{"./Feature.js":63}],61:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnSelection = Feature.extend('ColumnSelection', {

    alias: 'ColumnSelection',

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbAutoStart: 0,


    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
            return;
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {

        if ((!grid.isColumnSelection() || event.mousePoint.y < 5) && this.next) {
            this.next.handleMouseDown(grid, event);
            return;
        }

        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;

        var isHeader = grid.isShowHeaderRow() && dy === 0 && dx !== -1;

        if (isRightClick || !isHeader) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            var dCell = grid.newPoint(dx, 0);

            var primEvent = event.primitiveEvent;
            var keys = primEvent.detail.keys;
            this.dragging = true;
            this.extendSelection(grid, dCell, keys);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {

        if ((!grid.isColumnSelection() || this.isColumnDragging(grid)) && this.next) {
            this.next.handleMouseDrag(grid, event);
            return;
        }

        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (isRightClick || !this.dragging) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        if (grid.getLastSelectionType() !== 'column') {
            if (this.next) {
                this.next.handleKeyDown(grid, event);
            }
            return;
        }
        var command = 'handle' + event.detail.char;
        if (this[command]) {
            this[command].call(this, grid, event.detail);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {

        //var behavior = grid.getBehavior();
        var x = gridCell.x;
        //            var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        var newX = x - mouseDown.x;
        //var newY = y - mouseDown.y;

        // if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
        //     return;
        // }

        grid.clearMostRecentColumnSelection();

        grid.selectColumn(mouseDown.x, x);
        grid.setDragExtent(grid.newPoint(newX, 0));

        grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {

        if (!grid.isScrollingNow()) {
            return;
        }

        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (this.currentDrag.x < b.origin.x) {
            xOffset = -1;
        }

        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        grid.stopEditing();
        //var hasCTRL = keys.indexOf('CTRL') !== -1;
        var hasSHIFT = keys.indexOf('SHIFT') !== -1;

        // var scrollTop = grid.getVScrollValue();
        // var scrollLeft = grid.getHScrollValue();

        // var numFixedColumns = 0;//grid.getFixedColumnCount();
        // var numFixedRows = 0;//grid.getFixedRowCount();

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        // if (mousePoint && x === mousePoint.x && y === mousePoint.y) {
        //     grid.clearSelections();
        //     grid.popMouseDown();
        //     grid.repaint();
        //     return;
        // }

        // if (!hasCTRL && !hasSHIFT) {
        //     grid.clearSelections();
        // }

        if (hasSHIFT) {
            grid.clearMostRecentColumnSelection();
            grid.selectColumn(x, mousePoint.x);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x, 0));
        } else {
            grid.toggleSelectColumn(x, keys);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {

        // var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        // var maxRows = grid.getRowCount() - 1;

        // var newX = mouseCorner.x;
        // var newY = grid.getHeaderRowCount() + grid.getVScrollValue();

        // newY = Math.min(maxRows, newY);

        // grid.clearSelections();
        // grid.select(newX, newY, 0, 0);
        // grid.setMouseDown(new grid.rectangular.Point(newX, newY));
        // grid.setDragExtent(new grid.rectangular.Point(0, 0));

        // grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX) {

        var maxColumns = grid.getColumnCount() - 1;

        var maxViewableColumns = grid.getVisibleColumns() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newX = extent.x + offsetX;
        //var newY = grid.getRowCount();

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));

        grid.clearMostRecentColumnSelection();
        grid.selectColumn(origin.x, origin.x + newX);

        grid.setDragExtent(grid.newPoint(newX, 0));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX) {

        var maxColumns = grid.getColumnCount() - 1;

        var maxViewableColumns = grid.getVisibleColumnsCount() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newX = mouseCorner.x + offsetX;
        //var newY = grid.getRowCount();

        newX = Math.min(maxColumns, Math.max(0, newX));

        grid.clearSelections();
        grid.selectColumn(newX);
        grid.setMouseDown(grid.newPoint(newX, 0));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelColIsVisible(newX, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    isColumnDragging: function(grid) {
        var dragger = grid.lookupFeature('ColumnMoving');
        if (!dragger) {
            return false;
        }
        var isActivated = dragger.dragging && !this.dragging;
        return isActivated;
    }

});

module.exports = ColumnSelection;

},{"./Feature.js":63}],62:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnSorting = Feature.extend('ColumnSorting', {

    alias: 'ColumnSorting',

    /**
     * @memberOf ColumnSorting.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */

    handleDoubleClick: function(grid, event) {
        var gridCell = event.gridCell;
        if (grid.isShowHeaderRow() && gridCell.y === 0 && gridCell.x !== -1) {
            var keys = event.primitiveEvent.detail.keys;
            grid.toggleSort(gridCell.x, keys);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSorting.prototype
     * @desc * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        var y = event.gridCell.y;
        if (this.isFixedRow(grid, event) && y < 1) {
            this.cursor = 'pointer';
        } else {
            this.cursor = null;
        }
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    }

});

module.exports = ColumnSorting;

},{"./Feature.js":63}],63:[function(require,module,exports){
'use strict';

var Base = require('extend-me').Base;

/**
 * @constructor
 * @desc instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
 */
var Feature = Base.extend('Feature', {

    /**
     * the next feature to be given a chance to handle incoming events
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    next: null,

    /**
     * a temporary holding field for my next feature when I'm in a disconnected state
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    detached: null,

    /**
     * the cursor I want to be displayed
     * @type {string}
     * @default null
     * @memberOf Feature.prototype
     */
    cursor: null,

    /**
     * the cell location where the cursor is currently
     * @type {Point}
     * @default null
     * @memberOf Feature.prototype
     */
    currentHoverCell: null,

    /**
     * @memberOf Feature.prototype
     * @desc set my next field, or if it's populated delegate to the feature in my next field
     * @param {Feature} nextFeature - this is how we build the chain of responsibility
     */
    setNext: function(nextFeature) {
        if (this.next) {
            this.next.setNext(nextFeature);
        } else {
            this.next = nextFeature;
            this.detached = nextFeature;
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc disconnect my child
     */
    detachChain: function() {
        this.next = null;
    },

    /**
     * @memberOf Feature.prototype
     * @desc reattach my child from the detached reference
     */
    attachChain: function() {
        this.next = this.detached;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle mouse move down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function(grid, event) {
        if (this.next) {
            this.next.handleMouseExit(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseEnter: function(grid, event) {
        if (this.next) {
            this.next.handleMouseEnter(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyUp: function(grid, event) {
        if (this.next) {
            this.next.handleKeyUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function(grid, event) {
        if (this.next) {
            this.next.handleWheelMoved(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function(grid, event) {
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleHoldPulse: function(grid, event) {
        if (this.next) {
            this.next.handleHoldPulse(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleTap: function(grid, event) {
        if (this.next) {
            this.next.handleTap(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleContextMenu: function(grid, event) {
        if (this.next) {
            this.next.handleContextMenu(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc toggle the column picker
     */

    toggleColumnPicker: function(grid) {
        if (this.next) {
            this.next.toggleColumnPicker(grid);
        }
    },


    /**
     * @memberOf Feature.prototype
     * @desc toggle the column picker
     */

    moveSingleSelect: function(grid, x, y) {
        if (this.next) {
            this.next.moveSingleSelect(grid, x, y);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y < grid.getFixedRowCount();
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y < 1;
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedColumn: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.x < grid.getFixedColumnCount();
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedColumn: function(grid, event) {
        var gridCell = event.viewPoint;
        var edge = grid.isShowRowNumbers() ? 0 : 1;
        var isFixed = gridCell.x < edge;
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isTopLeft: function(grid, event) {
        var isTopLeft = this.isFixedRow(grid, event) && this.isFixedColumn(grid, event);
        return isTopLeft;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    setCursor: function(grid) {
        if (this.next) {
            this.next.setCursor(grid);
        }
        if (this.cursor) {
            grid.beCursor(this.cursor);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    initializeOn: function(grid) {
        if (this.next) {
            this.next.initializeOn(grid);
        }
    }

});

module.exports = Feature;

},{"extend-me":3}],64:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var Filters = Feature.extend('Filters', {

    alias: 'Filters',

    handleTap: function(grid, event) {
        var gridCell = event.gridCell;
        if (grid.isFilterRow(gridCell.y) && gridCell.x !== -1) {
            grid.filterClicked(event);
        } else if (this.next) {
            this.next.handleTap(grid, event);
        }
    }

});

module.exports = Filters;

},{"./Feature.js":63}],65:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

var commands = {
    PAGEDOWN: function(grid) { grid.pageDown(); },
    PAGEUP: function(grid) { grid.pageUp(); },
    PAGELEFT: function(grid) { grid.pageLeft(); },
    PAGERIGHT: function(grid) { grid.pageRight(); }
};

/**
 * @constructor
 */
var KeyPaging = Feature.extend('KeyPaging', {

    alias: 'KeyPaging',

    /**
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function(grid, event) {
        var detail = event.detail.char;
        var func = commands[detail];
        if (func) {
            func(grid);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

module.exports = KeyPaging;

},{"./Feature.js":63}],66:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var OnHover = Feature.extend('OnHover', {

    alias: 'OnHover',

    /**
     * @desc Hhandle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf OnHover.prototype
     */
    handleMouseMove: function(grid, event) {
        var currentHoverCell = grid.getHoverCell();
        if (!event.gridCell.equals(currentHoverCell)) {
            if (currentHoverCell) {
                this.handleMouseExit(grid, currentHoverCell);
            }
            this.handleMouseEnter(grid, event);
            grid.setHoverCell(event.gridCell);
        } else {
            if (this.next) {
                this.next.handleMouseMove(grid, event);
            }
        }
    }

});

module.exports = OnHover;

},{"./Feature.js":63}],67:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var Feature = require('./Feature.js');

var ANIMATION_TIME = 200;

/**
 * @constructor
 */
var Overlay = Feature.extend('Overlay', {

    alias: 'Overlay',

    /**
     * is the editor open
     * @type {boolean}
     * @memberOf Overlay.prototype
     */
    openEditor: false,

    /**
     * @memberOf Overlay.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyUp: function(grid, event) {
        var key = event.detail.char.toLowerCase();
        var keys = grid.resolveProperty('editorActivationKeys');
        if (keys.indexOf(key) > -1) {
            this.toggleColumnPicker(grid);
        }
    },

    /**
     * @memberOf Overlay.prototype
     * @desc toggle the column picker on/off
     * @param {Hypergrid} grid
     */
    toggleColumnPicker: function(grid) {
        if (this.isColumnPickerOpen(grid)) {
            this.closeColumnPicker(grid);
        } else {
            this.openColumnPicker(grid);
        }
    },

    /**
     * @memberOf Overlay.prototype
     * @desc returns true if the column picker is open
     * @returns {boolean}
     * @param {Hypergrid} grid
     */
    isColumnPickerOpen: function(grid) {
        return this.overlay.style.display !== 'none';
    },

    /**
     * @memberOf Overlay.prototype
     * @desc open the column picker
     * #### returns: type
     * @param {Hypergrid} grid
     */
    openColumnPicker: function(grid) {
        if (this.isColumnPickerOpen()) {
            return;
        }
        this.openEditor = true;
        if (grid.getBehavior().openEditor(this.overlay) === false) {
            return;
        }

        var self = this;
        this.overlay.style.backgroundColor = grid.resolveProperty('backgroundColor');

        this.overlay.style.top = '0%';
        this.overlay.style.right = '0%';
        this.overlay.style.bottom = '0%';
        this.overlay.style.left = '0%';

        this.overlay.style.marginTop = '15px';
        this.overlay.style.marginRight = '35px';
        this.overlay.style.marginBottom = '35px';
        this.overlay.style.marginLeft = '15px';

        self.overlay.style.display = '';


        if (!this._closer) {
            this._closer = function(e) {
                var key = self.getCharFor(grid, e.keyCode).toLowerCase();
                var keys = grid.resolveProperty('editorActivationKeys');
                if (keys.indexOf(key) > -1 || e.keyCode === 27) {
                    e.preventDefault();
                    self.closeColumnPicker(grid);
                }
            };
        }

        //grid.setFocusable(false);
        requestAnimationFrame(function() {
            self.overlay.style.opacity = 0.95;
            document.addEventListener('keydown', self._closer, false);
        });
        setTimeout(function() {
            self.overlay.focus();
        }, 100);
    },

    /**
     * @memberOf Overlay.prototype
     * @desc close the column picker
     * @param {Hypergrid} grid
     */
    closeColumnPicker: function(grid) {
        //grid.setFocusable(true);

        if (!this.isColumnPickerOpen()) {
            return;
        }
        if (this.openEditor) {
            this.openEditor = false;
        } else {
            return;
        }
        if (grid.getBehavior().closeEditor(this.overlay) === false) {
            return;
        }

        document.removeEventListener('keydown', this._closer, false);

        var self = this;

        requestAnimationFrame(function() {
            self.overlay.style.opacity = 0;
        });

        setTimeout(function() {
            self.overlay.innerHTML = '';
            self.overlay.style.display = 'none';
            grid.takeFocus();
        }, ANIMATION_TIME);
    },

    /**
     * @memberOf Overlay.prototype
     * @desc initialize myself into the grid
     * #### returns: type
     * @param {Hypergrid} grid
     */
    initializeOn: function(grid) {
        this.initializeOverlaySurface(grid);
        if (this.next) {
            this.next.initializeOn(grid);
        }
    },

    /**
     * @memberOf Overlay.prototype
     * @desc initialize the overlay surface into the grid
     * #### returns: type
     * @param {Hypergrid} grid
     */
    initializeOverlaySurface: function(grid) {
        this.overlay = document.createElement('div');
        this.overlay.setAttribute('tabindex', 0);
        this.overlay.style.outline = 'none';
        this.overlay.style.boxShadow = '0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22)';
        this.overlay.style.position = 'absolute';
        this.overlay.style.display = 'none';
        this.overlay.style.transition = 'opacity ' + ANIMATION_TIME + 'ms ease-in';
        this.overlay.style.opacity = 0;
        this.overlay.style.zIndex = 10;
        grid.div.appendChild(this.overlay);
        //document.body.appendChild(this.overlay);
    },

    /**
     * @memberOf Overlay.prototype
     * @desc get a human readable description of the key pressed from it's integer representation
     * @returns {string}
     * @param {Hypergrid} grid
     * @param {number} integer - the integer we want the char for
     */
    getCharFor: function(grid, integer) {
        var charMap = grid.getCanvas().getCharMap();
        return charMap[integer][0];
    }

});

module.exports = Overlay;

},{"./Feature.js":63}],68:[function(require,module,exports){
'use strict';

var ColumnResizing = require('./ColumnResizing');

/**
 * @constructor
 */
var RowResizing = ColumnResizing.extend('RowResizing', {

    alias: 'RowResizing',

    /**
     * the index of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragArea: -1,

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragAreaStartingSize: -1,

    /**
     * @memberOf RowResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.y;
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc get the grid cell x,y coordinate
     * @returns {number}
     * @param {Point} gridCell
     */
    getGridCellValue: function(gridCell) {
        return gridCell.x;
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the grids x,y scroll value
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getScrollValue: function(grid) {
        return grid.getVScrollValue();
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the width/height of the row/column of interest
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getAreaSize: function(grid, index) {
        return grid.getRowHeight(index);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc set the width/height of the row/column at index
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     * @param {number} value - the width/height to set to
     */
    setAreaSize: function(grid, index, value) {
        grid.setRowHeight(index, value);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        return grid.overRowDivider(event);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc am I over the column/row area
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedOtherArea: function(grid, event) {
        return this.isFirstFixedColumn(grid, event);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'row-resize';
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the recently rendered area's width/height
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getPreviousAbsoluteSize: function(grid, index) {
        return grid.getRenderedHeight(index);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the fixed area rows/columns count
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getOtherFixedAreaCount: function(grid) {
        return grid.getFixedColumnCount();
    },

    /**
     *
     * @param {Hypergrid} grid
     * @returns {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    getFixedAreaCount: function(grid) {
        return grid.getFixedRowCount() + grid.getHeaderRowCount();
    },

    /**
     *
     * @param {Hypergrid} grid
     * @returns {boolean}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    isEnabled: function(grid) {
        return grid.isRowResizeable();
    }

});

module.exports = RowResizing;

},{"./ColumnResizing":60}],69:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var RowSelection = Feature.extend('RowSelection', {

    alias: 'RowSelection',

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {Point}
     * @default null
     * @memberOf RowSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf RowSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbAutoStart: 0,

    dragArmed: false,

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragArmed) {
            this.dragArmed = false;
            //global row selection
            if (event.gridCell.x === -1 && event.gridCell.y === 0) {
                grid.toggleSelectAllRows();
            }
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.dragging) {
            this.dragging = false;
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {

        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;


        var isHeader = grid.isShowRowNumbers() && dx < 0;

        if (!grid.isRowSelection() || isRightClick || !isHeader) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {

            var numFixedRows = grid.getFixedRowCount();

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(0, dy);

            var primEvent = event.primitiveEvent;
            var keys = primEvent.detail.keys;
            this.dragArmed = true;
            this.extendSelection(grid, dCell, keys);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (!this.dragArmed || !grid.isRowSelection() || isRightClick) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {
            this.dragging = true;
            var numFixedRows = grid.getFixedRowCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            //var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(0, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        if (grid.getLastSelectionType() !== 'row') {
            if (this.next) {
                this.next.handleKeyDown(grid, event);
            }
            return;
        }
        var command = 'handle' + event.detail.char;
        if (this[command]) {
            this[command].call(this, grid, event.detail);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {

        //var behavior = grid.getBehavior();
        var y = gridCell.y;
        //            var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        var newY = y - mouseDown.y;
        //var newY = y - mouseDown.y;

        // if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
        //     return;
        // }

        grid.clearMostRecentRowSelection();

        grid.selectRow(mouseDown.y, y);
        grid.setDragExtent(grid.newPoint(0, newY));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (this.currentDrag.y < b.origin.y) {
            yOffset = -1;
        }

        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        grid.stopEditing();
        //var hasCTRL = keys.indexOf('CTRL') !== -1;
        var hasSHIFT = keys.indexOf('SHIFT') !== -1;

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        if (hasSHIFT) {
            grid.clearMostRecentRowSelection();
            grid.selectRow(y, mousePoint.y);
            grid.setDragExtent(grid.newPoint(0, y - mousePoint.y));
        } else {
            grid.toggleSelectRow(y, keys);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        var maxColumns = grid.getColumnCount() - 1;

        var newX = grid.getHeaderColumnCount() + grid.getHScrollValue();
        var newY = mouseCorner.y;

        newX = Math.min(maxColumns, newX);

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetY) {

        var maxRows = grid.getRowCount() - 1;

        var maxViewableRows = grid.getVisibleRows() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newY = extent.y + offsetY;
        //var newY = grid.getRowCount();

        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentRowSelection();
        grid.selectRow(origin.y, origin.y + newY);

        grid.setDragExtent(grid.newPoint(0, newY));

        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();

    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetY) {

        var maxRows = grid.getRowCount() - 1;

        var maxViewableRows = grid.getVisibleRowsCount() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newY = mouseCorner.y + offsetY;
        //var newY = grid.getRowCount();

        newY = Math.min(maxRows, Math.max(0, newY));

        grid.clearSelections();
        grid.selectRow(newY);
        grid.setMouseDown(grid.newPoint(0, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelRowIsVisible(newY, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();

    },

    isSingleRowSelection: function() {
        return true;
    }

});

module.exports = RowSelection;

},{"./Feature.js":63}],70:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ThumbwheelScrolling = Feature.extend('ThumbwheelScrolling', {

    alias: 'ThumbwheelScrolling',

    /**
     * @memberOf ThumbwheelScrolling.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function(grid, e) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var primEvent = e.primitiveEvent;
        var deltaY = primEvent.wheelDeltaY || -primEvent.deltaY;
        var deltaX = primEvent.wheelDeltaX || -primEvent.deltaX;
        if (deltaY > 0) {
            grid.scrollBy(0, -1);
        } else if (deltaY < -0) {
            grid.scrollBy(0, 1);
        } else if (deltaX > 0) {
            grid.scrollBy(-1, 0);
        } else if (deltaX < -0) {
            grid.scrollBy(1, 0);
        }
    }

});


module.exports = ThumbwheelScrolling;

},{"./Feature.js":63}],71:[function(require,module,exports){
'use strict';

module.exports = {
    Feature: require('./Feature'), // abstract base class
    CellClick: require('./CellClick'),
    CellEditing: require('./CellEditing'),
    CellSelection: require('./CellSelection'),
    ColumnAutosizing: require('./ColumnAutosizing'),
    ColumnMoving: require('./ColumnMoving'),
    ColumnResizing: require('./ColumnResizing'),
    ColumnSelection: require('./ColumnSelection'),
    ColumnSorting: require('./ColumnSorting'),
    Filters: require('./Filters'),
    KeyPaging: require('./KeyPaging'),
    OnHover: require('./OnHover'),
    Overlay: require('./Overlay'),
    RowResizing: require('./RowResizing'),
    RowSelection: require('./RowSelection'),
    ThumbwheelScrolling: require('./ThumbwheelScrolling')
};
},{"./CellClick":55,"./CellEditing":56,"./CellSelection":57,"./ColumnAutosizing":58,"./ColumnMoving":59,"./ColumnResizing":60,"./ColumnSelection":61,"./ColumnSorting":62,"./Feature":63,"./Filters":64,"./KeyPaging":65,"./OnHover":66,"./Overlay":67,"./RowResizing":68,"./RowSelection":69,"./ThumbwheelScrolling":70}],72:[function(require,module,exports){
'use strict';

var cssInjector = require('css-injector');

var stylesheets = {
    grid: [
        'div#grid-container {',
        '    position: relative;',
        '    display: inline-block;',
        '    -webkit-user-select: none;',
        '    -moz-user-select: none;',
        '    -ms-user-select: none;',
        '    -o-user-select: none;',
        '    user-select: none;',
        '    overflow: hidden; }',
        'visible { opacity: 0.75; }',
        'hidden { opacity: 0.0; }',
        'editor {',
        '    position: absolute;',
        '    display: none;',
        '    border: solid 2px black;',
        '    outline: 0;',
        '    padding: 0;',
        '    z-index: 1000; }'
    ],
    dnd: [
        'div.dragon-list, li.dragon-pop {',
        '    font-family: Roboto, sans-serif;',
        '    text-transform: capitalize; }',
        'div.dragon-list {',
        '    position: absolute;',
        '    top: 4%;',
        '    left: 4%;',
        '    height: 92%;',
        '    width: 20%; }',
        'div.dragon-list:nth-child(2) { left: 28%; }',
        'div.dragon-list:nth-child(3) { left: 52%; }',
        'div.dragon-list:nth-child(4) { left: 76%; }',
        'div.dragon-list > div, div.dragon-list > ul > li, li.dragon-pop { line-height: 46px; }',
        'div.dragon-list > ul { top: 46px; }',
        'div.dragon-list > ul > li:not(:last-child)::before, li.dragon-pop::before {',
        '    content: \'\\2b24\';', // BLACK LARGE CIRCLE
        '    color: #b6b6b6;',
        '    font-size: 30px;',
        '    margin: 8px 14px 8px 8px; }',
        'li.dragon-pop { opacity:.8; }'
    ]
};

function addStylesheet(key, referenceElement) {
    cssInjector(stylesheets[key], key, referenceElement);
}

module.exports = addStylesheet;

},{"css-injector":2}]},{},[54])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9pbWFnZXMvaW5kZXguanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvY3NzLWluamVjdG9yL2luZGV4LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2V4dGVuZC1tZS9pbmRleC5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5iYXJzL2luZGV4LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbmNhbnZhcy9pbmRleC5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5jYW52YXMvanMvR3JhcGhpY3NDb250ZXh0LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbmNhbnZhcy9qcy9nYy1jb25zb2xlLWxvZ2dlci5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5jYW52YXMvanMvcG9seW1lcmdlc3R1cmVzLmRldi5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3Mvc3JjL2pzL0RhdGFOb2RlQmFzZS5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3Mvc3JjL2pzL0RhdGFOb2RlR3JvdXAuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3NyYy9qcy9EYXRhTm9kZUxlYWYuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3NyYy9qcy9EYXRhTm9kZVRyZWUuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3NyYy9qcy9EYXRhU291cmNlLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9zcmMvanMvRGF0YVNvdXJjZUFnZ3JlZ2F0b3IuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3NyYy9qcy9EYXRhU291cmNlRmlsdGVyLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9zcmMvanMvRGF0YVNvdXJjZUdsb2JhbEZpbHRlci5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3Mvc3JjL2pzL0RhdGFTb3VyY2VJbmRleGVkLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9zcmMvanMvRGF0YVNvdXJjZVNvcnRlci5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3Mvc3JjL2pzL0RhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3NyYy9qcy9pbmRleC5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3Mvc3JjL2pzL3V0aWwvTWFwcHkuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3NyYy9qcy91dGlsL2FnZ3JlZ2F0aW9ucy5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3Mvc3JjL2pzL3V0aWwvaGVhZGVyaWZ5LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9zcmMvanMvdXRpbC9zdGFibGVTb3J0LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2xpc3QtZHJhZ29uL2luZGV4LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9saWIvbHJ1LWNhY2hlLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL211c3RhY2hlL211c3RhY2hlLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL29iamVjdC1pdGVyYXRvcnMvaW5kZXguanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvcmVjdGFuZ3VsYXIvaW5kZXguanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvc3BhcnNlLWJvb2xlYW4tYXJyYXkvaW5kZXguanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvdGVtcGxleC9pbmRleC5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9DZWxsUHJvdmlkZXIuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvSHlwZXJncmlkLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL1JlbmRlcmVyLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL1NlbGVjdGlvbk1vZGVsLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9CZWhhdmlvci5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvQ29sdW1uLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9EYXRhTW9kZWxEZWNvcmF0b3IuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL0pTT04uanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL051bGwuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL2ltYWdlcy5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvaW5kZXguanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvQ2VsbEVkaXRvci5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9DaG9pY2UuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvQ29sb3IuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvRGF0ZS5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9TaW1wbGUuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvU2xpZGVyLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL1NwaW5uZXIuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvVGV4dGZpZWxkLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL2luZGV4LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2RhdGFNb2RlbHMvRGF0YU1vZGVsLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2RhdGFNb2RlbHMvSlNPTi5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mYWtlXzdjMjgwZTk0LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NlbGxDbGljay5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9DZWxsRWRpdGluZy5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9DZWxsU2VsZWN0aW9uLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtbkF1dG9zaXppbmcuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ29sdW1uTW92aW5nLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtblJlc2l6aW5nLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtblNlbGVjdGlvbi5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Db2x1bW5Tb3J0aW5nLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0ZlYXR1cmUuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvRmlsdGVycy5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9LZXlQYWdpbmcuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvT25Ib3Zlci5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9PdmVybGF5LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL1Jvd1Jlc2l6aW5nLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL1Jvd1NlbGVjdGlvbi5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9UaHVtYndoZWVsU2Nyb2xsaW5nLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL2luZGV4LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL3N0eWxlc2hlZXRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy94QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHJFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMva0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25uQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuNEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW5EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3FCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3poQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSB7IC8vIFRoaXMgZmlsZSBnZW5lcmF0ZWQgYnkgZ3VscC1pbWFnaW5lLTY0IGF0IDEwOjA3OjIzIEFNIG9uIDEyLzIvMjAxNVxuXHRcIjEtYWJzLWRvd25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBS0NBWUFBQUNFMlcvSEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBRkZKUkVGVUtGTmpRQUwvb1RURC8vLy9DV0prZ0ZNakVBZ0Q4UTRnTGtNU2d3T3NHb0dnRENRRXhjUnJSRkpJbW8xSUNxbW5FVVNpWUpna01nWUNyRFlpYThUUUJGVklKNmNDQVhKMFFER0REUUQ2N09ZWDl3ZHAwd0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cdH0sXG5cdFwiMS1hYnMtdXBcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBS0NBWUFBQUNFMlcvSEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBRXhKUkVGVUtGUHRqWUVKQUNBSUJOMmhkWnFyMmRxdTN0QjhDNXFnaHpQeGxBUVpKNGlXSjlFOERwQUNPbWg3WmtMTHdvV0ROUEp4U01PTlN3YTVmelNCSnk4ei85QjZScGZWWmFSTzJvby96SlZSRHZJQUFBQUFTVVZPUks1Q1lJST1cIlxuXHR9LFxuXHRcIjEtZG93blwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFLQ0FZQUFBQ0UyVy9IQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd2dBQURzSUJGU2hLZ0FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFHdEpSRUZVS0ZPdGpvRUpnREFRQTZ1aUM3aU9jM1UydDNzVDZVdStYeERCd0ZsaUV0b2lzbllXTTN2RnRRRzZtV1pRMnNFSnF2eTd0UUM2RlV6ZHFMYU1wQ0gxT0IxS2NYZ2pCWjhIRGhTSEV1Q0laZVcvSWNSdndFTUZ5amV5N0hqUUEzMTdLc3ZNSXVXNEFGVFVFZ3ZzKzN3a0FBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcIjEtdXBcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBS0NBWUFBQUNFMlcvSEFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBYWRFVllkRk52Wm5SM1lYSmxBRkJoYVc1MExrNUZWQ0IyTXk0MUxqRXhSL05DTndBQUFGQkpSRUZVS0ZQdGpkc05RQ0VJUTkzQmRaekwyZHdPanc5Q3VWOTNBRW1PSmJZTnhjdzJESEwyUDV3SGNkUjBtQW9EdXZ4RnlYSHpCcnA0VVpRQUVvVXZUTDRvQnBMRHlpdmVYVm5oNVdWS202aVBSOFJiSHhMaEFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcIjItYWJzLWRvd25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBS0NBWUFBQUNFMlcvSEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBSDVKUkVGVUtGT1ZrQXNOZ0RBTVJPY0JCeGpBQUVKd2dBTWNZR0dtc0lBR0xKUzdwaUUzRmpKMnlSdnB4dXMrU1dMeFRXYldSRk9KeUFneXVEZ05EakQ5RVdld0F6Wmd2RWxUVkNKc2hMSmZYRUQzamp3dTc3cEc3VUtCQ3ZIVEFQZ3dXZVk4S241S0xONGk4MVN5eU9PZGdIZnpxTWl4UUJiOUZXdlNkZ05OODcxQUh3YmxWQUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cdH0sXG5cdFwiMi1hYnMtdXBcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBS0NBWUFBQUNFMlcvSEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBSlZKUkVGVUtGTjlrQUVWZ3pBTVJQRXdCek9BZ1FuQndSemdZQlpxQ2d0b3dBTDdsNlZ0SUxCNzd6YzAxeXR0QjdTZlFSciswajh1QXVnSkJUYjVzTUJvbmkvUVlOU1E5MS93QVcwZzJTYnU5VkFsaGlzdWJjU1VlVENzY1lkcmd0OGZnMEhKZ1FyU2NYWFh0ODJEUWNrQmdSNmdoeW10RjB6S01TQlFDMm5TK21FQkpZVjB2QlYwTjFQendpSktDdG9yWm9iNUN5MlJGdlhGUUFLbEFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcIjItZG93blwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFLQ0FZQUFBQ0UyVy9IQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd2dBQURzSUJGU2hLZ0FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFKdEpSRUZVS0ZPRmtBc05BakVRUkFzWE1JQURESndCaE9BQUJ6akF3cG5DQWhxd1VONHMyekpRQ0pPOGJHYTMwMTh4MWF5bDF2cVhwaTNJcldWc3VJY0Y3bXJERldZUFRpQzNnWlVGRDNBQmJTREZKaDZVdW10Qko2V05zQi9CdHVnYnFTTThUN1FCWlF3MGtLNnJ0NTdDMjRBeUJnVGFnVDVtc1Y2ODdZMDJ6QVU5Sk5QN09md1YwdlZ1b0xlRitzd1dVVjZoN01VdmpwVHpBNmZNNlNWVjJDYmdBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCIyLXVwXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQUtDQVlBQUFDRTJXL0hBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQWFkRVZZZEZOdlpuUjNZWEpsQUZCaGFXNTBMazVGVkNCMk15NDFMakV4Ui9OQ053QUFBSXhKUkVGVUtGT1ZrRnNSZ0RBTUJPc0JCeGpBQUVKd2dBTWNZQUZUV0VBREZzcGUraURRSDhqTWNyU1g2eXZFR0EwS1NmOWZTQitrOERCRDZHR0RVeDdzTUdUdkRoVmNjSVFWdElES0ZqSFBOU0gzYm05eWFTR0cvNE1UL041Ung5VmRaeHM3QTJrRGd1cEFEN1BWT1djaXo0Q2dha2lET3U4YWtDYWs0eDJndTFsVnp6VWhUZEJlc1NVc0YvdUhIdTExMGJaUkFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcIjMtYWJzLWRvd25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBS0NBWUFBQUNFMlcvSEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBSlZKUkVGVUtGT05rUUVOaERBTVJlY0JCMmNBQXloQXdUbkFBUTZ3Z0FhOG5JWFRjQmJHZjZOZHVpeUVlOGxqYWRsZk9raUJiR3ZLT1Q4YTZZTGlKWGY1b3kyLzh2MVBjSktiNUFCWUpTKzhMblRCcU1GQkZHT3BqS2ZnSUJsN3Q3cHlHeFErSW5lY1BjaXpNWVo4a3pGTEduWFVHTHdMT1RTNWE2WHVDcUZGTWliM0EycCtUZm1xN0dnTVFVNCt2QzgvVnkrbEV6R2Rvd3dIaVdNMkFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcIjMtYWJzLXVwXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQUtDQVlBQUFDRTJXL0hBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQUp0SlJFRlVLRk9Ga1FFUndqQU1SZXNCQnpPQWdTbVlBaHpnQUFkWW1BYThZQUVOV0lEM1NnTTVzb04vOTVvbTZlK2xXME9QYjVETFR6NmJEUU9hWUlXN2ZiakJvZmZHQVpkT21FWjloak40Z1RxQmpaNi9UVUUyQjBOZVpMTFBEVUkxQkdnSGpyMzJQRFVJMVNBb1J2U05TNitsSnFHYUpHa0JDLzlIM1pERk9SOGdGTk1SSE5QM0tYTi96WlFQRVlyUnIzaXhON2krYXEwOUFSRTcvTExPOEwyNkFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcIjMtZG93blwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFLQ0FZQUFBQ0UyVy9IQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd2dBQURzSUJGU2hLZ0FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFLZEpSRUZVS0ZOMWtRRVJ3akFNUlFzY0dNREJER0JnQ3FZQUJ6akFBUmFtQVM5WVFBTVd5bjhob2RsdC9YZnYwcDgwdVhRclNkWGpYN1hXTHFHVHdPM05OUTFpRmg5Qi9TMnV1ZkVnY0VleEkrRWF4VU13QU4wRjk4S2IyaGpYeG1vTXdsek11VlJmdmlNam5RVnJ6K1pUUVdIZEFGS3N5QnNueTZXaXdyb0praVpCd2xibHNLRFRGQ0k1UnJIWGRCT3N5ZnNRbmw4ejVFc0tyY2x6Zk1Vbk5lZjF5NVh5QllnZHR3bCtMbStMQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwiMy11cFwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFLQ0FZQUFBQ0UyVy9IQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFhZEVWWWRGTnZablIzWVhKbEFGQmhhVzUwTGs1RlZDQjJNeTQxTGpFeFIvTkNOd0FBQUpwSlJFRlVLRk9Oa1FzUndqQVFCZU1CQnpXQWdTcW9BaHpnQUFkWXFBYThZQUVOV0FpNytjQXg2VURmelBhYWUzMlpTNXB5emdWRXFlOTdxQTlLNTh0TWFZSVZubnJ3Z0ZQelBxRk9DTTV3QlRkUUY5Q1k0dTd2d0JaTmJ1VGlHQTNLR09pZ0F6ajJXdGJCb0l3QlFYMUV6N2lVWGpBcFkwaUNGckR4ZjlRTjJaempCNVFoZEFiSDlIekt0Yi9tOTYwaWIvR20xN2pYWGtvdjN6RUV1UTdoMTBvQUFBQUFTVVZPUks1Q1lJST1cIlxuXHR9LFxuXHRcImFkZC1jb2x1bW5cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBWUFBQUFmOC85aEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dRQUFEc0VCdUpGcjdRQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBUFZKUkVGVU9FOWpVS3RuY0FiaS8wUmdad1pzQUNRQlVsRHdPaHdySnRxQTNPZWh5SXJCR0UwTXZ3RlpqNE93WXFqbWM5ck43RnQxbXRrblE5V0xRTFVqREVpLzc0OXNHeGlEeExTYjJONmdpd01OT3dPa0lZWUFHVGpEUUxPUjVSTk1FMHdNeGdjYWZBeElpK0FNQTNRK3VnRlE3SXczREVEaU1JM29HTU1BOURDQThiRnBCbUdvT29RQnliZDhNREJVRVlwQnlHSkFqREFnL3BvbmlpU0lEd3pFcnpBK3VnSGF6V3duZ0RRaUVHTXV1V0hGV2syc0gyQ2FZQmlZSHM0QmFkUm9qRGpyaktJSVRldzhVTk5PM1JiT1dVQjJMUkJqSnFUUWt3NVlNVWdPaXZFbjVhQ2p0bGd4MFFZUWdiRVl3TUFBQUVxcWxTR0NqdytiQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwiYmFja1wiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FZQUFBQWY4LzloQUFBRDhHbERRMUJKUTBNZ1VISnZabWxzWlFBQU9JMk5WZDF2MjFRVVA0bHZYS1FXUDZDeGpnNFZpNjlWVTF1NUd4cXR4Z1pKazZYcFFocTV6ZGdxcE1sMWJocFQxemEyMDIxVm4vWUNid3o0QTRDeUJ4NlFlRUlhRE1UMnN1MEJ0RWxUUVJYVkpLUTlkTnBBYUpQMmdxcHdycTlUdTEzR3VKR3Zmem5uZHo3djBUVkF4MWVhNDVoSkdXRGU4bDAxbjVHUG41aVdPMVloQ2M5QkovUkFwNlo3VHJwY0xnSXV4b1ZIMXNOZkljSGVOd2ZhNi85emRWYXBwd01rbmtKc1Z6MTlIdkZwZ0pTcE82NFBJTjVHK2ZBcDMwSGM4VHppSFM0bWlGaGhlSmJqTE1NekhCOFBPRlBxS0dLV2k2VFh0U3JpSmNUOU16SDViQXp6SElLMUkwOHQ2aHE2ekhwUmR1MmFZZEpZdWs5US84ODFielphOFhyeDZmTG1Kby9pdTQvVlhuZkgxQkIvcm11NVNjUXZJNzdtK0JrbWZ4WHh2Y1pjSlkxNEwwRHltWnA3cE1MNXlUY1c2MVB2SU42SnVHcjRoYWxRdm1qTmxDYTRiWEo1emo2cWhweHJ1amVLUFlNWEVkK3EwMEtSNXlOQWxXWnpyRitJZSt1TnNkQy9NTzR0VE9aYWZoYnJveVh1UjNEZjA4YkxpSHNRZitqYTZnVFBXVmltWmw3bC9vVXJqbDhPY3hEV0xiTlU1RDZKUkwyZ3hrRHUxNmZHdUMwNTRPTWhjbHN5WFRPT0ZFTCtrbU1HczRpNWtmTnVRNjJFbkJ1YW04dHpQK1ErdFNxaHo5U3VxcFpsdlIxRWZCaU9KVFNnWU1NTTdqcFlzQUV5cUpDSERMNGRjRkZUQXdOTWxGRFVVcFFZaWFkaERtWHRlZVdBdzNIRW1BMnMxNWsxUm1uUDRSSHVoQnliZEJPRjdNZm5JQ21TUTJTWWpJQk0zaVJ2a2NNa2k5SVJjbkRUdGh5THoyTGQyZlR6UGpUUUsrTWRnOHk1bmtaZkZPK3NlOUxRcjMvMDl4WnIrNUdjYVN1ZmVBZkF3dzYwbUFQeCtxOHUvYkFyOHJGQ0xyeDdzK3ZxRWt3OHFiK3AyNm4xMUFydXE2bTFpSkg2UGJXR3YxVklZMjVta05FOFBrYVFoeGZMSUY3RFpYeDgwSEQvQTNsMmpMY2xZczA2MXhOcFdDZm9CNldISlRqYkgwbVYzNVEvbFJYbEMrVzhjbmRibDl0MlNmaFUrRmI0VWZoTytGNzRHV1Roa25CWitFbTRJbndqWEl5ZDFlUG5ZL1BzZzNwYjFUSk51MTVUTUtXTXRGdDZTY3BLTDBpdlNNWEluOVF0RFVsajBoN1U3TjQ4dDNpOGVDMEduTUM5MWRYMnNUaXZnbG9EVGdVVmVFR0hMVGl6YmY1RGE5Skxoa2hoMjlRT3MxbHVNY1NjbUJYVElJdDd4UkZ4U0J4bnVKV2Z1QWQxSTdqbnRreWQvcGdLYUl3VnIzTWdtRG8ycTh4NklkQjVRSDE2Mm1jWDdhanRuSEdOMmJvdjcxT1UxK1UwZnFxb1hMRDB3WDVaTTAwNVVIbXlTejNxTHREcUlMRHZJTCtpSDZqQjl5Mng4M29rODk4R09QUVgzbGszSXRsMEErQnJENkQ3dFVqV2gzZmlzNThCWERpZ045eUY4TTVQSkg0QjhHcjc5L0YvWFJtOG0yNDFtdy93dnVyNEJHRGo0MmJ6bitWbWMrTkw5TDhHY01uOEYxa0FjWGdTdGVHR0FBQUJVVWxFUVZRNEVXTmdHTFFnWlkxMmU5b2EvUy9ZSElnc3g0Sk5RZHdpclhhRy80emxqRXlNak9qeTZISk02QXJDSm1yMENRanlWQmdyMkRIKytmTVhSUnFiSElvTGZPcFU1bkVMTXlmS0Nhc3kvUHYvaCtIM2Q0UUJ1T1RnTG5ESWtsL0NJOGFTcUNDdHlQRG15d3VHYjc4K01mejYrZy9zQW54eVlCZFlSRXMvNHBOa2xSVlg0R2Q0OXU0SncvLy8veGs0V1RrWmZuMzV4NEJQRG1RNjJBVy9mL3kvK1B2YmY0WWZQMzh5L1ByeGgrSFg5ejhNWDM1OVp2Z0pkQUUrT2JnQlo5OCtDM3h4N2R2YSs4Yy9NVEN6TVRMOCsvZWY0ZnZQYnd3L1AvMWh3Q2NITjREaEFNT2Y4eHVmaDd5OC9tM1Z3Mk5mR0ZqWW1SaSsvL2dCRE1UL0RIamxnQ2FneE1MRnJTL0M5ZjVJL1B6MzkzK3NyQ2szUEJCQk51R1NRekVBcFBEU3poZHhtbjhrL3YzN3l4RC8rd2NrRmtEaUlJQlBEcUlDaWRSMEVKMnQ3eTBKOUFNbXdDZUhxWnJXSWdBWjRQWUR4ZnRHWWdBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXHR9LFxuXHRcImNoZWNrZWRcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTBBQUFBUENBWUFBQUEvSTBWM0FBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBWUpKUkVGVU9FK05rc3RMZ2xFUXhmMGZhaEcwaUZyVXhtMkVsRkRZTG9oQ3FDRGFDQWtXUGF4SVJiRkZFSkVhR0VLTERDb01FVFJGVUFNTHlhSUhCVUc2c1NLSU10S0ZxRWhMVDgxOFpVZ21EaHp1M0RQbjl6MHVWMVJybVV3bXlHUXlxTlZxZkZ2Vml3Qnh1NVJGUFp1TFN5R01LaHovcWxFc1JWMTlLOHhtNnkrdzdicEJQRm5BZmVyamozYmRRWDZEcEhjQVV3YXZBSFVOMlJHSVp4QkpaSEgybUMvVFVleWR3d1RadkJlZ0xFTk5ndzdzWDZXaDFGc3dObVBFbWpQQ0R5R1JSd0N0VzlFM3RNZ2RBdFF3N0daalljTlgrZ3phMndKM1pYc1NaVXVRMHZXQ09WOFNIZkpKL3VsdWhiSFVqMXY4UEtOTXN6SW9RTlJNSENTaEQ2V2g4enlocmJPUHd6OHcrU1RLbENDSjdvUk5VelFINjNrQnM1dGhCZ2hlUFh4bGoyYVVvU3hEUGN1WFBOaUxBYzVFRVo2SElrYm1WMkRZaVhCUEhzMG8wNzkrSzBEVFZqL3MxMW1FMDBBMEwrZzRWY0RwMTBxS1pNQXp5dEJoTWFUUmFQbVlnODg1RGxjU3pTaWowZW9FaUlvdW9VcWxxcXFhTDJybEVvaytBZDR2bGZ6UG9WRHNBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJjb2xsYXBzZVwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FZQUFBQWY4LzloQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd1FBQURzRUJ1SkZyN1FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFQTkpSRUZVT0U5amNJb3EvWStNR1hDQUNVYzYvNE13bElzQXlKcndHYUEzVWVFL0NFTzVDRUNNQVlFTDNmNEhITENHNEFXdXFHcEFtcEF4VkJnT1FNNDJYNkwyditCMU9CaUQySDBIMjdGYWhBRkFtalVuU1AxUHYrLy9QL2Q1S0JpbjNmUC9yOTR2Z1JFZWNBNnlhL1E3bGYrSG5yRC9uL1U0Q0FXRHhLeW02bUozQmN3Ymhac3ovaXUwQzhFeHlCVWdqQ3hXc0RFZGJnaU1nUklPTURaSWNmSXRIekFHc2NHU3VBRE0rVEFNRWdOcGlyL21DY2E0RE1CcktraFR6Q1UzTUNiYkJSRm5uY0dZa0F2Z21rQUEyWURRa3c1Z1RKUUxvRXdVQTRLTzJvSXhVUVlnWTVBWVNCTXlCaXNjSklDQkFRQ3BST0daNmtxSGZ3QUFBQUJKUlU1RXJrSmdnZz09XCJcblx0fSxcblx0XCJkb3duLWFycm93XCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFVQUFBQUtDQVlBQUFCOE9aUXdBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQVlkRVZZZEZOdlpuUjNZWEpsQUhCaGFXNTBMbTVsZENBMExqQXVOV1dGTW1VQUFBQStTVVJCVkJoWGhZdlJDZ0FnQ0FPdHFQLy80K1dXaHRCREIxZHVxQlVRLzJXNUxMdFNNRnlXMDIwc2t1ZWN3T0dqNlF6Zmt1RXh0MUxsY3FJQ2dHM1M3ei9TTC9qVnBnQUFBQUJKUlU1RXJrSmdnZz09XCJcblx0fSxcblx0XCJkb3duLXJlY3RhbmdsZVwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBa0FBQUFFQ0FZQUFBQmNEeFhPQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFhZEVWWWRGTnZablIzWVhKbEFGQmhhVzUwTGs1RlZDQjJNeTQxTGpFeFIvTkNOd0FBQUJwSlJFRlVHRmRqZ0lML2VEQUtJS2dBQmdncWdBRTBCUXdNQVBUbEQvRnBpMEpmQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwiZG93blwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FZQUFBQWY4LzloQUFBRDhHbERRMUJKUTBNZ1VISnZabWxzWlFBQU9JMk5WZDF2MjFRVVA0bHZYS1FXUDZDeGpnNFZpNjlWVTF1NUd4cXR4Z1pKazZYcFFocTV6ZGdxcE1sMWJocFQxemEyMDIxVm4vWUNid3o0QTRDeUJ4NlFlRUlhRE1UMnN1MEJ0RWxUUVJYVkpLUTlkTnBBYUpQMmdxcHdycTlUdTEzR3VKR3Zmem5uZHo3djBUVkF4MWVhNDVoSkdXRGU4bDAxbjVHUG41aVdPMVloQ2M5QkovUkFwNlo3VHJwY0xnSXV4b1ZIMXNOZkljSGVOd2ZhNi85emRWYXBwd01rbmtKc1Z6MTlIdkZwZ0pTcE82NFBJTjVHK2ZBcDMwSGM4VHppSFM0bWlGaGhlSmJqTE1NekhCOFBPRlBxS0dLV2k2VFh0U3JpSmNUOU16SDViQXp6SElLMUkwOHQ2aHE2ekhwUmR1MmFZZEpZdWs5US84ODFielphOFhyeDZmTG1Kby9pdTQvVlhuZkgxQkIvcm11NVNjUXZJNzdtK0JrbWZ4WHh2Y1pjSlkxNEwwRHltWnA3cE1MNXlUY1c2MVB2SU42SnVHcjRoYWxRdm1qTmxDYTRiWEo1emo2cWhweHJ1amVLUFlNWEVkK3EwMEtSNXlOQWxXWnpyRitJZSt1TnNkQy9NTzR0VE9aYWZoYnJveVh1UjNEZjA4YkxpSHNRZitqYTZnVFBXVmltWmw3bC9vVXJqbDhPY3hEV0xiTlU1RDZKUkwyZ3hrRHUxNmZHdUMwNTRPTWhjbHN5WFRPT0ZFTCtrbU1HczRpNWtmTnVRNjJFbkJ1YW04dHpQK1ErdFNxaHo5U3VxcFpsdlIxRWZCaU9KVFNnWU1NTTdqcFlzQUV5cUpDSERMNGRjRkZUQXdOTWxGRFVVcFFZaWFkaERtWHRlZVdBdzNIRW1BMnMxNWsxUm1uUDRSSHVoQnliZEJPRjdNZm5JQ21TUTJTWWpJQk0zaVJ2a2NNa2k5SVJjbkRUdGh5THoyTGQyZlR6UGpUUUsrTWRnOHk1bmtaZkZPK3NlOUxRcjMvMDl4WnIrNUdjYVN1ZmVBZkF3dzYwbUFQeCtxOHUvYkFyOHJGQ0xyeDdzK3ZxRWt3OHFiK3AyNm4xMUFydXE2bTFpSkg2UGJXR3YxVklZMjVta05FOFBrYVFoeGZMSUY3RFpYeDgwSEQvQTNsMmpMY2xZczA2MXhOcFdDZm9CNldISlRqYkgwbVYzNVEvbFJYbEMrVzhjbmRibDl0MlNmaFUrRmI0VWZoTytGNzRHV1Roa25CWitFbTRJbndqWEl5ZDFlUG5ZL1BzZzNwYjFUSk51MTVUTUtXTXRGdDZTY3BLTDBpdlNNWEluOVF0RFVsajBoN1U3TjQ4dDNpOGVDMEduTUM5MWRYMnNUaXZnbG9EVGdVVmVFR0hMVGl6YmY1RGE5Skxoa2hoMjlRT3MxbHVNY1NjbUJYVElJdDd4UkZ4U0J4bnVKV2Z1QWQxSTdqbnRreWQvcGdLYUl3VnIzTWdtRG8ycTh4NklkQjVRSDE2Mm1jWDdhanRuSEdOMmJvdjcxT1UxK1UwZnFxb1hMRDB3WDVaTTAwNVVIbXlTejNxTHREcUlMRHZJTCtpSDZqQjl5Mng4M29rODk4R09QUVgzbGszSXRsMEErQnJENkQ3dFVqV2gzZmlzNThCWERpZ045eUY4TTVQSkg0QjhHcjc5L0YvWFJtOG0yNDFtdy93dnVyNEJHRGo0MmJ6bitWbWMrTkw5TDhHY01uOEYxa0FjWGdTdGVHR0FBQUJWMGxFUVZRNEVXTmdHR2pBaU0wQkl0bDgvN21GR0JoK2ZXZGcrQS9FTVBCaTZpY005U3d3U1dSYTFveUhJVGJLanVIZW05c1E0YThNREh0WFBtQjRnYXdJeXNacXdLL3YveGs0djNJdy9BQnFCQUVPSVA3MUE4ekVJSmd3UklBQ2JKeU1ESnhjSUcyRUFWWVhRTFJ4Z20wR3M3blpHZGh3bUlmZEFDNVdCazVXVGdZR29FWVFBTElZZm9OWm1BVGNBSXVGeHY5ZmZyL053QXJVTENiTHhuRDN6M1VHTGk1Mmh2L2ZmaktBSW9LSGs0MUJ2cFh2UDhnSVFVNVpoZ3RGVjhFeGdoSXRoZ3RWLzNmSHBURThZYmpMY1BmVFRZYWZRTVVnQTJDQUEyamd1dVgzR0s1bVBJVHJnek5naXRRV1N2MmZGbGZJY09yUE1ZWVAzejdBaEJsQW5sbTUvQWJEcll6bktIb3dZdUZXL0RQR3JFWDlER1lzemd3Q1FCdEJHa0gweWcwM01UVERUY2ZHME4waTlmL28veW4vRi94UCtLKytXZ3JzZDJ6cThJbzVuTkQ1N3c3RWVCVVJrcXk1VUVtWkFZUXNBQURiT1dEVEF4Qm1rUUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cdH0sXG5cdFwiZW1wdHlcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkNBWUFBQUFmRmNTSkFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWWRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU5XV0ZNbVVBQUFBTlNVUkJWQmhYWS9qLy96OERBQWo4QXY2SVh3YmdBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJleHBhbmRcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBWUFBQUFmOC85aEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBUTlKUkVGVU9FOWpjSW9xL1krTWdZQ0JGQXcyQU1haG1RRUs3VUwva1RHeUhGRmVBR2tLT21vTHhoZ0dJSE53WVpDbTBKTU9ZSXpWQUNDQUMySnpFVWhUeEZsbk1DYm9BbVJ2SUJzUWM4a05qUEc2QUVUak1pRCttaWNZRStVQ1pBd1NBMmxLdnVVRHhuaGRnSXdMTnFXREZjTncrbjEvTUVZV0s5aVlqcW9KaEdFMk84UVUvRmRwbFBzZmVzTCtmOWJqSUJRTUVyT2FxZ3RVanVZQ0VBMXpOZ2hicHlUODE1d2dCYlk1NzBYby85em5vZi9UN3ZuL1YrK1grTjkzc0IyaUI2WVlocEVOQUxGQkNzMlhxUDB2ZUIwT3hpQTJURE1JbzJnR1laZ1hZQmdrRnJqUTdYL0FBV3NJWHVBS0ZvTmhGTTM0c041RWhmOGcvUGo5UXlBWElZNmlDQjhHT1J2WjZSRDhud0VBL1pTYm1MQ1JoRW9BQUFBQVNVVk9SSzVDWUlJPVwiXG5cdH0sXG5cdFwiZmlsdGVyLW9mZlwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFNQ0FZQUFBQlNnSXphQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFZZEVWWWRGTnZablIzWVhKbEFIQmhhVzUwTG01bGRDQTBMakF1TldXRk1tVUFBQUNoU1VSQlZDaFR6WkhCQ29VZ0ZFVDlUcUVpc2tneVdvdXRRdlJMUklyK2NSN1hRQWppSlcvMUJnWm1NVWV2WHNZNXh5OU9vREVHTWNZaVV6ZUI2N3FpYlZ1d1FqVk5BNjMxMVYrV0JlTTR2c0xETUVBcGRlLzFmWTlwbXRJNDUzbmVIRUtBbEJKZDF6MGZYdGMxNlBiak9ESzA3enZtZVVaVlZkOG5vb2M3NXpKSU9YM0dtNmkwYlZzR0tmOHhLSVJJdXlKVExnSkozbnZRenNqVzJnZUlzUS9wcjloTVZyU25jQUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cdH0sXG5cdFwiZmlsdGVyLW9uXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQU1DQVlBQUFCU2dJemFBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQVlkRVZZZEZOdlpuUjNZWEpsQUhCaGFXNTBMbTVsZENBMExqQXVOV1dGTW1VQUFBQ29TVVJCVkNoVFkzQnFmUDJmSEF6V21EYmo3ZjhwMjk0UmhWT0Jhc0VhMDJlKy9lL1ZCbVFRQ1R4YVgvOVBudllHb2o1eXdwdi9RZDJFTmZ0M3Z2NGYxZ2ZWQkFQK25XLytoL2ErQVR0bjFxNzNLSGp5dHZkZ2czMDcwRFRCZ0h2TDYvOGcyMmZzUUdpYURtU0hBMjF4YXliZ0lwREhpeGE4aFdzc25BOE5ERUlBcENoM0xrSWppRDJJTllKQ0wyWDZXM0I4Z2RoRWFRUUJVT0NBNGd5RTgrZTl4YUtKZ1FFQS83NEJORTNjRWxrQUFBQUFTVVZPUks1Q1lJST1cIlxuXHR9LFxuXHRcImZvcnRoXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQU1BQUFBb0xROVRBQUFBQjNSSlRVVUgxd2tiQ3hVN3d3elVDUUFBQUFsd1NGbHpBQUFld1FBQUhzRUJ3MmxVVXdBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFDY1VFeFVSUUFBQURoVUgzQ3ZPSGEzTzJpZ05EWlJIbDJPTHpoVUh6dFlJRkY3S2o1ZElVQmdJa05sSkVodEpYaTRQbmEyT3oxY0lVTmxKRWh0Sms5NEtWRjhLbE4vSzFTQksxV0NMRmFFTFZxSkxseU9MMStTTUdPWU1tbWlOR21qTkcrc04yK3ROM0d2T0hLd09IS3hPWE96T1hTME9uUzFPblcyTzNlM1BYaTRQbjI4UkgrOVJvQytSNGJDVUluRFZKSEhYcHZNYTV6TmJxVFJlYWJTZlZoZmdrUUFBQUFRZEZKT1V3QUVoNGVPbTU2Z29xU3ByTFBpOVA2NHlQZW9BQUFBWmtsRVFWUVkwNDNGUndLQ01BQUF3VVZBcVZZVXBBallZNlA5LzI5ZUF1U21jeG40YmE2ckFXSXhVUUl1M2RNWUEvSzJPVTZIZ0VQOXFUSzdEMGlydTNnbHZneUkzK1ZKN0QwWnNIc1V0OGpWWk1EbWVnNmRJV0JkYnEweFlCWE1sSUNscWZhSEwzSFNDNkdaS2liRUFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcInBhdXNlXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQVlBQUFBZjgvOWhBQUFCM2tsRVFWUTRqWDJUejBzYlVSekUzd1k4eEgrajNpMWV2QlNyVWhwUlFVd1VSZnhaSWlyRUVpRjRrMWlxWUMvVkZqd0k0c21ZbEJhQ2xxSUhxVEZvakttbVpxMmdvZGdXdmVqQlFnVi9ScVp2TnVFUll0WUhBOFBNN09mMFhTSDRMRkllS1ovVVhFYjByeDdJQzBYV0s1WHlDNnZtMTRLV2dIWmx5RzhKU2xubFJ6bTVsczVyc3dGbEJyM2JGcTdFejlRVy9xUitvQ1pzQXpPcUpsd2xzejNaYllNYkk3Zm5BdnhpeUszM0lIbTNnVjkzT3hqVTNaQ1psNkwvTFROMmJyMlgrWkJ3WkFPZXBnRXY5VzdzM1lhUVRFWGgwZnZUZ0lEdzBpZFRtN0piQlRjR29DRVB3SlhvUXZ4NkVidlhYekdRNkZNQSt0MmJGYU56SlY2WUEzcS90Mkg5NGlOaWx3dm8zM0VxQUgzczhqTWlGNS9BalNuQUdXL0c4cjhaaE01bjBSZHZWd0Q2MExuUDZMZ3hCWFJ1MlRGL05vNHZmeWZoM0c1V0FIcG04MmNUNE1ZVTBCcXJoZS9FaThESkNEcSsxU3NBL1lmVFVka05neHRUUUZQME9hYU8zSmcrOXFBbFdxMEE5TXpZY1hNZmtMa0RSNlFjYnc4N01YSG9SR1BrbWJvRGVtYnNISkdLUEhlUUFkU3RQY0hyQXp0R0R4cFJ2MWFtQVBUTTJIR1RIeURQczNqcEVjYjIyL0JtdngyUGw0clVLZE16WThmTi9WTXVNUUJXU1E1cUFYRkYwZk1ITTgxdEl1ZDFTTDJUZXA4UnZldUJ2Q0Q5Mlg5TmVYa1dPSEY3MmdBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXHR9LFxuXHRcInBsYXlcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBWUFBQUFmOC85aEFBQUFCR2RCVFVFQUFOanI5UndVcWdBQUFDQmpTRkpOQUFDSER3QUFqQTBBQVBtVEFBQ0U1UUFBZTRJQUFPdDFBQUEvdEFBQUlsaDFhMTZjQUFBRDhHbERRMUJKUTBNZ1VISnZabWxzWlFBQVNNZU5WZDF2MjFRVVA0bHZYS1FXUDZDeGpnNFZpNjlWVTF1NUd4cXR4Z1pKazZYcFFocTV6ZGdxcE1sMWJocFQxemEyMDIxVm4vWUNid3o0QTRDeUJ4NlFlRUlhRE1UMnN1MEJ0RWxUUVJYVkpLUTlkTnBBYUpQMmdxcHdycTlUdTEzR3VKR3Zmem5uZHo3djBUVkF4MWVhNDVoSkdXRGU4bDAxbjVHUG41aVdPMVloQ2M5QkovUkFwNlo3VHJwY0xnSXV4b1ZIMXNOZkljSGVOd2ZhNi85emRWYXBwd01rbmtKc1Z6MTlIdkZwZ0pTcE82NFBJTjVHK2ZBcDMwSGM4VHppSFM0bWlGaGhlSmJqTE1NekhCOFBPRlBxS0dLV2k2VFh0U3JpSmNUOU16SDViQXp6SElLMUkwOHQ2aHE2ekhwUmR1MmFZZEpZdWs5US84ODFielphOFhyeDZmTG1Kby9pdTQvVlhuZkgxQkIvcm11NVNjUXZJNzdtK0JrbWZ4WHh2Y1pjSlkxNEwwRHltWnA3cE1MNXlUY1c2MVB2SU42SnVHcjRoYWxRdm1qTmxDYTRiWEo1emo2cWhweHJ1amVLUFlNWEVkK3EwMEtSNXlOQWxXWnpyRitJZSt1TnNkQy9NTzR0VE9aYWZoYnJveVh1UjNEZjA4YkxpSHNRZitqYTZnVFBXVmltWmw3bC9vVXJqbDhPY3hEV0xiTlU1RDZKUkwyZ3hrRHUxNmZHdUMwNTRPTWhjbHN5WFRPT0ZFTCtrbU1HczRpNWtmTnVRNjJFbkJ1YW04dHpQK1ErdFNxaHo5U3VxcFpsdlIxRWZCaU9KVFNnWU1NTTdqcFlzQUV5cUpDSERMNGRjRkZUQXdOTWxGRFVVcFFZaWFkaERtWHRlZVdBdzNIRW1BMnMxNWsxUm1uUDRSSHVoQnliZEJPRjdNZm5JQ21TUTJTWWpJQk0zaVJ2a2NNa2k5SVJjbkRUdGh5THoyTGQyZlR6UGpUUUsrTWRnOHk1bmtaZkZPK3NlOUxRcjMvMDl4WnIrNUdjYVN1ZmVBZkF3dzYwbUFQeCtxOHUvYkFyOHJGQ0xyeDdzK3ZxRWt3OHFiK3AyNm4xMUFydXE2bTFpSkg2UGJXR3YxVklZMjVta05FOFBrYVFoeGZMSUY3RFpYeDgwSEQvQTNsMmpMY2xZczA2MXhOcFdDZm9CNldISlRqYkgwbVYzNVEvbFJYbEMrVzhjbmRibDl0MlNmaFUrRmI0VWZoTytGNzRHV1Roa25CWitFbTRJbndqWEl5ZDFlUG5ZL1BzZzNwYjFUSk51MTVUTUtXTXRGdDZTY3BLTDBpdlNNWEluOVF0RFVsajBoN1U3TjQ4dDNpOGVDMEduTUM5MWRYMnNUaXZnbG9EVGdVVmVFR0hMVGl6YmY1RGE5Skxoa2hoMjlRT3MxbHVNY1NjbUJYVElJdDd4UkZ4U0J4bnVKV2Z1QWQxSTdqbnRreWQvcGdLYUl3VnIzTWdtRG8ycTh4NklkQjVRSDE2Mm1jWDdhanRuSEdOMmJvdjcxT1UxK1UwZnFxb1hMRDB3WDVaTTAwNVVIbXlTejNxTHREcUlMRHZJTCtpSDZqQjl5Mng4M29rODk4R09QUVgzbGszSXRsMEErQnJENkQ3dFVqV2gzZmlzNThCWERpZ045eUY4TTVQSkg0QjhHcjc5L0YvWFJtOG0yNDFtdy93dnVyNEJHRGo0MmJ6bitWbWMrTkw5TDhHY01uOEYxa0FjWGhMdTdpUEFBQUFDWEJJV1hNQUFBN0RBQUFPd3dISGI2aGtBQUFBR0hSRldIUlRiMlowZDJGeVpRQndZV2x1ZEM1dVpYUWdOQzR3TGpWbGhUSmxBQUFCUEVsRVFWUTRUMk1BZ2FvVFl1SmdCcm1nK3JoY1h1cENtZjlGZTJURG9VS2tnWXBEQ2hrZ0ErcE9LZjR2MmlsM3FXQzNwQ1pVaWpoUUJqVWc2S2p0LzlDVER2K3JEaXY4ejlza3V6UmhQZ01IVkFsK1VMd1gxWUNJczg3L1l5NjUvUy9lcmZBL1o3MU1HVlFaYmxDNFN4YXJBZkhYUFA4bjMvSUJ1a2J1ZGZZNktWZW9ja3hRdUJtL0FlbjMvZjluUFE3Nm43VksrbkRHS21GcHFEWUV5TmxJbkFHNXowUC9GN3dPLzUrNVZIb21TdmprckpRbXlZRFVSZEpiWTNlS2MwTzFNekNrTHlmT2dLVDUwcmRTbDBvYlFMVWhBTkJFdkFha0xKRCttVFJiSWc2cUhCTUFUY1pxUU1vaW1mK3gweVg3b01wd2c0UlpraWdHZ05neGt5WDNKMHdWbFlBcXdROFNaa0FNU0ZzaTh6OTZvdFN6MkVrUzlsQXA0a0RjTktuY3VLbFMvOE43SlBPaFFxU0I2RWxDTW00bFNORkNOR0JnQUFBWSt2N3JqNWorU2dBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXHR9LFxuXHRcInJlY3RhbmdsZS1zcGFjZXJcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQWtBQUFBRUNBWUFBQUJjRHhYT0FBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dRQUFEc0VCdUpGcjdRQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBQTFKUkVGVUdGZGpHSFNBZ1FFQUFKUUFBWThMdkxFQUFBQUFTVVZPUks1Q1lJST1cIlxuXHR9LFxuXHRcInJlc2V0XCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQVlBQUFBZjgvOWhBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQVlkRVZZZEZOdlpuUjNZWEpsQUhCaGFXNTBMbTVsZENBMExqQXVOV1dGTW1VQUFBTDhTVVJCVkRoUGJaTFpUeE5SRk1ibkR6RDY1QnN1ckMydFNGbEVOaUc0RUFSQmd1eklHa0JEd0tBc0lxQStFQUlFNDVKZ29nYUN4cmRxZ2lRbXhoQVZqV0lFcEVpb0NoUktVR21aVHBlWmFTbFE2T2Vkb1ZZeG5PU1hlODkzdm5QdnpjbWwvbytWNFdHSnJiT21nbSt0VkxKTitVcWVZTDFacCtUYkxweTFxejd1ZDltMkQrdTl0anErcVlUbUxtYlp1VXZaSU9zbU5UbkNhdU92bFd1WDc3ZEh1dXgvd3pRNnNJdnJiT3ppS3JQQmxxYTY0WnNyd0Y4dTI2SnhsNHBnN1dwcHh1U2JIYTUyaXVKcnk5clpndE93WkNkc1VwZ0tDOG5YdFJxc0RRMlN4Z3hZOHBQZGRaYlUyZHJTYXJIWmRxc2p4WFRxcU5sOE1oWUNYRWtPMWo1OUFGZWVENmZGRE1jWEZhemtRc2VFQ214QnV1Z1JPWk13dFhLclEwS3hSZGw5NW1QUk1NZEZnaTNLeFladUVXdGpuMkZKVDRIVFRBNFlId043cmdUcjgvUGtrSEZZVWhORnJ6a2hqcnlzc0lneVJrV09tWUtEWUFvTHhVci9NemlOUm1JNkRVRnpta3h3akk2SWUwdFdKcHdNQSs1S0Ewd2h3YUptU2tycXBnd1N1WnFSeUdBTWp5WTNxMkJYUGdFamtSTmtaQVphckw1NkxlNEZiZlhsQUd3OXZUQUdLRVROS0ExUVVreG9sSlgyOElFaE9BSnI0eE93UGVpQmtBc3dNU2ZBaE1lNmMvdlRQdGdlUGdidExSZHpZMG82VGVtODVXcmRIbC9vcFlGWWZmZWV2R0ljK24xK0VMUi9FVFRIdCsvZ1dqdWc4NVNLR3EwSVUxSy81Q0Z2Zis3MWd3RFhjUU5PK3dyTURWZkYvRis0enR2WUlQTXhaT1M2dGFYNDVCWktuNVoxZDhITGYzMkJDQXYrQ2xpZnY4QTZUWU85Y3hkMFRpRU1CYVd3a2FkdnNCelk3bDRzK01naGVIL0lndXgwV2s0aXhkVFhlOHdkREJ2UzdKZENZRTRXREgxdEE1YUhSK0F3TUhEbzllREo4SFRucXpBclZZZ2VBVzFRaEpLcHVyNVQvRXlXbmtmSFo4bXdwa2hCWU5wTGhwa0RJZEFvRG92TXlJSXc1ZW52cnM4ZUljTjkwQnN1TnYrSnhab3I2ZE9Ib3JXVFBuS25tZ3hwTzc3NkhuQm9ZdUpWUzdlN29sMXRXMk8rK0p4c05pT3ZjVElrWWxCTmJwN3c4c2VFdHd6ZkltS2hEanpVcjhuTXExNHNydHJ0c3BPZ3FOOXdhMFl2Y3d6VXVRQUFBQUJKUlU1RXJrSmdnZz09XCJcblx0fSxcblx0XCJzb3J0YWJsZVwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFLQ0FZQUFBQ0UyVy9IQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFZZEVWWWRGTnZablIzWVhKbEFIQmhhVzUwTG01bGRDQTBMakF1TldXRk1tVUFBQUF4U1VSQlZDaFRZOEFEL2tOcGtnQklFd3dURFpBMUVhMFpteVlZSG1RQW14TmhtQ0FnU3hNTWtLVUpCdkJvWW1BQUFKQ1hIK0ZVMVQ4K0FBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcInN3YXBcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBWUFBQUFmOC85aEFBQUFCR2RCVFVFQUFLL0lOd1dLNlFBQUFCbDBSVmgwVTI5bWRIZGhjbVVBUVdSdlltVWdTVzFoWjJWU1pXRmtlWEhKWlR3QUFBSTlTVVJCVkRqTHBaTkJTOVJoRU1aL3U2MGFaQWROU1hkTHJjeE5TODJEYVJRVlJCQ1VHbmd3d2tPbnZrQjB5RXQwcXkvUUtTcnE1RFVTUWdMVFNpMDFkODBnY3JYU1RUZFRWaVRVLy8rZGVkOE9SaWhGWUQ0d2wrRmhZT1kzVDhBNXgyWVUzSWo1NHFPbXA4MzN6bVgrMTRDV2g0MzF2bTlPR3MrOFc5c1BYT200OUhzSHF4YXJGaFhiWjlXMkVReGVFQ05ueFVoMFcyWTJrZHdJY3d0ekpDYkhZOCt1dmFnQkNBRzBWbDNHNFhET1laMWpiUGJqMGZmSjBTNnhRclQ0QUZzenN4QzFxRlB5Y3ZKWVhsNDVmT3hHN2N0WE53ZU9CNTF6V0J6VzJWK2w3TW5iUzIxSkxlbUZOQm1oREl3SXhocU1Hb3dLeGdqR054a0FJU3VXQjIvdW9xSUU3UmIyNTVkeE1IS0luTzA3Q0xrTXhwTVRwT1pubUU3TkVONFpRVVZJVEl5UEROeUsxd0VFMW1Kc3VkK1FMVWF2bDRjcjJvNUU2NGdsaHVtSjlhZzYyOVRWMXR0UmQ3VkdOV1EvRGQ2T2wvNlZnZ3VDRFRqaVl6R1d2Q1dpUmVYNFB3eGUyZ1BBWC9MeDVyeDFkQUt0N2MxT2pDQkdjT0lveUMxa01iMUlXVGpLdnFKU0pxYkdHUjZOazBna09CaXRRTVF5TkRnMGttai9YQTBRTXI3aFJQa3AxQ2xxQmJIS1hOWTg4UTl4aW5lVkVDNklVRmdRd1o2MnFGVXNGbS9GcTlwOVB2eDY2c2wwWGRENDZ5OHNLaXd1TFpMNi9vM252ZDNNcCtjUko0Z1Z4Q2xpRlJGRmpCcUFRTU9kTTA2TVlIeEIvRlZFWXFSUFBHM3owLzdxSS9rYXpjL1BwN0s2a3VTWEpFUDliMk16bmJNMWYxRDRsNG9hSS9VcTJxVmlKMU9kczlFTloySHk4ZGQrTmRxdFJpdlhVZGhzbkg4Q242UnN0Q00wMUg0QUFBQUFTVVZPUks1Q1lJST1cIlxuXHR9LFxuXHRcInVuY2hlY2tlZFwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBMEFBQUFQQ0FZQUFBQS9JMFYzQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd2dBQURzSUJGU2hLZ0FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFSQkpSRUZVT0UrOWtydHVnMUFRUlBsZFNpbzdGUTF0WkltT2tvS09Cb21HVDBFVVJDNWlubzU0eVR3OTBXeXdRaFRrSWtWV0dvRjJ6dXhkcmxEK3QwelRoS1pwVDBWbXhiOENRUkNnNnpyMGZiOHJlcjd2ZndjUHh4ZGNyeCtZcGduelBHTlpsaDlpYnh4SGxHVUpzaExTZFYwYXQ5dE5wZzdESUJyWDUrT2tQTTlCVmtLR1lTQkpFdFIxamJackJkaXFiVnRVVllVMFRVRldRcStuRStJNHh2dmxJbUdhVzdGSGp3eFpDVm1XaGJmekdWbVdvU2dLV1hVcjl1aVJJU3NoeDNGa0VsZG9tdWJYYXV6UkkwTldRcDdueVVSK05HL3Jmci9qVVh4bmp4NXZtS3lFYk51V294OVh2aWQ2Wk1oSzZIQTR3blZkaEdHSUtJcDJSWThNV1FteCtKdW9xdnBVWkZiOEw2VW9ueVlMM3VPdHJGSCtBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJ1cC1hcnJvd1wiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBVUFBQUFLQ0FZQUFBQjhPWlF3QUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFZZEVWWWRGTnZablIzWVhKbEFIQmhhVzUwTG01bGRDQTBMakF1TldXRk1tVUFBQUE5U1VSQlZCaFhiWXZSQ2dBZ0NBT3RxUC8vWTl0RWx3OE5EcmNEemQwREJDZDdpU0wzRTBJdkdPcGYyZktYZVpVRktEY1lGTXdCbEROV1M3NmJYVU01UDlJbjVBenlBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJ1cC1kb3duLXNwaW5cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBUENBWUFBQURVRlA1MEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dRQUFEc0VCdUpGcjdRQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBR0pKUkVGVU9FK2xrd0VLQUNFSUJIMlpiL1BuSHNvR2VhVkpEVWpHT2dSUnBLcGtpSWoreTRNTUUzZURSN2thS09WTnNKeU1OaklIekd5OVluVzZKN3FJY3JyaVFpbWVDcU9STkFCZDBmcFJUa3Q4dVZVajdFc3hDNnZzL3EzZS9RNmlEMmJ3bkJ5alBYSE5BQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJ1cC1kb3duXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQVBDQVlBQUFEVUZQNTBBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93UUFBRHNFQnVKRnI3UUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQUdGSlJFRlVPRStsa2tFS1FDRUlSRDJaSjNQaDNpTjRXRDlHZmxwWWhqMFlZb3dwR2dKbWJpa2QzZ2pNREZva3didVQxaUFpdXJHNW5vbWdxbzVRYVBvOUVSUVJJNkpmN3NmR2p1ZHkyamUyMytpMFdsMm9RODVUT2RsZnJKUU9hekY4YnIrcnFUWFFLbjBBQUFBQVNVVk9SSzVDWUlJPVwiXG5cdH0sXG5cdFwidXAtcmVjdGFuZ2xlXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFrQUFBQUVDQVlBQUFCY0R4WE9BQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJwMFJWaDBVMjltZEhkaGNtVUFVR0ZwYm5RdVRrVlVJSFl6TGpVdU1URkg4MEkzQUFBQUhrbEVRVlFZVjJQQUF2NURhWndBcEFDR3NRSmtCVmdWWWxNQXhRd01BQk9yRC9HdlArRVdBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJ1cFwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FZQUFBQWY4LzloQUFBRDhHbERRMUJKUTBNZ1VISnZabWxzWlFBQU9JMk5WZDF2MjFRVVA0bHZYS1FXUDZDeGpnNFZpNjlWVTF1NUd4cXR4Z1pKazZYcFFocTV6ZGdxcE1sMWJocFQxemEyMDIxVm4vWUNid3o0QTRDeUJ4NlFlRUlhRE1UMnN1MEJ0RWxUUVJYVkpLUTlkTnBBYUpQMmdxcHdycTlUdTEzR3VKR3Zmem5uZHo3djBUVkF4MWVhNDVoSkdXRGU4bDAxbjVHUG41aVdPMVloQ2M5QkovUkFwNlo3VHJwY0xnSXV4b1ZIMXNOZkljSGVOd2ZhNi85emRWYXBwd01rbmtKc1Z6MTlIdkZwZ0pTcE82NFBJTjVHK2ZBcDMwSGM4VHppSFM0bWlGaGhlSmJqTE1NekhCOFBPRlBxS0dLV2k2VFh0U3JpSmNUOU16SDViQXp6SElLMUkwOHQ2aHE2ekhwUmR1MmFZZEpZdWs5US84ODFielphOFhyeDZmTG1Kby9pdTQvVlhuZkgxQkIvcm11NVNjUXZJNzdtK0JrbWZ4WHh2Y1pjSlkxNEwwRHltWnA3cE1MNXlUY1c2MVB2SU42SnVHcjRoYWxRdm1qTmxDYTRiWEo1emo2cWhweHJ1amVLUFlNWEVkK3EwMEtSNXlOQWxXWnpyRitJZSt1TnNkQy9NTzR0VE9aYWZoYnJveVh1UjNEZjA4YkxpSHNRZitqYTZnVFBXVmltWmw3bC9vVXJqbDhPY3hEV0xiTlU1RDZKUkwyZ3hrRHUxNmZHdUMwNTRPTWhjbHN5WFRPT0ZFTCtrbU1HczRpNWtmTnVRNjJFbkJ1YW04dHpQK1ErdFNxaHo5U3VxcFpsdlIxRWZCaU9KVFNnWU1NTTdqcFlzQUV5cUpDSERMNGRjRkZUQXdOTWxGRFVVcFFZaWFkaERtWHRlZVdBdzNIRW1BMnMxNWsxUm1uUDRSSHVoQnliZEJPRjdNZm5JQ21TUTJTWWpJQk0zaVJ2a2NNa2k5SVJjbkRUdGh5THoyTGQyZlR6UGpUUUsrTWRnOHk1bmtaZkZPK3NlOUxRcjMvMDl4WnIrNUdjYVN1ZmVBZkF3dzYwbUFQeCtxOHUvYkFyOHJGQ0xyeDdzK3ZxRWt3OHFiK3AyNm4xMUFydXE2bTFpSkg2UGJXR3YxVklZMjVta05FOFBrYVFoeGZMSUY3RFpYeDgwSEQvQTNsMmpMY2xZczA2MXhOcFdDZm9CNldISlRqYkgwbVYzNVEvbFJYbEMrVzhjbmRibDl0MlNmaFUrRmI0VWZoTytGNzRHV1Roa25CWitFbTRJbndqWEl5ZDFlUG5ZL1BzZzNwYjFUSk51MTVUTUtXTXRGdDZTY3BLTDBpdlNNWEluOVF0RFVsajBoN1U3TjQ4dDNpOGVDMEduTUM5MWRYMnNUaXZnbG9EVGdVVmVFR0hMVGl6YmY1RGE5Skxoa2hoMjlRT3MxbHVNY1NjbUJYVElJdDd4UkZ4U0J4bnVKV2Z1QWQxSTdqbnRreWQvcGdLYUl3VnIzTWdtRG8ycTh4NklkQjVRSDE2Mm1jWDdhanRuSEdOMmJvdjcxT1UxK1UwZnFxb1hMRDB3WDVaTTAwNVVIbXlTejNxTHREcUlMRHZJTCtpSDZqQjl5Mng4M29rODk4R09QUVgzbGszSXRsMEErQnJENkQ3dFVqV2gzZmlzNThCWERpZ045eUY4TTVQSkg0QjhHcjc5L0YvWFJtOG0yNDFtdy93dnVyNEJHRGo0MmJ6bitWbWMrTkw5TDhHY01uOEYxa0FjWGdTdGVHR0FBQUJWVWxFUVZRNEVXTmdvRFdvdVZENUg1OGRUUGdrSFU3by9ELzlZek0rSmJqbGRMZEkvVC82ZjhyL0JmOFQvcXV2bHNMcENrWnNScWd0bFBvL0xhNks0ZFNmTFF6ZnYvMWs0T1JpWjFpdzdCTERyZmhuR09veEJDQ2FDNEdhanpGOCtQWUJiajQ3a0xWeStRMkdXeG5QVWZTZ2hJSGhRbFdnellVTVR4anVBbTJHYVA0UGRBRUkvd0RpOEVnTkJ1MFo4aWplZ1p0bXNkRDQvOHZ2dHhsWXVWZ1pGTldFR095TmRjQXVBR24rRHJUOXlQTDdETysvZndXN1NKQlRsdUZDMFZXd1hoYVlHMC9FbjRVYnhyMmE1Nyt5dVNiRDRXOEh3TktjUVBMTDkxOE1ENnMvZ2RVOFpMZ0swOGFBNGdXNDZMZmZETjkvQSszOStoT01RUzVnaFV1aU1yQWJBRmJ6bmVFSGtBWmhrRUcvd0F5d0JBcUIxWUJmMy84REF4R0hEaFR0REF6d01FQVdaK05rWlBqTy9ZT0JBK1IyRUFDR0hSc0hoSWxPWWpYZzhha3ZEQlB2YkdQNEJUVGdQOHdRZEoyRGhnOEE5U1NENEVUSUhLNEFBQUFBU1VWT1JLNUNZSUk9XCJcblx0fSxcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblxuICAgIC8vIFRoaXMgY2xvc3VyZSBzdXBwb3J0cyBOb2RlSlMtbGVzcyBjbGllbnQgc2lkZSBpbmNsdWRlcyB3aXRoIDxzY3JpcHQ+IHRhZ3MuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L21ubS5cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEluc2VydCBiYXNlIHN0eWxlc2hlZXQgaW50byBET01cbiAgICAgKiBAZGVzYyBDcmVhdGVzIGEgbmV3IGA8c3R5bGU+Li4uPC9zdHlsZT5gIGVsZW1lbnQgZnJvbSB0aGUgbmFtZWQgdGV4dCBzdHJpbmcocykgYW5kIGluc2VydHMgaXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNzc1J1bGVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtJRF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fHVuZGVmaW5lZHxudWxsfSBbcmVmZXJlbmNlRWxlbWVudF1cbiAgICAgKiAqIGB1bmRlZmluZWRgIHR5cGUgKG9yIG9taXR0ZWQpOiBpbmplY3RzIHN0eWxlc2hlZXQgYXQgdG9wIG9mIGA8aGVhZC4uLjwvaGVhZD5gIGVsZW1lbnRcbiAgICAgKiAqIGBudWxsYCB2YWx1ZTogaW5qZWN0cyBzdHlsZXNoZWV0IGF0IGJvdHRvbSBvZiBgPGhlYWQ+Li4uPC9oZWFkPmAgZWxlbWVudFxuICAgICAqICogYEVsZW1lbnRgIHR5cGU6IGluamVjdHMgc3R5bGVzaGVldCBpbW1lZGlhdGVseSBiZWZvcmUgZ2l2ZW4gZWxlbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNzc0luamVjdG9yKGNzc1J1bGVzLCBJRCwgcmVmZXJlbmNlRWxlbWVudCkge1xuICAgICAgICBpZiAoSUQpIHtcbiAgICAgICAgICAgIElEID0gY3NzSW5qZWN0b3IuaWRQcmVmaXggKyBJRDtcblxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKElEKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gc3R5bGVzaGVldCBhbHJlYWR5IGluIERPTVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZWZlcmVuY2VFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocmVmZXJlbmNlRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoIXJlZmVyZW5jZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGZpbmQgcmVmZXJlbmNlIGVsZW1lbnQgZm9yIENTUyBpbmplY3Rpb24uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcmVuY2VFbGVtZW50ICYmICEocmVmZXJlbmNlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyAnR2l2ZW4gdmFsdWUgbm90IGEgcmVmZXJlbmNlIGVsZW1lbnQuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgICBpZiAoSUQpIHtcbiAgICAgICAgICAgIHN0eWxlLmlkID0gSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNzc1J1bGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGNzc1J1bGVzID0gY3NzUnVsZXMuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY3NzUnVsZXMgPSAnXFxuJyArIGNzc1J1bGVzICsgJ1xcbic7XG4gICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NSdWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1J1bGVzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGFpbmVyID0gcmVmZXJlbmNlRWxlbWVudCAmJiByZWZlcmVuY2VFbGVtZW50LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuXG4gICAgICAgIGlmIChyZWZlcmVuY2VFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoc3R5bGUsIHJlZmVyZW5jZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIGNzc0luamVjdG9yLmlkUHJlZml4ID0gJ2luamVjdGVkLXN0eWxlc2hlZXQtJztcblxuICAgIC8vIEludGVyZmFjZVxuICAgIG1vZHVsZS5leHBvcnRzID0gY3NzSW5qZWN0b3I7XG59KShcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUgfHwgKHdpbmRvdy5jc3NJbmplY3RvciA9IHt9KSxcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyB8fCAod2luZG93LmNzc0luamVjdG9yLmV4cG9ydHMgPSB7fSlcbikgfHwgKFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnIHx8ICh3aW5kb3cuY3NzSW5qZWN0b3IgPSB3aW5kb3cuY3NzSW5qZWN0b3IuZXhwb3J0cylcbik7XG5cbi8qIEFib3V0IHRoZSBhYm92ZSBJSUZFOlxuICogVGhpcyBmaWxlIGlzIGEgXCJtb2RpZmllZCBub2RlIG1vZHVsZS5cIiBJdCBmdW5jdGlvbnMgYXMgdXN1YWwgaW4gTm9kZS5qcyAqYW5kKiBpcyBhbHNvIHVzYWJsZSBkaXJlY3RseSBpbiB0aGUgYnJvd3Nlci5cbiAqIDEuIE5vZGUuanM6IFRoZSBJSUZFIGlzIHN1cGVyZmx1b3VzIGJ1dCBpbm5vY3VvdXMuXG4gKiAyLiBJbiB0aGUgYnJvd3NlcjogVGhlIElJRkUgY2xvc3VyZSBzZXJ2ZXMgdG8ga2VlcCBpbnRlcm5hbCBkZWNsYXJhdGlvbnMgcHJpdmF0ZS5cbiAqIDIuYS4gSW4gdGhlIGJyb3dzZXIgYXMgYSBnbG9iYWw6IFRoZSBsb2dpYyBpbiB0aGUgYWN0dWFsIHBhcmFtZXRlciBleHByZXNzaW9ucyArIHRoZSBwb3N0LWludm9jYXRpb24gZXhwcmVzc2lvblxuICogd2lsbCBwdXQgeW91ciBBUEkgaW4gYHdpbmRvdy5jc3NJbmplY3RvcmAuXG4gKiAyLmIuIEluIHRoZSBicm93c2VyIGFzIGEgbW9kdWxlOiBJZiB5b3UgcHJlZGVmaW5lIGEgYHdpbmRvdy5tb2R1bGVgIG9iamVjdCwgdGhlIHJlc3VsdHMgd2lsbCBiZSBpbiBgbW9kdWxlLmV4cG9ydHNgLlxuICogVGhlIGJvd2VyIGNvbXBvbmVudCBgbW5tYCBtYWtlcyB0aGlzIGVhc3kgYW5kIGFsc28gcHJvdmlkZXMgYSBnbG9iYWwgYHJlcXVpcmUoKWAgZnVuY3Rpb24gZm9yIHJlZmVyZW5jaW5nIHlvdXIgbW9kdWxlXG4gKiBmcm9tIG90aGVyIGNsb3N1cmVzLiBJbiBlaXRoZXIgY2FzZSwgdGhpcyB3b3JrcyB3aXRoIGJvdGggTm9kZUpzLXN0eWxlIGV4cG9ydCBtZWNoYW5pc21zIC0tIGEgc2luZ2xlIEFQSSBhc3NpZ25tZW50LFxuICogYG1vZHVsZS5leHBvcnRzID0geW91ckFQSWAgKm9yKiBhIHNlcmllcyBvZiBpbmRpdmlkdWFsIHByb3BlcnR5IGFzc2lnbm1lbnRzLCBgbW9kdWxlLmV4cG9ydHMucHJvcGVydHkgPSBwcm9wZXJ0eWAuXG4gKlxuICogQmVmb3JlIHRoZSBJSUZFIHJ1bnMsIHRoZSBhY3R1YWwgcGFyYW1ldGVyIGV4cHJlc3Npb25zIGFyZSBleGVjdXRlZDpcbiAqIDEuIElmIGBtb2R1bGVgIG9iamVjdCBkZWZpbmVkLCB3ZSdyZSBpbiBOb2RlSnMgc28gYXNzdW1lIHRoZXJlIGlzIGEgYG1vZHVsZWAgb2JqZWN0IHdpdGggYW4gYGV4cG9ydHNgIG9iamVjdFxuICogMi4gSWYgYG1vZHVsZWAgb2JqZWN0IHVuZGVmaW5lZCwgd2UncmUgaW4gYnJvd3NlciBzbyBkZWZpbmUgYSBgd2luZG93LmNzc0luamVjdG9yYCBvYmplY3Qgd2l0aCBhbiBgZXhwb3J0c2Agb2JqZWN0XG4gKlxuICogQWZ0ZXIgdGhlIElJRkUgcmV0dXJuczpcbiAqIEJlY2F1c2UgaXQgYWx3YXlzIHJldHVybnMgdW5kZWZpbmVkLCB0aGUgZXhwcmVzc2lvbiBhZnRlciB0aGUgfHwgd2lsbCBhbHdheXMgZXhlY3V0ZTpcbiAqIDEuIElmIGBtb2R1bGVgIG9iamVjdCBkZWZpbmVkLCB0aGVuIHdlJ3JlIGluIE5vZGVKcyBzbyB3ZSdyZSBkb25lXG4gKiAyLiBJZiBgbW9kdWxlYCBvYmplY3QgdW5kZWZpbmVkLCB0aGVuIHdlJ3JlIGluIGJyb3dzZXIgc28gcmVkZWZpbmVgd2luZG93LmNzc0luamVjdG9yYCBhcyBpdHMgYGV4cG9ydHNgIG9iamVjdFxuICovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAbmFtZXNwYWNlIGV4dGVuZC1tZSAqKi9cblxuLyoqIEBzdW1tYXJ5IEV4dGVuZHMgYW4gZXhpc3RpbmcgY29uc3RydWN0b3IgaW50byBhIG5ldyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcmV0dXJucyB7Q2hpbGRDb25zdHJ1Y3Rvcn0gQSBuZXcgY29uc3RydWN0b3IsIGV4dGVuZGVkIGZyb20gdGhlIGdpdmVuIGNvbnRleHQsIHBvc3NpYmx5IHdpdGggc29tZSBwcm90b3R5cGUgYWRkaXRpb25zLlxuICpcbiAqIEBkZXNjIEV4dGVuZHMgXCJvYmplY3RzXCIgKGNvbnN0cnVjdG9ycyksIHdpdGggb3B0aW9uYWwgYWRkaXRpb25hbCBjb2RlLCBvcHRpb25hbCBwcm90b3R5cGUgYWRkaXRpb25zLCBhbmQgb3B0aW9uYWwgcHJvdG90eXBlIG1lbWJlciBhbGlhc2VzLlxuICpcbiAqID4gQ0FWRUFUOiBOb3QgdG8gYmUgY29uZnVzZWQgd2l0aCBVbmRlcnNjb3JlLXN0eWxlIC5leHRlbmQoKSB3aGljaCBpcyBzb21ldGhpbmcgZWxzZSBlbnRpcmVseS4gSSd2ZSB1c2VkIHRoZSBuYW1lIFwiZXh0ZW5kXCIgaGVyZSBiZWNhdXNlIG90aGVyIHBhY2thZ2VzIChsaWtlIEJhY2tib25lLmpzKSB1c2UgaXQgdGhpcyB3YXkuIFlvdSBhcmUgZnJlZSB0byBjYWxsIGl0IHdoYXRldmVyIHlvdSB3YW50IHdoZW4geW91IFwicmVxdWlyZVwiIGl0LCBzdWNoIGFzIGB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdleHRlbmQnKWAuXG4gKlxuICogUHJvdmlkZSBhIGNvbnN0cnVjdG9yIGFzIHRoZSBjb250ZXh0IGFuZCBhbnkgcHJvdG90eXBlIGFkZGl0aW9ucyB5b3UgcmVxdWlyZSBpbiB0aGUgZmlyc3QgYXJndW1lbnQuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSB3aXNoIHRvIGJlIGFibGUgdG8gZXh0ZW5kIGBCYXNlQ29uc3RydWN0b3JgIHRvIGEgbmV3IGNvbnN0cnVjdG9yIHdpdGggcHJvdG90eXBlIG92ZXJyaWRlcyBhbmQvb3IgYWRkaXRpb25zLCBiYXNpYyB1c2FnZSBpczpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgQmFzZSA9IHJlcXVpcmUoJ2V4dGVuZC1tZScpLkJhc2U7XG4gKiB2YXIgQmFzZUNvbnN0cnVjdG9yID0gQmFzZS5leHRlbmQoYmFzZVByb3RvdHlwZSk7IC8vIG1peGVzIGluIC5leHRlbmRcbiAqIHZhciBDaGlsZENvbnN0cnVjdG9yID0gQmFzZUNvbnN0cnVjdG9yLmV4dGVuZChjaGlsZFByb3RvdHlwZU92ZXJyaWRlc0FuZEFkZGl0aW9ucyk7XG4gKiB2YXIgR3JhbmRjaGlsZENvbnN0cnVjdG9yID0gQ2hpbGRDb25zdHJ1Y3Rvci5leHRlbmQoZ3JhbmRjaGlsZFByb3RvdHlwZU92ZXJyaWRlc0FuZEFkZGl0aW9ucyk7XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIChgZXh0ZW5kKClgKSBpcyBhZGRlZCB0byB0aGUgbmV3IGV4dGVuZGVkIG9iamVjdCBjb25zdHJ1Y3RvciBhcyBhIHByb3BlcnR5IGAuZXh0ZW5kYCwgZXNzZW50aWFsbHkgbWFraW5nIHRoZSBvYmplY3QgY29uc3RydWN0b3IgaXRzZWxmIGVhc2lseSBcImV4dGVuZGFibGUuXCIgKE5vdGU6IFRoaXMgaXMgYSBwcm9wZXJ0eSBvZiBlYWNoIGNvbnN0cnVjdG9yIGFuZCBub3QgYSBtZXRob2Qgb2YgaXRzIHByb3RvdHlwZSEpXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtleHRlbmRlZENsYXNzTmFtZV0gLSBUaGlzIGlzIHNpbXBseSBhZGRlZCB0byB0aGUgcHJvdG90eXBlIGFzICQkQ0xBU1NfTkFNRS4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcgYmVjYXVzZSBhbGwgZGVyaXZlZCBjb25zdHJ1Y3RvcnMgYXBwZWFyIHRvIGhhdmUgdGhlIHNhbWUgbmFtZSAoXCJDb25zdHJ1Y3RvclwiKSBpbiB0aGUgZGVidWdnZXIuIFRoaXMgcHJvcGVydHkgaXMgaWdub3JlZCB1bmxlc3MgYGV4dGVuZC5kZWJ1Z2AgaXMgZXhwbGljaXRseSBzZXQgdG8gYSB0cnV0aHkgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtleHRlbmRlZFByb3RvdHlwZUFkZGl0aW9uc09iamVjdH0gW3Byb3RvdHlwZUFkZGl0aW9uc10gLSBPYmplY3Qgd2l0aCBtZW1iZXJzIHRvIGNvcHkgdG8gbmV3IGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLiBNb3N0IG1lbWJlcnMgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIHByb3RvdHlwZS4gU29tZSBtZW1iZXJzLCBob3dldmVyLCBoYXZlIHNwZWNpYWwgbWVhbmluZ3MgYXMgZXhwbGFpbmVkIGluIHRoZSB7QGxpbmsgZXh0ZW5kZWRQcm90b3R5cGVBZGRpdGlvbnNPYmplY3R8dHlwZSBkZWZpbml0aW9ufSAoYW5kIG1heSBvciBtYXkgbm90IGJlIGNvcGllZCB0byB0aGUgcHJvdG90eXBlKS5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZWJ1Z10gLSBTZWUgcGFyYW1ldGVyIGBleHRlbmRlZENsYXNzTmFtZWAgXyhhYm92ZSlfLlxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBCYXNlIC0gQSBjb252ZW5pZW50IGJhc2UgY2xhc3MgZnJvbSB3aGljaCBhbGwgb3RoZXIgY2xhc3NlcyBjYW4gYmUgZXh0ZW5kZWQuXG4gKlxuICogQG1lbWJlck9mIGV4dGVuZC1tZVxuICovXG5mdW5jdGlvbiBleHRlbmQoZXh0ZW5kZWRDbGFzc05hbWUsIHByb3RvdHlwZUFkZGl0aW9ucykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwcm90b3R5cGVBZGRpdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBwcm90b3R5cGVBZGRpdGlvbnMgPSBleHRlbmRlZENsYXNzTmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlQWRkaXRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93ICdTaW5nbGUgcGFyYW1ldGVyIG92ZXJsb2FkIG11c3QgYmUgb2JqZWN0Lic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRlbmRlZENsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dGVuZGVkQ2xhc3NOYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvdG90eXBlQWRkaXRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93ICdUd28gcGFyYW1ldGVyIG92ZXJsb2FkIG11c3QgYmUgc3RyaW5nLCBvYmplY3QuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1RvbyBtYW55IHBhcmFtZXRlcnMnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbnN0cnVjdG9yKCkge1xuICAgICAgICBpZiAocHJvdG90eXBlQWRkaXRpb25zLnByZUluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIHByb3RvdHlwZUFkZGl0aW9ucy5wcmVJbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0aWFsaXplUHJvdG90eXBlQ2hhaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICBpZiAocHJvdG90eXBlQWRkaXRpb25zLnBvc3RJbml0aWFsaXplKSB7XG4gICAgICAgICAgICBwcm90b3R5cGVBZGRpdGlvbnMucG9zdEluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIENvbnN0cnVjdG9yLmV4dGVuZCA9IGV4dGVuZDtcblxuICAgIHZhciBwcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcbiAgICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcblxuICAgIGlmIChleHRlbmRlZENsYXNzTmFtZSAmJiBleHRlbmQuZGVidWcpIHtcbiAgICAgICAgcHJvdG90eXBlLiQkQ0xBU1NfTkFNRSA9IGV4dGVuZGVkQ2xhc3NOYW1lO1xuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBwcm90b3R5cGVBZGRpdGlvbnMpIHtcbiAgICAgICAgaWYgKHByb3RvdHlwZUFkZGl0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm90b3R5cGVBZGRpdGlvbnNba2V5XTtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW5pdGlhbGl6ZU93bic6XG4gICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgY2FsbGVkIGFib3ZlOyBub3QgbmVlZGVkIGluIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdhbGlhc2VzJzpcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYWxpYXMgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShhbGlhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlQWxpYXModmFsdWVbYWxpYXNdLCBhbGlhcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0gPT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZUFsaWFzKHZhbHVlLCBrZXkuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3RvdHlwZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcblxuICAgIGZ1bmN0aW9uIG1ha2VBbGlhcyh2YWx1ZSwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2hhZG93XG4gICAgICAgIHByb3RvdHlwZVtrZXldID0gcHJvdG90eXBlQWRkaXRpb25zW3ZhbHVlXTtcbiAgICB9XG59XG5cbmV4dGVuZC5CYXNlID0gZnVuY3Rpb24gKCkge307XG5leHRlbmQuQmFzZS5leHRlbmQgPSBleHRlbmQ7XG5cbi8qKiBAdHlwZWRlZiB7ZnVuY3Rpb259IGV4dGVuZGVkQ29uc3RydWN0b3JcbiAqIEBwcm9wZXJ0eSBwcm90b3R5cGUuc3VwZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgcHJvdG90eXBlIHRoaXMgY29uc3RydWN0b3Igd2FzIGV4dGVuZGVkIGZyb20uXG4gKiBAcHJvcGVydHkgW2V4dGVuZF0gLSBJZiBgcHJvdG90eXBlQWRkaXRpb25zLmV4dGVuZGFibGVgIHdhcyB0cnV0aHksIHRoaXMgd2lsbCBiZSBhIHJlZmVyZW5jZSB0byB7QGxpbmsgZXh0ZW5kLmV4dGVuZHxleHRlbmR9LlxuICovXG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBleHRlbmRlZFByb3RvdHlwZUFkZGl0aW9uc09iamVjdFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2luaXRpYWxpemVdIC0gQWRkaXRpb25hbCBjb25zdHJ1Y3RvciBjb2RlIGZvciBuZXcgb2JqZWN0LiBUaGlzIG1ldGhvZCBpcyBhZGRlZCB0byB0aGUgbmV3IGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLiBHZXRzIHBhc3NlZCBuZXcgb2JqZWN0IGFzIGNvbnRleHQgKyBzYW1lIGFyZ3MgYXMgY29uc3RydWN0b3IgaXRzZWxmLiBDYWxsZWQgb24gaW5zdGFudGlhdGlvbiBhZnRlciBzaW1pbGFyIGZ1bmN0aW9uIGluIGFsbCBhbmNlc3RvcnMgY2FsbGVkIHdpdGggc2FtZSBzaWduYXR1cmUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbaW5pdGlhbGl6ZU93bl0gLSBBZGRpdGlvbmFsIGNvbnN0cnVjdG9yIGNvZGUgZm9yIG5ldyBvYmplY3QuIFRoaXMgbWV0aG9kIGlzIGFkZGVkIHRvIHRoZSBuZXcgY29uc3RydWN0b3IncyBwcm90b3R5cGUuIEdldHMgcGFzc2VkIG5ldyBvYmplY3QgYXMgY29udGV4dCArIHNhbWUgYXJncyBhcyBjb25zdHJ1Y3RvciBpdHNlbGYuIENhbGxlZCBvbiBpbnN0YW50aWF0aW9uIGFmdGVyIChhbGwpIHRoZSBgaW5pdGlhbGl6ZWAgZnVuY3Rpb24ocykuXG4gKiBAcHJvcGVydHkge29iamVjdH0gW2FsaWFzZXNdIC0gSGFzaCBvZiBhbGlhc2VzIGZvciBwcm90b3R5cGUgbWVtYmVycyBpbiBmb3JtIGB7IGtleTogJ21lbWJlcicsIC4uLiB9YCB3aGVyZSBga2V5YCBpcyB0aGUgbmFtZSBvZiBhbiBhbGllYXMgYW5kIGAnbWVtYmVyJ2AgaXMgdGhlIG5hbWUgb2YgYW4gZXhpc3RpbmcgbWVtYmVyIGluIHRoZSBwcm90b3R5cGUuIEVhY2ggc3VjaCBrZXkgaXMgYWRkZWQgdG8gdGhlIHByb3RvdHlwZSBhcyBhIHJlZmVyZW5jZSB0byB0aGUgbmFtZWQgbWVtYmVyLiAoVGhlIGBhbGlhc2VzYCBvYmplY3QgaXRzZWxmIGlzICpub3QqIGFkZGVkIHRvIHByb3RvdHlwZS4pIEFsdGVybmF0aXZlbHk6XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2tleXNdIC0gQXJiaXRyYXJ5IHByb3BlcnR5IG5hbWVzIGRlZmluZWQgaGVyZSB3aXRoIHN0cmluZyB2YWx1ZXMgc3RhcnRpbmcgd2l0aCBhIGAjYCBjaGFyYWN0ZXIgd2lsbCBhbGlhcyB0aGUgYWN0dWFsIHByb3BlcnRpZXMgbmFtZWQgaW4gdGhlIHN0cmluZ3MgKGZvbGxvd2luZyB0aGUgYCNgKS4gVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSB0byBwcm92aWRpbmcgYW4gYGFsaWFzZXNgIGhhc2gsIHBlcmhhcHMgc2ltcGxlciAodGhvdWdoIHN1YnRsZXIpLiAoVXNlIGFyYml0cmFyeSBpZGVudGlmaWVycyBoZXJlOyBkb24ndCB1c2UgdGhlIG5hbWUgYGtleXNgISlcbiAqIEBwcm9wZXJ0eSB7Kn0gW2FyYml0cmFyeVByb3BlcnRpZXNdIC0gQW55IGFkZGl0aW9uYWwgYXJiaXRyYXJ5IHByb3BlcnRpZXMgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG5ldyBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZS4gKFVzZSBhcmJpdHJhcnkgaWRlbnRpZmllcnMgaGVyZTsgZG9uJ3QgdXNlIHRoZSBuYW1lIGBhcmliaXRyYXJ5UHJvcGVydGllc2AhKVxuICovXG5cbi8qKiBAc3VtbWFyeSBDYWxsIGFsbCBgaW5pdGlhbGl6ZWAgbWV0aG9kcyBmb3VuZCBpbiBwcm90b3R5cGUgY2hhaW4uXG4gKiBAZGVzYyBUaGlzIHJlY3Vyc2l2ZSByb3V0aW5lIGlzIGNhbGxlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gKiAxLiBXYWxrcyBiYWNrIHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gYE9iamVjdGAncyBwcm90b3R5cGVcbiAqIDIuIFdhbGtzIGZvcndhcmQgdG8gbmV3IG9iamVjdCwgY2FsbGluZyBhbnkgYGluaXRpYWxpemVgIG1ldGhvZHMgaXQgZmluZHMgYWxvbmcgdGhlIHdheSB3aXRoIHRoZSBzYW1lIGNvbnRleHQgYW5kIGFyZ3VtZW50cyB3aXRoIHdoaWNoIHRoZSBjb25zdHJ1Y3RvciB3YXMgY2FsbGVkLlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJPZiBleHRlbmQtbWVcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb3RvdHlwZUNoYWluKCkge1xuICAgIHZhciB0ZXJtID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZWN1cih0ZXJtKTtcblxuICAgIGZ1bmN0aW9uIHJlY3VyKG9iaikge1xuICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgaWYgKHByb3RvLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHJlY3VyKHByb3RvKTtcbiAgICAgICAgICAgIGlmIChwcm90by5pbml0aWFsaXplKSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uaW5pdGlhbGl6ZS5hcHBseSh0ZXJtLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG52YXIgY3NzSW5qZWN0b3IgPSByZXF1aXJlKCdjc3MtaW5qZWN0b3InKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgRmluQmFyXG4gKiBAc3VtbWFyeSBDcmVhdGUgYSBzY3JvbGxiYXIgb2JqZWN0LlxuICogQGRlc2MgQ3JlYXRpbmcgYSBzY3JvbGxiYXIgaXMgYSB0aHJlZS1zdGVwIHByb2Nlc3M6XG4gKlxuICogMS4gSW5zdGFudGlhdGUgdGhlIHNjcm9sbGJhciBvYmplY3QgYnkgY2FsbGluZyB0aGlzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLiBVcG9uIGluc3RhbnRpYXRpb24sIHRoZSBET00gZWxlbWVudCBmb3IgdGhlIHNjcm9sbGJhciAod2l0aCBhIHNpbmdsZSBjaGlsZCBlbGVtZW50IGZvciB0aGUgc2Nyb2xsYmFyIFwidGh1bWJcIikgaXMgY3JlYXRlZCBidXQgaXMgbm90IGluc2VydCBpdCBpbnRvIHRoZSBET00uXG4gKiAyLiBBZnRlciBpbnN0YW50aWF0aW9uLCBpdCBpcyB0aGUgY2FsbGVyJ3MgcmVzcG9uc2liaWxpdHkgdG8gaW5zZXJ0IHRoZSBzY3JvbGxiYXIsIHtAbGluayBGaW5CYXIjYmFyfHRoaXMuYmFyfSwgaW50byB0aGUgRE9NLlxuICogMy4gQWZ0ZXIgaW5zZXJ0aW9uLCB0aGUgY2FsbGVyIG11c3QgY2FsbCB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0gYXQgbGVhc3Qgb25jZSB0byBzaXplIGFuZCBwb3NpdGlvbiB0aGUgc2Nyb2xsYmFyIGFuZCBpdHMgdGh1bWIuIEFmdGVyIHRoYXQsIGByZXNpemUoKWAgc2hvdWxkIGFsc28gYmUgY2FsbGVkIHJlcGVhdGVkbHkgb24gcmVzaXplIGV2ZW50cyAoYXMgdGhlIGNvbnRlbnQgZWxlbWVudCBpcyBiZWluZyByZXNpemVkKS5cbiAqXG4gKiBTdWdnZXN0ZWQgY29uZmlndXJhdGlvbnM6XG4gKiAqIF8qKlVuYm91bmQqKl88YnIvPlxuICogVGhlIHNjcm9sbGJhciBzZXJ2ZXMgbWVyZWx5IGFzIGEgc2ltcGxlIHJhbmdlIChzbGlkZXIpIGNvbnRyb2wuIE9taXQgYm90aCBgb3B0aW9ucy5vbmNoYW5nZWAgYW5kIGBvcHRpb25zLmNvbnRlbnRgLlxuICogKiBfKipCb3VuZCB0byB2aXJ0dWFsIGNvbnRlbnQgZWxlbWVudCoqXzxici8+XG4gKiBWaXJ0dWFsIGNvbnRlbnQgaXMgcHJvamVjdGVkIGludG8gdGhlIGVsZW1lbnQgdXNpbmcgYSBjdXN0b20gZXZlbnQgaGFuZGxlciBzdXBwbGllZCBieSB0aGUgcHJvZ3JhbW1lciBpbiBgb3B0aW9ucy5vbmNoYW5nZWAuIEEgdHlwaWNhbCB1c2UgY2FzZSB3b3VsZCBiZSB0byBoYW5kbGUgc2Nyb2xsaW5nIG9mIHRoZSB2aXJ0dWFsIGNvbnRlbnQuIE90aGVyIHVzZSBjYXNlcyBpbmNsdWRlIGRhdGEgdHJhbnNmb3JtYXRpb25zLCBncmFwaGljcyB0cmFuc2Zvcm1hdGlvbnMsIF9ldGMuX1xuICogKiBfKipCb3VuZCB0byByZWFsIGNvbnRlbnQqKl88YnIvPlxuICogU2V0IGBvcHRpb25zLmNvbnRlbnRgIHRvIHRoZSBcInJlYWxcIiBjb250ZW50IGVsZW1lbnQgYnV0IG9taXQgYG9wdGlvbnMub25jaGFuZ2VgLiBUaGlzIHdpbGwgY2F1c2UgdGhlIHNjcm9sbGJhciB0byB1c2UgdGhlIGJ1aWx0LWluIGV2ZW50IGhhbmRsZXIgKGB0aGlzLnNjcm9sbFJlYWxDb250ZW50YCkgd2hpY2ggaW1wbGVtZW50cyBzbW9vdGggc2Nyb2xsaW5nIG9mIHRoZSBjb250ZW50IGVsZW1lbnQgd2l0aGluIHRoZSBjb250YWluZXIuXG4gKlxuICogQHBhcmFtIHtmaW5iYXJPcHRpb25zfSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIG9iamVjdC4gU2VlIHRoZSB0eXBlIGRlZmluaXRpb24gZm9yIG1lbWJlciBkZXRhaWxzLlxuICovXG5mdW5jdGlvbiBGaW5CYXIob3B0aW9ucykge1xuXG4gICAgLy8gbWFrZSBib3VuZCB2ZXJzaW9ucyBvZiBhbGwgdGhlIG1vdXNlIGV2ZW50IGhhbmRsZXJcbiAgICB2YXIgYm91bmQgPSB0aGlzLl9ib3VuZCA9IHt9O1xuICAgIGZvciAoa2V5IGluIGhhbmRsZXJzVG9CZUJvdW5kKSB7XG4gICAgICAgIGJvdW5kW2tleV0gPSBoYW5kbGVyc1RvQmVCb3VuZFtrZXldLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgdGh1bWJcbiAgICAgKiBAc3VtbWFyeSBUaGUgZ2VuZXJhdGVkIHNjcm9sbGJhciB0aHVtYiBlbGVtZW50LlxuICAgICAqIEBkZXNjIFRoZSB0aHVtYiBlbGVtZW50J3MgcGFyZW50IGVsZW1lbnQgaXMgYWx3YXlzIHRoZSB7QGxpbmsgRmluQmFyI2JhcnxiYXJ9IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHR5cGljYWxseSByZWZlcmVuY2VkIGludGVybmFsbHkgb25seS4gVGhlIHNpemUgYW5kIHBvc2l0aW9uIG9mIHRoZSB0aHVtYiBlbGVtZW50IGlzIG1haW50YWluZWQgYnkgYF9jYWxjVGh1bWIoKWAuXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2YXIgdGh1bWIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aHVtYi5jbGFzc0xpc3QuYWRkKCd0aHVtYicpO1xuICAgIHRodW1iLm9uY2xpY2sgPSBib3VuZC5zaG9ydFN0b3A7XG4gICAgdGh1bWIub25tb3VzZW92ZXIgPSBib3VuZC5vbm1vdXNlb3ZlcjtcbiAgICB0aGlzLnRodW1iID0gdGh1bWI7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBiYXJcbiAgICAgKiBAc3VtbWFyeSBUaGUgZ2VuZXJhdGVkIHNjcm9sbGJhciBlbGVtZW50LlxuICAgICAqIEBkZXNjIFRoZSBjYWxsZXIgaW5zZXJ0cyB0aGlzIGVsZW1lbnQgaW50byB0aGUgRE9NICh0eXBpY2FsbHkgaW50byB0aGUgY29udGVudCBjb250YWluZXIpIGFuZCB0aGVuIGNhbGxzIGl0cyB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0gbWV0aG9kLlxuICAgICAqXG4gICAgICogVGh1cyB0aGUgbm9kZSB0cmVlIGlzIHR5cGljYWxseTpcbiAgICAgKiAqIEEgKipjb250ZW50IGNvbnRhaW5lcioqIGVsZW1lbnQsIHdoaWNoIGNvbnRhaW5zOlxuICAgICAqICAgICogVGhlIGNvbnRlbnQgZWxlbWVudChzKVxuICAgICAqICAgICogVGhpcyAqKnNjcm9sbGJhciBlbGVtZW50KiosIHdoaWNoIGluIHR1cm4gY29udGFpbnM6XG4gICAgICogICAgICAgICogVGhlICoqdGh1bWIgZWxlbWVudCoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHZhciBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGJhci5jbGFzc0xpc3QuYWRkKCdmaW5iYXItdmVydGljYWwnKTtcblxuICAgIGJhci5hcHBlbmRDaGlsZCh0aHVtYik7XG4gICAgaWYgKHRoaXMucGFnaW5nKSB7XG4gICAgICAgIGJhci5vbmNsaWNrID0gYm91bmQub25jbGljaztcbiAgICB9XG4gICAgdGhpcy5iYXIgPSBiYXI7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIHByZXNldHNcbiAgICB0aGlzLm9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJztcbiAgICB0aGlzLl9taW4gPSB0aGlzLl9pbmRleCA9IDA7XG4gICAgdGhpcy5fbWF4ID0gMTAwO1xuXG4gICAgLy8gb3B0aW9uc1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuXG4gICAgICAgICAgICBjYXNlICdpbmRleCc6XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSBvcHRpb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JhbmdlJzpcbiAgICAgICAgICAgICAgICB2YWxpZFJhbmdlKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluID0gb3B0aW9uLm1pbjtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXggPSBvcHRpb24ubWF4O1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFNpemUgPSBvcHRpb24ubWF4IC0gb3B0aW9uLm1pbiArIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBrZXkuY2hhckF0KDApICE9PSAnXycgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIEZpbkJhci5wcm90b3R5cGVba2V5XSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBwcm90b3R5cGUgZGVmYXVsdHMgZm9yIHN0YW5kYXJkIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZW5kIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzIChmb3IgdXNlIGluIG9uY2hhbmdlIGV2ZW50IGhhbmRsZXJzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjc3NJbmplY3Rvcihjc3NGaW5CYXJzLCAnZmluYmFyLWJhc2UnLCBvcHRpb25zLmNzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50KTtcbn1cblxuRmluQmFyLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFRoZSBzY3JvbGxiYXIgb3JpZW50YXRpb24uXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvciB0byBlaXRoZXIgYCd2ZXJ0aWNhbCdgIG9yIGAnaG9yaXpvbnRhbCdgLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIFVzZWZ1bCB2YWx1ZXMgYXJlIGAndmVydGljYWwnYCAodGhlIGRlZmF1bHQpIG9yIGAnaG9yaXpvbnRhbCdgLlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IHJlc2V0cyBgdGhpcy5vaGAgYW5kIGB0aGlzLmRlbHRhUHJvcGAgYW5kIGNoYW5nZXMgdGhlIGNsYXNzIG5hbWVzIHNvIGFzIHRvIHJlcG9zaXRpb24gdGhlIHNjcm9sbGJhciBhcyBwZXIgdGhlIENTUyBydWxlcyBmb3IgdGhlIG5ldyBvcmllbnRhdGlvbi5cbiAgICAgKiBAZGVmYXVsdCAndmVydGljYWwnXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBvcmllbnRhdGlvbihvcmllbnRhdGlvbikge1xuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG5hbWUgb2hcbiAgICAgICAgICogQHN1bW1hcnkgPHU+TzwvdT5yaWVudGF0aW9uIDx1Pmg8L3U+YXNoIGZvciB0aGlzIHNjcm9sbGJhci5cbiAgICAgICAgICogQGRlc2MgU2V0IGJ5IHRoZSBgb3JpZW50YXRpb25gIHNldHRlciB0byBlaXRoZXIgdGhlIHZlcnRpY2FsIG9yIHRoZSBob3Jpem9udGFsIG9yaWVudGF0aW9uIGhhc2guIFRoZSBwcm9wZXJ0eSBzaG91bGQgYWx3YXlzIGJlIHN5bmNocm9uaXplZCB3aXRoIGBvcmllbnRhdGlvbmA7IGRvIG5vdCB1cGRhdGUgZGlyZWN0bHkhXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgb2JqZWN0IGlzIHVzZWQgaW50ZXJuYWxseSB0byBhY2Nlc3Mgc2Nyb2xsYmFycycgRE9NIGVsZW1lbnQgcHJvcGVydGllcyBpbiBhIGdlbmVyYWxpemVkIHdheSB3aXRob3V0IG5lZWRpbmcgdG8gY29uc3RhbnRseSBxdWVyeSB0aGUgc2Nyb2xsYmFyIG9yaWVudGF0aW9uLiBGb3IgZXhhbXBsZSwgaW5zdGVhZCBvZiBleHBsaWNpdGx5IGNvZGluZyBgdGhpcy5iYXIudG9wYCBmb3IgYSB2ZXJ0aWNhbCBzY3JvbGxiYXIgYW5kIGB0aGlzLmJhci5sZWZ0YCBmb3IgYSBob3Jpem9udGFsIHNjcm9sbGJhciwgc2ltcGx5IGNvZGUgYHRoaXMuYmFyW3RoaXMub2gubGVhZGluZ11gIGluc3RlYWQuIFNlZSB0aGUge0BsaW5rIG9yaWVudGF0aW9uSGFzaFR5cGV9IGRlZmluaXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgb2JqZWN0IGlzIHVzZWZ1bCBleHRlcm5hbGx5IGZvciBjb2RpbmcgZ2VuZXJhbGl6ZWQge0BsaW5rIGZpbmJhck9uQ2hhbmdlfSBldmVudCBoYW5kbGVyIGZ1bmN0aW9ucyB0aGF0IHNlcnZlIGJvdGggaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2Nyb2xsYmFycy5cbiAgICAgICAgICogQHR5cGUge29yaWVudGF0aW9uSGFzaFR5cGV9XG4gICAgICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9oID0gb3JpZW50YXRpb25IYXNoZXNbdGhpcy5fb3JpZW50YXRpb25dO1xuXG4gICAgICAgIGlmICghdGhpcy5vaCkge1xuICAgICAgICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIGBvcHRpb25zLl9vcmllbnRhdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBkZWx0YVByb3BcbiAgICAgICAgICogQHN1bW1hcnkgVGhlIG5hbWUgb2YgdGhlIGBXaGVlbEV2ZW50YCBwcm9wZXJ0eSB0aGlzIHNjcm9sbGJhciBzaG91bGQgbGlzdGVuIHRvLlxuICAgICAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlZnVsIHZhbHVlcyBhcmUgYCdkZWx0YVgnYCwgYCdkZWx0YVknYCwgb3IgYCdkZWx0YVonYC4gQSB2YWx1ZSBvZiBgbnVsbGAgbWVhbnMgdG8gaWdub3JlIG1vdXNlIHdoZWVsIGV2ZW50cyBlbnRpcmVseS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIG1vdXNlIHdoZWVsIGlzIG9uZS1kaW1lbnNpb25hbCBhbmQgb25seSBlbWl0cyBldmVudHMgd2l0aCBgZGVsdGFZYCBkYXRhLiBUaGlzIHByb3BlcnR5IGlzIHByb3ZpZGVkIHNvIHRoYXQgeW91IGNhbiBvdmVycmlkZSB0aGUgZGVmYXVsdCBvZiBgJ2RlbHRhWCdgIHdpdGggYSB2YWx1ZSBvZiBgJ2RlbHRhWSdgIG9uIHlvdXIgaG9yaXpvbnRhbCBzY3JvbGxiYXIgcHJpbWFyaWx5IHRvIGFjY29tbW9kYXRlIGNlcnRhaW4gXCJwYW5vcmFtaWNcIiBpbnRlcmZhY2UgZGVzaWducyB3aGVyZSB0aGUgbW91c2Ugd2hlZWwgc2hvdWxkIGNvbnRyb2wgaG9yaXpvbnRhbCByYXRoZXIgdGhhbiB2ZXJ0aWNhbCBzY3JvbGxpbmcuIEp1c3QgZ2l2ZSBgeyBkZWx0YVByb3A6ICdkZWx0YVknIH1gIGluIHlvdXIgaG9yaXpvbnRhbCBzY3JvbGxiYXIgaW5zdGFudGlhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2F2ZWF0OiBOb3RlIHRoYXQgYSAyLWZpbmdlciBkcmFnIG9uIGFuIEFwcGxlIHRyYWNrcGFkIGVtaXRzIGV2ZW50cyB3aXRoIF9ib3RoXyBgZGVsdGFYIGAgYW5kIGBkZWx0YVlgIGRhdGEgc28geW91IG1pZ2h0IHdhbnQgdG8gZGVsYXkgbWFraW5nIHRoZSBhYm92ZSBhZGp1c3RtZW50IHVudGlsIHlvdSBjYW4gZGV0ZXJtaW5lIHRoYXQgeW91IGFyZSBnZXR0aW5nIFkgZGF0YSBvbmx5IHdpdGggbm8gWCBkYXRhIGF0IGFsbCAod2hpY2ggaXMgYSBzdXJlIGJldCB5b3Ugb24gYSBtb3VzZSB3aGVlbCByYXRoZXIgdGhhbiBhIHRyYWNrcGFkKS5cblxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fG51bGx9XG4gICAgICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbHRhUHJvcCA9IHRoaXMub2guZGVsdGE7XG5cbiAgICAgICAgdGhpcy5iYXIuY2xhc3NOYW1lID0gdGhpcy5iYXIuY2xhc3NOYW1lLnJlcGxhY2UoLyh2ZXJ0aWNhbHxob3Jpem9udGFsKS9nLCBvcmllbnRhdGlvbik7XG5cbiAgICAgICAgaWYgKHRoaXMuYmFyLnN0eWxlLmNzc1RleHQgfHwgdGhpcy50aHVtYi5zdHlsZS5jc3NUZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmJhci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLnRodW1iLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldCBvcmllbnRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDYWxsYmFjayBmb3Igc2Nyb2xsIGV2ZW50cy5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yIHZpYSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LiBBZnRlciBpbnN0YW50aWF0aW9uLCBgdGhpcy5vbmNoYW5nZWAgbWF5IGJlIHVwZGF0ZWQgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGV2ZW50IGhhbmRsZXIgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBvZiB0aGUgc2Nyb2xsYmFyIGlzIGNoYW5nZWQgdGhyb3VnaCB1c2VyIGludGVyYWN0aW9uLiBUaGUgdHlwaWNhbCB1c2UgY2FzZSBpcyB3aGVuIHRoZSBjb250ZW50IGlzIHNjcm9sbGVkLiBJdCBpcyBjYWxsZWQgd2l0aCB0aGUgYEZpbkJhcmAgb2JqZWN0IGFzIGl0cyBjb250ZXh0IGFuZCB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc2Nyb2xsYmFyIChpdHMgaW5kZXgsIHJvdW5kZWQpIGFzIHRoZSBvbmx5IHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIFNldCB0aGlzIHByb3BlcnR5IHRvIGBudWxsYCB0byBzdG9wIGVtaXR0aW5nIHN1Y2ggZXZlbnRzLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIpfG51bGx9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBvbmNoYW5nZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIHRoZSBiYXIgZWxlbWVudCdzIGNsYXNzIGxpc3QuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0IHdpbGwgYWx3YXlzIGluY2x1ZGUgYGZpbmJhci12ZXJ0aWNhbGAgKG9yIGBmaW5iYXItaG9yaXpvbnRhbGAgYmFzZWQgb24gdGhlIGN1cnJlbnQgb3JpZW50YXRpb24pLiBXaGVuZXZlciB0aGlzIHByb3BlcnR5IGlzIHNldCB0byBzb21lIHZhbHVlLCBmaXJzdCB0aGUgb2xkIHByZWZpeCtvcmllbnRhdGlvbiBpcyByZW1vdmVkIGZyb20gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdDsgdGhlbiB0aGUgbmV3IHByZWZpeCtvcmllbnRhdGlvbiBpcyBhZGRlZCB0byB0aGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0LiBUaGlzIHByb3BlcnR5IGNhdXNlcyBfYW4gYWRkaXRpb25hbF8gY2xhc3MgbmFtZSB0byBiZSBhZGRlZCB0byB0aGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0LiBUaGVyZWZvcmUsIHRoaXMgcHJvcGVydHkgd2lsbCBvbmx5IGFkZCBhdCBtb3N0IG9uZSBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgdG8gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBUbyByZW1vdmUgX2NsYXNzbmFtZS1vcmllbnRhdGlvbl8gZnJvbSB0aGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0LCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBhIGZhbHN5IHZhbHVlLCBzdWNoIGFzIGBudWxsYC5cbiAgICAgKlxuICAgICAqID4gTk9URTogWW91IG9ubHkgbmVlZCB0byBzcGVjaWZ5IGFuIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSB3aGVuIHlvdSBuZWVkIHRvIGhhdmUgbXVsbHRpcGxlIGRpZmZlcmVudCBzdHlsZXMgb2Ygc2Nyb2xsYmFycyBvbiB0aGUgc2FtZSBwYWdlLiBJZiB0aGlzIGlzIG5vdCBhIHJlcXVpcmVtZW50LCB0aGVuIHlvdSBkb24ndCBuZWVkIHRvIG1ha2UgYSBuZXcgY2xhc3M7IHlvdSB3b3VsZCBqdXN0IGNyZWF0ZSBzb21lIGFkZGl0aW9uYWwgcnVsZXMgdXNpbmcgdGhlIHNhbWUgc2VsZWN0b3JzIGluIHRoZSBidWlsdC1pbiBzdHlsZXNoZWV0ICguLi9jc3MvZmluYmFycy5jc3MpOlxuICAgICAqICpgZGl2LmZpbmJhci12ZXJ0aWNhbGAgKG9yIGBkaXYuZmluYmFyLWhvcml6b250YWxgKSBmb3IgdGhlIHNjcm9sbGJhclxuICAgICAqICpgZGl2LmZpbmJhci12ZXJ0aWNhbCA+IGRpdmAgKG9yIGBkaXYuZmluYmFyLWhvcml6b250YWwgPiBkaXZgKSBmb3IgdGhlIFwidGh1bWIuXCJcbiAgICAgKlxuICAgICAqIE9mIGNvdXJzZSwgeW91ciBydWxlcyBzaG91bGQgY29tZSBhZnRlciB0aGUgYnVpbHQtaW5zLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXQgY2xhc3NQcmVmaXgocHJlZml4KSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGFzc1ByZWZpeCkge1xuICAgICAgICAgICAgdGhpcy5iYXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc1ByZWZpeCArIHRoaXMub3JpZW50YXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2xhc3NQcmVmaXggPSBwcmVmaXg7XG5cbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgdGhpcy5iYXIuY2xhc3NMaXN0LmFkZChwcmVmaXggKyAnLScgKyB0aGlzLm9yaWVudGF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IGNsYXNzUHJlZml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3NQcmVmaXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGluY3JlbWVudFxuICAgICAqIEBzdW1tYXJ5IE51bWJlciBvZiBzY3JvbGxiYXIgaW5kZXggdW5pdHMgcmVwcmVzZW50aW5nIGEgcGFnZWZ1bC4gVXNlZCBleGNsdXNpdmVseSBmb3IgcGFnaW5nIHVwIGFuZCBkb3duIGFuZCBmb3Igc2V0dGluZyB0aHVtYiBzaXplIHJlbGF0aXZlIHRvIGNvbnRlbnQgc2l6ZS5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIENhbiBhbHNvIGJlIGdpdmVuIGFzIGEgcGFyYW1ldGVyIHRvIHRoZSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemV9IG1ldGhvZCwgd2hpY2ggaXMgcGVydGluZW50IGJlY2F1c2UgY29udGVudCBhcmVhIHNpemUgY2hhbmdlcyBhZmZlY3QgdGhlIGRlZmluaXRpb24gb2YgYSBcInBhZ2VmdWwuXCIgSG93ZXZlciwgeW91IG9ubHkgbmVlZCB0byBkbyB0aGlzIGlmIHRoaXMgdmFsdWUgaXMgYmVpbmcgdXNlZC4gSXQgbm90IHVzZWQgd2hlbjpcbiAgICAgKiAqIHlvdSBkZWZpbmUgYHBhZ2luZy51cGAgYW5kIGBwYWdpbmcuZG93bmBcbiAgICAgKiAqIHlvdXIgc2Nyb2xsYmFyIGlzIHVzaW5nIGBzY3JvbGxSZWFsQ29udGVudGBcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5jcmVtZW50OiAxLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgYmFyU3R5bGVzXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsYmFyIHN0eWxlcyB0byBiZSBhcHBsaWVkIGJ5IHtAbGluayBGaW5CYXIjcmVzaXplfHJlc2l6ZSgpfS5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSB2YWx1ZSB0byBiZSBhc3NpZ25lZCB0byB7QGxpbmsgRmluQmFyI3N0eWxlc3xzdHlsZXN9IG9uIGVhY2ggY2FsbCB0byB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0uIFRoYXQgaXMsIGEgaGFzaCBvZiB2YWx1ZXMgdG8gYmUgY29waWVkIHRvIHRoZSBzY3JvbGxiYXIgZWxlbWVudCdzIHN0eWxlIG9iamVjdCBvbiByZXNpemU7IG9yIGBudWxsYCBmb3Igbm9uZS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNzdHlsZXxzdHlsZX1cbiAgICAgKiBAdHlwZSB7ZmluYmFyU3R5bGVzfG51bGx9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBiYXJTdHlsZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBzdHlsZVxuICAgICAqIEBzdW1tYXJ5IEFkZGl0aW9uYWwgc2Nyb2xsYmFyIHN0eWxlcy5cbiAgICAgKiBAZGVzYyBTZWUgdHlwZSBkZWZpbml0aW9uIGZvciBtb3JlIGRldGFpbHMuIFRoZXNlIHN0eWxlcyBhcmUgYXBwbGllZCBkaXJlY3RseSB0byB0aGUgc2Nyb2xsYmFyJ3MgYGJhcmAgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFZhbHVlcyBhcmUgYWRqdXN0ZWQgYXMgZm9sbG93cyBiZWZvcmUgYmVpbmcgYXBwbGllZCB0byB0aGUgZWxlbWVudDpcbiAgICAgKiAxLiBJbmNsdWRlZCBcInBzZXVkby1wcm9wZXJ0eVwiIG5hbWVzIGZyb20gdGhlIHNjcm9sbGJhcidzIG9yaWVudGF0aW9uIGhhc2gsIHtAbGluayBGaW5CYXIjb2h8b2h9LCBhcmUgdHJhbnNsYXRlZCB0byBhY3R1YWwgcHJvcGVydHkgbmFtZXMgYmVmb3JlIGJlaW5nIGFwcGxpZWQuXG4gICAgICogMi4gV2hlbiB0aGVyZSBhcmUgbWFyZ2lucywgcGVyY2VudGFnZXMgYXJlIHRyYW5zbGF0ZWQgdG8gYWJzb2x1dGUgcGl4ZWwgdmFsdWVzIGJlY2F1c2UgQ1NTIGlnbm9yZXMgbWFyZ2lucyBpbiBpdHMgcGVyY2VudGFnZSBjYWxjdWxhdGlvbnMuXG4gICAgICogMy4gSWYgeW91IGdpdmUgYSB2YWx1ZSB3aXRob3V0IGEgdW5pdCAoYSByYXcgbnVtYmVyKSwgXCJweFwiIHVuaXQgaXMgYXBwZW5kZWQuXG4gICAgICpcbiAgICAgKiBHZW5lcmFsIG5vdGVzOlxuICAgICAqIDEuIEl0IGlzIGFsd2F5cyBwcmVmZXJhYmxlIHRvIHNwZWNpZnkgc3R5bGVzIHZpYSBhIHN0eWxlc2hlZXQuIE9ubHkgc2V0IHRoaXMgcHJvcGVydHkgd2hlbiB5b3UgbmVlZCB0byBzcGVjaWZpY2FsbHkgb3ZlcnJpZGUgKGEpIHN0eWxlc2hlZXQgdmFsdWUocykuXG4gICAgICogMi4gQ2FuIGJlIHNldCBkaXJlY3RseSBvciB2aWEgY2FsbHMgdG8gdGhlIHtAbGluayBGaW5CYXIjcmVzaXplfHJlc2l6ZX0gbWV0aG9kLlxuICAgICAqIDMuIFNob3VsZCBvbmx5IGJlIHNldCBhZnRlciB0aGUgc2Nyb2xsYmFyIGhhcyBiZWVuIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICAgKiA0LiBCZWZvcmUgYXBwbHlpbmcgdGhlc2UgbmV3IHZhbHVlcyB0byB0aGUgZWxlbWVudCwgX2FsbF8gaW4tbGluZSBzdHlsZSB2YWx1ZXMgYXJlIHJlc2V0IChieSByZW1vdmluZyB0aGUgZWxlbWVudCdzIGBzdHlsZWAgYXR0cmlidXRlKSwgZXhwb3NpbmcgaW5oZXJpdGVkIHZhbHVlcyAoZnJvbSBzdHlsZXNoZWV0cykuXG4gICAgICogNS4gRW1wdHkgb2JqZWN0IGhhcyBubyBlZmZlY3QuXG4gICAgICogNi4gRmFsc2V5IHZhbHVlIGluIHBsYWNlIG9mIG9iamVjdCBoYXMgbm8gZWZmZWN0LlxuICAgICAqXG4gICAgICogPiBDQVZFQVQ6IERvIG5vdCBhdHRlbXB0IHRvIHRyZWF0IHRoZSBvYmplY3QgeW91IGFzc2lnbiB0byB0aGlzIHByb3BlcnR5IGFzIGlmIGl0IHdlcmUgYHRoaXMuYmFyLnN0eWxlYC4gU3BlY2lmaWNhbGx5LCBjaGFuZ2luZyB0aGlzIG9iamVjdCBhZnRlciBhc3NpZ25pbmcgaXQgd2lsbCBoYXZlIG5vIGVmZmVjdCBvbiB0aGUgc2Nyb2xsYmFyLiBZb3UgbXVzdCBhc3NpZ24gaXQgYWdhaW4gaWYgeW91IHdhbnQgaXQgdG8gaGF2ZSBhbiBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjYmFyU3R5bGVzfGJhclN0eWxlc31cbiAgICAgKiBAdHlwZSB7ZmluYmFyU3R5bGVzfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IHN0eWxlKHN0eWxlcykge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlcyA9IGV4dGVuZCh7fSwgc3R5bGVzLCB0aGlzLl9hdXhTdHlsZXMpKTtcblxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBiYXIgPSB0aGlzLmJhcixcbiAgICAgICAgICAgICAgICBiYXJSZWN0ID0gYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyIHx8IGJhci5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICAgb2ggPSB0aGlzLm9oO1xuXG4gICAgICAgICAgICAvLyBCZWZvcmUgYXBwbHlpbmcgbmV3IHN0eWxlcywgcmV2ZXJ0IGFsbCBzdHlsZXMgdG8gdmFsdWVzIGluaGVyaXRlZCBmcm9tIHN0eWxlc2hlZXRzXG4gICAgICAgICAgICBiYXIucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBzdHlsZXNba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gb2gpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gb2hba2V5XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKE51bWJlcih2YWwpKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAodmFsIHx8IDApICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC8lJC8udGVzdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gYmFyIHNpemUgZ2l2ZW4gYXMgcGVyY2VudGFnZSBvZiBjb250YWluZXIsIGlmIGJhciBoYXMgbWFyZ2lucywgcmVzdGF0ZSBzaXplIGluIHBpeGVscyBsZXNzIG1hcmdpbnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIChJZiBsZWZ0IGFzIHBlcmNlbnRhZ2UsIENTUydzIGNhbGN1bGF0aW9uIHdpbGwgbm90IGV4Y2x1ZGUgbWFyZ2lucy4pXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmllbnRlZCA9IGF4aXNba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbnMgPSBiYXJSZWN0W29yaWVudGVkLm1hcmdpbkxlYWRpbmddICsgYmFyUmVjdFtvcmllbnRlZC5tYXJnaW5UcmFpbGluZ107XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJnaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUludCh2YWwsIDEwKSAvIDEwMCAqIGNvbnRhaW5lclJlY3Rbb3JpZW50ZWQuc2l6ZV0gLSBtYXJnaW5zICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJhci5zdHlsZVtrZXldID0gdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG5hbWUgcGFnaW5nXG4gICAgICogQHN1bW1hcnkgRW5hYmxlIHBhZ2UgdXAvZG4gY2xpY2tzLlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogSWYgdHJ1dGh5LCBsaXN0ZW4gZm9yIGNsaWNrcyBpbiBwYWdlLXVwIGFuZCBwYWdlLWRvd24gcmVnaW9ucyBvZiBzY3JvbGxiYXIuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QsIGNhbGwgYC5wYWdpbmcudXAoKWAgb24gcGFnZS11cCBjbGlja3MgYW5kIGAucGFnaW5nLmRvd24oKWAgd2lsbCBiZSBjYWxsZWQgb24gcGFnZS1kb3duIGNsaWNrcy5cbiAgICAgKlxuICAgICAqIENoYW5naW5nIHRoZSB0cnV0aGluZXNzIG9mIHRoaXMgdmFsdWUgYWZ0ZXIgaW5zdGFudGlhdGlvbiBjdXJyZW50bHkgaGFzIG5vIGVmZmVjdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnxvYmplY3R9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWdpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSByYW5nZVxuICAgICAqIEBzdW1tYXJ5IFNldHRlciBmb3IgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gc2Nyb2xsIHZhbHVlcy5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBUaGVzZSB2YWx1ZXMgYXJlIHRoZSBsaW1pdHMgZm9yIHtAbGluayBGb29CYXIjaW5kZXh8aW5kZXh9LlxuICAgICAqXG4gICAgICogVGhlIHNldHRlciBhY2NlcHRzIGFuIG9iamVjdCB3aXRoIGV4YWN0bHkgdHdvIG51bWVyaWMgcHJvcGVydGllczogYC5taW5gIHdoaWNoIG11c3QgYmUgbGVzcyB0aGFuIGAubWF4YC4gVGhlIHZhbHVlcyBhcmUgZXh0cmFjdGVkIGFuZCB0aGUgb2JqZWN0IGlzIGRpc2NhcmRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBnZXR0ZXIgcmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBgLm1pbmAgYW5kICcubWF4YC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtyYW5nZVR5cGV9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXQgcmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgdmFsaWRSYW5nZShyYW5nZSk7XG4gICAgICAgIHRoaXMuX21pbiA9IHJhbmdlLm1pbjtcbiAgICAgICAgdGhpcy5fbWF4ID0gcmFuZ2UubWF4O1xuICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gcmFuZ2UubWF4IC0gcmFuZ2UubWluICsgMTtcbiAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuaW5kZXg7IC8vIHJlLWNsYW1wXG4gICAgfSxcbiAgICBnZXQgcmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IHRoaXMuX21pbixcbiAgICAgICAgICAgIG1heDogdGhpcy5fbWF4XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEluZGV4IHZhbHVlIG9mIHRoZSBzY3JvbGxiYXIuXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgcG9zaXRpb24gb2YgdGhlIHNjcm9sbCB0aHVtYi5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyB2YWx1ZSBjbGFtcHMgaXQgdG8ge0BsaW5rIEZpbkJhciNtaW58bWlufS4ue0BsaW5rIEZpbkJhciNtYXh8bWF4fSwgc2Nyb2xsIHRoZSBjb250ZW50LCBhbmQgbW92ZXMgdGh1bWIuXG4gICAgICpcbiAgICAgKiBHZXR0aW5nIHRoaXMgdmFsdWUgcmV0dXJucyB0aGUgY3VycmVudCBpbmRleC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgaW4gdGhlIHJhbmdlIGBtaW5gLi5gbWF4YC4gSXQgaXMgaW50ZW50aW9uYWxseSBub3Qgcm91bmRlZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIHZhbHVlIGFzIGFuIGFsdGVybmF0aXZlIHRvIChvciBpbiBhZGRpdGlvbiB0bykgdXNpbmcgdGhlIHtAbGluayBGaW5CYXIjb25jaGFuZ2V8b25jaGFuZ2V9IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI19zZXRTY3JvbGx8X3NldFNjcm9sbH1cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IGluZGV4KGlkeCkge1xuICAgICAgICBpZHggPSBNYXRoLm1pbih0aGlzLl9tYXgsIE1hdGgubWF4KHRoaXMuX21pbiwgaWR4KSk7IC8vIGNsYW1wIGl0XG4gICAgICAgIHRoaXMuX3NldFNjcm9sbChpZHgpO1xuICAgICAgICAvLyB0aGlzLl9zZXRUaHVtYlNpemUoKTtcbiAgICB9LFxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdW1tYXJ5IE1vdmUgdGhlIHRodW1iLlxuICAgICAqIEBkZXNjIEFsc28gZGlzcGxheXMgdGhlIGluZGV4IHZhbHVlIGluIHRoZSB0ZXN0IHBhbmVsIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0gaWR4IC0gVGhlIG5ldyBzY3JvbGwgaW5kZXgsIGEgdmFsdWUgaW4gdGhlIHJhbmdlIGBtaW5gLi5gbWF4YC5cbiAgICAgKiBAcGFyYW0gW3NjYWxlZD1mKGlkeCldIC0gVGhlIG5ldyB0aHVtYiBwb3NpdGlvbiBpbiBwaXhlbHMgYW5kIHNjYWxlZCByZWxhdGl2ZSB0byB0aGUgY29udGFpbmluZyB7QGxpbmsgRmluQmFyI2JhcnxiYXJ9IGVsZW1lbnQsIGkuZS4sIGEgcHJvcG9ydGlvbmFsIG51bWJlciBpbiB0aGUgcmFuZ2UgYDBgLi5gdGh1bWJNYXhgLiBXaGVuIG9taXR0ZWQsIGEgZnVuY3Rpb24gb2YgYGlkeGAgaXMgdXNlZC5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIF9zZXRTY3JvbGw6IGZ1bmN0aW9uIChpZHgsIHNjYWxlZCkge1xuICAgICAgICB0aGlzLl9pbmRleCA9IGlkeDtcblxuICAgICAgICAvLyBEaXNwbGF5IHRoZSBpbmRleCB2YWx1ZSBpbiB0aGUgdGVzdCBwYW5lbFxuICAgICAgICBpZiAodGhpcy50ZXN0UGFuZWxJdGVtICYmIHRoaXMudGVzdFBhbmVsSXRlbS5pbmRleCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudGVzdFBhbmVsSXRlbS5pbmRleC5pbm5lckhUTUwgPSBNYXRoLnJvdW5kKGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFja1xuICAgICAgICBpZiAodGhpcy5vbmNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbmNoYW5nZS5jYWxsKHRoaXMsIE1hdGgucm91bmQoaWR4KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ZlIHRoZSB0aHVtYlxuICAgICAgICBpZiAoc2NhbGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNjYWxlZCA9IChpZHggLSB0aGlzLl9taW4pIC8gKHRoaXMuX21heCAtIHRoaXMuX21pbikgKiB0aGlzLl90aHVtYk1heDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRodW1iLnN0eWxlW3RoaXMub2gubGVhZGluZ10gPSBzY2FsZWQgKyAncHgnO1xuICAgIH0sXG5cbiAgICBzY3JvbGxSZWFsQ29udGVudDogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICB2YXIgY29udGFpbmVyUmVjdCA9IHRoaXMuY29udGVudC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgc2l6ZVByb3AgPSB0aGlzLm9oLnNpemUsXG4gICAgICAgICAgICBtYXhTY3JvbGwgPSBNYXRoLm1heCgwLCB0aGlzLmNvbnRlbnRbc2l6ZVByb3BdIC0gY29udGFpbmVyUmVjdFtzaXplUHJvcF0pLFxuICAgICAgICAgICAgLy9zY3JvbGwgPSBNYXRoLm1pbihpZHgsIG1heFNjcm9sbCk7XG4gICAgICAgICAgICBzY3JvbGwgPSAoaWR4IC0gdGhpcy5fbWluKSAvICh0aGlzLl9tYXggLSB0aGlzLl9taW4pICogbWF4U2Nyb2xsO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdzY3JvbGw6ICcgKyBzY3JvbGwpO1xuICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGVbdGhpcy5vaC5sZWFkaW5nXSA9IC1zY3JvbGwgKyAncHgnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZWNhbGN1bGF0ZSB0aHVtYiBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHJlY2FsY3VsYXRlcyB0aGUgdGh1bWIgc2l6ZSBhbmQgcG9zaXRpb24uIENhbGwgaXQgb25jZSBhZnRlciBpbnNlcnRpbmcgeW91ciBzY3JvbGxiYXIgaW50byB0aGUgRE9NLCBhbmQgcmVwZWF0ZWRseSB3aGlsZSByZXNpemluZyB0aGUgc2Nyb2xsYmFyICh3aGljaCB0eXBpY2FsbHkgaGFwcGVucyB3aGVuIHRoZSBzY3JvbGxiYXIncyBwYXJlbnQgaXMgcmVzaXplZCBieSB1c2VyLlxuICAgICAqXG4gICAgICogPiBUaGlzIGZ1bmN0aW9uIHNoaWZ0cyBhcmdzIGlmIGZpcnN0IGFyZyBvbWl0dGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmNyZW1lbnQ9dGhpcy5pbmNyZW1lbnRdIC0gUmVzZXRzIHtAbGluayBGb29CYXIjaW5jcmVtZW50fGluY3JlbWVudH0gKHNlZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ZpbmJhclN0eWxlc30gW2JhclN0eWxlcz10aGlzLmJhclN0eWxlc10gLSAoU2VlIHR5cGUgZGVmaW5pdGlvbiBmb3IgZGV0YWlscy4pIFNjcm9sbGJhciBzdHlsZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgYmFyIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBPbmx5IHNwZWNpZnkgYSBgYmFyU3R5bGVzYCBvYmplY3Qgd2hlbiB5b3UgbmVlZCB0byBvdmVycmlkZSBzdHlsZXNoZWV0IHZhbHVlcy4gSWYgcHJvdmlkZWQsIGJlY29tZXMgdGhlIG5ldyBkZWZhdWx0IChgdGhpcy5iYXJTdHlsZXNgKSwgZm9yIHVzZSBhcyBhIGRlZmF1bHQgb24gc3Vic2VxdWVudCBjYWxscy5cbiAgICAgKlxuICAgICAqIEl0IGlzIGdlbmVyYWxseSB0aGUgY2FzZSB0aGF0IHRoZSBzY3JvbGxiYXIncyBuZXcgcG9zaXRpb24gaXMgc3VmZmljaWVudGx5IGRlc2NyaWJlZCBieSB0aGUgY3VycmVudCBzdHlsZXMuIFRoZXJlZm9yZSwgaXQgaXMgdW51c3VhbCB0byBuZWVkIHRvIHByb3ZpZGUgYSBgYmFyU3R5bGVzYCBvYmplY3Qgb24gZXZlcnkgY2FsbCB0byBgcmVzaXplYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGaW5CYXJ9IFNlbGYgZm9yIGNoYWluaW5nLlxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbiAoaW5jcmVtZW50LCBiYXJTdHlsZXMpIHtcbiAgICAgICAgdmFyIGJhciA9IHRoaXMuYmFyO1xuXG4gICAgICAgIGlmICghYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gbm90IGluIERPTSB5ZXQgc28gbm90aGluZyB0byBkb1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyIHx8IGJhci5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAvLyBzaGlmdCBhcmdzIGlmIGlmIDFzdCBhcmcgb21pdHRlZFxuICAgICAgICBpZiAodHlwZW9mIGluY3JlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGJhclN0eWxlcyA9IGluY3JlbWVudDtcbiAgICAgICAgICAgIGluY3JlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3R5bGUgPSB0aGlzLmJhclN0eWxlcyA9IGJhclN0eWxlcyB8fCB0aGlzLmJhclN0eWxlcztcblxuICAgICAgICAvLyBCb3VuZCB0byByZWFsIGNvbnRlbnQ6IENvbnRlbnQgd2FzIGdpdmVuIGJ1dCBubyBvbmNoYW5nZSBoYW5kbGVyLlxuICAgICAgICAvLyBTZXQgdXAgLm9uY2hhbmdlLCAuY29udGFpbmVyU2l6ZSwgYW5kIC5pbmNyZW1lbnQuXG4gICAgICAgIC8vIE5vdGUgdGhpcyBvbmx5IG1ha2VzIHNlbnNlIGlmIHlvdXIgaW5kZXggdW5pdCBpcyBwaXhlbHMuXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vbmNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25jaGFuZ2UgPSB0aGlzLnNjcm9sbFJlYWxDb250ZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFNpemUgPSB0aGlzLmNvbnRlbnRbdGhpcy5vaC5zaXplXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW4gPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX21heCA9IHRoaXMuY29udGVudFNpemUgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uY2hhbmdlID09PSB0aGlzLnNjcm9sbFJlYWxDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclNpemUgPSBjb250YWluZXJSZWN0W3RoaXMub2guc2l6ZV07XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudCA9IHRoaXMuY29udGFpbmVyU2l6ZSAvICh0aGlzLmNvbnRlbnRTaXplIC0gdGhpcy5jb250YWluZXJTaXplKSAqICh0aGlzLl9tYXggLSB0aGlzLl9taW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJTaXplID0gMTtcbiAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50ID0gaW5jcmVtZW50IHx8IHRoaXMuaW5jcmVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy50ZXN0UGFuZWxJdGVtID0gdGhpcy50ZXN0UGFuZWxJdGVtIHx8IHRoaXMuX2FkZFRlc3RQYW5lbEl0ZW0oKTtcbiAgICAgICAgdGhpcy5fc2V0VGh1bWJTaXplKCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcblxuICAgICAgICBpZiAodGhpcy5kZWx0YVByb3AgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX2JvdW5kLm9ud2hlZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNob3J0ZW4gdHJhaWxpbmcgZW5kIG9mIHNjcm9sbGJhciBieSB0aGlja25lc3Mgb2Ygc29tZSBvdGhlciBzY3JvbGxiYXIuXG4gICAgICogQGRlc2MgSW4gdGhlIFwiY2xhc3NpY2FsXCIgc2NlbmFyaW8gd2hlcmUgdmVydGljYWwgc2Nyb2xsIGJhciBpcyBvbiB0aGUgcmlnaHQgYW5kIGhvcml6b250YWwgc2Nyb2xsYmFyIGlzIG9uIHRoZSBib3R0b20sIHlvdSB3YW50IHRvIHNob3J0ZW4gdGhlIFwidHJhaWxpbmcgZW5kXCIgKGJvdHRvbSBhbmQgcmlnaHQgZW5kcywgcmVzcGVjdGl2ZWx5KSBvZiBhdCBsZWFzdCBvbmUgb2YgdGhlbSBzbyB0aGV5IGRvbid0IG92ZXJsYXkuXG4gICAgICpcbiAgICAgKiBUaGlzIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGlzIGFuIHByb2dyYW1tYXRpYyBhbHRlcm5hdGl2ZSB0byBoYXJkY29kaW5nIHRoZSBjb3JyZWN0IHN0eWxlIHdpdGggdGhlIGNvcnJlY3QgdmFsdWUgaW4geW91ciBzdHlsZXNoZWV0OyBvciBzZXR0aW5nIHRoZSBjb3JyZWN0IHN0eWxlIHdpdGggdGhlIGNvcnJlY3QgdmFsdWUgaW4gdGhlIHtAbGluayBGaW5CYXIjYmFyU3R5bGVzfGJhclN0eWxlc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI2ZvcmVzaG9ydGVuQnl8Zm9yZXNob3J0ZW5CeX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZpbkJhcnxudWxsfSBvdGhlckZpbkJhciAtIE90aGVyIHNjcm9sbGJhciB0byBhdm9pZCBieSBzaG9ydGVuaW5nIHRoaXMgb25lOyBgbnVsbGAgcmVtb3ZlcyB0aGUgdHJhaWxpbmcgc3BhY2VcbiAgICAgKiBAcmV0dXJucyB7RmluQmFyfSBGb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBzaG9ydGVuQnk6IGZ1bmN0aW9uIChvdGhlckZpbkJhcikgeyByZXR1cm4gdGhpcy5zaG9ydGVuRW5kQnkoJ3RyYWlsaW5nJywgb3RoZXJGaW5CYXIpOyB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2hvcnRlbiBsZWFkaW5nIGVuZCBvZiBzY3JvbGxiYXIgYnkgdGhpY2tuZXNzIG9mIHNvbWUgb3RoZXIgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIFN1cHBvcnRzIG5vbi1jbGFzc2ljYWwgc2Nyb2xsYmFyIHNjZW5hcmlvcyB3aGVyZSB2ZXJ0aWNhbCBzY3JvbGwgYmFyIG1heSBiZSBvbiBsZWZ0IGFuZCBob3Jpem9udGFsIHNjcm9sbGJhciBtYXkgYmUgb24gdG9wLCBpbiB3aGljaCBjYXNlIHlvdSB3YW50IHRvIHNob3J0ZW4gdGhlIFwibGVhZGluZyBlbmRcIiByYXRoZXIgdGhhbiB0aGUgdHJhaWxpbmcgZW5kLlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNzaG9ydGVuQnl8c2hvcnRlbkJ5fS5cbiAgICAgKiBAcGFyYW0ge0ZpbkJhcnxudWxsfSBvdGhlckZpbkJhciAtIE90aGVyIHNjcm9sbGJhciB0byBhdm9pZCBieSBzaG9ydGVuaW5nIHRoaXMgb25lOyBgbnVsbGAgcmVtb3ZlcyB0aGUgdHJhaWxpbmcgc3BhY2VcbiAgICAgKiBAcmV0dXJucyB7RmluQmFyfSBGb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBmb3Jlc2hvcnRlbkJ5OiBmdW5jdGlvbiAob3RoZXJGaW5CYXIpIHsgcmV0dXJuIHRoaXMuc2hvcnRlbkVuZEJ5KCdsZWFkaW5nJywgb3RoZXJGaW5CYXIpOyB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2VuZXJhbGl6ZWQgc2hvcnRlbmluZyBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc2hvcnRlbkJ5fHNob3J0ZW5CeX0uXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI2ZvcmVzaG9ydGVuQnl8Zm9yZXNob3J0ZW5CeX0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdoaWNoRW5kIC0gYSBDU1Mgc3R5bGUgcHJvcGVydHkgbmFtZSBvciBhbiBvcmllbnRhdGlvbiBoYXNoIG5hbWUgdGhhdCB0cmFuc2xhdGVzIHRvIGEgQ1NTIHN0eWxlIHByb3BlcnR5IG5hbWUuXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgc2hvcnRlbkVuZEJ5OiBmdW5jdGlvbiAod2hpY2hFbmQsIG90aGVyRmluQmFyKSB7XG4gICAgICAgIGlmICghb3RoZXJGaW5CYXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hdXhTdHlsZXM7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoZXJGaW5CYXIgaW5zdGFuY2VvZiBGaW5CYXIgJiYgb3RoZXJGaW5CYXIub3JpZW50YXRpb24gIT09IHRoaXMub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBvdGhlclN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUob3RoZXJGaW5CYXIuYmFyKSxcbiAgICAgICAgICAgICAgICBvb2ggPSBvcmllbnRhdGlvbkhhc2hlc1tvdGhlckZpbkJhci5vcmllbnRhdGlvbl07XG4gICAgICAgICAgICB0aGlzLl9hdXhTdHlsZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2F1eFN0eWxlc1t3aGljaEVuZF0gPSBvdGhlclN0eWxlW29vaC50aGlja25lc3NdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSBTZXRzIHRoZSBwcm9wb3J0aW9uYWwgdGh1bWIgc2l6ZSBhbmQgaGlkZXMgdGh1bWIgd2hlbiAxMDAlLlxuICAgICAqIEBkZXNjIFRoZSB0aHVtYiBzaXplIGhhcyBhbiBhYnNvbHV0ZSBtaW5pbXVtIG9mIDIwIChwaXhlbHMpLlxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgX3NldFRodW1iU2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2ggPSB0aGlzLm9oLFxuICAgICAgICAgICAgdGh1bWJDb21wID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy50aHVtYiksXG4gICAgICAgICAgICB0aHVtYk1hcmdpbkxlYWRpbmcgPSBwYXJzZUludCh0aHVtYkNvbXBbb2gubWFyZ2luTGVhZGluZ10pLFxuICAgICAgICAgICAgdGh1bWJNYXJnaW5UcmFpbGluZyA9IHBhcnNlSW50KHRodW1iQ29tcFtvaC5tYXJnaW5UcmFpbGluZ10pLFxuICAgICAgICAgICAgdGh1bWJNYXJnaW5zID0gdGh1bWJNYXJnaW5MZWFkaW5nICsgdGh1bWJNYXJnaW5UcmFpbGluZyxcbiAgICAgICAgICAgIGJhclNpemUgPSB0aGlzLmJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtvaC5zaXplXSxcbiAgICAgICAgICAgIHRodW1iU2l6ZSA9IE1hdGgubWF4KDIwLCBiYXJTaXplICogdGhpcy5jb250YWluZXJTaXplIC8gdGhpcy5jb250ZW50U2l6ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyU2l6ZSA8IHRoaXMuY29udGVudFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICB0aGlzLnRodW1iLnN0eWxlW29oLnNpemVdID0gdGh1bWJTaXplICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbmFtZSBfdGh1bWJNYXhcbiAgICAgICAgICogQHN1bW1hcnkgTWF4aW11bSBvZmZzZXQgb2YgdGh1bWIncyBsZWFkaW5nIGVkZ2UuXG4gICAgICAgICAqIEBkZXNjIFRoaXMgaXMgdGhlIHBpeGVsIG9mZnNldCB3aXRoaW4gdGhlIHNjcm9sbGJhciBvZiB0aGUgdGh1bWIgd2hlbiBpdCBpcyBhdCBpdHMgbWF4aW11bSBwb3NpdGlvbiBhdCB0aGUgZXh0cmVtZSBlbmQgb2YgaXRzIHJhbmdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHZhbHVlIHRha2VzIGludG8gYWNjb3VudCB0aGUgbmV3bHkgY2FsY3VsYXRlZCBzaXplIG9mIHRoZSB0aHVtYiBlbGVtZW50IChpbmNsdWRpbmcgaXRzIG1hcmdpbnMpIGFuZCB0aGUgaW5uZXIgc2l6ZSBvZiB0aGUgc2Nyb2xsYmFyICh0aGUgdGh1bWIncyBjb250YWluaW5nIGVsZW1lbnQsIGluY2x1ZGluZyBfaXRzXyBtYXJnaW5zKS5cbiAgICAgICAgICpcbiAgICAgICAgICogTk9URTogU2Nyb2xsYmFyIHBhZGRpbmcgaXMgbm90IHRha2VuIGludG8gYWNjb3VudCBhbmQgYXNzdW1lZCB0byBiZSAwIGluIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIGFuZCBpcyBhc3N1bWVkIHRvIGJlIGAwYDsgdXNlIHRodW1iIG1hcmdpbnMgaW4gcGxhY2Ugb2Ygc2Nyb2xsYmFyIHBhZGRpbmcuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90aHVtYk1heCA9IGJhclNpemUgLSB0aHVtYlNpemUgLSB0aHVtYk1hcmdpbnM7XG5cbiAgICAgICAgdGhpcy5fdGh1bWJNYXJnaW5MZWFkaW5nID0gdGh1bWJNYXJnaW5MZWFkaW5nOyAvLyB1c2VkIGluIG1vdXNlZG93blxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZW1vdmUgdGhlIHNjcm9sbGJhci5cbiAgICAgKiBAZGVzYyBVbmhvb2tzIGFsbCB0aGUgZXZlbnQgaGFuZGxlcnMgYW5kIHRoZW4gcmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00uIEFsd2F5cyBjYWxsIHRoaXMgbWV0aG9kIHByaW9yIHRvIGRpc3Bvc2luZyBvZiB0aGUgc2Nyb2xsYmFyIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdnQoJ21vdXNlZG93bicpO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdnQoJ21vdXNlbW92ZScpO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdnQoJ21vdXNldXAnKTtcblxuICAgICAgICAodGhpcy5jb250YWluZXIgfHwgdGhpcy5iYXIucGFyZW50RWxlbWVudCkuX3JlbW92ZUV2dCgnd2hlZWwnLCB0aGlzLl9ib3VuZC5vbndoZWVsKTtcblxuICAgICAgICB0aGlzLmJhci5vbmNsaWNrID1cbiAgICAgICAgICAgIHRoaXMudGh1bWIub25jbGljayA9XG4gICAgICAgICAgICAgICAgdGhpcy50aHVtYi5vbm1vdXNlb3ZlciA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGh1bWIudHJhbnNpdGlvbmVuZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRodW1iLm9ubW91c2VvdXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuYmFyLnJlbW92ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBfYWRkVGVzdFBhbmVsSXRlbVxuICAgICAqIEBzdW1tYXJ5IEFwcGVuZCBhIHRlc3QgcGFuZWwgZWxlbWVudC5cbiAgICAgKiBAZGVzYyBJZiB0aGVyZSBpcyBhIHRlc3QgcGFuZWwgaW4gdGhlIERPTSAodHlwaWNhbGx5IGFuIGA8b2w+Li4uPC9vbD5gIGVsZW1lbnQpIHdpdGggY2xhc3MgbmFtZXMgb2YgYm90aCBgdGhpcy5jbGFzc1ByZWZpeGAgYW5kIGAndGVzdC1wYW5lbCdgIChvciwgYmFycmluZyB0aGF0LCBhbnkgZWxlbWVudCB3aXRoIGNsYXNzIG5hbWUgYCd0ZXN0LXBhbmVsJ2ApLCBhbiBgPGxpPi4uLjwvbGk+YCBlbGVtZW50IHdpbGwgYmUgY3JlYXRlZCBhbmQgYXBwZW5kZWQgdG8gaXQuIFRoaXMgbmV3IGVsZW1lbnQgd2lsbCBjb250YWluIGEgc3BhbiBmb3IgZWFjaCBjbGFzcyBuYW1lIGdpdmVuLlxuICAgICAqXG4gICAgICogWW91IHNob3VsZCBkZWZpbmUgYSBDU1Mgc2VsZWN0b3IgYC5saXN0ZW5pbmdgIGZvciB0aGVzZSBzcGFucy4gVGhpcyBjbGFzcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzcGFucyB0byBhbHRlciB0aGVpciBhcHBlYXJhbmNlIHdoZW4gYSBsaXN0ZW5lciBpcyBhZGRlZCB3aXRoIHRoYXQgY2xhc3MgbmFtZSAocHJlZml4ZWQgd2l0aCAnb24nKS5cbiAgICAgKlxuICAgICAqIChUaGlzIGlzIGFuIGludGVybmFsIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uY2UgYnkgdGhlIGNvbnN0cnVjdG9yIG9uIGV2ZXJ5IGluc3RhbnRpYXRpb24uKVxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fHVuZGVmaW5lZH0gVGhlIGFwcGVuZGVkIGA8bGk+Li4uPC9saT5gIGVsZW1lbnQgb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgaXMgbm8gdGVzdCBwYW5lbC5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIF9hZGRUZXN0UGFuZWxJdGVtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXN0UGFuZWxJdGVtLFxuICAgICAgICAgICAgdGVzdFBhbmVsRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy5fY2xhc3NQcmVmaXggKyAnLnRlc3QtcGFuZWwnKSB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGVzdC1wYW5lbCcpO1xuXG4gICAgICAgIGlmICh0ZXN0UGFuZWxFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgdGVzdFBhbmVsSXRlbVBhcnROYW1lcyA9IFsgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdpbmRleCcgXSxcbiAgICAgICAgICAgICAgICBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblxuICAgICAgICAgICAgdGVzdFBhbmVsSXRlbVBhcnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0TmFtZSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uaW5uZXJIVE1MICs9ICc8c3BhbiBjbGFzcz1cIicgKyBwYXJ0TmFtZSArICdcIj4nICsgcGFydE5hbWUucmVwbGFjZSgnbW91c2UnLCAnJykgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGVzdFBhbmVsRWxlbWVudC5hcHBlbmRDaGlsZChpdGVtKTtcblxuICAgICAgICAgICAgdGVzdFBhbmVsSXRlbSA9IHt9O1xuICAgICAgICAgICAgdGVzdFBhbmVsSXRlbVBhcnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0TmFtZSkge1xuICAgICAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW1bcGFydE5hbWVdID0gaXRlbS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHBhcnROYW1lKVswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRlc3RQYW5lbEl0ZW07XG4gICAgfSxcblxuICAgIF9hZGRFdnQ6IGZ1bmN0aW9uIChldnROYW1lKSB7XG4gICAgICAgIHZhciBzcHkgPSB0aGlzLnRlc3RQYW5lbEl0ZW0gJiYgdGhpcy50ZXN0UGFuZWxJdGVtW2V2dE5hbWVdO1xuICAgICAgICBpZiAoc3B5KSB7IHNweS5jbGFzc0xpc3QuYWRkKCdsaXN0ZW5pbmcnKTsgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldnROYW1lLCB0aGlzLl9ib3VuZFsnb24nICsgZXZ0TmFtZV0pO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlRXZ0OiBmdW5jdGlvbiAoZXZ0TmFtZSkge1xuICAgICAgICB2YXIgc3B5ID0gdGhpcy50ZXN0UGFuZWxJdGVtICYmIHRoaXMudGVzdFBhbmVsSXRlbVtldnROYW1lXTtcbiAgICAgICAgaWYgKHNweSkgeyBzcHkuY2xhc3NMaXN0LnJlbW92ZSgnbGlzdGVuaW5nJyk7IH1cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0TmFtZSwgdGhpcy5fYm91bmRbJ29uJyArIGV2dE5hbWVdKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBleHRlbmQob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG9iam4gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGlmIChvYmpuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2Jqbikge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gb2JqbltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHZhbGlkUmFuZ2UocmFuZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJhbmdlKSxcbiAgICAgICAgdmFsaWQgPSAga2V5cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIHR5cGVvZiByYW5nZS5taW4gPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICB0eXBlb2YgcmFuZ2UubWF4ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgcmFuZ2UubWluIDw9IHJhbmdlLm1heDtcblxuICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgLnJhbmdlIG9iamVjdC4nKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhbmRsZXJzVG9CZUJvdW5kXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQGRlc2MgVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIGluIHRoaXMgb2JqZWN0IGFyZSBhbGwgRE9NIGV2ZW50IGhhbmRsZXJzIHRoYXQgYXJlIGJvdW5kIGJ5IHRoZSBGaW5CYXIgY29uc3RydWN0b3IgdG8gZWFjaCBuZXcgaW5zdGFuY2UuIEluIG90aGVyIHdvcmRzLCB0aGUgYHRoaXNgIHZhbHVlIG9mIHRoZXNlIGhhbmRsZXJzLCBvbmNlIGJvdW5kLCByZWZlciB0byB0aGUgRmluQmFyIG9iamVjdCBhbmQgbm90IHRvIHRoZSBldmVudCBlbWl0dGVyLiBcIkRvIG5vdCBjb25zdW1lIHJhdy5cIlxuICovXG52YXIgaGFuZGxlcnNUb0JlQm91bmQgPSB7XG4gICAgc2hvcnRTdG9wOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgb253aGVlbDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB0aGlzLmluZGV4ICs9IGV2dFt0aGlzLmRlbHRhUHJvcF07XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIG9uY2xpY2s6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIHRodW1iQm94ID0gdGhpcy50aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIGdvaW5nVXAgPSBldnRbdGhpcy5vaC5jb29yZGluYXRlXSA8IHRodW1iQm94W3RoaXMub2gubGVhZGluZ107XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhZ2luZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnBhZ2luZ1tnb2luZ1VwID8gJ3VwJyA6ICdkb3duJ10oTWF0aC5yb3VuZCh0aGlzLmluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ICs9IGdvaW5nVXAgPyAtdGhpcy5pbmNyZW1lbnQgOiB0aGlzLmluY3JlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2UgdGhlIHRodW1iIGdsb3cgbW9tZW50YXJpbHlcbiAgICAgICAgdGhpcy50aHVtYi5jbGFzc0xpc3QuYWRkKCdob3ZlcicpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMudGh1bWIuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uIHdhaXRGb3JJdCgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHdhaXRGb3JJdCk7XG4gICAgICAgICAgICBzZWxmLl9ib3VuZC5vbm1vdXNldXAoZXZ0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRodW1iLmNsYXNzTGlzdC5hZGQoJ2hvdmVyJyk7XG4gICAgICAgIHRoaXMudGh1bWIub25tb3VzZW91dCA9IHRoaXMuX2JvdW5kLm9ubW91c2VvdXQ7XG4gICAgICAgIHRoaXMuX2FkZEV2dCgnbW91c2Vkb3duJyk7XG4gICAgfSxcblxuICAgIG9ubW91c2VvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZWRvd24nKTtcbiAgICAgICAgdGhpcy50aHVtYi5vbm1vdXNlb3ZlciA9IHRoaXMuX2JvdW5kLm9ubW91c2VvdmVyO1xuICAgICAgICB0aGlzLnRodW1iLmNsYXNzTGlzdC5yZW1vdmUoJ2hvdmVyJyk7XG4gICAgfSxcblxuICAgIG9ubW91c2Vkb3duOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2Vkb3duJyk7XG4gICAgICAgIHRoaXMudGh1bWIub25tb3VzZW92ZXIgPSB0aGlzLnRodW1iLm9ubW91c2VvdXQgPSBudWxsO1xuXG4gICAgICAgIHZhciB0aHVtYkJveCA9IHRoaXMudGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMucGluT2Zmc2V0ID0gZXZ0W3RoaXMub2guYXhpc10gLSB0aHVtYkJveFt0aGlzLm9oLmxlYWRpbmddICsgdGhpcy5iYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbdGhpcy5vaC5sZWFkaW5nXSArIHRoaXMuX3RodW1iTWFyZ2luTGVhZGluZztcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcblxuICAgICAgICB0aGlzLl9hZGRFdnQoJ21vdXNlbW92ZScpO1xuICAgICAgICB0aGlzLl9hZGRFdnQoJ21vdXNldXAnKTtcblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlbW92ZTogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgc2NhbGVkID0gTWF0aC5taW4odGhpcy5fdGh1bWJNYXgsIE1hdGgubWF4KDAsIGV2dFt0aGlzLm9oLmF4aXNdIC0gdGhpcy5waW5PZmZzZXQpKTtcbiAgICAgICAgdmFyIGlkeCA9IHNjYWxlZCAvIHRoaXMuX3RodW1iTWF4ICogKHRoaXMuX21heCAtIHRoaXMuX21pbikgKyB0aGlzLl9taW47XG5cbiAgICAgICAgdGhpcy5fc2V0U2Nyb2xsKGlkeCwgc2NhbGVkKTtcblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNldXA6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmN1cnNvciA9ICdhdXRvJztcblxuICAgICAgICB2YXIgdGh1bWJCb3ggPSB0aGlzLnRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aHVtYkJveC5sZWZ0IDw9IGV2dC5jbGllbnRYICYmIGV2dC5jbGllbnRYIDw9IHRodW1iQm94LnJpZ2h0ICYmXG4gICAgICAgICAgICB0aHVtYkJveC50b3AgPD0gZXZ0LmNsaWVudFkgJiYgZXZ0LmNsaWVudFkgPD0gdGh1bWJCb3guYm90dG9tXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5fYm91bmQub25tb3VzZW92ZXIoZXZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kLm9ubW91c2VvdXQoZXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxudmFyIG9yaWVudGF0aW9uSGFzaGVzID0ge1xuICAgIHZlcnRpY2FsOiB7XG4gICAgICAgIGNvb3JkaW5hdGU6ICAgICAnY2xpZW50WScsXG4gICAgICAgIGF4aXM6ICAgICAgICAgICAncGFnZVknLFxuICAgICAgICBzaXplOiAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgIG91dHNpZGU6ICAgICAgICAncmlnaHQnLFxuICAgICAgICBpbnNpZGU6ICAgICAgICAgJ2xlZnQnLFxuICAgICAgICBsZWFkaW5nOiAgICAgICAgJ3RvcCcsXG4gICAgICAgIHRyYWlsaW5nOiAgICAgICAnYm90dG9tJyxcbiAgICAgICAgbWFyZ2luTGVhZGluZzogICdtYXJnaW5Ub3AnLFxuICAgICAgICBtYXJnaW5UcmFpbGluZzogJ21hcmdpbkJvdHRvbScsXG4gICAgICAgIHRoaWNrbmVzczogICAgICAnd2lkdGgnLFxuICAgICAgICBkZWx0YTogICAgICAgICAgJ2RlbHRhWSdcbiAgICB9LFxuICAgIGhvcml6b250YWw6IHtcbiAgICAgICAgY29vcmRpbmF0ZTogICAgICdjbGllbnRYJyxcbiAgICAgICAgYXhpczogICAgICAgICAgICdwYWdlWCcsXG4gICAgICAgIHNpemU6ICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICBvdXRzaWRlOiAgICAgICAgJ2JvdHRvbScsXG4gICAgICAgIGluc2lkZTogICAgICAgICAndG9wJyxcbiAgICAgICAgbGVhZGluZzogICAgICAgICdsZWZ0JyxcbiAgICAgICAgdHJhaWxpbmc6ICAgICAgICdyaWdodCcsXG4gICAgICAgIG1hcmdpbkxlYWRpbmc6ICAnbWFyZ2luTGVmdCcsXG4gICAgICAgIG1hcmdpblRyYWlsaW5nOiAnbWFyZ2luUmlnaHQnLFxuICAgICAgICB0aGlja25lc3M6ICAgICAgJ2hlaWdodCcsXG4gICAgICAgIGRlbHRhOiAgICAgICAgICAnZGVsdGFYJ1xuICAgIH1cbn07XG5cbnZhciBheGlzID0ge1xuICAgIHRvcDogICAgJ3ZlcnRpY2FsJyxcbiAgICBib3R0b206ICd2ZXJ0aWNhbCcsXG4gICAgaGVpZ2h0OiAndmVydGljYWwnLFxuICAgIGxlZnQ6ICAgJ2hvcml6b250YWwnLFxuICAgIHJpZ2h0OiAgJ2hvcml6b250YWwnLFxuICAgIHdpZHRoOiAgJ2hvcml6b250YWwnXG59O1xuXG52YXIgY3NzRmluQmFyczsgLy8gZGVmaW5pdGlvbiBpbnNlcnRlZCBieSBndWxwZmlsZSBiZXR3ZWVuIGZvbGxvd2luZyBjb21tZW50c1xuLyogaW5qZWN0OmNzcyAqL1xuY3NzRmluQmFycyA9ICdkaXYuZmluYmFyLWhvcml6b250YWwsZGl2LmZpbmJhci12ZXJ0aWNhbHtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW46M3B4fWRpdi5maW5iYXItaG9yaXpvbnRhbD4udGh1bWIsZGl2LmZpbmJhci12ZXJ0aWNhbD4udGh1bWJ7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZC1jb2xvcjojZDNkM2QzOy13ZWJraXQtYm94LXNoYWRvdzowIDAgMXB4ICMwMDA7LW1vei1ib3gtc2hhZG93OjAgMCAxcHggIzAwMDtib3gtc2hhZG93OjAgMCAxcHggIzAwMDtib3JkZXItcmFkaXVzOjRweDttYXJnaW46MnB4O29wYWNpdHk6LjQ7dHJhbnNpdGlvbjpvcGFjaXR5IC41c31kaXYuZmluYmFyLWhvcml6b250YWw+LnRodW1iLmhvdmVyLGRpdi5maW5iYXItdmVydGljYWw+LnRodW1iLmhvdmVye29wYWNpdHk6MTt0cmFuc2l0aW9uOm9wYWNpdHkgLjVzfWRpdi5maW5iYXItdmVydGljYWx7dG9wOjA7Ym90dG9tOjA7cmlnaHQ6MDt3aWR0aDoxMXB4fWRpdi5maW5iYXItdmVydGljYWw+LnRodW1ie3RvcDowO3JpZ2h0OjA7d2lkdGg6N3B4fWRpdi5maW5iYXItaG9yaXpvbnRhbHtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDtoZWlnaHQ6MTFweH1kaXYuZmluYmFyLWhvcml6b250YWw+LnRodW1ie2xlZnQ6MDtib3R0b206MDtoZWlnaHQ6N3B4fSc7XG4vKiBlbmRpbmplY3QgKi9cblxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gICAgdGhyb3cgJ2ZpbmJhcnM6ICcgKyBtc2c7XG59XG5cbi8vIEludGVyZmFjZVxubW9kdWxlLmV4cG9ydHMgPSBGaW5CYXI7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVjdGFuZ3VsYXIgPSByZXF1aXJlKCdyZWN0YW5ndWxhcicpO1xuXG52YXIgZ2VzdHVyZXMgPSByZXF1aXJlKCcuL2pzL3BvbHltZXJnZXN0dXJlcy5kZXYuanMnKTtcbnZhciBHcmFwaGljc0NvbnRleHQgPSByZXF1aXJlKCcuL2pzL0dyYXBoaWNzQ29udGV4dC5qcycpO1xuXG52YXIgUkVTSVpFX1BPTExJTkdfSU5URVJWQUwgPSAyMDAsXG4gICAgcGFpbnRhYmxlcyA9IFtdLFxuICAgIHJlc2l6YWJsZXMgPSBbXSxcbiAgICBwYWludExvb3BSdW5uaW5nID0gdHJ1ZSxcbiAgICByZXNpemVMb29wUnVubmluZyA9IHRydWUsXG4gICAgY2hhck1hcCA9IG1ha2VDaGFyTWFwKCk7XG5cbmZ1bmN0aW9uIENhbnZhcyhkaXYsIGNvbXBvbmVudCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuX2NvbXBvbmVudCA9IGNvbXBvbmVudDtcblxuICAgIHRoaXMuZHJhZ0VuZHRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG5cbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuXG4gICAgLy8gdGhpcy5mb2N1c2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAvLyB0aGlzLmZvY3VzZXIuc3R5bGUudG9wID0gJzBweCc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAvLyB0aGlzLmZvY3VzZXIuc3R5bGUuekluZGV4ID0gJy0xJztcbiAgICAvLyB0aGlzLmZvY3VzZXIuc3R5bGUub3V0bGluZSA9ICdub25lJztcbiAgICAvLyB0aGlzLmRpdi5hcHBlbmRDaGlsZCh0aGlzLmZvY3VzZXIpO1xuXG4gICAgdGhpcy5jYW52YXNDVFggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuZ2MgPSBuZXcgR3JhcGhpY3NDb250ZXh0KHRoaXMuY2FudmFzQ1RYKTtcblxuICAgIHRoaXMuYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5idWZmZXJDVFggPSB0aGlzLmJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuYnVmZmVyR0MgPSBuZXcgR3JhcGhpY3NDb250ZXh0KHRoaXMuYnVmZmVyQ1RYKTtcblxuICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgtMSwgLTEpO1xuICAgIHRoaXMuZHJhZ3N0YXJ0ID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KC0xLCAtMSk7XG4gICAgLy90aGlzLm9yaWdpbiA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgwLCAwKTtcbiAgICB0aGlzLmJvdW5kcyA9IG5ldyByZWN0YW5ndWxhci5SZWN0YW5nbGUoMCwgMCwgMCwgMCk7XG4gICAgdGhpcy5oYXNNb3VzZSA9IGZhbHNlO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoc2VsZi5oYXNNb3VzZSB8fCBzZWxmLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgc2VsZi5maW5tb3VzZW1vdmUoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbm1vdXNldXAoZSk7XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmlud2hlZWxtb3ZlZChlKTtcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmtleWRvd24oZSk7XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmlua2V5dXAoZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5vbm1vdXNlb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmhhc01vdXNlID0gdHJ1ZTtcbiAgICB9O1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmZvY3VzZ2FpbmVkKGUpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluZm9jdXNsb3N0KGUpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5tb3VzZWRvd24oZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuaGFzTW91c2UgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5maW5tb3VzZW91dChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5jbGljayhlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5jb250ZXh0bWVudShlKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBnZXN0dXJlcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuY2FudmFzLCAndGFwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbnRhcChlKTtcbiAgICB9KTtcbiAgICBnZXN0dXJlcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuY2FudmFzLCAnaG9sZHB1bHNlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmhvbGRwdWxzZShlKTtcbiAgICB9KTtcbiAgICBnZXN0dXJlcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuY2FudmFzLCAnZmxpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluZmxpY2soZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3JlbGVhc2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmlucmVsZWFzZShlKTtcbiAgICB9KTtcbiAgICBnZXN0dXJlcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuY2FudmFzLCAndHJhY2tzdGFydCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW50cmFja3N0YXJ0KGUpO1xuICAgIH0pO1xuICAgIGdlc3R1cmVzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5jYW52YXMsICd0cmFjaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW50cmFjayhlKTtcbiAgICB9KTtcbiAgICBnZXN0dXJlcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuY2FudmFzLCAndHJhY2tlbmQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmludHJhY2tlbmQoZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgdGhpcy5jYW52YXMuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcblxuICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICB0aGlzLmJlZ2luUmVzaXppbmcoKTtcbiAgICB0aGlzLmJlZ2luUGFpbnRpbmcoKTtcbn1cblxuQ2FudmFzLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ2FudmFzLnByb3RvdHlwZS5jb25zdHJ1Y3RvcixcbiAgICBkaXY6IG51bGwsXG4gICAgX2NvbXBvbmVudDogbnVsbCxcbiAgICBnZXN0dXJlczogZ2VzdHVyZXMsIC8vIFRPRE86IHdoeSBkbyB3ZSBuZWVkIHRoaXM/ICh3YXMgcHJldmlvdXNseSBhdCBib3R0b20gb2YgZmlsZSlcbiAgICBjYW52YXM6IG51bGwsXG4gICAgY2FudmFzQ1RYOiBudWxsLFxuICAgIGZvY3VzZXI6IG51bGwsXG4gICAgYnVmZmVyOiBudWxsLFxuICAgIGN0eDogbnVsbCxcbiAgICBtb3VzZUxvY2F0aW9uOiBudWxsLFxuICAgIGhvbGRQdWxzZUNvdW50OiAtMSxcbiAgICBkcmFnc3RhcnQ6IG51bGwsXG4gICAgb3JpZ2luOiBudWxsLFxuICAgIGJvdW5kczogbnVsbCxcbiAgICBkaXJ0eTogZmFsc2UsXG4gICAgc2l6ZTogbnVsbCxcbiAgICBtb3VzZWRvd246IGZhbHNlLFxuICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICByZXBlYXRLZXlDb3VudDogMCxcbiAgICByZXBlYXRLZXk6IG51bGwsXG4gICAgcmVwZWF0S2V5U3RhcnRUaW1lOiAwLFxuICAgIGN1cnJlbnRLZXlzOiBbXSxcbiAgICBoYXNNb3VzZTogZmFsc2UsXG4gICAgbGFzdERvdWJsZUNsaWNrVGltZTogMCxcbiAgICBkcmFnRW5kVGltZTogMCxcbiAgICBsYXN0UmVwYWludFRpbWU6IDAsXG5cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgc3RvcFBhaW50TG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhaW50TG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgcmVzdGFydFBhaW50TG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChwYWludExvb3BSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgcnVubmluZ1xuICAgICAgICB9XG4gICAgICAgIHBhaW50TG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGFpbnRMb29wRnVuY3Rpb24pO1xuICAgIH0sXG5cbiAgICBzdG9wUmVzaXplTG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc2l6ZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlc3RhcnRSZXNpemVMb29wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlc2l6ZUxvb3BSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgcnVubmluZ1xuICAgICAgICB9XG4gICAgICAgIHJlc2l6ZUxvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgc2V0SW50ZXJ2YWwocmVzaXphYmxlc0xvb3BGdW5jdGlvbiwgMjAwKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3BQYWludGluZygpO1xuICAgICAgICB0aGlzLnN0b3BSZXNpemluZygpO1xuICAgIH0sXG5cbiAgICB1c2VIaURQSTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnQucmVzb2x2ZVByb3BlcnR5KCd1c2VIaURQSScpO1xuICAgIH0sXG5cbiAgICB1c2VCaXRCbGl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudC5yZXNvbHZlUHJvcGVydHkoJ3VzZUJpdEJsaXQnKTtcbiAgICB9LFxuXG4gICAgZ2V0RlBTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZwcyA9IHRoaXMuX2NvbXBvbmVudC5yZXNvbHZlUHJvcGVydHkoJ3JlcGFpbnRJbnRlcnZhbFJhdGUnKTtcbiAgICAgICAgcmV0dXJuIGZwcyA/IHBhcnNlSW50KGZwcykgOiAwO1xuICAgIH0sXG5cbiAgICB0aWNrUGFpbnQ6IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICB2YXIgZnBzID0gdGhpcy5nZXRGUFMoKTtcbiAgICAgICAgaWYgKGZwcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDEwMDAgLyBmcHM7XG5cbiAgICAgICAgdmFyIGVsYXBzZWQgPSBub3cgLSB0aGlzLmxhc3RSZXBhaW50VGltZTtcbiAgICAgICAgaWYgKGVsYXBzZWQgPiBpbnRlcnZhbCAmJiB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZXBhaW50VGltZSA9IG5vdyAtIChlbGFwc2VkICUgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJlZ2luUGFpbnRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnRpY2tQYWludGVyID0gZnVuY3Rpb24obm93KSB7XG4gICAgICAgICAgICBzZWxmLnRpY2tQYWludChub3cpO1xuICAgICAgICB9O1xuICAgICAgICBwYWludGFibGVzLnB1c2godGhpcyk7XG4gICAgfSxcblxuICAgIHN0b3BQYWludGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhaW50YWJsZXMuc3BsaWNlKHBhaW50YWJsZXMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgfSxcblxuICAgIGJlZ2luUmVzaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMudGlja1Jlc2l6ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuY2hlY2tzaXplKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlc2l6YWJsZXMucHVzaCh0aGlzKTtcbiAgICB9LFxuXG4gICAgc3RvcFJlc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzaXphYmxlcy5zcGxpY2UocmVzaXphYmxlcy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICB9LFxuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJlZ2luUGFpbnRpbmcoKTtcbiAgICAgICAgdGhpcy5iZWdpblJlc2l6aW5nKCk7XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3BQYWludGluZygpO1xuICAgICAgICB0aGlzLnN0b3BSZXNpemluZygpO1xuICAgIH0sXG5cbiAgICBjaGVja3NpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3RoaXMgaXMgZXhwZW5zaXZlIGxldHMgZG8gaXQgYXQgc29tZSBtb2R1bG9cbiAgICAgICAgdmFyIHNpemVOb3cgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKHNpemVOb3cud2lkdGggIT09IHRoaXMuc2l6ZS53aWR0aCB8fCBzaXplTm93LmhlaWdodCAhPT0gdGhpcy5zaXplLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5zaXplQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNpemVDaGFuZ2VkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJveCA9IHRoaXMuc2l6ZSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5idWZmZXIud2lkdGggPSBib3gud2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuYnVmZmVyLmhlaWdodCA9IGJveC5oZWlnaHQ7XG5cbiAgICAgICAgLy9maXggYWxhIHNpciBzcGlua2EsIHNlZVxuICAgICAgICAvL2h0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9oaWRwaS9cbiAgICAgICAgLy9qdXN0IGFkZCAnaGRwaScgYXMgYW4gYXR0cmlidXRlIHRvIHRoZSBmaW4tY2FudmFzIHRhZ1xuICAgICAgICB2YXIgcmF0aW8gPSAxO1xuICAgICAgICB2YXIgdXNlQml0QmxpdCA9IHRoaXMudXNlQml0QmxpdCgpO1xuICAgICAgICB2YXIgaXNISURQSSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICYmIHRoaXMudXNlSGlEUEkoKTtcbiAgICAgICAgaWYgKGlzSElEUEkpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgICAgIHZhciBiYWNraW5nU3RvcmVSYXRpbyA9IHRoaXMuY2FudmFzQ1RYLndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDVFgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDVFgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAgICAgICAgIHJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICAgICAgICAgICAgLy90aGlzLmNhbnZhc0NUWC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGggKiByYXRpbztcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmF0aW87XG4gICAgICAgIHRoaXMuYnVmZmVyLndpZHRoID0gd2lkdGggKiByYXRpbztcbiAgICAgICAgdGhpcy5idWZmZXIuaGVpZ2h0ID0gaGVpZ2h0ICogcmF0aW87XG5cbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIHRoaXMuYnVmZmVyQ1RYLnNjYWxlKHJhdGlvLCByYXRpbyk7XG4gICAgICAgIGlmIChpc0hJRFBJICYmICF1c2VCaXRCbGl0KSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90aGlzLm9yaWdpbiA9IG5ldyByZWN0YW5ndWxhci5Qb2ludChNYXRoLnJvdW5kKHRoaXMuc2l6ZS5sZWZ0KSwgTWF0aC5yb3VuZCh0aGlzLnNpemUudG9wKSk7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbmV3IHJlY3Rhbmd1bGFyLlJlY3RhbmdsZSgwLCAwLCBib3gud2lkdGgsIGJveC5oZWlnaHQpO1xuICAgICAgICAvL3NldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb21wID0gdGhpcy5fY29tcG9uZW50O1xuICAgICAgICBpZiAoY29tcCkge1xuICAgICAgICAgICAgY29tcC5zZXRCb3VuZHModGhpcy5ib3VuZHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzaXplTm90aWZpY2F0aW9uKCk7XG4gICAgICAgIHRoaXMucGFpbnROb3coKTtcbiAgICAgICAgLy99KTtcbiAgICB9LFxuXG4gICAgcmVzaXplTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy90byBiZSBvdmVycmlkZGVuXG4gICAgfSxcblxuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kcztcbiAgICB9LFxuXG4gICAgcGFpbnROb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2FmZVBhaW50SW1tZWRpYXRlbHkoZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgICAgIGdjLmNsZWFyUmVjdCgwLCAwLCBzZWxmLmNhbnZhcy53aWR0aCwgc2VsZi5jYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICAgICAgdmFyIGNvbXAgPSBzZWxmLl9jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAoY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAuX3BhaW50KGdjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2FmZVBhaW50SW1tZWRpYXRlbHk6IGZ1bmN0aW9uKHBhaW50RnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHVzZUJpdEJsaXQgPSB0aGlzLnVzZUJpdEJsaXQoKSxcbiAgICAgICAgICAgIGdjID0gdXNlQml0QmxpdCA/IHRoaXMuYnVmZmVyR0MgOiB0aGlzLmdjO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2Muc2F2ZSgpO1xuICAgICAgICAgICAgcGFpbnRGdW5jdGlvbihnYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBnYy5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZUJpdEJsaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmbHVzaEJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci53aWR0aCA+IDAgJiYgdGhpcy5idWZmZXIuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNDVFguZHJhd0ltYWdlKHRoaXMuYnVmZmVyLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwYXRjaE5ld0V2ZW50OiBmdW5jdGlvbihldmVudCwgbmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsIHx8IHt9XG4gICAgICAgIH07XG4gICAgICAgIGRldGFpbC5kZXRhaWwucHJpbWl0aXZlRXZlbnQgPSBldmVudDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIGRldGFpbCkpO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50OiBmdW5jdGlvbihldmVudCwgbmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIGRldGFpbCA9IGRldGFpbCB8fCB7fTtcbiAgICAgICAgZGV0YWlsLm1vdXNlID0gdGhpcy5tb3VzZUxvY2F0aW9uO1xuICAgICAgICBkZXRhaWwua2V5cyA9IHRoaXMuY3VycmVudEtleXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZXZlbnQsIG5hbWUsIGRldGFpbCk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpICYmIHRoaXMubW91c2Vkb3duKSB7XG4gICAgICAgICAgICB0aGlzLmJlRHJhZ2dpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1kcmFnc3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRyYWdzdGFydCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCh0aGlzLm1vdXNlTG9jYXRpb24ueCwgdGhpcy5tb3VzZUxvY2F0aW9uLnkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5tb3VzZUxvY2F0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZHJhZycsIHtcbiAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuZHJhZ3N0YXJ0LFxuICAgICAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvdW5kcy5jb250YWlucyh0aGlzLm1vdXNlTG9jYXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtbW91c2Vtb3ZlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlubW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIHRoaXMubW91c2Vkb3duID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtbW91c2Vkb3duJywge1xuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50YWtlRm9jdXMoKTtcbiAgICB9LFxuXG4gICAgZmlubW91c2V1cDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1kcmFnZW5kJywge1xuICAgICAgICAgICAgICAgIGRyYWdzdGFydDogdGhpcy5kcmFnc3RhcnQsXG4gICAgICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmJlTm90RHJhZ2dpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VuZHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1tb3VzZXVwJywge1xuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICAgICAgLy90aGlzLm1vdXNlTG9jYXRpb24gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoLTEsIC0xKTtcbiAgICB9LFxuXG4gICAgZmlubW91c2VvdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlZG93bikge1xuICAgICAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KC0xLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLW1vdXNlb3V0Jyk7XG4gICAgfSxcblxuICAgIGZpbndoZWVsbW92ZWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpIHx8ICF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy13aGVlbG1vdmVkJywge1xuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmluY2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLmxhc3RDbGlja1RpbWUgPCAyNTApIHtcbiAgICAgICAgICAgIC8vdGhpcyBpcyBhIGRvdWJsZSBjbGljay4uLlxuICAgICAgICAgICAgdGhpcy5maW5kYmxjbGljayhlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtY2xpY2snLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxhc3RDbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICBmaW5yZWxlYXNlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuaG9sZFB1bHNlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtcmVsZWFzZScpO1xuICAgIH0sXG5cbiAgICBmaW5mbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1mbGljaycsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbnRyYWNrc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtdHJhY2tzdGFydCcpO1xuICAgIH0sXG5cbiAgICBmaW50cmFjazogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy10cmFjaycpO1xuICAgIH0sXG5cbiAgICBmaW50cmFja2VuZDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtdHJhY2tlbmQnKTtcbiAgICB9LFxuXG4gICAgZmluaG9sZDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtaG9sZCcsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbmhvbGRwdWxzZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtaG9sZHB1bHNlJywge1xuICAgICAgICAgICAgY291bnQ6IHRoaXMuaG9sZFB1bHNlQ291bnQrK1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmludGFwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vdGhpcyBub25zZW5zZSBpcyB0byBob2xkIGEgdGFwIGlmIGl0J3MgcmVhbGx5IGEgZG91YmxlIGNsaWNrXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBkaWYgPSBub3cgLSB0aGlzLmxhc3REb3VibGVDbGlja1RpbWU7XG4gICAgICAgIGlmIChkaWYgPCAzMDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvL2RyYWdlbmQgaXMgYWxzbyBjYXVzaW5nIGEgdGFwXG4gICAgICAgIC8vbGV0cyBmaXggdGhpcyBoZXJlXG4gICAgICAgIGlmIChub3cgLSB0aGlzLmRyYWdFbmR0aW1lIDwgMTAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX2ZpbnRhcChlKTtcbiAgICAgICAgfSwgMTgwKTtcbiAgICB9LFxuXG4gICAgX2ZpbnRhcDogZnVuY3Rpb24oZSkge1xuICAgICAgICAvL3RoaXMgbm9uc2Vuc2UgaXMgdG8gaG9sZCBhIHRhcCBpZiBpdCdzIHJlYWxseSBhIGRvdWJsZSBjbGlja1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGRpZiA9IG5vdyAtIHRoaXMubGFzdERvdWJsZUNsaWNrVGltZTtcbiAgICAgICAgaWYgKGRpZiA8IDMwMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXRhcCcsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbmRibGNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIHRoaXMubGFzdERvdWJsZUNsaWNrVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1kYmxjbGljaycsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2RibGNsaWNrJywgdGhpcy5jdXJyZW50S2V5cyk7XG4gICAgfSxcblxuICAgIGdldENoYXJNYXA6IGZ1bmN0aW9uKCkgeyAvL1RPRE86IFRoaXMgaXMgc3RhdGljLiBNYWtlIGl0IGEgcHJvcGVydHkgb2YgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICByZXR1cm4gY2hhck1hcDtcbiAgICB9LFxuXG4gICAgZmlua2V5ZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBrZXlDaGFyID0gZS5zaGlmdEtleSA/IGNoYXJNYXBbZS5rZXlDb2RlXVsxXSA6IGNoYXJNYXBbZS5rZXlDb2RlXVswXTtcbiAgICAgICAgaWYgKGUucmVwZWF0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRLZXkgPT09IGtleUNoYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEtleUNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0S2V5ID0ga2V5Q2hhcjtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdEtleSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdEtleUNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0S2V5U3RhcnRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50S2V5cy5pbmRleE9mKGtleUNoYXIpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5cy5wdXNoKGtleUNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coa2V5Q2hhciwgZS5rZXlDb2RlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld0V2ZW50KGUsICdmaW4tY2FudmFzLWtleWRvd24nLCB7XG4gICAgICAgICAgICBhbHQ6IGUuYWx0S2V5LFxuICAgICAgICAgICAgY3RybDogZS5jdHJsS2V5LFxuICAgICAgICAgICAgY2hhcjoga2V5Q2hhcixcbiAgICAgICAgICAgIGNvZGU6IGUuY2hhckNvZGUsXG4gICAgICAgICAgICBrZXk6IGUua2V5Q29kZSxcbiAgICAgICAgICAgIG1ldGE6IGUubWV0YUtleSxcbiAgICAgICAgICAgIHJlcGVhdENvdW50OiB0aGlzLnJlcGVhdEtleUNvdW50LFxuICAgICAgICAgICAgcmVwZWF0U3RhcnRUaW1lOiB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSxcbiAgICAgICAgICAgIHNoaWZ0OiBlLnNoaWZ0S2V5LFxuICAgICAgICAgICAgaWRlbnRpZmllcjogZS5rZXlJZGVudGlmaWVyLFxuICAgICAgICAgICAgY3VycmVudEtleXM6IHRoaXMuY3VycmVudEtleXMuc2xpY2UoMClcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbmtleXVwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBrZXlDaGFyID0gZS5zaGlmdEtleSA/IGNoYXJNYXBbZS5rZXlDb2RlXVsxXSA6IGNoYXJNYXBbZS5rZXlDb2RlXVswXTtcbiAgICAgICAgdGhpcy5jdXJyZW50S2V5cy5zcGxpY2UodGhpcy5jdXJyZW50S2V5cy5pbmRleE9mKGtleUNoYXIpLCAxKTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcGVhdEtleUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5yZXBlYXRLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdFdmVudChlLCAnZmluLWNhbnZhcy1rZXl1cCcsIHtcbiAgICAgICAgICAgIGFsdDogZS5hbHRLZXksXG4gICAgICAgICAgICBjdHJsOiBlLmN0cmxLZXksXG4gICAgICAgICAgICBjaGFyOiBrZXlDaGFyLFxuICAgICAgICAgICAgY29kZTogZS5jaGFyQ29kZSxcbiAgICAgICAgICAgIGtleTogZS5rZXlDb2RlLFxuICAgICAgICAgICAgbWV0YTogZS5tZXRhS2V5LFxuICAgICAgICAgICAgcmVwZWF0OiBlLnJlcGVhdCxcbiAgICAgICAgICAgIHNoaWZ0OiBlLnNoaWZ0S2V5LFxuICAgICAgICAgICAgaWRlbnRpZmllcjogZS5rZXlJZGVudGlmaWVyLFxuICAgICAgICAgICAgY3VycmVudEtleXM6IHRoaXMuY3VycmVudEtleXMuc2xpY2UoMClcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbmZvY3VzZ2FpbmVkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdFdmVudChlLCAnZmluLWNhbnZhcy1mb2N1cy1nYWluZWQnKTtcbiAgICB9LFxuXG4gICAgZmluZm9jdXNsb3N0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdFdmVudChlLCAnZmluLWNhbnZhcy1mb2N1cy1sb3N0Jyk7XG4gICAgfSxcblxuICAgIGZpbmNvbnRleHRtZW51OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmN0cmxLZXkgJiYgdGhpcy5jdXJyZW50S2V5cy5pbmRleE9mKCdDVFJMJykgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRLZXlzLnB1c2goJ0NUUkwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdENsaWNrVGltZSA8IDI1MCkge1xuICAgICAgICAgICAgLy90aGlzIGlzIGEgZG91YmxlIGNsaWNrLi4uXG4gICAgICAgICAgICB0aGlzLmZpbmRibGNsaWNrKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1jb250ZXh0LW1lbnUnLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxhc3RDbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICByZXBhaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZwcyA9IHRoaXMuZ2V0RlBTKCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICBpZiAoIXBhaW50TG9vcFJ1bm5pbmcgfHwgZnBzID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50Tm93KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TW91c2VMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlTG9jYXRpb247XG4gICAgfSxcblxuICAgIGdldE9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBwID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KHJlY3QubGVmdCwgcmVjdC50b3ApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgZ2V0TG9jYWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHAgPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoZS5jbGllbnRYIC0gcmVjdC5sZWZ0LCBlLmNsaWVudFkgLSByZWN0LnRvcCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICBoYXNGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLmNhbnZhcztcbiAgICB9LFxuXG4gICAgdGFrZUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy5mb2N1cygpO1xuICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJlRHJhZ2dpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlRG9jdW1lbnRFbGVtZW50U2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIGJlTm90RHJhZ2dpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5hYmxlRG9jdW1lbnRFbGVtZW50U2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIGlzRHJhZ2dpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnZ2luZztcbiAgICB9LFxuXG4gICAgZGlzYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgICAgIHN0eWxlLmNzc1RleHQgPSBzdHlsZS5jc3NUZXh0ICsgJy13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmUnO1xuICAgIH0sXG5cbiAgICBlbmFibGVEb2N1bWVudEVsZW1lbnRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gc3R5bGUuY3NzVGV4dC5yZXBsYWNlKCctd2Via2l0LXVzZXItc2VsZWN0OiBub25lJywgJycpO1xuICAgIH0sXG5cbiAgICBzZXRGb2N1c2FibGU6IGZ1bmN0aW9uKHRydXRoeSkge1xuICAgICAgICB0aGlzLmZvY3VzZXIuc3R5bGUuZGlzcGxheSA9IHRydXRoeSA/ICcnIDogJ25vbmUnO1xuICAgIH0sXG5cbiAgICBpc1JpZ2h0Q2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGlzUmlnaHRNQjtcbiAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgICAgIGlmICgnd2hpY2gnIGluIGUpIHsgLy8gR2Vja28gKEZpcmVmb3gpLCBXZWJLaXQgKFNhZmFyaS9DaHJvbWUpICYgT3BlcmFcbiAgICAgICAgICAgIGlzUmlnaHRNQiA9IGUud2hpY2ggPT09IDM7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2J1dHRvbicgaW4gZSkgeyAvLyBJRSwgT3BlcmFcbiAgICAgICAgICAgIGlzUmlnaHRNQiA9IGUuYnV0dG9uID09PSAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1JpZ2h0TUI7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcGFpbnRMb29wRnVuY3Rpb24obm93KSB7XG4gICAgaWYgKCFwYWludExvb3BSdW5uaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWludGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYWludGFibGVzW2ldLnRpY2tQYWludGVyKG5vdyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHBhaW50TG9vcEZ1bmN0aW9uKTtcbn1cbnJlcXVlc3RBbmltYXRpb25GcmFtZShwYWludExvb3BGdW5jdGlvbik7XG5cbmZ1bmN0aW9uIHJlc2l6YWJsZXNMb29wRnVuY3Rpb24obm93KSB7XG4gICAgaWYgKCFyZXNpemVMb29wUnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzaXphYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzaXphYmxlc1tpXS50aWNrUmVzaXplcihub3cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuc2V0SW50ZXJ2YWwocmVzaXphYmxlc0xvb3BGdW5jdGlvbiwgUkVTSVpFX1BPTExJTkdfSU5URVJWQUwpO1xuXG5mdW5jdGlvbiBtYWtlQ2hhck1hcCgpIHtcbiAgICB2YXIgbWFwID0gW107XG5cbiAgICB2YXIgZW1wdHkgPSBbJycsICcnXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgbWFwW2ldID0gZW1wdHk7XG4gICAgfVxuXG4gICAgbWFwWzI3XSA9IFsnRVNDJywgJ0VTQ1NISUZUJ107XG4gICAgbWFwWzE5Ml0gPSBbJ2AnLCAnfiddO1xuICAgIG1hcFs0OV0gPSBbJzEnLCAnISddO1xuICAgIG1hcFs1MF0gPSBbJzInLCAnQCddO1xuICAgIG1hcFs1MV0gPSBbJzMnLCAnIyddO1xuICAgIG1hcFs1Ml0gPSBbJzQnLCAnJCddO1xuICAgIG1hcFs1M10gPSBbJzUnLCAnJSddO1xuICAgIG1hcFs1NF0gPSBbJzYnLCAnXiddO1xuICAgIG1hcFs1NV0gPSBbJzcnLCAnJiddO1xuICAgIG1hcFs1Nl0gPSBbJzgnLCAnKiddO1xuICAgIG1hcFs1N10gPSBbJzknLCAnKCddO1xuICAgIG1hcFs0OF0gPSBbJzAnLCAnKSddO1xuICAgIG1hcFsxODldID0gWyctJywgJ18nXTtcbiAgICBtYXBbMTg3XSA9IFsnPScsICcrJ107XG4gICAgbWFwWzhdID0gWydERUxFVEUnLCAnREVMRVRFU0hJRlQnXTtcbiAgICBtYXBbOV0gPSBbJ1RBQicsICdUQUJTSElGVCddO1xuICAgIG1hcFs4MV0gPSBbJ3EnLCAnUSddO1xuICAgIG1hcFs4N10gPSBbJ3cnLCAnVyddO1xuICAgIG1hcFs2OV0gPSBbJ2UnLCAnRSddO1xuICAgIG1hcFs4Ml0gPSBbJ3InLCAnUiddO1xuICAgIG1hcFs4NF0gPSBbJ3QnLCAnVCddO1xuICAgIG1hcFs4OV0gPSBbJ3knLCAnWSddO1xuICAgIG1hcFs4NV0gPSBbJ3UnLCAnVSddO1xuICAgIG1hcFs3M10gPSBbJ2knLCAnSSddO1xuICAgIG1hcFs3OV0gPSBbJ28nLCAnTyddO1xuICAgIG1hcFs4MF0gPSBbJ3AnLCAnUCddO1xuICAgIG1hcFsyMTldID0gWydbJywgJ3snXTtcbiAgICBtYXBbMjIxXSA9IFsnXScsICd9J107XG4gICAgbWFwWzIyMF0gPSBbJ1xcXFwnLCAnfCddO1xuICAgIG1hcFsyMjBdID0gWydDQVBTTE9DSycsICdDQVBTTE9DS1NISUZUJ107XG4gICAgbWFwWzY1XSA9IFsnYScsICdBJ107XG4gICAgbWFwWzgzXSA9IFsncycsICdTJ107XG4gICAgbWFwWzY4XSA9IFsnZCcsICdEJ107XG4gICAgbWFwWzcwXSA9IFsnZicsICdGJ107XG4gICAgbWFwWzcxXSA9IFsnZycsICdHJ107XG4gICAgbWFwWzcyXSA9IFsnaCcsICdIJ107XG4gICAgbWFwWzc0XSA9IFsnaicsICdKJ107XG4gICAgbWFwWzc1XSA9IFsnaycsICdLJ107XG4gICAgbWFwWzc2XSA9IFsnbCcsICdMJ107XG4gICAgbWFwWzE4Nl0gPSBbJzsnLCAnOiddO1xuICAgIG1hcFsyMjJdID0gWydcXCcnLCAnfCddO1xuICAgIG1hcFsxM10gPSBbJ1JFVFVSTicsICdSRVRVUk5TSElGVCddO1xuICAgIG1hcFsxNl0gPSBbJ1NISUZUJywgJ1NISUZUJ107XG4gICAgbWFwWzkwXSA9IFsneicsICdaJ107XG4gICAgbWFwWzg4XSA9IFsneCcsICdYJ107XG4gICAgbWFwWzY3XSA9IFsnYycsICdDJ107XG4gICAgbWFwWzg2XSA9IFsndicsICdWJ107XG4gICAgbWFwWzY2XSA9IFsnYicsICdCJ107XG4gICAgbWFwWzc4XSA9IFsnbicsICdOJ107XG4gICAgbWFwWzc3XSA9IFsnbScsICdNJ107XG4gICAgbWFwWzE4OF0gPSBbJywnLCAnPCddO1xuICAgIG1hcFsxOTBdID0gWycuJywgJz4nXTtcbiAgICBtYXBbMTkxXSA9IFsnLycsICc/J107XG4gICAgbWFwWzE2XSA9IFsnU0hJRlQnLCAnU0hJRlQnXTtcbiAgICBtYXBbMTddID0gWydDVFJMJywgJ0NUUkxTSElGVCddO1xuICAgIG1hcFsxOF0gPSBbJ0FMVCcsICdBTFRTSElGVCddO1xuICAgIG1hcFs5MV0gPSBbJ0NPTU1BTkRMRUZUJywgJ0NPTU1BTkRMRUZUU0hJRlQnXTtcbiAgICBtYXBbMzJdID0gWydTUEFDRScsICdTUEFDRVNISUZUJ107XG4gICAgbWFwWzkzXSA9IFsnQ09NTUFORFJJR0hUJywgJ0NPTU1BTkRSSUdIVFNISUZUJ107XG4gICAgbWFwWzE4XSA9IFsnQUxUJywgJ0FMVFNISUZUJ107XG4gICAgbWFwWzM4XSA9IFsnVVAnLCAnVVBTSElGVCddO1xuICAgIG1hcFszN10gPSBbJ0xFRlQnLCAnTEVGVFNISUZUJ107XG4gICAgbWFwWzQwXSA9IFsnRE9XTicsICdET1dOU0hJRlQnXTtcbiAgICBtYXBbMzldID0gWydSSUdIVCcsICdSSUdIVFNISUZUJ107XG5cbiAgICBtYXBbMzNdID0gWydQQUdFVVAnLCAnUEFHRVVQU0hJRlQnXTtcbiAgICBtYXBbMzRdID0gWydQQUdFRE9XTicsICdQQUdFRE9XTlNISUZUJ107XG4gICAgbWFwWzM1XSA9IFsnUEFHRVJJR0hUJywgJ1BBR0VSSUdIVFNISUZUJ107XG4gICAgbWFwWzM2XSA9IFsnUEFHRUxFRlQnLCAnUEFHRUxFRlRTSElGVCddO1xuXG4gICAgcmV0dXJuIG1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb25zb2xlTG9nZ2VyID0gcmVxdWlyZSgnLi9nYy1jb25zb2xlLWxvZ2dlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGdjIC0gVGhlIDItRCBncmFwaGljcyBjb250ZXh0IGZyb20geW91ciBjYW52YXNcbiAqIEBwYXJhbSB7Ym9vbGVhbnxhcGlMb2dnZXJ9IFtsb2dnZXI9dHJ1ZV1cbiAqICogYHRydWVgIHVzZXMgYGdjLWNvbnNvbGUtbG9nZ2VyYCBmdW5jdGlvbiBib3VuZCB0byAnZ2MuJyBhcyBwcmVmaXhcbiAqICogc3RyaW5nIHVzZXMgYGdjLWNvbnNvbGUtbG9nZ2VyYCBmdW5jdGlvbiBib3VuZCB0byBzdHJpbmdcbiAqICogZnVuY3Rpb24gdXNlZCBhcyBpc1xuICovXG5mdW5jdGlvbiBHcmFwaGljc0NvbnRleHQoZ2MsIGxvZ2dlcikge1xuICAgIHRoaXMuZ2MgPSBnYztcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVXRUJLSVQgPSAvXndlYmtpdC87XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiBsb2dnZXIpIHtcblxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgbG9nZ2VyID0gIGNvbnNvbGVMb2dnZXIuYmluZCh1bmRlZmluZWQsIGxvZ2dlciArICcuJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGlmIChsb2dnZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIgPSBjb25zb2xlTG9nZ2VyLmJpbmQodW5kZWZpbmVkLCAnZ2MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICBpZiAobG9nZ2VyLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgIHRocm93ICdHcmFwaGljc0NvbnRleHQ6IFVzZXItc3VwcGxpZWQgQVBJIGxvZ2dlciBmdW5jdGlvbiBkb2VzIG5vdCBhY2NlcHQgdGhyZWUgcGFyYW1ldGVycy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGxvZ2dlciA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFN0dWIgb3V0IGFsbCB0aGUgcHJvdG90eXBlIG1lbWJlcnMgb2YgdGhlIGNhbnZhcyAyRCBncmFwaGljcyBjb250ZXh0OlxuICAgIE9iamVjdC5rZXlzKE9iamVjdC5nZXRQcm90b3R5cGVPZihnYykpLmZvckVhY2goTWFrZVN0dWIpO1xuXG4gICAgLy8gU29tZSBvbGRlciBicm93c2VycyAoZS5nLiwgQ2hyb21lIDQwKSBkaWQgbm90IGhhdmUgYWxsIG1lbWJlcnMgb2YgY2FudmFzXG4gICAgLy8gMkQgZ3JhcGhpY3MgY29udGV4dCBpbiB0aGUgcHJvdG90eXBlIHNvIHdlIG1ha2UgdGhpcyBhZGRpdGlvbmFsIGNhbGw6XG4gICAgT2JqZWN0LmtleXMoZ2MpLmZvckVhY2goTWFrZVN0dWIpO1xuXG4gICAgZnVuY3Rpb24gTWFrZVN0dWIoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgaW4gR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZSB8fCByZVdFQktJVC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdjW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGZba2V5XSA9ICFsb2dnZXIgPyBnY1trZXldLmJpbmQoZ2MpIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlcihrZXksIGFyZ3VtZW50cywgZ2Nba2V5XS5hcHBseShnYywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBnY1trZXldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyID8gbG9nZ2VyKGtleSwgJ2dldHRlcicsIHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdjW2tleV0gPSBsb2dnZXIgPyBsb2dnZXIoa2V5LCAnc2V0dGVyJywgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3NDb250ZXh0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgWUlFTERTID0gJ1xcdTI3RjknOyAvLyBMT05HIFJJR0hUV0FSRFMgRE9VQkxFIEFSUk9XXG5cbmZ1bmN0aW9uIGNvbnNvbGVMb2dnZXIocHJlZml4LCBuYW1lLCBhcmdzLCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc3VsdCA9ICdcIicgKyByZXN1bHQgKyAnXCInO1xuICAgIH1cblxuICAgIG5hbWUgPSBwcmVmaXggKyBuYW1lO1xuXG4gICAgc3dpdGNoIChhcmdzKSB7XG4gICAgICAgIGNhc2UgJ2dldHRlcic6XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCAnPScsIHJlc3VsdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZXR0ZXInOlxuICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZSwgWUlFTERTLCByZXN1bHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDogLy8gbWV0aG9kIGNhbGxcbiAgICAgICAgICAgIG5hbWUgKz0gJygnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignLCAnKSArICcpJztcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCBZSUVMRFMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGVMb2dnZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8vbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGhhc0Z1bGxQYXRoID0gZmFsc2U7XG5cbiAgICAvLyB0ZXN0IGZvciBmdWxsIGV2ZW50IHBhdGggc3VwcG9ydFxuICAgIHZhciBwYXRoVGVzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcbiAgICBpZiAocGF0aFRlc3QuY3JlYXRlU2hhZG93Um9vdCkge1xuICAgICAgICB2YXIgc3IgPSBwYXRoVGVzdC5jcmVhdGVTaGFkb3dSb290KCk7XG4gICAgICAgIHZhciBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBzci5hcHBlbmRDaGlsZChzKTtcbiAgICAgICAgcGF0aFRlc3QuYWRkRXZlbnRMaXN0ZW5lcigndGVzdHBhdGgnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgaWYgKGV2LnBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3BhbiBpcyBpbiB0aGUgZXZlbnQgcGF0aCwgdGhlbiBwYXRoWzBdIGlzIHRoZSByZWFsIHNvdXJjZSBmb3IgYWxsIGV2ZW50c1xuICAgICAgICAgICAgICAgIGhhc0Z1bGxQYXRoID0gZXYucGF0aFswXSA9PT0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGV2ID0gbmV3IEN1c3RvbUV2ZW50KCd0ZXN0cGF0aCcsIHtcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG11c3QgYWRkIG5vZGUgdG8gRE9NIHRvIHRyaWdnZXIgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChwYXRoVGVzdCk7XG4gICAgICAgIHMuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICAgIHBhdGhUZXN0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocGF0aFRlc3QpO1xuICAgICAgICBzciA9IHMgPSBudWxsO1xuICAgIH1cbiAgICBwYXRoVGVzdCA9IG51bGw7XG5cbiAgICB2YXIgdGFyZ2V0ID0ge1xuICAgICAgICBzaGFkb3c6IGZ1bmN0aW9uKGluRWwpIHtcbiAgICAgICAgICAgIGlmIChpbkVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluRWwuc2hhZG93Um9vdCB8fCBpbkVsLndlYmtpdFNoYWRvd1Jvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhblRhcmdldDogZnVuY3Rpb24oc2hhZG93KSB7XG4gICAgICAgICAgICByZXR1cm4gc2hhZG93ICYmIEJvb2xlYW4oc2hhZG93LmVsZW1lbnRGcm9tUG9pbnQpO1xuICAgICAgICB9LFxuICAgICAgICB0YXJnZXRpbmdTaGFkb3c6IGZ1bmN0aW9uKGluRWwpIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zaGFkb3coaW5FbCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5UYXJnZXQocykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb2xkZXJTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgICAgICAgdmFyIG9zID0gc2hhZG93Lm9sZGVyU2hhZG93Um9vdDtcbiAgICAgICAgICAgIGlmICghb3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2UgPSBzaGFkb3cucXVlcnlTZWxlY3Rvcignc2hhZG93Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9zID0gc2Uub2xkZXJTaGFkb3dSb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcztcbiAgICAgICAgfSxcbiAgICAgICAgYWxsU2hhZG93czogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHNoYWRvd3MgPSBbXSxcbiAgICAgICAgICAgICAgICBzID0gdGhpcy5zaGFkb3coZWxlbWVudCk7XG4gICAgICAgICAgICB3aGlsZSAocykge1xuICAgICAgICAgICAgICAgIHNoYWRvd3MucHVzaChzKTtcbiAgICAgICAgICAgICAgICBzID0gdGhpcy5vbGRlclNoYWRvdyhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaGFkb3dzO1xuICAgICAgICB9LFxuICAgICAgICBzZWFyY2hSb290OiBmdW5jdGlvbihpblJvb3QsIHgsIHkpIHtcbiAgICAgICAgICAgIHZhciB0LCBzdCwgc3IsIG9zO1xuICAgICAgICAgICAgaWYgKGluUm9vdCkge1xuICAgICAgICAgICAgICAgIHQgPSBpblJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBlbGVtZW50LCBjaGVjayBpZiBpdCBoYXMgYSBTaGFkb3dSb290XG4gICAgICAgICAgICAgICAgICAgIHNyID0gdGhpcy50YXJnZXRpbmdTaGFkb3codCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpblJvb3QgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzaWJsaW5nIHJvb3RzXG4gICAgICAgICAgICAgICAgICAgIHNyID0gdGhpcy5vbGRlclNoYWRvdyhpblJvb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzZWFyY2ggb3RoZXIgcm9vdHMsIGZhbGwgYmFjayB0byBsaWdodCBkb20gZWxlbWVudFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaFJvb3Qoc3IsIHgsIHkpIHx8IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG93bmVyOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcyA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAvLyB3YWxrIHVwIHVudGlsIHlvdSBoaXQgdGhlIHNoYWRvdyByb290IG9yIGRvY3VtZW50XG4gICAgICAgICAgICB3aGlsZSAocy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZSBvd25lciBlbGVtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGEgRG9jdW1lbnQgb3IgU2hhZG93Um9vdFxuICAgICAgICAgICAgaWYgKHMubm9kZVR5cGUgIT0gTm9kZS5ET0NVTUVOVF9OT0RFICYmIHMubm9kZVR5cGUgIT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcyA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRUYXJnZXQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChoYXNGdWxsUGF0aCAmJiBpbkV2ZW50LnBhdGggJiYgaW5FdmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbkV2ZW50LnBhdGhbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5ID0gaW5FdmVudC5jbGllbnRZO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGxpc3RlbmVyIGlzIGluIHRoZSBzaGFkb3cgcm9vdCwgaXQgaXMgbXVjaCBmYXN0ZXIgdG8gc3RhcnQgdGhlcmVcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5vd25lcihpbkV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAvLyBpZiB4LCB5IGlzIG5vdCBpbiB0aGlzIHJvb3QsIGZhbGwgYmFjayB0byBkb2N1bWVudCBzZWFyY2hcbiAgICAgICAgICAgIGlmICghcy5lbGVtZW50RnJvbVBvaW50KHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgcyA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoUm9vdChzLCB4LCB5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZFRvdWNoQWN0aW9uOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgIGlmIChoYXNGdWxsUGF0aCAmJiBpbkV2ZW50LnBhdGggJiYgaW5FdmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gaW5FdmVudC5wYXRoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuID0gcGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIG4uaGFzQXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uZ2V0QXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IGluRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBuLmhhc0F0dHJpYnV0ZSgndG91Y2gtYWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuLmdldEF0dHJpYnV0ZSgndG91Y2gtYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZSB8fCBuLmhvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXV0byBpcyBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4gXCJhdXRvXCI7XG4gICAgICAgIH0sXG4gICAgICAgIExDQTogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhICYmICFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiAmJiAhYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFiICYmICFhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFzdCBjYXNlLCBhIGlzIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgYiBvciB2aWNlIHZlcnNhXG4gICAgICAgICAgICBpZiAoYS5jb250YWlucyAmJiBhLmNvbnRhaW5zKGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYi5jb250YWlucyAmJiBiLmNvbnRhaW5zKGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWRlcHRoID0gdGhpcy5kZXB0aChhKTtcbiAgICAgICAgICAgIHZhciBiZGVwdGggPSB0aGlzLmRlcHRoKGIpO1xuICAgICAgICAgICAgdmFyIGQgPSBhZGVwdGggLSBiZGVwdGg7XG4gICAgICAgICAgICBpZiAoZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYSA9IHRoaXMud2FsayhhLCBkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYiA9IHRoaXMud2FsayhiLCAtZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoYSAmJiBiICYmIGEgIT09IGIpIHtcbiAgICAgICAgICAgICAgICBhID0gYS5wYXJlbnROb2RlIHx8IGEuaG9zdDtcbiAgICAgICAgICAgICAgICBiID0gYi5wYXJlbnROb2RlIHx8IGIuaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9LFxuICAgICAgICB3YWxrOiBmdW5jdGlvbihuLCB1KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgbiAmJiAoaSA8IHUpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9LFxuICAgICAgICBkZXB0aDogZnVuY3Rpb24obikge1xuICAgICAgICAgICAgdmFyIGQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgICAgICAgICBkKys7XG4gICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZSB8fCBuLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVlcENvbnRhaW5zOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICB2YXIgY29tbW9uID0gdGhpcy5MQ0EoYSwgYik7XG4gICAgICAgICAgICAvLyBpZiBhIGlzIHRoZSBjb21tb24gYW5jZXN0b3IsIGl0IG11c3QgXCJkZWVwbHlcIiBjb250YWluIGJcbiAgICAgICAgICAgIHJldHVybiBjb21tb24gPT09IGE7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2lkZU5vZGU6IGZ1bmN0aW9uKG5vZGUsIHgsIHkpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiAocmVjdC5sZWZ0IDw9IHgpICYmICh4IDw9IHJlY3QucmlnaHQpICYmIChyZWN0LnRvcCA8PSB5KSAmJiAoeSA8PSByZWN0LmJvdHRvbSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIGlmIChoYXNGdWxsUGF0aCAmJiBldmVudC5wYXRoICYmIGV2ZW50LnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcCA9IGV2ZW50LnBhdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuZmluZFRhcmdldChldmVudCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKG4pO1xuICAgICAgICAgICAgICAgICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc2NvcGUudGFyZ2V0RmluZGluZyA9IHRhcmdldDtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBldmVudCwgZmluZHMgdGhlIFwiZGVlcGVzdFwiIG5vZGUgdGhhdCBjb3VsZCBoYXZlIGJlZW4gdGhlIG9yaWdpbmFsIHRhcmdldCBiZWZvcmUgU2hhZG93RE9NIHJldGFyZ2V0dGluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gRXZlbnQgQW4gZXZlbnQgb2JqZWN0IHdpdGggY2xpZW50WCBhbmQgY2xpZW50WSBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIHByb2JhYmxlIGV2ZW50IG9yaWduaW5hdG9yXG4gICAgICovXG4gICAgc2NvcGUuZmluZFRhcmdldCA9IHRhcmdldC5maW5kVGFyZ2V0LmJpbmQodGFyZ2V0KTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBcImNvbnRhaW5lclwiIG5vZGUgZGVlcGx5IGNvbnRhaW5zIHRoZSBcImNvbnRhaW5lZVwiIG5vZGUsIGluY2x1ZGluZyBzaXR1YXRpb25zIHdoZXJlIHRoZSBcImNvbnRhaW5lZVwiIGlzIGNvbnRhaW5lZCBieSBvbmUgb3IgbW9yZSBTaGFkb3dET01cbiAgICAgKiByb290cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHtOb2RlfSBjb250YWluZWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNjb3BlLmRlZXBDb250YWlucyA9IHRhcmdldC5kZWVwQ29udGFpbnMuYmluZCh0YXJnZXQpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgeC95IHBvc2l0aW9uIGlzIGluc2lkZSB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgZnVuY3Rpb24gdXBIYW5kbGVyKGV2ZW50KSB7XG4gICAgICogICAgICAgdmFyIGlubm9kZSA9IFBvbHltZXJHZXN0dXJlcy5pbnNpZGVOb2RlKGV2ZW50LnRhcmdldCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICogICAgICAgaWYgKGlubm9kZSkge1xuICAgICAqICAgICAgICAgLy8gd2FpdCBmb3IgdGFwP1xuICAgICAqICAgICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgICAvLyB0YXAgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFNjcmVlbiBYIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgc2NyZWVuIFkgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNjb3BlLmluc2lkZU5vZGUgPSB0YXJnZXQuaW5zaWRlTm9kZTtcblxufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBzaGFkb3dTZWxlY3Rvcih2KSB7XG4gICAgICAgIHJldHVybiAnaHRtbCAvZGVlcC8gJyArIHNlbGVjdG9yKHYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdG9yKHYpIHtcbiAgICAgICAgcmV0dXJuICdbdG91Y2gtYWN0aW9uPVwiJyArIHYgKyAnXCJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydWxlKHYpIHtcbiAgICAgICAgcmV0dXJuICd7IC1tcy10b3VjaC1hY3Rpb246ICcgKyB2ICsgJzsgdG91Y2gtYWN0aW9uOiAnICsgdiArICc7fSc7XG4gICAgfVxuICAgIHZhciBhdHRyaWIyY3NzID0gW1xuICAgICAgICAnbm9uZScsXG4gICAgICAgICdhdXRvJyxcbiAgICAgICAgJ3Bhbi14JyxcbiAgICAgICAgJ3Bhbi15Jywge1xuICAgICAgICAgICAgcnVsZTogJ3Bhbi14IHBhbi15JyxcbiAgICAgICAgICAgIHNlbGVjdG9yczogW1xuICAgICAgICAgICAgICAgICdwYW4teCBwYW4teScsXG4gICAgICAgICAgICAgICAgJ3Bhbi15IHBhbi14J1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAnbWFuaXB1bGF0aW9uJ1xuICAgIF07XG4gICAgdmFyIHN0eWxlcyA9ICcnO1xuICAgIC8vIG9ubHkgaW5zdGFsbCBzdHlsZXNoZWV0IGlmIHRoZSBicm93c2VyIGhhcyB0b3VjaCBhY3Rpb24gc3VwcG9ydFxuICAgIHZhciBoYXNUb3VjaEFjdGlvbiA9IHR5cGVvZiBkb2N1bWVudC5oZWFkLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnc3RyaW5nJztcbiAgICAvLyBvbmx5IGFkZCBzaGFkb3cgc2VsZWN0b3JzIGlmIHNoYWRvd2RvbSBpcyBzdXBwb3J0ZWRcbiAgICB2YXIgaGFzU2hhZG93Um9vdCA9ICF3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwgJiYgZG9jdW1lbnQuaGVhZC5jcmVhdGVTaGFkb3dSb290O1xuXG4gICAgaWYgKGhhc1RvdWNoQWN0aW9uKSB7XG4gICAgICAgIGF0dHJpYjJjc3MuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICBpZiAoU3RyaW5nKHIpID09PSByKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzICs9IHNlbGVjdG9yKHIpICsgcnVsZShyKSArICdcXG4nO1xuICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyArPSBzaGFkb3dTZWxlY3RvcihyKSArIHJ1bGUocikgKyAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlcyArPSByLnNlbGVjdG9ycy5tYXAoc2VsZWN0b3IpICsgcnVsZShyLnJ1bGUpICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzICs9IHIuc2VsZWN0b3JzLm1hcChzaGFkb3dTZWxlY3RvcikgKyBydWxlKHIucnVsZSkgKyAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gc3R5bGVzO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG59KSgpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbnN0cnVjdG9yIGZvciBuZXcgUG9pbnRlckV2ZW50cy5cbiAqXG4gKiBOZXcgUG9pbnRlciBFdmVudHMgbXVzdCBiZSBnaXZlbiBhIHR5cGUsIGFuZCBhbiBvcHRpb25hbCBkaWN0aW9uYXJ5IG9mXG4gKiBpbml0aWFsaXphdGlvbiBwcm9wZXJ0aWVzLlxuICpcbiAqIER1ZSB0byBjZXJ0YWluIHBsYXRmb3JtIHJlcXVpcmVtZW50cywgZXZlbnRzIHJldHVybmVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gKiBpZGVudGlmeSBhcyBNb3VzZUV2ZW50cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBpblR5cGUgVGhlIHR5cGUgb2YgdGhlIGV2ZW50IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaW5EaWN0XSBBbiBvcHRpb25hbCBkaWN0aW9uYXJ5IG9mIGluaXRpYWwgZXZlbnQgcHJvcGVydGllcy5cbiAqIEByZXR1cm4ge0V2ZW50fSBBIG5ldyBQb2ludGVyRXZlbnQgb2YgdHlwZSBgaW5UeXBlYCBhbmQgaW5pdGlhbGl6ZWQgd2l0aCBwcm9wZXJ0aWVzIGZyb20gYGluRGljdGAuXG4gKi9cbihmdW5jdGlvbihzY29wZSkge1xuXG4gICAgdmFyIE1PVVNFX1BST1BTID0gW1xuICAgICAgICAnYnViYmxlcycsXG4gICAgICAgICdjYW5jZWxhYmxlJyxcbiAgICAgICAgJ3ZpZXcnLFxuICAgICAgICAnZGV0YWlsJyxcbiAgICAgICAgJ3NjcmVlblgnLFxuICAgICAgICAnc2NyZWVuWScsXG4gICAgICAgICdjbGllbnRYJyxcbiAgICAgICAgJ2NsaWVudFknLFxuICAgICAgICAnY3RybEtleScsXG4gICAgICAgICdhbHRLZXknLFxuICAgICAgICAnc2hpZnRLZXknLFxuICAgICAgICAnbWV0YUtleScsXG4gICAgICAgICdidXR0b24nLFxuICAgICAgICAncmVsYXRlZFRhcmdldCcsXG4gICAgICAgICdwYWdlWCcsXG4gICAgICAgICdwYWdlWSdcbiAgICBdO1xuXG4gICAgdmFyIE1PVVNFX0RFRkFVTFRTID0gW1xuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAwLFxuICAgICAgICBudWxsLFxuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgXTtcblxuICAgIHZhciBOT1BfRkFDVE9SWSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHtcbiAgICAgICAgLy8gVE9ETyhkZnJlZWRtKTogdGhpcyBpcyBvdmVycmlkZGVuIGJ5IHRhcCByZWNvZ25pemVyLCBuZWVkcyByZXZpZXdcbiAgICAgICAgcHJldmVudFRhcDogTk9QX0ZBQ1RPUlksXG4gICAgICAgIG1ha2VCYXNlRXZlbnQ6IGZ1bmN0aW9uKGluVHlwZSwgaW5EaWN0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgICAgZS5pbml0RXZlbnQoaW5UeXBlLCBpbkRpY3QuYnViYmxlcyB8fCBmYWxzZSwgaW5EaWN0LmNhbmNlbGFibGUgfHwgZmFsc2UpO1xuICAgICAgICAgICAgZS5wcmV2ZW50VGFwID0gZXZlbnRGYWN0b3J5LnByZXZlbnRUYXAoZSk7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFrZUdlc3R1cmVFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkRpY3QpIHtcbiAgICAgICAgICAgIGluRGljdCA9IGluRGljdCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMubWFrZUJhc2VFdmVudChpblR5cGUsIGluRGljdCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGluRGljdCksIGs7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgayA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGsgIT09ICdidWJibGVzJyAmJiBrICE9PSAnY2FuY2VsYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrXSA9IGluRGljdFtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFrZVBvaW50ZXJFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkRpY3QpIHtcbiAgICAgICAgICAgIGluRGljdCA9IGluRGljdCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMubWFrZUJhc2VFdmVudChpblR5cGUsIGluRGljdCk7XG4gICAgICAgICAgICAvLyBkZWZpbmUgaW5oZXJpdGVkIE1vdXNlRXZlbnQgcHJvcGVydGllc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDIsIHA7IGkgPCBNT1VTRV9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHAgPSBNT1VTRV9QUk9QU1tpXTtcbiAgICAgICAgICAgICAgICBlW3BdID0gaW5EaWN0W3BdIHx8IE1PVVNFX0RFRkFVTFRTW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5idXR0b25zID0gaW5EaWN0LmJ1dHRvbnMgfHwgMDtcblxuICAgICAgICAgICAgLy8gU3BlYyByZXF1aXJlcyB0aGF0IHBvaW50ZXJzIHdpdGhvdXQgcHJlc3N1cmUgc3BlY2lmaWVkIHVzZSAwLjUgZm9yIGRvd25cbiAgICAgICAgICAgIC8vIHN0YXRlIGFuZCAwIGZvciB1cCBzdGF0ZS5cbiAgICAgICAgICAgIHZhciBwcmVzc3VyZSA9IDA7XG4gICAgICAgICAgICBpZiAoaW5EaWN0LnByZXNzdXJlKSB7XG4gICAgICAgICAgICAgICAgcHJlc3N1cmUgPSBpbkRpY3QucHJlc3N1cmU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXNzdXJlID0gZS5idXR0b25zID8gMC41IDogMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHgveSBwcm9wZXJ0aWVzIGFsaWFzZWQgdG8gY2xpZW50WC9ZXG4gICAgICAgICAgICBlLnggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICBlLnkgPSBlLmNsaWVudFk7XG5cbiAgICAgICAgICAgIC8vIGRlZmluZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgUG9pbnRlckV2ZW50IGludGVyZmFjZVxuICAgICAgICAgICAgZS5wb2ludGVySWQgPSBpbkRpY3QucG9pbnRlcklkIHx8IDA7XG4gICAgICAgICAgICBlLndpZHRoID0gaW5EaWN0LndpZHRoIHx8IDA7XG4gICAgICAgICAgICBlLmhlaWdodCA9IGluRGljdC5oZWlnaHQgfHwgMDtcbiAgICAgICAgICAgIGUucHJlc3N1cmUgPSBwcmVzc3VyZTtcbiAgICAgICAgICAgIGUudGlsdFggPSBpbkRpY3QudGlsdFggfHwgMDtcbiAgICAgICAgICAgIGUudGlsdFkgPSBpbkRpY3QudGlsdFkgfHwgMDtcbiAgICAgICAgICAgIGUucG9pbnRlclR5cGUgPSBpbkRpY3QucG9pbnRlclR5cGUgfHwgJyc7XG4gICAgICAgICAgICBlLmh3VGltZXN0YW1wID0gaW5EaWN0Lmh3VGltZXN0YW1wIHx8IDA7XG4gICAgICAgICAgICBlLmlzUHJpbWFyeSA9IGluRGljdC5pc1ByaW1hcnkgfHwgZmFsc2U7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSBpbkRpY3QuX3NvdXJjZSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNjb3BlLmV2ZW50RmFjdG9yeSA9IGV2ZW50RmFjdG9yeTtcbn0pKGV4cG9ydHMpO1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGltcGxlbWVudHMgYW4gbWFwIG9mIHBvaW50ZXIgc3RhdGVzXG4gKi9cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBVU0VfTUFQID0gd2luZG93Lk1hcCAmJiB3aW5kb3cuTWFwLnByb3RvdHlwZS5mb3JFYWNoO1xuICAgIHZhciBQT0lOVEVSU19GTiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBQb2ludGVyTWFwKCkge1xuICAgICAgICBpZiAoVVNFX01BUCkge1xuICAgICAgICAgICAgdmFyIG0gPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBtLnBvaW50ZXJzID0gUE9JTlRFUlNfRk47XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFBvaW50ZXJNYXAucHJvdG90eXBlID0ge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGluSWQsIGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5rZXlzLmluZGV4T2YoaW5JZCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXNbaV0gPSBpbkV2ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleXMucHVzaChpbklkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKGluRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoYXM6IGZ1bmN0aW9uKGluSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleXMuaW5kZXhPZihpbklkKSA+IC0xO1xuICAgICAgICB9LFxuICAgICAgICAnZGVsZXRlJzogZnVuY3Rpb24oaW5JZCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmtleXMuaW5kZXhPZihpbklkKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihpbklkKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMua2V5cy5pbmRleE9mKGluSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2ldO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmtleXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJldHVybiB2YWx1ZSwga2V5LCBtYXBcbiAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdiwgdGhpcy5rZXlzW2ldLCB0aGlzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5Qb2ludGVyTWFwID0gUG9pbnRlck1hcDtcbn0pKGV4cG9ydHMpO1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgQ0xPTkVfUFJPUFMgPSBbXG4gICAgICAgIC8vIE1vdXNlRXZlbnRcbiAgICAgICAgJ2J1YmJsZXMnLFxuICAgICAgICAnY2FuY2VsYWJsZScsXG4gICAgICAgICd2aWV3JyxcbiAgICAgICAgJ2RldGFpbCcsXG4gICAgICAgICdzY3JlZW5YJyxcbiAgICAgICAgJ3NjcmVlblknLFxuICAgICAgICAnY2xpZW50WCcsXG4gICAgICAgICdjbGllbnRZJyxcbiAgICAgICAgJ2N0cmxLZXknLFxuICAgICAgICAnYWx0S2V5JyxcbiAgICAgICAgJ3NoaWZ0S2V5JyxcbiAgICAgICAgJ21ldGFLZXknLFxuICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgJ3JlbGF0ZWRUYXJnZXQnLFxuICAgICAgICAvLyBET00gTGV2ZWwgM1xuICAgICAgICAnYnV0dG9ucycsXG4gICAgICAgIC8vIFBvaW50ZXJFdmVudFxuICAgICAgICAncG9pbnRlcklkJyxcbiAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICdwcmVzc3VyZScsXG4gICAgICAgICd0aWx0WCcsXG4gICAgICAgICd0aWx0WScsXG4gICAgICAgICdwb2ludGVyVHlwZScsXG4gICAgICAgICdod1RpbWVzdGFtcCcsXG4gICAgICAgICdpc1ByaW1hcnknLFxuICAgICAgICAvLyBldmVudCBpbnN0YW5jZVxuICAgICAgICAndHlwZScsXG4gICAgICAgICd0YXJnZXQnLFxuICAgICAgICAnY3VycmVudFRhcmdldCcsXG4gICAgICAgICd3aGljaCcsXG4gICAgICAgICdwYWdlWCcsXG4gICAgICAgICdwYWdlWScsXG4gICAgICAgICd0aW1lU3RhbXAnLFxuICAgICAgICAvLyBnZXN0dXJlIGFkZG9uc1xuICAgICAgICAncHJldmVudFRhcCcsXG4gICAgICAgICd0YXBQcmV2ZW50ZWQnLFxuICAgICAgICAnX3NvdXJjZSdcbiAgICBdO1xuXG4gICAgdmFyIENMT05FX0RFRkFVTFRTID0gW1xuICAgICAgICAvLyBNb3VzZUV2ZW50XG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDAsXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIERPTSBMZXZlbCAzXG4gICAgICAgIDAsXG4gICAgICAgIC8vIFBvaW50ZXJFdmVudFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAnJyxcbiAgICAgICAgMCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIC8vIGV2ZW50IGluc3RhbmNlXG4gICAgICAgICcnLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBmdW5jdGlvbigpIHt9LFxuICAgICAgICBmYWxzZVxuICAgIF07XG5cbiAgICB2YXIgSEFTX1NWR19JTlNUQU5DRSA9ICh0eXBlb2YgU1ZHRWxlbWVudEluc3RhbmNlICE9PSAndW5kZWZpbmVkJyk7XG5cbiAgICB2YXIgZXZlbnRGYWN0b3J5ID0gc2NvcGUuZXZlbnRGYWN0b3J5O1xuXG4gICAgLy8gc2V0IG9mIHJlY29nbml6ZXJzIHRvIHJ1biBmb3IgdGhlIGN1cnJlbnRseSBoYW5kbGVkIGV2ZW50XG4gICAgdmFyIGN1cnJlbnRHZXN0dXJlcztcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbW9kdWxlIGlzIGZvciBub3JtYWxpemluZyBldmVudHMuIE1vdXNlIGFuZCBUb3VjaCBldmVudHMgd2lsbCBiZVxuICAgICAqIGNvbGxlY3RlZCBoZXJlLCBhbmQgZmlyZSBQb2ludGVyRXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBzZW1hbnRpY3MsIG5vXG4gICAgICogbWF0dGVyIHRoZSBzb3VyY2UuXG4gICAgICogRXZlbnRzIGZpcmVkOlxuICAgICAqICAgLSBwb2ludGVyZG93bjogYSBwb2ludGluZyBpcyBhZGRlZFxuICAgICAqICAgLSBwb2ludGVydXA6IGEgcG9pbnRlciBpcyByZW1vdmVkXG4gICAgICogICAtIHBvaW50ZXJtb3ZlOiBhIHBvaW50ZXIgaXMgbW92ZWRcbiAgICAgKiAgIC0gcG9pbnRlcm92ZXI6IGEgcG9pbnRlciBjcm9zc2VzIGludG8gYW4gZWxlbWVudFxuICAgICAqICAgLSBwb2ludGVyb3V0OiBhIHBvaW50ZXIgbGVhdmVzIGFuIGVsZW1lbnRcbiAgICAgKiAgIC0gcG9pbnRlcmNhbmNlbDogYSBwb2ludGVyIHdpbGwgbm8gbG9uZ2VyIGdlbmVyYXRlIGV2ZW50c1xuICAgICAqL1xuICAgIHZhciBkaXNwYXRjaGVyID0ge1xuICAgICAgICBJU19JT1M6IGZhbHNlLFxuICAgICAgICBwb2ludGVybWFwOiBuZXcgc2NvcGUuUG9pbnRlck1hcCgpLFxuICAgICAgICByZXF1aXJlZEdlc3R1cmVzOiBuZXcgc2NvcGUuUG9pbnRlck1hcCgpLFxuICAgICAgICBldmVudE1hcDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgLy8gU2NvcGUgb2JqZWN0cyBmb3IgbmF0aXZlIGV2ZW50cy5cbiAgICAgICAgLy8gVGhpcyBleGlzdHMgZm9yIGVhc2Ugb2YgdGVzdGluZy5cbiAgICAgICAgZXZlbnRTb3VyY2VzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBldmVudFNvdXJjZUxpc3Q6IFtdLFxuICAgICAgICBnZXN0dXJlczogW10sXG4gICAgICAgIC8vIG1hcCBnZXN0dXJlIGV2ZW50IC0+IHtsaXN0ZW5lcnM6IGludCwgaW5kZXg6IGdlc3R1cmVzW2ludF19XG4gICAgICAgIGRlcGVuZGVuY3lNYXA6IHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBkb3duIGFuZCB1cCBhcmUgaW4gdGhlIG1hcCB0byB0cmlnZ2VyIFwicmVnaXN0ZXJcIlxuICAgICAgICAgICAgZG93bjoge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogMCxcbiAgICAgICAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cDoge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogMCxcbiAgICAgICAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VzdHVyZVF1ZXVlOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIG5ldyBldmVudCBzb3VyY2UgdGhhdCB3aWxsIGdlbmVyYXRlIHBvaW50ZXIgZXZlbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgaW5Tb3VyY2VgIG11c3QgY29udGFpbiBhbiBhcnJheSBvZiBldmVudCBuYW1lcyBuYW1lZCBgZXZlbnRzYCwgYW5kXG4gICAgICAgICAqIGZ1bmN0aW9ucyB3aXRoIHRoZSBuYW1lcyBzcGVjaWZpZWQgaW4gdGhlIGBldmVudHNgIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIG5hbWUgZm9yIHRoZSBldmVudCBzb3VyY2VcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBBIG5ldyBzb3VyY2Ugb2YgcGxhdGZvcm0gZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXJTb3VyY2U6IGZ1bmN0aW9uKG5hbWUsIHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIHMgPSBzb3VyY2U7XG4gICAgICAgICAgICB2YXIgbmV3RXZlbnRzID0gcy5ldmVudHM7XG4gICAgICAgICAgICBpZiAobmV3RXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgbmV3RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc1tlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudE1hcFtlXSA9IHNbZV0uYmluZChzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRTb3VyY2VzW25hbWVdID0gcztcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50U291cmNlTGlzdC5wdXNoKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3Rlckdlc3R1cmU6IGZ1bmN0aW9uKG5hbWUsIHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBvYmoubGlzdGVuZXJzID0gMDtcbiAgICAgICAgICAgIG9iai5pbmRleCA9IHRoaXMuZ2VzdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGc7IGkgPCBzb3VyY2UuZXhwb3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGcgPSBzb3VyY2UuZXhwb3Nlc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeU1hcFtnXSA9IG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24oZWxlbWVudCwgaW5pdGlhbCkge1xuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmV2ZW50U291cmNlTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZXM7XG4gICAgICAgICAgICAgICAgKGkgPCBsKSAmJiAoZXMgPSB0aGlzLmV2ZW50U291cmNlTGlzdFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZXZlbnRzb3VyY2UgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICBlcy5yZWdpc3Rlci5jYWxsKGVzLCBlbGVtZW50LCBpbml0aWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmV2ZW50U291cmNlTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZXM7XG4gICAgICAgICAgICAgICAgKGkgPCBsKSAmJiAoZXMgPSB0aGlzLmV2ZW50U291cmNlTGlzdFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZXZlbnRzb3VyY2UgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICBlcy51bnJlZ2lzdGVyLmNhbGwoZXMsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBFVkVOVFNcbiAgICAgICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZEdlc3R1cmVzLnNldChpbkV2ZW50LnBvaW50ZXJJZCwgY3VycmVudEdlc3R1cmVzKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCdkb3duJywgaW5FdmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmU6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIHBpcGUgbW92ZSBldmVudHMgaW50byBnZXN0dXJlIHF1ZXVlIGRpcmVjdGx5XG4gICAgICAgICAgICBpbkV2ZW50LnR5cGUgPSAnbW92ZSc7XG4gICAgICAgICAgICB0aGlzLmZpbGxHZXN0dXJlUXVldWUoaW5FdmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgndXAnLCBpbkV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZWRHZXN0dXJlcy5kZWxldGUoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGluRXZlbnQudGFwUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCd1cCcsIGluRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZEdlc3R1cmVzLmRlbGV0ZShpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEdlc3R1cmVEZXBlbmRlbmN5OiBmdW5jdGlvbihub2RlLCBjdXJyZW50R2VzdHVyZXMpIHtcbiAgICAgICAgICAgIHZhciBnZXN0dXJlc1dhbnRlZCA9IG5vZGUuX3BnRXZlbnRzO1xuICAgICAgICAgICAgaWYgKGdlc3R1cmVzV2FudGVkICYmIGN1cnJlbnRHZXN0dXJlcykge1xuICAgICAgICAgICAgICAgIHZhciBnayA9IE9iamVjdC5rZXlzKGdlc3R1cmVzV2FudGVkKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgciwgcmksIGc7IGkgPCBnay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXN0dXJlXG4gICAgICAgICAgICAgICAgICAgIGcgPSBna1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlc3R1cmVzV2FudGVkW2ddID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9va3VwIGdlc3R1cmUgcmVjb2duaXplclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMuZGVwZW5kZW5jeU1hcFtnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY29nbml6ZXIgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpID0gciA/IHIuaW5kZXggOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHZXN0dXJlc1tyaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBMSVNURU5FUiBMT0dJQ1xuICAgICAgICBldmVudEhhbmRsZXI6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50IG11bHRpcGxlIGRpc3BhdGNoIG9mIGV2ZW50cyBmcm9tXG4gICAgICAgICAgICAvLyBwbGF0Zm9ybSBldmVudHMuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHR3byBlbGVtZW50cyBpbiBkaWZmZXJlbnQgc2NvcGVzXG4gICAgICAgICAgICAvLyBhcmUgc2V0IHVwIHRvIGNyZWF0ZSBwb2ludGVyIGV2ZW50cywgd2hpY2ggaXMgcmVsZXZhbnQgdG8gU2hhZG93IERPTS5cblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBpbkV2ZW50LnR5cGU7XG5cbiAgICAgICAgICAgIC8vIG9ubHkgZ2VuZXJhdGUgdGhlIGxpc3Qgb2YgZGVzaXJlZCBldmVudHMgb24gXCJkb3duXCJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ21vdXNlZG93bicgfHwgdHlwZSA9PT0gJ3BvaW50ZXJkb3duJyB8fCB0eXBlID09PSAnTVNQb2ludGVyRG93bicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluRXZlbnQuX2hhbmRsZWRCeVBHKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHZXN0dXJlcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGluIElPUyBtb2RlLCB0aGVyZSBpcyBvbmx5IGEgbGlzdGVuZXIgb24gdGhlIGRvY3VtZW50LCBzbyB0aGlzIGlzIG5vdCByZS1lbnRyYW50XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuSVNfSU9TKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldiA9IGluRXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdXAgYSBmYWtlIGV2ZW50IHRvIGdpdmUgdG8gdGhlIHBhdGggYnVpbGRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBpbkV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBjdC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGN0LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogaW5FdmVudC5wYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBldmVudCBwYXRoIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGJ1aWxkIGEgcGF0aCBmcm9tIHRhcmdldCBmaW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IGluRXZlbnQucGF0aCB8fCBzY29wZS50YXJnZXRGaW5kaW5nLnBhdGgoZXYpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbjsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEdlc3R1cmVEZXBlbmRlbmN5KG4sIGN1cnJlbnRHZXN0dXJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEdlc3R1cmVEZXBlbmRlbmN5KGluRXZlbnQuY3VycmVudFRhcmdldCwgY3VycmVudEdlc3R1cmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbkV2ZW50Ll9oYW5kbGVkQnlQRykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMuZXZlbnRNYXAgJiYgdGhpcy5ldmVudE1hcFt0eXBlXTtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGZuKGluRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5FdmVudC5faGFuZGxlZEJ5UEcgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAvLyBzZXQgdXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIGxpc3RlbjogZnVuY3Rpb24odGFyZ2V0LCBldmVudHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnRzLmxlbmd0aCwgZTtcbiAgICAgICAgICAgICAgICAoaSA8IGwpICYmIChlID0gZXZlbnRzW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudCh0YXJnZXQsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHVubGlzdGVuOiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudHMubGVuZ3RoLCBlO1xuICAgICAgICAgICAgICAgIChpIDwgbCkgJiYgKGUgPSBldmVudHNbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50KHRhcmdldCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEV2ZW50OiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLmJvdW5kSGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUV2ZW50OiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLmJvdW5kSGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVWRU5UIENSRUFUSU9OIEFORCBUUkFDS0lOR1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBFdmVudCBvZiB0eXBlIGBpblR5cGVgLCBiYXNlZCBvbiB0aGUgaW5mb3JtYXRpb24gaW5cbiAgICAgICAgICogYGluRXZlbnRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5UeXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiBldmVudCB0byBjcmVhdGVcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBBIHBsYXRmb3JtIGV2ZW50IHdpdGggYSB0YXJnZXRcbiAgICAgICAgICogQHJldHVybiB7RXZlbnR9IEEgUG9pbnRlckV2ZW50IG9mIHR5cGUgYGluVHlwZWBcbiAgICAgICAgICovXG4gICAgICAgIG1ha2VFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlUG9pbnRlckV2ZW50KGluVHlwZSwgaW5FdmVudCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gaW5FdmVudC5wcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgIGUudGFwUHJldmVudGVkID0gaW5FdmVudC50YXBQcmV2ZW50ZWQ7XG4gICAgICAgICAgICBlLl90YXJnZXQgPSBlLl90YXJnZXQgfHwgaW5FdmVudC50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbWFrZSBhbmQgZGlzcGF0Y2ggYW4gZXZlbnQgaW4gb25lIGNhbGxcbiAgICAgICAgZmlyZUV2ZW50OiBmdW5jdGlvbihpblR5cGUsIGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5tYWtlRXZlbnQoaW5UeXBlLCBpbkV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgc25hcHNob3Qgb2YgaW5FdmVudCwgd2l0aCB3cml0YWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IEFuIGV2ZW50IHRoYXQgY29udGFpbnMgcHJvcGVydGllcyB0byBjb3B5LlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHNoYWxsb3cgY29waWVzIG9mIGBpbkV2ZW50YCdzXG4gICAgICAgICAqICAgIHByb3BlcnRpZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZUV2ZW50OiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRDb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICBwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDTE9ORV9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHAgPSBDTE9ORV9QUk9QU1tpXTtcbiAgICAgICAgICAgICAgICBldmVudENvcHlbcF0gPSBpbkV2ZW50W3BdIHx8IENMT05FX0RFRkFVTFRTW2ldO1xuICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIFNWR0luc3RhbmNlRWxlbWVudCBzaGFkb3cgdHJlZVxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgPHVzZT4gZWxlbWVudCB0aGF0IGlzIHJlcHJlc2VudGVkIGJ5IHRoZSBpbnN0YW5jZSBmb3IgU2FmYXJpLCBDaHJvbWUsIElFLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGJlaGF2aW9yIGltcGxlbWVudGVkIGJ5IEZpcmVmb3guXG4gICAgICAgICAgICAgICAgaWYgKHAgPT09ICd0YXJnZXQnIHx8IHAgPT09ICdyZWxhdGVkVGFyZ2V0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoSEFTX1NWR19JTlNUQU5DRSAmJiBldmVudENvcHlbcF0gaW5zdGFuY2VvZiBTVkdFbGVtZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q29weVtwXSA9IGV2ZW50Q29weVtwXS5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGtlZXAgdGhlIHNlbWFudGljcyBvZiBwcmV2ZW50RGVmYXVsdFxuICAgICAgICAgICAgZXZlbnRDb3B5LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaW5FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBldmVudENvcHk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudCB0byBpdHMgdGFyZ2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGFuIGV2ZW50IGhhbmRsZXIgcmV0dXJucyB0cnVlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdCA9IGluRXZlbnQuX3RhcmdldDtcbiAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgdC5kaXNwYXRjaEV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGNsb25lIHRoZSBldmVudCBmb3IgdGhlIGdlc3R1cmUgc3lzdGVtIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAvLyBjbG9uZSBhZnRlciBkaXNwYXRjaCB0byBwaWNrIHVwIGdlc3R1cmUgcHJldmVudGlvbiBjb2RlXG4gICAgICAgICAgICAgICAgdmFyIGNsb25lID0gdGhpcy5jbG9uZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGNsb25lLnRhcmdldCA9IHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsR2VzdHVyZVF1ZXVlKGNsb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VzdHVyZVRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgZ2VzdHVyZSBxdWV1ZVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGUsIHJnOyBpIDwgdGhpcy5nZXN0dXJlUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlID0gdGhpcy5nZXN0dXJlUXVldWVbaV07XG4gICAgICAgICAgICAgICAgcmcgPSBlLl9yZXF1aXJlZEdlc3R1cmVzO1xuICAgICAgICAgICAgICAgIGlmIChyZykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgZywgZm47IGogPCB0aGlzLmdlc3R1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHJ1biByZWNvZ25pemVyIGlmIGFuIGVsZW1lbnQgaW4gdGhlIHNvdXJjZSBldmVudCdzIHBhdGggaXMgbGlzdGVuaW5nIGZvciB0aG9zZSBnZXN0dXJlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJnW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHRoaXMuZ2VzdHVyZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBnW2UudHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmNhbGwoZywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nZXN0dXJlUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbEdlc3R1cmVRdWV1ZTogZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgdHJpZ2dlciB0aGUgZ2VzdHVyZSBxdWV1ZSBvbmNlXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2VzdHVyZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmJvdW5kR2VzdHVyZVRyaWdnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXYuX3JlcXVpcmVkR2VzdHVyZXMgPSB0aGlzLnJlcXVpcmVkR2VzdHVyZXMuZ2V0KGV2LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICB0aGlzLmdlc3R1cmVRdWV1ZS5wdXNoKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGlzcGF0Y2hlci5ib3VuZEhhbmRsZXIgPSBkaXNwYXRjaGVyLmV2ZW50SGFuZGxlci5iaW5kKGRpc3BhdGNoZXIpO1xuICAgIGRpc3BhdGNoZXIuYm91bmRHZXN0dXJlVHJpZ2dlciA9IGRpc3BhdGNoZXIuZ2VzdHVyZVRyaWdnZXIuYmluZChkaXNwYXRjaGVyKTtcbiAgICBzY29wZS5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcblxuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgYGdlc3R1cmVgIG9uIGBub2RlYCB3aXRoIHRoZSBgaGFuZGxlcmAgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIElmIGBoYW5kbGVyYCBpcyB0aGUgZmlyc3QgbGlzdGVuZXIgZm9yIGBnZXN0dXJlYCwgdGhlIHVuZGVybHlpbmcgZ2VzdHVyZSByZWNvZ25pemVyIGlzIHRoZW4gZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBnZXN0dXJlXG4gICAgICogQHJldHVybiBCb29sZWFuIGBnZXN0dXJlYCBpcyBhIHZhbGlkIGdlc3R1cmVcbiAgICAgKi9cbiAgICBzY29wZS5hY3RpdmF0ZUdlc3R1cmUgPSBmdW5jdGlvbihub2RlLCBnZXN0dXJlKSB7XG4gICAgICAgIHZhciBnID0gZ2VzdHVyZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgZGVwID0gZGlzcGF0Y2hlci5kZXBlbmRlbmN5TWFwW2ddO1xuICAgICAgICBpZiAoZGVwKSB7XG4gICAgICAgICAgICB2YXIgcmVjb2duaXplciA9IGRpc3BhdGNoZXIuZ2VzdHVyZXNbZGVwLmluZGV4XTtcbiAgICAgICAgICAgIGlmICghbm9kZS5fcGdMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUuX3BnTGlzdGVuZXJzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8oZGZyZWVkbSk6IHJlLWV2YWx1YXRlIGJvb2trZWVwaW5nIHRvIGF2b2lkIHVzaW5nIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoQWN0aW9uID0gcmVjb2duaXplci5kZWZhdWx0QWN0aW9ucyAmJiByZWNvZ25pemVyLmRlZmF1bHRBY3Rpb25zW2ddO1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25Ob2RlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25Ob2RlID0gbm9kZS5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25Ob2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG91Y2hBY3Rpb24gJiYgYWN0aW9uTm9kZSAmJiAhYWN0aW9uTm9kZS5oYXNBdHRyaWJ1dGUoJ3RvdWNoLWFjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbk5vZGUuc2V0QXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nLCB0b3VjaEFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlLl9wZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIG5vZGUuX3BnRXZlbnRzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLl9wZ0V2ZW50c1tnXSA9IChub2RlLl9wZ0V2ZW50c1tnXSB8fCAwKSArIDE7XG4gICAgICAgICAgICBub2RlLl9wZ0xpc3RlbmVycysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCb29sZWFuKGRlcCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTGlzdGVuIGZvciBgZ2VzdHVyZWAgZnJvbSBgbm9kZWAgd2l0aCBgaGFuZGxlcmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ2VzdHVyZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAgICAgKi9cbiAgICBzY29wZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24obm9kZSwgZ2VzdHVyZSwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgc2NvcGUuYWN0aXZhdGVHZXN0dXJlKG5vZGUsIGdlc3R1cmUpO1xuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlYXJzIGRvd24gdGhlIGdlc3R1cmUgY29uZmlndXJhdGlvbiBmb3IgYG5vZGVgXG4gICAgICpcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yIGBnZXN0dXJlYCwgdGhlIHVuZGVybHlpbmcgZ2VzdHVyZSByZWNvZ25pemVyIGlzIGRpc2FibGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdlc3R1cmVcbiAgICAgKiBAcmV0dXJuIEJvb2xlYW4gYGdlc3R1cmVgIGlzIGEgdmFsaWQgZ2VzdHVyZVxuICAgICAqL1xuICAgIHNjb3BlLmRlYWN0aXZhdGVHZXN0dXJlID0gZnVuY3Rpb24obm9kZSwgZ2VzdHVyZSkge1xuICAgICAgICB2YXIgZyA9IGdlc3R1cmUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGRlcCA9IGRpc3BhdGNoZXIuZGVwZW5kZW5jeU1hcFtnXTtcbiAgICAgICAgaWYgKGRlcCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuX3BnTGlzdGVuZXJzID4gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUuX3BnTGlzdGVuZXJzLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5fcGdMaXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnVucmVnaXN0ZXIobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5fcGdFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fcGdFdmVudHNbZ10gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX3BnRXZlbnRzW2ddLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fcGdFdmVudHNbZ10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQm9vbGVhbihkZXApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgYGdlc3R1cmVgIGZyb20gYG5vZGVgIHdpdGggYGhhbmRsZXJgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gICAgICovXG4gICAgc2NvcGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5vZGUsIGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNjb3BlLmRlYWN0aXZhdGVHZXN0dXJlKG5vZGUsIGdlc3R1cmUpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKGV4cG9ydHMpO1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIHBvaW50ZXJtYXAgPSBkaXNwYXRjaGVyLnBvaW50ZXJtYXA7XG4gICAgLy8gcmFkaXVzIGFyb3VuZCB0b3VjaGVuZCB0aGF0IHN3YWxsb3dzIG1vdXNlIGV2ZW50c1xuICAgIHZhciBERURVUF9ESVNUID0gMjU7XG5cbiAgICB2YXIgV0hJQ0hfVE9fQlVUVE9OUyA9IFswLCAxLCA0LCAyXTtcblxuICAgIHZhciBjdXJyZW50QnV0dG9ucyA9IDA7XG5cbiAgICB2YXIgRklSRUZPWF9MSU5VWCA9IC9MaW51eC4qRmlyZWZveFxcLy9pO1xuXG4gICAgdmFyIEhBU19CVVRUT05TID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBmaXJlZm94IG9uIGxpbnV4IHJldHVybnMgc3BlYy1pbmNvcnJlY3QgdmFsdWVzIGZvciBtb3VzZXVwLmJ1dHRvbnNcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQuYnV0dG9ucyNTZWVfYWxzb1xuICAgICAgICAvLyBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzcyNzU5MzAwMy8jbXNnMTZcbiAgICAgICAgaWYgKEZJUkVGT1hfTElOVVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vdXNlRXZlbnQoJ3Rlc3QnLCB7XG4gICAgICAgICAgICAgICAgYnV0dG9uczogMVxuICAgICAgICAgICAgfSkuYnV0dG9ucyA9PT0gMTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSkoKTtcblxuICAgIC8vIGhhbmRsZXIgYmxvY2sgZm9yIG5hdGl2ZSBtb3VzZSBldmVudHNcbiAgICB2YXIgbW91c2VFdmVudHMgPSB7XG4gICAgICAgIFBPSU5URVJfSUQ6IDEsXG4gICAgICAgIFBPSU5URVJfVFlQRTogJ21vdXNlJyxcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgJ21vdXNldXAnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgICAgICAnbW92ZSdcbiAgICAgICAgXSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2hlci51bmxpc3Rlbih0YXJnZXQsIHRoaXMuZXZlbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGFzdFRvdWNoZXM6IFtdLFxuICAgICAgICAvLyBjb2xsaWRlIHdpdGggdGhlIGdsb2JhbCBtb3VzZSBsaXN0ZW5lclxuICAgICAgICBpc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICAgICAgICAgIHZhciB4ID0gaW5FdmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHkgPSBpbkV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGx0cy5sZW5ndGgsIHQ7IGkgPCBsICYmICh0ID0gbHRzW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyB3aWxsIGJlIHN3YWxsb3dlZCBuZWFyIGEgcHJpbWFyeSB0b3VjaGVuZFxuICAgICAgICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpLFxuICAgICAgICAgICAgICAgICAgICBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuICAgICAgICAgICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUICYmIGR5IDw9IERFRFVQX0RJU1QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlRXZlbnQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5wb2ludGVySWQgPSB0aGlzLlBPSU5URVJfSUQ7XG4gICAgICAgICAgICBlLmlzUHJpbWFyeSA9IHRydWU7XG4gICAgICAgICAgICBlLnBvaW50ZXJUeXBlID0gdGhpcy5QT0lOVEVSX1RZUEU7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSAnbW91c2UnO1xuICAgICAgICAgICAgaWYgKCFIQVNfQlVUVE9OUykge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gaW5FdmVudC50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBiaXQgPSBXSElDSF9UT19CVVRUT05TW2luRXZlbnQud2hpY2hdIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCdXR0b25zIHw9IGJpdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QnV0dG9ucyAmPSB+Yml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLmJ1dHRvbnMgPSBjdXJyZW50QnV0dG9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoKGluRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwb2ludGVybWFwLmhhcyh0aGlzLlBPSU5URVJfSUQpO1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgZS50YXJnZXQgPSBzY29wZS5maW5kVGFyZ2V0KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KHRoaXMuUE9JTlRFUl9JRCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIuZG93bihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaChpbkV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBwb2ludGVybWFwLmdldCh0aGlzLlBPSU5URVJfSUQpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBjYXNlIHdoZXJlIHdlIG1pc3NlZCBhIG1vdXNldXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKChIQVNfQlVUVE9OUyA/IGUuYnV0dG9ucyA6IGUud2hpY2gpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUhBU19CVVRUT05TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJ1dHRvbnMgPSBlLmJ1dHRvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5jYW5jZWwoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBNb3VzZShlLmJ1dHRvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5tb3ZlKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZXVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaChpbkV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KHRoaXMuUE9JTlRFUl9JRCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBNb3VzZShlLmJ1dHRvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwTW91c2U6IGZ1bmN0aW9uKGJ1dHRvbnMpIHtcbiAgICAgICAgICAgIGlmIChidXR0b25zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5kZWxldGUodGhpcy5QT0lOVEVSX0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5tb3VzZUV2ZW50cyA9IG1vdXNlRXZlbnRzO1xufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgYWxsU2hhZG93cyA9IHNjb3BlLnRhcmdldEZpbmRpbmcuYWxsU2hhZG93cy5iaW5kKHNjb3BlLnRhcmdldEZpbmRpbmcpO1xuICAgIHZhciBwb2ludGVybWFwID0gZGlzcGF0Y2hlci5wb2ludGVybWFwO1xuICAgIHZhciB0b3VjaE1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbC5iaW5kKEFycmF5LnByb3RvdHlwZS5tYXApO1xuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGxvbmcgZW5vdWdoIHRvIGlnbm9yZSBjb21wYXQgbW91c2UgZXZlbnRzIG1hZGUgYnkgdG91Y2hcbiAgICB2YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG4gICAgdmFyIERFRFVQX0RJU1QgPSAyNTtcbiAgICB2YXIgQ0xJQ0tfQ09VTlRfVElNRU9VVCA9IDIwMDtcbiAgICB2YXIgSFlTVEVSRVNJUyA9IDIwO1xuICAgIHZhciBBVFRSSUIgPSAndG91Y2gtYWN0aW9uJztcbiAgICAvLyBUT0RPKGRmcmVlZG0pOiBkaXNhYmxlIHVudGlsIGh0dHA6Ly9jcmJ1Zy5jb20vMzk5NzY1IGlzIHJlc29sdmVkXG4gICAgLy8gdmFyIEhBU19UT1VDSF9BQ1RJT04gPSBBVFRSSUIgaW4gZG9jdW1lbnQuaGVhZC5zdHlsZTtcbiAgICB2YXIgSEFTX1RPVUNIX0FDVElPTiA9IGZhbHNlO1xuXG4gICAgLy8gaGFuZGxlciBibG9jayBmb3IgbmF0aXZlIHRvdWNoIGV2ZW50c1xuICAgIHZhciB0b3VjaEV2ZW50cyA9IHtcbiAgICAgICAgSVNfSU9TOiBmYWxzZSxcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAndG91Y2hzdGFydCcsXG4gICAgICAgICAgICAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICd0b3VjaGVuZCcsXG4gICAgICAgICAgICAndG91Y2hjYW5jZWwnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgICAgICAnbW92ZSdcbiAgICAgICAgXSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCwgaW5pdGlhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuSVNfSU9TID8gaW5pdGlhbCA6ICFpbml0aWFsKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLklTX0lPUykge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIudW5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbFR5cGVzOiB7XG4gICAgICAgICAgICBFTUlUVEVSOiAnbm9uZScsXG4gICAgICAgICAgICBYU0NST0xMRVI6ICdwYW4teCcsXG4gICAgICAgICAgICBZU0NST0xMRVI6ICdwYW4teScsXG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoQWN0aW9uVG9TY3JvbGxUeXBlOiBmdW5jdGlvbih0b3VjaEFjdGlvbikge1xuICAgICAgICAgICAgdmFyIHQgPSB0b3VjaEFjdGlvbjtcbiAgICAgICAgICAgIHZhciBzdCA9IHRoaXMuc2Nyb2xsVHlwZXM7XG4gICAgICAgICAgICBpZiAodCA9PT0gc3QuRU1JVFRFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT09IHN0LlhTQ1JPTExFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnWCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT09IHN0LllTQ1JPTExFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnWSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnWFknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBQT0lOVEVSX1RZUEU6ICd0b3VjaCcsXG4gICAgICAgIGZpcnN0VG91Y2g6IG51bGwsXG4gICAgICAgIGlzUHJpbWFyeVRvdWNoOiBmdW5jdGlvbihpblRvdWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdFRvdWNoID09PSBpblRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFByaW1hcnlUb3VjaDogZnVuY3Rpb24oaW5Ub3VjaCkge1xuICAgICAgICAgICAgLy8gc2V0IHByaW1hcnkgdG91Y2ggaWYgdGhlcmUgbm8gcG9pbnRlcnMsIG9yIHRoZSBvbmx5IHBvaW50ZXIgaXMgdGhlIG1vdXNlXG4gICAgICAgICAgICBpZiAocG9pbnRlcm1hcC5wb2ludGVycygpID09PSAwIHx8IChwb2ludGVybWFwLnBvaW50ZXJzKCkgPT09IDEgJiYgcG9pbnRlcm1hcC5oYXMoMSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdFRvdWNoID0gaW5Ub3VjaC5pZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RYWSA9IHtcbiAgICAgICAgICAgICAgICAgICAgWDogaW5Ub3VjaC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBZOiBpblRvdWNoLmNsaWVudFlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RUYXJnZXQgPSBpblRvdWNoLnRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxSZXNldENsaWNrQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlUHJpbWFyeVBvaW50ZXI6IGZ1bmN0aW9uKGluUG9pbnRlcikge1xuICAgICAgICAgICAgaWYgKGluUG9pbnRlci5pc1ByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0VG91Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RYWSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldENsaWNrQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xpY2tDb3VudDogMCxcbiAgICAgICAgcmVzZXRJZDogbnVsbCxcbiAgICAgICAgcmVzZXRDbGlja0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldElkID0gbnVsbDtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRJZCA9IHNldFRpbWVvdXQoZm4sIENMSUNLX0NPVU5UX1RJTUVPVVQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWxSZXNldENsaWNrQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzZXRJZCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0eXBlVG9CdXR0b25zOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICAgICAgICByZXQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZFRhcmdldDogZnVuY3Rpb24odG91Y2gsIGlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VG91Y2hFdmVudC50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnlUb3VjaCh0b3VjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhc3RQYXRoID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB0aGlzLmN1cnJlbnRUb3VjaEV2ZW50LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuY3VycmVudFRvdWNoRXZlbnQudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5maW5kVGFyZ2V0KGZhc3RQYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZmluZFRhcmdldCh0b3VjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV1c2UgdGFyZ2V0IHdlIGZvdW5kIGluIHRvdWNoc3RhcnRcbiAgICAgICAgICAgIHJldHVybiBwb2ludGVybWFwLmdldChpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoVG9Qb2ludGVyOiBmdW5jdGlvbihpblRvdWNoKSB7XG4gICAgICAgICAgICB2YXIgY3RlID0gdGhpcy5jdXJyZW50VG91Y2hFdmVudDtcbiAgICAgICAgICAgIHZhciBlID0gZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluVG91Y2gpO1xuICAgICAgICAgICAgLy8gU3BlYyBzcGVjaWZpZXMgdGhhdCBwb2ludGVySWQgMSBpcyByZXNlcnZlZCBmb3IgTW91c2UuXG4gICAgICAgICAgICAvLyBUb3VjaCBpZGVudGlmaWVycyBjYW4gc3RhcnQgYXQgMC5cbiAgICAgICAgICAgIC8vIEFkZCAyIHRvIHRoZSB0b3VjaCBpZGVudGlmaWVyIGZvciBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgdmFyIGlkID0gZS5wb2ludGVySWQgPSBpblRvdWNoLmlkZW50aWZpZXIgKyAyO1xuICAgICAgICAgICAgZS50YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoaW5Ub3VjaCwgaWQpO1xuICAgICAgICAgICAgZS5idWJibGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGUuY2FuY2VsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBlLmRldGFpbCA9IHRoaXMuY2xpY2tDb3VudDtcbiAgICAgICAgICAgIGUuYnV0dG9ucyA9IHRoaXMudHlwZVRvQnV0dG9ucyhjdGUudHlwZSk7XG4gICAgICAgICAgICBlLndpZHRoID0gaW5Ub3VjaC53ZWJraXRSYWRpdXNYIHx8IGluVG91Y2gucmFkaXVzWCB8fCAwO1xuICAgICAgICAgICAgZS5oZWlnaHQgPSBpblRvdWNoLndlYmtpdFJhZGl1c1kgfHwgaW5Ub3VjaC5yYWRpdXNZIHx8IDA7XG4gICAgICAgICAgICBlLnByZXNzdXJlID0gaW5Ub3VjaC53ZWJraXRGb3JjZSB8fCBpblRvdWNoLmZvcmNlIHx8IDAuNTtcbiAgICAgICAgICAgIGUuaXNQcmltYXJ5ID0gdGhpcy5pc1ByaW1hcnlUb3VjaChpblRvdWNoKTtcbiAgICAgICAgICAgIGUucG9pbnRlclR5cGUgPSB0aGlzLlBPSU5URVJfVFlQRTtcbiAgICAgICAgICAgIGUuX3NvdXJjZSA9ICd0b3VjaCc7XG4gICAgICAgICAgICAvLyBmb3J3YXJkIHRvdWNoIHByZXZlbnREZWZhdWx0c1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJzdFhZID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjdGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzc1RvdWNoZXM6IGZ1bmN0aW9uKGluRXZlbnQsIGluRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0bCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUb3VjaEV2ZW50ID0gaW5FdmVudDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCB0LCBwOyBpIDwgdGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ID0gdGxbaV07XG4gICAgICAgICAgICAgICAgcCA9IHRoaXMudG91Y2hUb1BvaW50ZXIodCk7XG4gICAgICAgICAgICAgICAgaWYgKGluRXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KHAucG9pbnRlcklkLCBwLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb2ludGVybWFwLmhhcyhwLnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5GdW5jdGlvbi5jYWxsKHRoaXMsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5FdmVudC50eXBlID09PSAndG91Y2hlbmQnIHx8IGluRXZlbnQuX2NhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuVXBQb2ludGVyKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gRm9yIHNpbmdsZSBheGlzIHNjcm9sbGVycywgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBlbGVtZW50IHNob3VsZCBlbWl0XG4gICAgICAgIC8vIHBvaW50ZXIgZXZlbnRzIG9yIGJlaGF2ZSBhcyBhIHNjcm9sbGVyXG4gICAgICAgIHNob3VsZFNjcm9sbDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RYWSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoQWN0aW9uID0gc2NvcGUudGFyZ2V0RmluZGluZy5maW5kVG91Y2hBY3Rpb24oaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbEF4aXMgPSB0aGlzLnRvdWNoQWN0aW9uVG9TY3JvbGxUeXBlKHRvdWNoQWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsQXhpcyA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgZWxlbWVudCBpcyBhIHRvdWNoLWFjdGlvbjogbm9uZSwgc2hvdWxkIG5ldmVyIHNjcm9sbFxuICAgICAgICAgICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbEF4aXMgPT09ICdYWScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBlbGVtZW50IHNob3VsZCBhbHdheXMgc2Nyb2xsXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgaW50ZW5kZWQgc2Nyb2xsIGF4aXMsIGFuZCBvdGhlciBheGlzXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gc2Nyb2xsQXhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9hID0gc2Nyb2xsQXhpcyA9PT0gJ1knID8gJ1gnIDogJ1knO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGEgPSBNYXRoLmFicyh0WydjbGllbnQnICsgYV0gLSB0aGlzLmZpcnN0WFlbYV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9hID0gTWF0aC5hYnModFsnY2xpZW50JyArIG9hXSAtIHRoaXMuZmlyc3RYWVtvYV0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBkZWx0YSBpbiB0aGUgc2Nyb2xsIGF4aXMgPiBkZWx0YSBvdGhlciBheGlzLCBzY3JvbGwgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGRhID49IGRvYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmluZFRvdWNoOiBmdW5jdGlvbihpblRMLCBpbklkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluVEwubGVuZ3RoLCB0OyBpIDwgbCAmJiAodCA9IGluVExbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodC5pZGVudGlmaWVyID09PSBpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gSW4gc29tZSBpbnN0YW5jZXMsIGEgdG91Y2hzdGFydCBjYW4gaGFwcGVuIHdpdGhvdXQgYSB0b3VjaGVuZC4gVGhpc1xuICAgICAgICAvLyBsZWF2ZXMgdGhlIHBvaW50ZXJtYXAgaW4gYSBicm9rZW4gc3RhdGUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgb24gZXZlcnkgdG91Y2hzdGFydCwgd2UgcmVtb3ZlIHRoZSB0b3VjaGVzIHRoYXQgZGlkIG5vdCBmaXJlIGFcbiAgICAgICAgLy8gdG91Y2hlbmQgZXZlbnQuXG4gICAgICAgIC8vIFRvIGtlZXAgc3RhdGUgZ2xvYmFsbHkgY29uc2lzdGVudCwgd2UgZmlyZSBhXG4gICAgICAgIC8vIHBvaW50ZXJjYW5jZWwgZm9yIHRoaXMgXCJhYmFuZG9uZWRcIiB0b3VjaFxuICAgICAgICB2YWN1dW1Ub3VjaGVzOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGwgPSBpbkV2ZW50LnRvdWNoZXM7XG4gICAgICAgICAgICAvLyBwb2ludGVybWFwLnBvaW50ZXJzKCkgc2hvdWxkIGJlIDwgdGwubGVuZ3RoIGhlcmUsIGFzIHRoZSB0b3VjaHN0YXJ0IGhhcyBub3RcbiAgICAgICAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkIHlldC5cbiAgICAgICAgICAgIGlmIChwb2ludGVybWFwLnBvaW50ZXJzKCkgPj0gdGwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciByZW1vdmUgcG9pbnRlcklkID09IDEsIHdoaWNoIGlzIG1vdXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBUb3VjaCBpZGVudGlmaWVycyBhcmUgMiBzbWFsbGVyIHRoYW4gdGhlaXIgcG9pbnRlcklkLCB3aGljaCBpcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggaW4gcG9pbnRlcm1hcC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gMSAmJiAhdGhpcy5maW5kVG91Y2godGwsIGtleSAtIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgZC5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuZGVsZXRlKHAucG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy52YWN1dW1Ub3VjaGVzKGluRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRQcmltYXJ5VG91Y2goaW5FdmVudC5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgICAgICAgICB0aGlzLmRlZHVwU3ludGhNb3VzZShpbkV2ZW50KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWNrQ291bnQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMuZG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluUG9pbnRlcikge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5kb3duKGluUG9pbnRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKEhBU19UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgICAgICAgICAvLyB0b3VjaGV2ZW50LmNhbmNlbGFibGUgPT0gZmFsc2UgaXMgc2VudCB3aGVuIHRoZSBwYWdlIGlzIHNjcm9sbGluZyB1bmRlciBuYXRpdmUgVG91Y2ggQWN0aW9uIGluIENocm9tZSAzNlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZC9tc2cvaW5wdXQtZGV2L3dIbnl1a2NZQmNBL2I5a210d00xakpRSlxuICAgICAgICAgICAgICAgIGlmIChpbkV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzVG91Y2hlcyhpbkV2ZW50LCB0aGlzLm1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNjcm9sbGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxpbmcgPT09IG51bGwgJiYgdGhpcy5zaG91bGRTY3JvbGwoaW5FdmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMubW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlyc3RYWSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IHQuY2xpZW50WCAtIHRoaXMuZmlyc3RYWS5YO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSB0LmNsaWVudFkgLSB0aGlzLmZpcnN0WFkuWTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRkID49IEhZU1RFUkVTSVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG91Y2hjYW5jZWwoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0WFkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIubW92ZShpblBvaW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICB0b3VjaGVuZDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy5kZWR1cFN5bnRoTW91c2UoaW5FdmVudCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMudXApO1xuICAgICAgICB9LFxuICAgICAgICB1cDogZnVuY3Rpb24oaW5Qb2ludGVyKSB7XG4gICAgICAgICAgICBpblBvaW50ZXIucmVsYXRlZFRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5Qb2ludGVyKTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIudXAoaW5Qb2ludGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuY2FuY2VsKGluUG9pbnRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoY2FuY2VsOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpbkV2ZW50Ll9jYW5jZWwgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzVG91Y2hlcyhpbkV2ZW50LCB0aGlzLmNhbmNlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFuVXBQb2ludGVyOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXBbJ2RlbGV0ZSddKGluUG9pbnRlci5wb2ludGVySWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQcmltYXJ5UG9pbnRlcihpblBvaW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV2ZW50IHN5bnRoIG1vdXNlIGV2ZW50cyBmcm9tIGNyZWF0aW5nIHBvaW50ZXIgZXZlbnRzXG4gICAgICAgIGRlZHVwU3ludGhNb3VzZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGx0cyA9IHNjb3BlLm1vdXNlRXZlbnRzLmxhc3RUb3VjaGVzO1xuICAgICAgICAgICAgdmFyIHQgPSBpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgLy8gb25seSB0aGUgcHJpbWFyeSBmaW5nZXIgd2lsbCBzeW50aCBtb3VzZSBldmVudHNcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeVRvdWNoKHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgeC95IG9mIGxhc3QgdG91Y2hcbiAgICAgICAgICAgICAgICB2YXIgbHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgeTogdC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsdHMucHVzaChsdCk7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gKGZ1bmN0aW9uKGx0cywgbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5iaW5kKG51bGwsIGx0cywgbHQpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIERFRFVQX1RJTUVPVVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHByZXZlbnQgXCJnaG9zdCBjbGlja3NcIiB0aGF0IGNvbWUgZnJvbSBlbGVtZW50cyB0aGF0IHdlcmUgcmVtb3ZlZCBpbiBhIHRvdWNoIGhhbmRsZXJcbiAgICB2YXIgU1RPUF9QUk9QX0ZOID0gRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiB8fCBFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIHggPSBldi5jbGllbnRYLFxuICAgICAgICAgICAgeSA9IGV2LmNsaWVudFk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGEgY2xpY2sgaXMgd2l0aGluIERFRFVQX0RJU1QgcHggcmFkaXVzIG9mIHRoZSB0b3VjaHN0YXJ0XG4gICAgICAgIHZhciBjbG9zZVRvID0gZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0b3VjaC54KSxcbiAgICAgICAgICAgICAgICBkeSA9IE1hdGguYWJzKHkgLSB0b3VjaC55KTtcbiAgICAgICAgICAgIHJldHVybiAoZHggPD0gREVEVVBfRElTVCAmJiBkeSA8PSBERURVUF9ESVNUKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaWYgY2xpY2sgY29vcmRpbmF0ZXMgYXJlIGNsb3NlIHRvIHRvdWNoIGNvb3JkaW5hdGVzLCBhc3N1bWUgdGhlIGNsaWNrIGNhbWUgZnJvbSBhIHRvdWNoXG4gICAgICAgIHZhciB3YXNUb3VjaGVkID0gc2NvcGUubW91c2VFdmVudHMubGFzdFRvdWNoZXMuc29tZShjbG9zZVRvKTtcbiAgICAgICAgLy8gaWYgdGhlIGNsaWNrIGNhbWUgZnJvbSB0b3VjaCwgYW5kIHRoZSB0b3VjaHN0YXJ0IHRhcmdldCBpcyBub3QgaW4gdGhlIHBhdGggb2YgdGhlIGNsaWNrIGV2ZW50LFxuICAgICAgICAvLyB0aGVuIHRoZSB0b3VjaHN0YXJ0IHRhcmdldCB3YXMgcHJvYmFibHkgcmVtb3ZlZCwgYW5kIHRoZSBjbGljayBzaG91bGQgYmUgXCJidXN0ZWRcIlxuICAgICAgICB2YXIgcGF0aCA9IHNjb3BlLnRhcmdldEZpbmRpbmcucGF0aChldik7XG4gICAgICAgIGlmICh3YXNUb3VjaGVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aFtpXSA9PT0gdG91Y2hFdmVudHMuZmlyc3RUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBTVE9QX1BST1BfRk4uY2FsbChldik7XG4gICAgICAgIH1cbiAgICB9LCB0cnVlKTtcblxuICAgIHNjb3BlLnRvdWNoRXZlbnRzID0gdG91Y2hFdmVudHM7XG59KShleHBvcnRzKTtcblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSBzY29wZS5kaXNwYXRjaGVyO1xuICAgIHZhciBwb2ludGVybWFwID0gZGlzcGF0Y2hlci5wb2ludGVybWFwO1xuICAgIHZhciBIQVNfQklUTUFQX1RZUEUgPSB3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgdHlwZW9mIHdpbmRvdy5NU1BvaW50ZXJFdmVudC5NU1BPSU5URVJfVFlQRV9NT1VTRSA9PT0gJ251bWJlcic7XG4gICAgdmFyIG1zRXZlbnRzID0ge1xuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdNU1BvaW50ZXJEb3duJyxcbiAgICAgICAgICAgICdNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICAgICAgICdNU1BvaW50ZXJVcCcsXG4gICAgICAgICAgICAnTVNQb2ludGVyQ2FuY2VsJyxcbiAgICAgICAgXSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2hlci51bmxpc3Rlbih0YXJnZXQsIHRoaXMuZXZlbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgUE9JTlRFUl9UWVBFUzogW1xuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAndW5hdmFpbGFibGUnLFxuICAgICAgICAgICAgJ3RvdWNoJyxcbiAgICAgICAgICAgICdwZW4nLFxuICAgICAgICAgICAgJ21vdXNlJ1xuICAgICAgICBdLFxuICAgICAgICBwcmVwYXJlRXZlbnQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gaW5FdmVudDtcbiAgICAgICAgICAgIGUgPSBkaXNwYXRjaGVyLmNsb25lRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBpZiAoSEFTX0JJVE1BUF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgZS5wb2ludGVyVHlwZSA9IHRoaXMuUE9JTlRFUl9UWVBFU1tpbkV2ZW50LnBvaW50ZXJUeXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUuX3NvdXJjZSA9ICdtcyc7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXBbJ2RlbGV0ZSddKGlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgTVNQb2ludGVyRG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KGluRXZlbnQucG9pbnRlcklkLCBlLnRhcmdldCk7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLmRvd24oZSk7XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlck1vdmU6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBwb2ludGVybWFwLmdldChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLm1vdmUoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlclVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gcG9pbnRlcm1hcC5nZXQoZS5wb2ludGVySWQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlckNhbmNlbDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KGUucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuY2FuY2VsKGUpO1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5tc0V2ZW50cyA9IG1zRXZlbnRzO1xufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IGRpc3BhdGNoZXIucG9pbnRlcm1hcDtcbiAgICB2YXIgcG9pbnRlckV2ZW50cyA9IHtcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAncG9pbnRlcmRvd24nLFxuICAgICAgICAgICAgJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgICAgICdwb2ludGVydXAnLFxuICAgICAgICAgICAgJ3BvaW50ZXJjYW5jZWwnXG4gICAgICAgIF0sXG4gICAgICAgIHByZXBhcmVFdmVudDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSBkaXNwYXRjaGVyLmNsb25lRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSAncG9pbnRlcic7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2hlci51bmxpc3Rlbih0YXJnZXQsIHRoaXMuZXZlbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXBbJ2RlbGV0ZSddKGlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5FdmVudCk7XG4gICAgICAgICAgICBwb2ludGVybWFwLnNldChlLnBvaW50ZXJJZCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5kb3duKGUpO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludGVybW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIubW92ZShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRlcnVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gcG9pbnRlcm1hcC5nZXQoZS5wb2ludGVySWQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50ZXJjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnJlbGF0ZWRUYXJnZXQgPSBzY29wZS5maW5kVGFyZ2V0KGluRXZlbnQpO1xuICAgICAgICAgICAgZS50YXJnZXQgPSBwb2ludGVybWFwLmdldChlLnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLmNhbmNlbChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2NvcGUucG9pbnRlckV2ZW50cyA9IHBvaW50ZXJFdmVudHM7XG59KShleHBvcnRzKTtcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyB0aGUgaGFuZGxlcnMgZm9yIG5hdGl2ZSBwbGF0Zm9ybSBldmVudHMuXG4gKiBGcm9tIGhlcmUsIHRoZSBkaXNwYXRjaGVyIGlzIGNhbGxlZCB0byBjcmVhdGUgdW5pZmllZCBwb2ludGVyIGV2ZW50cy5cbiAqIEluY2x1ZGVkIGFyZSB0b3VjaCBldmVudHMgKHYxKSwgbW91c2UgZXZlbnRzLCBhbmQgTVNQb2ludGVyRXZlbnRzLlxuICovXG4oZnVuY3Rpb24oc2NvcGUpIHtcblxuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgbmF2ID0gd2luZG93Lm5hdmlnYXRvcjtcblxuICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJTb3VyY2UoJ3BvaW50ZXInLCBzY29wZS5wb2ludGVyRXZlbnRzKTtcbiAgICB9IGVsc2UgaWYgKG5hdi5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJTb3VyY2UoJ21zJywgc2NvcGUubXNFdmVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJTb3VyY2UoJ21vdXNlJywgc2NvcGUubW91c2VFdmVudHMpO1xuICAgICAgICBpZiAod2luZG93Lm9udG91Y2hzdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyU291cmNlKCd0b3VjaCcsIHNjb3BlLnRvdWNoRXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdvcmsgYXJvdW5kIGlPUyBidWdzIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzU2MjggYW5kIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY1MDZcbiAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIHZhciBJU19JT1MgPSB1YS5tYXRjaCgvaVBhZHxpUGhvbmV8aVBvZC8pICYmICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcblxuICAgIGRpc3BhdGNoZXIuSVNfSU9TID0gSVNfSU9TO1xuICAgIHNjb3BlLnRvdWNoRXZlbnRzLklTX0lPUyA9IElTX0lPUztcblxuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXIoZG9jdW1lbnQsIHRydWUpO1xufSkoZXhwb3J0cyk7XG5cbi8qKlxuICogVGhpcyBldmVudCBkZW5vdGVzIHRoZSBiZWdpbm5pbmcgb2YgYSBzZXJpZXMgb2YgdHJhY2tpbmcgZXZlbnRzLlxuICpcbiAqIEBtb2R1bGUgUG9pbnRlckdlc3R1cmVzXG4gKiBAc3VibW9kdWxlIEV2ZW50c1xuICogQGNsYXNzIHRyYWNrc3RhcnRcbiAqL1xuLyoqXG4gKiBQaXhlbHMgbW92ZWQgaW4gdGhlIHggZGlyZWN0aW9uIHNpbmNlIHRyYWNrc3RhcnQuXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBkeFxuICovXG4vKipcbiAqIFBpeGVzIG1vdmVkIGluIHRoZSB5IGRpcmVjdGlvbiBzaW5jZSB0cmFja3N0YXJ0LlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgZHlcbiAqL1xuLyoqXG4gKiBQaXhlbHMgbW92ZWQgaW4gdGhlIHggZGlyZWN0aW9uIHNpbmNlIHRoZSBsYXN0IHRyYWNrLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgZGR4XG4gKi9cbi8qKlxuICogUGl4bGVzIG1vdmVkIGluIHRoZSB5IGRpcmVjdGlvbiBzaW5jZSB0aGUgbGFzdCB0cmFjay5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IGRkeVxuICovXG4vKipcbiAqIFRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgY2xpZW50WFxuICovXG4vKipcbiAqIFRoZSBjbGllbnRZIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgY2xpZW50WVxuICovXG4vKipcbiAqIFRoZSBwYWdlWCBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHBhZ2VYXG4gKi9cbi8qKlxuICogVGhlIHBhZ2VZIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgcGFnZVlcbiAqL1xuLyoqXG4gKiBUaGUgc2NyZWVuWCBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHNjcmVlblhcbiAqL1xuLyoqXG4gKiBUaGUgc2NyZWVuWSBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHNjcmVlbllcbiAqL1xuLyoqXG4gKiBUaGUgbGFzdCB4IGF4aXMgZGlyZWN0aW9uIG9mIHRoZSBwb2ludGVyLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgeERpcmVjdGlvblxuICovXG4vKipcbiAqIFRoZSBsYXN0IHkgYXhpcyBkaXJlY3Rpb24gb2YgdGhlIHBvaW50ZXIuXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSB5RGlyZWN0aW9uXG4gKi9cbi8qKlxuICogQSBzaGFyZWQgb2JqZWN0IGJldHdlZW4gYWxsIHRyYWNraW5nIGV2ZW50cy5cbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHRyYWNrSW5mb1xuICovXG4vKipcbiAqIFRoZSBlbGVtZW50IGN1cnJlbnRseSB1bmRlciB0aGUgcG9pbnRlci5cbiAqIEB0eXBlIEVsZW1lbnRcbiAqIEBwcm9wZXJ0eSByZWxhdGVkVGFyZ2V0XG4gKi9cbi8qKlxuICogVGhlIHR5cGUgb2YgcG9pbnRlciB0aGF0IG1ha2UgdGhlIHRyYWNrIGdlc3R1cmUuXG4gKiBAdHlwZSBTdHJpbmdcbiAqIEBwcm9wZXJ0eSBwb2ludGVyVHlwZVxuICovXG4vKipcbiAqXG4gKiBUaGlzIGV2ZW50IGZpcmVzIGZvciBhbGwgcG9pbnRlciBtb3ZlbWVudCBiZWluZyB0cmFja2VkLlxuICpcbiAqIEBjbGFzcyB0cmFja1xuICogQGV4dGVuZHMgdHJhY2tzdGFydFxuICovXG4vKipcbiAqIFRoaXMgZXZlbnQgZmlyZXMgd2hlbiB0aGUgcG9pbnRlciBpcyBubyBsb25nZXIgYmVpbmcgdHJhY2tlZC5cbiAqXG4gKiBAY2xhc3MgdHJhY2tlbmRcbiAqIEBleHRlbmRzIHRyYWNrc3RhcnRcbiAqL1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHNjb3BlLmV2ZW50RmFjdG9yeTtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IG5ldyBzY29wZS5Qb2ludGVyTWFwKCk7XG4gICAgdmFyIHRyYWNrID0ge1xuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICdtb3ZlJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICd0cmFja3N0YXJ0JyxcbiAgICAgICAgICAgICd0cmFjaycsXG4gICAgICAgICAgICAndHJhY2t4JyxcbiAgICAgICAgICAgICd0cmFja3knLFxuICAgICAgICAgICAgJ3RyYWNrZW5kJ1xuICAgICAgICBdLFxuICAgICAgICBkZWZhdWx0QWN0aW9uczoge1xuICAgICAgICAgICAgJ3RyYWNrJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3RyYWNreCc6ICdwYW4teScsXG4gICAgICAgICAgICAndHJhY2t5JzogJ3Bhbi14J1xuICAgICAgICB9LFxuICAgICAgICBXSUdHTEVfVEhSRVNIT0xEOiA0LFxuICAgICAgICBjbGFtcERpcjogZnVuY3Rpb24oaW5EZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGluRGVsdGEgPiAwID8gMSA6IC0xO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjUG9zaXRpb25EZWx0YTogZnVuY3Rpb24oaW5BLCBpbkIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIGlmIChpbkEgJiYgaW5CKSB7XG4gICAgICAgICAgICAgICAgeCA9IGluQi5wYWdlWCAtIGluQS5wYWdlWDtcbiAgICAgICAgICAgICAgICB5ID0gaW5CLnBhZ2VZIC0gaW5BLnBhZ2VZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGZpcmVUcmFjazogZnVuY3Rpb24oaW5UeXBlLCBpbkV2ZW50LCBpblRyYWNraW5nRGF0YSkge1xuICAgICAgICAgICAgdmFyIHQgPSBpblRyYWNraW5nRGF0YTtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5jYWxjUG9zaXRpb25EZWx0YSh0LmRvd25FdmVudCwgaW5FdmVudCk7XG4gICAgICAgICAgICB2YXIgZGQgPSB0aGlzLmNhbGNQb3NpdGlvbkRlbHRhKHQubGFzdE1vdmVFdmVudCwgaW5FdmVudCk7XG4gICAgICAgICAgICBpZiAoZGQueCkge1xuICAgICAgICAgICAgICAgIHQueERpcmVjdGlvbiA9IHRoaXMuY2xhbXBEaXIoZGQueCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluVHlwZSA9PT0gJ3RyYWNreCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGQueSkge1xuICAgICAgICAgICAgICAgIHQueURpcmVjdGlvbiA9IHRoaXMuY2xhbXBEaXIoZGQueSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluVHlwZSA9PT0gJ3RyYWNreScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZ2VzdHVyZVByb3RvID0ge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cmFja0luZm86IHQudHJhY2tJbmZvLFxuICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGluRXZlbnQucmVsYXRlZFRhcmdldCxcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogaW5FdmVudC5wb2ludGVyVHlwZSxcbiAgICAgICAgICAgICAgICBwb2ludGVySWQ6IGluRXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgICAgIF9zb3VyY2U6ICd0cmFjaydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW5UeXBlICE9PSAndHJhY2t5Jykge1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by54ID0gaW5FdmVudC54O1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by5keCA9IGQueDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uZGR4ID0gZGQueDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uY2xpZW50WCA9IGluRXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8ucGFnZVggPSBpbkV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by5zY3JlZW5YID0gaW5FdmVudC5zY3JlZW5YO1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by54RGlyZWN0aW9uID0gdC54RGlyZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluVHlwZSAhPT0gJ3RyYWNreCcpIHtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uZHkgPSBkLnk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLmRkeSA9IGRkLnk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLnkgPSBpbkV2ZW50Lnk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLmNsaWVudFkgPSBpbkV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLnBhZ2VZID0gaW5FdmVudC5wYWdlWTtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uc2NyZWVuWSA9IGluRXZlbnQuc2NyZWVuWTtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8ueURpcmVjdGlvbiA9IHQueURpcmVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlID0gZXZlbnRGYWN0b3J5Lm1ha2VHZXN0dXJlRXZlbnQoaW5UeXBlLCBnZXN0dXJlUHJvdG8pO1xuICAgICAgICAgICAgdC5kb3duVGFyZ2V0LmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbkV2ZW50LmlzUHJpbWFyeSAmJiAoaW5FdmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyA/IGluRXZlbnQuYnV0dG9ucyA9PT0gMSA6IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRvd25FdmVudDogaW5FdmVudCxcbiAgICAgICAgICAgICAgICAgICAgZG93blRhcmdldDogaW5FdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrSW5mbzoge30sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb3ZlRXZlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHhEaXJlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgICAgIHlEaXJlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNraW5nOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwLnRyYWNraW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5jYWxjUG9zaXRpb25EZWx0YShwLmRvd25FdmVudCwgaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3ZlID0gZC54ICogZC54ICsgZC55ICogZC55O1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCB0cmFja2luZyBvbmx5IGlmIGZpbmdlciBtb3ZlcyBtb3JlIHRoYW4gV0lHR0xFX1RIUkVTSE9MRFxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZSA+IHRoaXMuV0lHR0xFX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC50cmFja2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxhc3RNb3ZlRXZlbnQgPSBwLmRvd25FdmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja3N0YXJ0JywgaW5FdmVudCwgcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHAudHJhY2tpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlVHJhY2soJ3RyYWNrJywgaW5FdmVudCwgcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja3gnLCBpbkV2ZW50LCBwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlVHJhY2soJ3RyYWNreScsIGluRXZlbnQsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwLmxhc3RNb3ZlRXZlbnQgPSBpbkV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIHAgPSBwb2ludGVybWFwLmdldChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIGlmIChwLnRyYWNraW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja2VuZCcsIGluRXZlbnQsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLmRlbGV0ZShpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJHZXN0dXJlKCd0cmFjaycsIHRyYWNrKTtcbn0pKGV4cG9ydHMpO1xuXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIHBvaW50ZXIgaXMgaGVsZCBkb3duIGZvciAyMDBtcy5cbiAqXG4gKiBAbW9kdWxlIFBvaW50ZXJHZXN0dXJlc1xuICogQHN1Ym1vZHVsZSBFdmVudHNcbiAqIEBjbGFzcyBob2xkXG4gKi9cbi8qKlxuICogVHlwZSBvZiBwb2ludGVyIHRoYXQgbWFkZSB0aGUgaG9sZGluZyBldmVudC5cbiAqIEB0eXBlIFN0cmluZ1xuICogQHByb3BlcnR5IHBvaW50ZXJUeXBlXG4gKi9cbi8qKlxuICogU2NyZWVuIFggYXhpcyBwb3NpdGlvbiBvZiB0aGUgaGVsZCBwb2ludGVyXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBjbGllbnRYXG4gKi9cbi8qKlxuICogU2NyZWVuIFkgYXhpcyBwb3NpdGlvbiBvZiB0aGUgaGVsZCBwb2ludGVyXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBjbGllbnRZXG4gKi9cbi8qKlxuICogVHlwZSBvZiBwb2ludGVyIHRoYXQgbWFkZSB0aGUgaG9sZGluZyBldmVudC5cbiAqIEB0eXBlIFN0cmluZ1xuICogQHByb3BlcnR5IHBvaW50ZXJUeXBlXG4gKi9cbi8qKlxuICogVGhpcyBldmVudCBpcyBmaXJlZCBldmVyeSAyMDBtcyB3aGlsZSBhIHBvaW50ZXIgaXMgaGVsZCBkb3duLlxuICpcbiAqIEBjbGFzcyBob2xkcHVsc2VcbiAqIEBleHRlbmRzIGhvbGRcbiAqL1xuLyoqXG4gKiBNaWxsaXNlY29uZHMgcG9pbnRlciBoYXMgYmVlbiBoZWxkIGRvd24uXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBob2xkVGltZVxuICovXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGhlbGQgcG9pbnRlciBpcyByZWxlYXNlZCBvciBtb3ZlZC5cbiAqXG4gKiBAY2xhc3MgcmVsZWFzZVxuICovXG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgZXZlbnRGYWN0b3J5ID0gc2NvcGUuZXZlbnRGYWN0b3J5O1xuICAgIHZhciBob2xkID0ge1xuICAgICAgICAvLyB3YWl0IGF0IGxlYXN0IEhPTERfREVMQVkgbXMgYmV0d2VlbiBob2xkIGFuZCBwdWxzZSBldmVudHNcbiAgICAgICAgSE9MRF9ERUxBWTogMjAwLFxuICAgICAgICAvLyBwb2ludGVyIGNhbiBtb3ZlIFdJR0dMRV9USFJFU0hPTEQgcGl4ZWxzIGJlZm9yZSBub3QgY291bnRpbmcgYXMgYSBob2xkXG4gICAgICAgIFdJR0dMRV9USFJFU0hPTEQ6IDE2LFxuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICdtb3ZlJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdob2xkJyxcbiAgICAgICAgICAgICdob2xkcHVsc2UnLFxuICAgICAgICAgICAgJ3JlbGVhc2UnXG4gICAgICAgIF0sXG4gICAgICAgIGhlbGRQb2ludGVyOiBudWxsLFxuICAgICAgICBob2xkSm9iOiBudWxsLFxuICAgICAgICBwdWxzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaG9sZCA9IERhdGUubm93KCkgLSB0aGlzLmhlbGRQb2ludGVyLnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5oZWxkID8gJ2hvbGRwdWxzZScgOiAnaG9sZCc7XG4gICAgICAgICAgICB0aGlzLmZpcmVIb2xkKHR5cGUsIGhvbGQpO1xuICAgICAgICAgICAgdGhpcy5oZWxkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5ob2xkSm9iKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVIb2xkKCdyZWxlYXNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhlbGQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGVsZFBvaW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ob2xkSm9iID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKGluRXZlbnQuaXNQcmltYXJ5ICYmICF0aGlzLmhlbGRQb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxkUG9pbnRlciA9IGluRXZlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBpbkV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLmhvbGRKb2IgPSBzZXRJbnRlcnZhbCh0aGlzLnB1bHNlLmJpbmQodGhpcyksIHRoaXMuSE9MRF9ERUxBWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWxkUG9pbnRlciAmJiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJJZCA9PT0gaW5FdmVudC5wb2ludGVySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWxkUG9pbnRlciAmJiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJJZCA9PT0gaW5FdmVudC5wb2ludGVySWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WCAtIHRoaXMuaGVsZFBvaW50ZXIuY2xpZW50WDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGluRXZlbnQuY2xpZW50WSAtIHRoaXMuaGVsZFBvaW50ZXIuY2xpZW50WTtcbiAgICAgICAgICAgICAgICBpZiAoKHggKiB4ICsgeSAqIHkpID4gdGhpcy5XSUdHTEVfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaXJlSG9sZDogZnVuY3Rpb24oaW5UeXBlLCBpbkhvbGRUaW1lKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IHRoaXMuaGVsZFBvaW50ZXIucG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcklkOiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJJZCxcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmhlbGRQb2ludGVyLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5oZWxkUG9pbnRlci5jbGllbnRZLFxuICAgICAgICAgICAgICAgIF9zb3VyY2U6ICdob2xkJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbkhvbGRUaW1lKSB7XG4gICAgICAgICAgICAgICAgcC5ob2xkVGltZSA9IGluSG9sZFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlR2VzdHVyZUV2ZW50KGluVHlwZSwgcCk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyR2VzdHVyZSgnaG9sZCcsIGhvbGQpO1xufSkoZXhwb3J0cyk7XG5cbi8qKlxuICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgcG9pbnRlciBxdWlja2x5IGdvZXMgZG93biBhbmQgdXAsIGFuZCBpcyB1c2VkIHRvXG4gKiBkZW5vdGUgYWN0aXZhdGlvbi5cbiAqXG4gKiBBbnkgZ2VzdHVyZSBldmVudCBjYW4gcHJldmVudCB0aGUgdGFwIGV2ZW50IGZyb20gYmVpbmcgY3JlYXRlZCBieSBjYWxsaW5nXG4gKiBgZXZlbnQucHJldmVudFRhcGAuXG4gKlxuICogQW55IHBvaW50ZXIgZXZlbnQgY2FuIHByZXZlbnQgdGhlIHRhcCBieSBzZXR0aW5nIHRoZSBgdGFwUHJldmVudGVkYCBwcm9wZXJ0eVxuICogb24gaXRzZWxmLlxuICpcbiAqIEBtb2R1bGUgUG9pbnRlckdlc3R1cmVzXG4gKiBAc3VibW9kdWxlIEV2ZW50c1xuICogQGNsYXNzIHRhcFxuICovXG4vKipcbiAqIFggYXhpcyBwb3NpdGlvbiBvZiB0aGUgdGFwLlxuICogQHByb3BlcnR5IHhcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIFkgYXhpcyBwb3NpdGlvbiBvZiB0aGUgdGFwLlxuICogQHByb3BlcnR5IHlcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIFR5cGUgb2YgdGhlIHBvaW50ZXIgdGhhdCBtYWRlIHRoZSB0YXAuXG4gKiBAcHJvcGVydHkgcG9pbnRlclR5cGVcbiAqIEB0eXBlIFN0cmluZ1xuICovXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHNjb3BlLmV2ZW50RmFjdG9yeTtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IG5ldyBzY29wZS5Qb2ludGVyTWFwKCk7XG4gICAgdmFyIHRhcCA9IHtcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAnZG93bicsXG4gICAgICAgICAgICAndXAnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICd0YXAnXG4gICAgICAgIF0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbkV2ZW50LmlzUHJpbWFyeSAmJiAhaW5FdmVudC50YXBQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLnNldChpbkV2ZW50LnBvaW50ZXJJZCwge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGluRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBpbkV2ZW50LmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIHg6IGluRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgeTogaW5FdmVudC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZFRhcDogZnVuY3Rpb24oZSwgZG93blN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgdGFwID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhbGxvdyBsZWZ0IGNsaWNrIHRvIHRhcCBmb3IgbW91c2VcbiAgICAgICAgICAgICAgICB0YXAgPSAoZS5idXR0b25zIF4gMSkgJiYgKGRvd25TdGF0ZS5idXR0b25zICYgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFwICYmICFlLnRhcFByZXZlbnRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmIChzdGFydCAmJiB0aGlzLnNob3VsZFRhcChpbkV2ZW50LCBzdGFydCkpIHtcbiAgICAgICAgICAgICAgICAvLyB1cC5yZWxhdGVkVGFyZ2V0IGlzIHRhcmdldCBjdXJyZW50bHkgdW5kZXIgZmluZ2VyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBzY29wZS50YXJnZXRGaW5kaW5nLkxDQShzdGFydC50YXJnZXQsIGluRXZlbnQucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBldmVudEZhY3RvcnkubWFrZUdlc3R1cmVFdmVudCgndGFwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpbkV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBpbkV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGluRXZlbnQuZGV0YWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IGluRXZlbnQucG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVySWQ6IGluRXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx0S2V5OiBpbkV2ZW50LmFsdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmxLZXk6IGluRXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFLZXk6IGluRXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0S2V5OiBpbkV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgX3NvdXJjZTogJ3RhcCdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVybWFwLmRlbGV0ZShpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHBhdGNoIGV2ZW50RmFjdG9yeSB0byByZW1vdmUgaWQgZnJvbSB0YXAncyBwb2ludGVybWFwIGZvciBwcmV2ZW50VGFwIGNhbGxzXG4gICAgZXZlbnRGYWN0b3J5LnByZXZlbnRUYXAgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGUudGFwUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBvaW50ZXJtYXAuZGVsZXRlKGUucG9pbnRlcklkKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJHZXN0dXJlKCd0YXAnLCB0YXApO1xufSkoZXhwb3J0cyk7XG5cbi8qXG4gKiBCYXNpYyBzdHJhdGVneTogZmluZCB0aGUgZmFydGhlc3QgYXBhcnQgcG9pbnRzLCB1c2UgYXMgZGlhbWV0ZXIgb2YgY2lyY2xlXG4gKiByZWFjdCB0byBzaXplIGNoYW5nZSBhbmQgcm90YXRpb24gb2YgdGhlIGNob3JkXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIHBvaW50ZXItZ2VzdHVyZXNcbiAqIEBzdWJtb2R1bGUgRXZlbnRzXG4gKiBAY2xhc3MgcGluY2hcbiAqL1xuLyoqXG4gKiBTY2FsZSBvZiB0aGUgcGluY2ggem9vbSBnZXN0dXJlXG4gKiBAcHJvcGVydHkgc2NhbGVcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIENlbnRlciBYIHBvc2l0aW9uIG9mIHBvaW50ZXJzIGNhdXNpbmcgcGluY2hcbiAqIEBwcm9wZXJ0eSBjZW50ZXJYXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuLyoqXG4gKiBDZW50ZXIgWSBwb3NpdGlvbiBvZiBwb2ludGVycyBjYXVzaW5nIHBpbmNoXG4gKiBAcHJvcGVydHkgY2VudGVyWVxuICogQHR5cGUgTnVtYmVyXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIHBvaW50ZXItZ2VzdHVyZXNcbiAqIEBzdWJtb2R1bGUgRXZlbnRzXG4gKiBAY2xhc3Mgcm90YXRlXG4gKi9cbi8qKlxuICogQW5nbGUgKGluIGRlZ3JlZXMpIG9mIHJvdGF0aW9uLiBNZWFzdXJlZCBmcm9tIHN0YXJ0aW5nIHBvc2l0aW9ucyBvZiBwb2ludGVycy5cbiAqIEBwcm9wZXJ0eSBhbmdsZVxuICogQHR5cGUgTnVtYmVyXG4gKi9cbi8qKlxuICogQ2VudGVyIFggcG9zaXRpb24gb2YgcG9pbnRlcnMgY2F1c2luZyByb3RhdGlvblxuICogQHByb3BlcnR5IGNlbnRlclhcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIENlbnRlciBZIHBvc2l0aW9uIG9mIHBvaW50ZXJzIGNhdXNpbmcgcm90YXRpb25cbiAqIEBwcm9wZXJ0eSBjZW50ZXJZXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSBzY29wZS5kaXNwYXRjaGVyO1xuICAgIHZhciBldmVudEZhY3RvcnkgPSBzY29wZS5ldmVudEZhY3Rvcnk7XG4gICAgdmFyIHBvaW50ZXJtYXAgPSBuZXcgc2NvcGUuUG9pbnRlck1hcCgpO1xuICAgIHZhciBSQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcbiAgICB2YXIgcGluY2ggPSB7XG4gICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgJ2Rvd24nLFxuICAgICAgICAgICAgJ3VwJyxcbiAgICAgICAgICAgICdtb3ZlJyxcbiAgICAgICAgICAgICdjYW5jZWwnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdwaW5jaHN0YXJ0JyxcbiAgICAgICAgICAgICdwaW5jaCcsXG4gICAgICAgICAgICAncGluY2hlbmQnLFxuICAgICAgICAgICAgJ3JvdGF0ZSdcbiAgICAgICAgXSxcbiAgICAgICAgZGVmYXVsdEFjdGlvbnM6IHtcbiAgICAgICAgICAgICdwaW5jaCc6ICdub25lJyxcbiAgICAgICAgICAgICdyb3RhdGUnOiAnbm9uZSdcbiAgICAgICAgfSxcbiAgICAgICAgcmVmZXJlbmNlOiB7fSxcbiAgICAgICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIGluRXZlbnQpO1xuICAgICAgICAgICAgaWYgKHBvaW50ZXJtYXAucG9pbnRlcnMoKSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY2FsY0Nob3JkKCk7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5jYWxjQW5nbGUocG9pbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBkaWFtZXRlcjogcG9pbnRzLmRpYW1ldGVyLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHNjb3BlLnRhcmdldEZpbmRpbmcuTENBKHBvaW50cy5hLnRhcmdldCwgcG9pbnRzLmIudGFyZ2V0KVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVQaW5jaCgncGluY2hzdGFydCcsIHBvaW50cy5kaWFtZXRlciwgcG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBwID0gcG9pbnRlcm1hcC5nZXQoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgdmFyIG51bSA9IHBvaW50ZXJtYXAucG9pbnRlcnMoKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51bSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlICdwaW5jaGVuZCcgYmVmb3JlIGRlbGV0aW5nIHBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY2FsY0Nob3JkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBpbmNoKCdwaW5jaGVuZCcsIHBvaW50cy5kaWFtZXRlciwgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5kZWxldGUoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAocG9pbnRlcm1hcC5oYXMoaW5FdmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludGVybWFwLnBvaW50ZXJzKCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY1BpbmNoUm90YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudXAoaW5FdmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpcmVQaW5jaDogZnVuY3Rpb24odHlwZSwgZGlhbWV0ZXIsIHBvaW50cykge1xuICAgICAgICAgICAgdmFyIHpvb20gPSBkaWFtZXRlciAvIHRoaXMucmVmZXJlbmNlLmRpYW1ldGVyO1xuICAgICAgICAgICAgdmFyIGUgPSBldmVudEZhY3RvcnkubWFrZUdlc3R1cmVFdmVudCh0eXBlLCB7XG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNjYWxlOiB6b29tLFxuICAgICAgICAgICAgICAgIGNlbnRlclg6IHBvaW50cy5jZW50ZXIueCxcbiAgICAgICAgICAgICAgICBjZW50ZXJZOiBwb2ludHMuY2VudGVyLnksXG4gICAgICAgICAgICAgICAgX3NvdXJjZTogJ3BpbmNoJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZS50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlyZVJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIHBvaW50cykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLnJvdW5kKChhbmdsZSAtIHRoaXMucmVmZXJlbmNlLmFuZ2xlKSAlIDM2MCk7XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlR2VzdHVyZUV2ZW50KCdyb3RhdGUnLCB7XG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBkaWZmLFxuICAgICAgICAgICAgICAgIGNlbnRlclg6IHBvaW50cy5jZW50ZXIueCxcbiAgICAgICAgICAgICAgICBjZW50ZXJZOiBwb2ludHMuY2VudGVyLnksXG4gICAgICAgICAgICAgICAgX3NvdXJjZTogJ3BpbmNoJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZS50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY1BpbmNoUm90YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmNhbGNDaG9yZCgpO1xuICAgICAgICAgICAgdmFyIGRpYW1ldGVyID0gcG9pbnRzLmRpYW1ldGVyO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5jYWxjQW5nbGUocG9pbnRzKTtcbiAgICAgICAgICAgIGlmIChkaWFtZXRlciAhPSB0aGlzLnJlZmVyZW5jZS5kaWFtZXRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBpbmNoKCdwaW5jaCcsIGRpYW1ldGVyLCBwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuZ2xlICE9IHRoaXMucmVmZXJlbmNlLmFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUm90YXRlKGFuZ2xlLCBwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxjQ2hvcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgICAgICAgICBwb2ludGVybWFwLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJzLnB1c2gocCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gMDtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHdpdGggYXQgbGVhc3QgdHdvIHBvaW50ZXJzXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0ge1xuICAgICAgICAgICAgICAgIGE6IHBvaW50ZXJzWzBdLFxuICAgICAgICAgICAgICAgIGI6IHBvaW50ZXJzWzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHgsIHksIGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBwb2ludGVyc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBwb2ludGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHBvaW50ZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5hYnMoYS5jbGllbnRYIC0gYi5jbGllbnRYKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IE1hdGguYWJzKGEuY2xpZW50WSAtIGIuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgICAgIGQgPSB4ICsgeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgPiBkaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiBhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGI6IGJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ID0gTWF0aC5hYnMocG9pbnRzLmEuY2xpZW50WCArIHBvaW50cy5iLmNsaWVudFgpIC8gMjtcbiAgICAgICAgICAgIHkgPSBNYXRoLmFicyhwb2ludHMuYS5jbGllbnRZICsgcG9pbnRzLmIuY2xpZW50WSkgLyAyO1xuICAgICAgICAgICAgcG9pbnRzLmNlbnRlciA9IHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb2ludHMuZGlhbWV0ZXIgPSBkaXN0O1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY0FuZ2xlOiBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcG9pbnRzLmEuY2xpZW50WCAtIHBvaW50cy5iLmNsaWVudFg7XG4gICAgICAgICAgICB2YXIgeSA9IHBvaW50cy5hLmNsaWVudFkgLSBwb2ludHMuYi5jbGllbnRZO1xuICAgICAgICAgICAgcmV0dXJuICgzNjAgKyBNYXRoLmF0YW4yKHksIHgpICogUkFEX1RPX0RFRykgJSAzNjA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJHZXN0dXJlKCdwaW5jaCcsIHBpbmNoKTtcbn0pKGV4cG9ydHMpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xuXG52YXIgRGF0YU5vZGVCYXNlID0gQmFzZS5leHRlbmQoJ0RhdGFOb2RlQmFzZScsIHtcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICBJTkRFTlQ6ICcgICAnLCAvLyAzIHNwYWNlc1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHRoaXMubGFiZWwgPSBrZXk7XG4gICAgICAgIHRoaXMuZGF0YSA9IFsnJ107IC8vIFRPRE86IFdoeSBpcyB0aGlzIGZpcnN0IGVsZW1lbnQgbmVlZGVkP1xuICAgICAgICB0aGlzLmluZGV4ID0gW107IC8vIFRPRE86IGZvcm1lcmx5IHJvd0luZGV4XG4gICAgICAgIHRoaXMuaGFzQ2hpbGRyZW4gPSBmYWxzZTsgLy8gVE9ETzogV2hlcmUvaG93IGlzIHRoaXMgdXNlZD9cbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3hdO1xuICAgIH0sXG5cbiAgICBwcnVuZTogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgIH0sXG5cbiAgICBjb21wdXRlRGVwdGhTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkodGhpcy5kZXB0aCArIDEpLmpvaW4odGhpcy5JTkRFTlQpICsgJyAgJyArIHRoaXMubGFiZWw7XG4gICAgfSxcblxuICAgIGNvbXB1dGVIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkgeyAvLyBUT0RPOiBmb3JtZXJseSBnZXRBbGxSb3dJbmRleGVzXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4O1xuICAgIH0sXG5cbiAgICBjb21wdXRlQWdncmVnYXRlczogZnVuY3Rpb24oYWdncmVnYXRvcikge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG5cbiAgICAgICAgaWYgKGluZGV4Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGdyb3Vwc09mZnNldCA9IE51bWJlcihhZ2dyZWdhdG9yLmhhc0dyb3VwcygpKTtcblxuICAgICAgICAgICAgLy8gcmVkaW1lbnNpb24gdGhlIGRhdGFcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgZGF0YS5sZW5ndGggPSBncm91cHNPZmZzZXQgKyBhZ2dyZWdhdG9yLmFnZ3JlZ2F0ZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgc29ydGVyID0gYWdncmVnYXRvci5zb3J0ZXJJbnN0YW5jZTtcbiAgICAgICAgICAgIHNvcnRlci5pbmRleCA9IGluZGV4O1xuXG4gICAgICAgICAgICBhZ2dyZWdhdG9yLmFnZ3JlZ2F0ZXMuZm9yRWFjaChmdW5jdGlvbihhZ2dyZWdhdGUsIGkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2dyb3Vwc09mZnNldCArIGldID0gYWdncmVnYXRlKHNvcnRlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgYWdncmVnYXRvci5hZGRWaWV3KHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b2dnbGVFeHBhbnNpb25TdGF0ZTogZnVuY3Rpb24oKSB7IC8qIGFnZ3JlZ2F0b3IgKi9cbiAgICAgICAgLy9kbyBub3RoaW5nIGJ5IGRlZmF1bHRcbiAgICB9XG5cbn0pO1xuXG4vL0RhdGFOb2RlQmFzZS5wcm90b3R5cGUuYXBwbHlBZ2dyZWdhdGVzID0gRGF0YU5vZGVCYXNlLnByb3RvdHlwZS5jb21wdXRlQWdncmVnYXRlcztcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZUJhc2U7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWFwID0gcmVxdWlyZSgnLi91dGlsL01hcHB5Jyk7XG52YXIgRGF0YU5vZGVCYXNlID0gcmVxdWlyZSgnLi9EYXRhTm9kZUJhc2UnKTtcblxudmFyIGV4cGFuZGVkTWFwID0ge1xuICAgIHRydWU6ICdcXHUyNWJlJywgLy8gJ+KWvidcbiAgICBmYWxzZTogJ1xcdTI1YjgnIC8vICfilrgnXG59O1xuXG52YXIgRGF0YU5vZGVHcm91cCA9IERhdGFOb2RlQmFzZS5leHRlbmQoJ0RhdGFOb2RlR3JvdXAnLCB7XG5cbiAgICBleHRlbmRhYmxlOiB0cnVlLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgfSxcblxuICAgIHBydW5lOiBmdW5jdGlvbihkZXB0aCkge1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnZhbHVlczsgLy8gVE9ETzogd2h5P1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBydW5lKGRlcHRoICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgIH0sXG5cbiAgICBjb21wdXRlRGVwdGhTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkodGhpcy5kZXB0aCArIDEpLmpvaW4odGhpcy5JTkRFTlQpICtcbiAgICAgICAgICAgIGV4cGFuZGVkTWFwW3RoaXMuZXhwYW5kZWRdICsgJyAnICtcbiAgICAgICAgICAgIHRoaXMubGFiZWw7XG4gICAgfSxcblxuICAgIGdldEluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5jb21wdXRlSW5kZXgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9LFxuXG4gICAgY29tcHV0ZUluZGV4OiBmdW5jdGlvbigpIHsgLy8gVE9ETzogZm9ybWVybHkgY29tcHV0ZXJBbGxSb3dJbmRleGVzXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZCA9IGFwcGVuZDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKGNoaWxkLmdldEluZGV4KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgdG9nZ2xlRXhwYW5zaW9uU3RhdGU6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHsgLyogYWdncmVnYXRvciAqL1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gIXRoaXMuZXhwYW5kZWQ7XG4gICAgICAgIHRoaXMuZGF0YVswXSA9IHRoaXMuY29tcHV0ZURlcHRoU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVBZ2dyZWdhdGVzKGFnZ3JlZ2F0b3IpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXB1dGVBZ2dyZWdhdGVzOiBmdW5jdGlvbihhZ2dyZWdhdG9yKSB7XG4gICAgICAgIERhdGFOb2RlQmFzZS5wcm90b3R5cGUuY29tcHV0ZUFnZ3JlZ2F0ZXMuY2FsbCh0aGlzLCBhZ2dyZWdhdG9yKTsgLy8gY2FsbCBiYXNlIGNsYXNzJ3MgdmVyc2lvblxuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuY29tcHV0ZUFnZ3JlZ2F0ZXMoYWdncmVnYXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgYWdncmVnYXRvci52aWV3LnB1c2godGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5idWlsZFZpZXcoYWdncmVnYXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wdXRlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IDE7XG5cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCArIGNoaWxkLmNvbXB1dGVIZWlnaHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLmhlaWdodCA9IGhlaWdodCk7XG4gICAgfVxuXG59KTtcblxuLyoqXG4gKiBAc3VtbWFyeSBBcnJheSBtaXhpbiB0byBhcHBlbmQgYW5vdGhlciBhcnJheSB0byBlbmQgb2YgYHRoaXNgIG9uZS5cbiAqIEBkZXNjIEFwcGVuZHMgaW4gcGxhY2UsIHVubGlrZSBgdGhpcy5jb25jYXQoKWAgd2hpY2ggY3JlYXRlcyBhIG5ldyBhcnJheS5cbiAqIFVzZXMgbGVzcyBtZW1vcnkgdGhhbiBjb25jYXQsIGltcG9ydGFudCB3aGVuIGBhcHBlbmRpeGAgaXMgaHVnZS5cbiAqID4gQ0FVVElPTjogTXV0YXRlcyBgdGhpc2AgYXJyYXkhXG4gKiBAcGFyYW0ge0FycmF5fSBhcHBlbmRpeFxuICogQHJldHVybnMge0FycmF5fSBSZWZlcmVuY2UgdG8gYHRoaXNgIChmb3IgY29udmVuaWVuY2UpXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZChhcHBlbmRpeCkge1xuICAgIHRoaXMuc3BsaWNlLmJpbmQodGhpcywgdGhpcy5sZW5ndGgsIDApLmFwcGx5KHRoaXMsIGFwcGVuZGl4KTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZUdyb3VwOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFOb2RlQmFzZSA9IHJlcXVpcmUoJy4vRGF0YU5vZGVCYXNlJyk7XG5cbnZhciBEYXRhTm9kZUxlYWYgPSBEYXRhTm9kZUJhc2UuZXh0ZW5kKCdEYXRhTm9kZUxlYWYnLCB7XG5cbiAgICBwcnVuZTogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgIH0sXG5cbiAgICBnZXRJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4O1xuICAgIH0sXG5cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgYWdncmVnYXRvci5hZGRWaWV3KHRoaXMpO1xuICAgIH0sXG5cbiAgICBjb21wdXRlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZUxlYWY7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YU5vZGVHcm91cCA9IHJlcXVpcmUoJy4vRGF0YU5vZGVHcm91cCcpO1xuXG52YXIgRGF0YU5vZGVUcmVlID0gRGF0YU5vZGVHcm91cC5leHRlbmQoJ0RhdGFOb2RlVHJlZScsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBwcnVuZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnZhbHVlcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5wcnVuZSgwKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oYWdncmVnYXRvcikge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLmJ1aWxkVmlldyhhZ2dyZWdhdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNvbXB1dGVIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMTtcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCArIGNoaWxkLmNvbXB1dGVIZWlnaHQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLmhlaWdodCA9IGhlaWdodCk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZVRyZWU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVhZGVyaWZ5ID0gcmVxdWlyZSgnLi91dGlsL2hlYWRlcmlmeScpO1xuXG5mdW5jdGlvbiBEYXRhU291cmNlKGRhdGEsIGZpZWxkcykge1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzIHx8IGNvbXB1dGVGaWVsZE5hbWVzKGRhdGFbMF0pO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG59XG5cbkRhdGFTb3VyY2UucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBEYXRhU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciwgLy8gcHJlc2VydmUgY29uc3RydWN0b3JcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt5XTtcbiAgICB9LFxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0Um93KHkpO1xuICAgICAgICBpZiAoIXJvdykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd1t0aGlzLmZpZWxkc1t4XV07XG4gICAgfSxcblxuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmdldFJvdyh5KVt0aGlzLmZpZWxkc1t4XV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZHMoKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIGdldEZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkcztcbiAgICB9LFxuXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSB0aGlzLmhlYWRlcnMgfHxcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVmYXVsdEhlYWRlcnMoKS5tYXAoZnVuY3Rpb24oZWFjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJpZnkoZWFjaCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkcygpO1xuICAgIH0sXG5cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICB9LFxuXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVycykge1xuICAgICAgICBpZiAoIShoZWFkZXJzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICBlcnJvcignc2V0SGVhZGVycycsICdwYXJhbSAjMSBgaGVhZGVyc2Agbm90IGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB9LFxuXG4gICAgZ2V0R3JhbmRUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL25vdGhpbmcgaGVyZVxuICAgICAgICByZXR1cm47XG4gICAgfSxcblxuICAgIHNldERhdGE6IGZ1bmN0aW9uKGFycmF5T2ZVbmlmb3JtT2JqZWN0cykge1xuICAgICAgICB0aGlzLmRhdGEgPSBhcnJheU9mVW5pZm9ybU9iamVjdHM7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZXJyb3IobWV0aG9kTmFtZSwgbWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGF0YVNvdXJjZS4nICsgbWV0aG9kTmFtZSArICc6ICcgKyBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUZpZWxkTmFtZXMob2JqZWN0KSB7XG4gICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgZmllbGRzID0gW10uY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuc3Vic3RyKDAsIDIpICE9PSAnX18nO1xuICAgIH0pKTtcbiAgICByZXR1cm4gZmllbGRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2U7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxudmFyIERhdGFTb3VyY2VTb3J0ZXIgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VTb3J0ZXInKTtcbnZhciBEYXRhTm9kZVRyZWUgPSByZXF1aXJlKCcuL0RhdGFOb2RlVHJlZScpO1xudmFyIERhdGFOb2RlR3JvdXAgPSByZXF1aXJlKCcuL0RhdGFOb2RlR3JvdXAnKTtcbnZhciBEYXRhTm9kZUxlYWYgPSByZXF1aXJlKCcuL0RhdGFOb2RlTGVhZicpO1xudmFyIGhlYWRlcmlmeSA9IHJlcXVpcmUoJy4vdXRpbC9oZWFkZXJpZnknKTtcblxuLy8/W3QsYyxiLGFdXG4vLyB0IGlzIGEgZGF0YVNvdXJjZSxcbi8vIGEgaXMgYSBkaWN0aW9uYXJ5IG9mIGFnZ3JlZ2F0ZXMsICBjb2x1bW5OYW1lOmZ1bmN0aW9uXG4vLyBiIGlzIGEgZGljdGlvbmFyeSBvZiBncm91cGJ5cywgY29sdW1uTmFtZTpzb3VyY2VDb2x1bW5OYW1lXG4vLyBjIGlzIGEgbGlzdCBvZiBjb25zdHJhaW50cyxcblxuZnVuY3Rpb24gRGF0YVNvdXJjZUFnZ3JlZ2F0b3IoZGF0YVNvdXJjZSkge1xuICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgdGhpcy50cmVlID0gbmV3IERhdGFOb2RlVHJlZSgnVG90YWxzJyk7XG4gICAgdGhpcy5pbmRleCA9IFtdO1xuICAgIHRoaXMuYWdncmVnYXRlcyA9IFtdO1xuICAgIHRoaXMuaGVhZGVycyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBCeXMgPSBbXTtcbiAgICB0aGlzLnZpZXcgPSBbXTtcbiAgICB0aGlzLnNvcnRlckluc3RhbmNlID0ge307XG4gICAgdGhpcy5wcmVzb3J0R3JvdXBzID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3RBZ2dyZWdhdGUgPSB7fTtcbiAgICB0aGlzLnNldEFnZ3JlZ2F0ZXMoe30pO1xufVxuXG5EYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciwgLy8gcHJlc2VydmUgY29uc3RydWN0b3JcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICBzZXRBZ2dyZWdhdGVzOiBmdW5jdGlvbihhZ2dyZWdhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sYXN0QWdncmVnYXRlID0gYWdncmVnYXRpb25zO1xuICAgICAgICB0aGlzLmNsZWFyQWdncmVnYXRpb25zKCk7XG4gICAgICAgIHRoaXMuaGVhZGVycy5sZW5ndGggPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0dyb3VwcygpKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMucHVzaCgnVHJlZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBfKGFnZ3JlZ2F0aW9ucykuZWFjaChmdW5jdGlvbihhZ2dyZWdhdGlvbiwga2V5KSB7XG4gICAgICAgICAgICBzZWxmLmFkZEFnZ3JlZ2F0ZShrZXksIGFnZ3JlZ2F0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFkZEFnZ3JlZ2F0ZTogZnVuY3Rpb24obGFiZWwsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnB1c2goaGVhZGVyaWZ5KGxhYmVsKSk7XG4gICAgICAgIHRoaXMuYWdncmVnYXRlcy5wdXNoKGZ1bmMpO1xuICAgIH0sXG5cbiAgICBzZXRHcm91cEJ5czogZnVuY3Rpb24oY29sdW1uSW5kZXhBcnJheSkge1xuICAgICAgICB2YXIgZ3JvdXBCeXMgPSB0aGlzLmdyb3VwQnlzO1xuICAgICAgICBncm91cEJ5cy5sZW5ndGggPSAwO1xuICAgICAgICBjb2x1bW5JbmRleEFycmF5LmZvckVhY2goZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgIGdyb3VwQnlzLnB1c2goY29sdW1uSW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRBZ2dyZWdhdGVzKHRoaXMubGFzdEFnZ3JlZ2F0ZSk7XG4gICAgfSxcblxuICAgIGFkZEdyb3VwQnk6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHRoaXMuZ3JvdXBCeXMucHVzaChpbmRleCk7XG4gICAgfSxcblxuICAgIGhhc0dyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ3JvdXBCeXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBoYXNBZ2dyZWdhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5hZ2dyZWdhdGVzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgYXBwbHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1aWxkR3JvdXBUcmVlKCk7XG4gICAgfSxcblxuICAgIGNsZWFyR3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ncm91cEJ5cy5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICBjbGVhckFnZ3JlZ2F0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYWdncmVnYXRlcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmhlYWRlcnMubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgYnVpbGRHcm91cFRyZWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JvdXBCeXMgPSB0aGlzLmdyb3VwQnlzLFxuICAgICAgICAgICAgbGVhZkRlcHRoID0gZ3JvdXBCeXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZSxcbiAgICAgICAgICAgIHJvd0NvdW50ID0gc291cmNlLmdldFJvd0NvdW50KCksXG4gICAgICAgICAgICB0cmVlID0gdGhpcy50cmVlID0gbmV3IERhdGFOb2RlVHJlZSgnVG90YWxzJyk7XG5cbiAgICAgICAgLy8gZmlyc3Qgc29ydCBkYXRhXG4gICAgICAgIGlmICh0aGlzLnByZXNvcnRHcm91cHMpIHtcbiAgICAgICAgICAgIGdyb3VwQnlzLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwQnkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBuZXcgRGF0YVNvdXJjZVNvcnRlcihzb3VyY2UpO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5zb3J0T24oZ3JvdXBCeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0cmVlO1xuXG4gICAgICAgICAgICBncm91cEJ5cy5mb3JFYWNoKGZ1bmN0aW9uKGcsIGMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gc291cmNlLmdldFZhbHVlKGcsIHIpLFxuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbE5vZGUgPSAoYyA9PT0gbGVhZkRlcHRoKSxcbiAgICAgICAgICAgICAgICAgICAgQ29uc3RydWN0b3IgPSB0ZXJtaW5hbE5vZGUgPyBEYXRhTm9kZUxlYWYgOiBEYXRhTm9kZUdyb3VwLFxuICAgICAgICAgICAgICAgICAgICBpZkFic2VudEZ1bmMgPSBjcmVhdGVOb2RlLmJpbmQodGhpcywgQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLmNoaWxkcmVuLmdldElmQWJzZW50KGtleSwgaWZBYnNlbnRGdW5jKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwYXRoLmluZGV4LnB1c2gocik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNvcnRlckluc3RhbmNlID0gbmV3IERhdGFTb3VyY2VTb3J0ZXIoc291cmNlKTtcbiAgICAgICAgdHJlZS5wcnVuZSgpO1xuICAgICAgICB0cmVlLmNvbXB1dGVBZ2dyZWdhdGVzKHRoaXMpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlldygpO1xuICAgIH0sXG5cbiAgICBhZGRWaWV3OiBmdW5jdGlvbihkYXRhTm9kZSkge1xuICAgICAgICB0aGlzLnZpZXcucHVzaChkYXRhTm9kZSk7XG4gICAgfSxcblxuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnRyZWUuY29tcHV0ZUhlaWdodCgpO1xuICAgICAgICB0aGlzLnRyZWUuYnVpbGRWaWV3KHRoaXMpO1xuICAgIH0sXG5cbiAgICB2aWV3TWFrZXNTZW5zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKTtcbiAgICB9LFxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0VmFsdWUoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvdyA9IHRoaXMudmlld1t5XTtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3cuZ2V0VmFsdWUoeCk7IC8vIFRPRE86IHdoYXQga2luZCBvZiBvYmplY3QgaXMgcm93Li4uID8gc2hvdWxkIGl0IGJlIHVuZmlsdHJlZD9cbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNldFZhbHVlKHgsIHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVhZGVycygpLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcubGVuZ3RoOyAvL2hlYWRlciBjb2x1bW5cbiAgICB9LFxuXG4gICAgY2xpY2s6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy52aWV3W3ldO1xuICAgICAgICBncm91cC50b2dnbGVFeHBhbnNpb25TdGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXcoKTtcbiAgICB9LFxuXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEhlYWRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzOyAvLyBUT0RPOiBWaWV3cyBvdmVycmlkZSBkYXRhU291cmNlIGhlYWRlcnMgd2l0aCB0aGVpciBvd24gaGVhZGVycz9cbiAgICB9LFxuXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVycykge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc2V0SGVhZGVycyhoZWFkZXJzKTtcbiAgICB9LFxuXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRGaWVsZHMoKTtcbiAgICB9LFxuXG4gICAgc2V0RmllbGRzOiBmdW5jdGlvbihmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXRGaWVsZHMoZmllbGRzKTtcbiAgICB9LFxuXG4gICAgZ2V0R3JhbmRUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmlldyA9IHRoaXMudHJlZTtcbiAgICAgICAgcmV0dXJuIFt2aWV3LmRhdGFdO1xuICAgIH0sXG5cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93KHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvbGx1cHMgPSB0aGlzLnZpZXdbeV07XG5cbiAgICAgICAgcmV0dXJuIHJvbGx1cHMgPyByb2xsdXBzIDogdGhpcy50cmVlO1xuICAgIH0sXG5cbiAgICBzZXREYXRhOiBmdW5jdGlvbihhcnJheU9mVW5pZm9ybU9iamVjdHMpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNldERhdGEoYXJyYXlPZlVuaWZvcm1PYmplY3RzKTtcbiAgICAgICAgdGhpcy5hcHBseSgpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUoRGF0YU5vZGVDb25zdHJ1Y3Rvciwga2V5LCBtYXApIHtcbiAgICB2YXIgdmFsdWUgPSBuZXcgRGF0YU5vZGVDb25zdHJ1Y3RvcihrZXkpO1xuICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VBZ2dyZWdhdG9yOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFTb3VyY2VJbmRleGVkID0gcmVxdWlyZSgnLi9EYXRhU291cmNlSW5kZXhlZCcpO1xuXG52YXIgRGF0YVNvdXJjZUZpbHRlciA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZUZpbHRlcicsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICB9LFxuXG4gICAgYWRkOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgZmlsdGVyKSB7XG4gICAgICAgIGZpbHRlci5jb2x1bW5JbmRleCA9IGNvbHVtbkluZGV4O1xuICAgICAgICB0aGlzLmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgIH0sXG5cbiAgICBjbGVhckFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmNsZWFySW5kZXgoKTtcbiAgICB9LFxuXG4gICAgYXBwbHlBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJJbmRleCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWlsZEluZGV4KGFwcGx5RmlsdGVycyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzLmxlbmd0aCA/IHRoaXMuaW5kZXgubGVuZ3RoIDogdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIGFsaWFzZXM6IHtcbiAgICAgICAgc2V0OiAnYWRkJ1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBhcHBseUZpbHRlcnMociwgcm93T2JqZWN0KSB7IC8vIGNhbGxlZCBpbiBjb250ZXh0IGZyb20gLmJ1aWxkSW5kZXgoKVxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgICAgICAvLyBkb3VibGUgbmVnYXRpdmUgaGVyZSBtZWFucyBcIm5vIGZpbHRlciBmYWlsc1wiIChpLmUuLCByb3cgcGFzc2VzIGFsbCBmaWx0ZXJzKVxuICAgICAgICByZXR1cm4gIXRoaXMuZmlsdGVycy5maW5kKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuICFmaWx0ZXIoc2VsZi5kYXRhU291cmNlLmdldFZhbHVlKGZpbHRlci5jb2x1bW5JbmRleCwgciksIHJvd09iamVjdCwgcik7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnMucmVkdWNlKGZ1bmN0aW9uKGlzRmlsdGVyZWQsIGZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmlsdGVyZWQgJiYgZmlsdGVyKHNlbGYuZGF0YVNvdXJjZS5nZXRWYWx1ZShmaWx0ZXIuY29sdW1uSW5kZXgsIHIpLCByb3dPYmplY3QsIHIpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZUZpbHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFTb3VyY2VJbmRleGVkID0gcmVxdWlyZSgnLi9EYXRhU291cmNlSW5kZXhlZCcpO1xuXG52YXIgRGF0YVNvdXJjZUdsb2JhbEZpbHRlciA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZUdsb2JhbEZpbHRlcicsIHtcblxuICAgIHNldDogZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcjtcbiAgICAgICAgdGhpcy5jbGVhckluZGV4KCk7XG4gICAgfSxcblxuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlcikge1xuICAgICAgICAgICAgdGhpcy5jbGVhckluZGV4KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkSW5kZXgoYXBwbHlGaWx0ZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyID8gdGhpcy5pbmRleC5sZW5ndGggOiB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93Q291bnQoKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gYXBwbHlGaWx0ZXIociwgcm93T2JqZWN0KSB7IC8vIGNhbGxlZCBpbiBjb250ZXh0IGZyb20gLmJ1aWxkSW5kZXgoKVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5nZXRGaWVsZHMoKS5maW5kKGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHZhciBjZWxsVmFsdWUgPSBzZWxmLmRhdGFTb3VyY2UuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIHIpO1xuICAgICAgICByZXR1cm4gc2VsZi5maWx0ZXIoY2VsbFZhbHVlLCByb3dPYmplY3QsIHIpO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VHbG9iYWxGaWx0ZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2V4dGVuZC1tZScpLkJhc2U7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IEJhc2UuZXh0ZW5kKCdEYXRhU291cmNlSW5kZXhlZCcsIHtcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICB9LFxuXG4gICAgdHJhbnNwb3NlWTogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleC5sZW5ndGggPyB0aGlzLmluZGV4W3ldIDogeTtcbiAgICB9LFxuXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93KHRoaXMudHJhbnNwb3NlWSh5KSk7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0VmFsdWUoeCwgdGhpcy50cmFuc3Bvc2VZKHkpKTtcbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXRWYWx1ZSh4LCB0aGlzLnRyYW5zcG9zZVkoeSksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleC5sZW5ndGggfHwgdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEZpZWxkcygpO1xuICAgIH0sXG5cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNldEZpZWxkcyhmaWVsZHMpO1xuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0RmllbGRzKCk7XG4gICAgfSxcblxuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXRIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH0sXG5cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRIZWFkZXJzKCk7XG4gICAgfSxcblxuICAgIGdldEdyYW5kVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRHcmFuZFRvdGFscygpO1xuICAgIH0sXG5cbiAgICBzZXREYXRhOiBmdW5jdGlvbihhcnJheU9mVW5pZm9ybU9iamVjdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXREYXRhKGFycmF5T2ZVbmlmb3JtT2JqZWN0cyk7XG4gICAgfSxcblxuICAgIGNsZWFySW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmluZGV4Lmxlbmd0aCA9IDA7XG4gICAgfSxcblxuICAgIGJ1aWxkSW5kZXg6IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgcm93Q291bnQgPSB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcblxuICAgICAgICBpbmRleC5sZW5ndGggPSAwO1xuXG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlLmNhbGwodGhpcywgciwgdGhpcy5kYXRhU291cmNlLmdldFJvdyhyKSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleC5wdXNoKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZUluZGV4ZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcbnZhciBzdGFibGVTb3J0ID0gcmVxdWlyZSgnLi91dGlsL3N0YWJsZVNvcnQnKTtcblxudmFyIERhdGFTb3VyY2VTb3J0ZXIgPSBEYXRhU291cmNlSW5kZXhlZC5leHRlbmQoJ0RhdGFTb3VyY2VTb3J0ZXInLCB7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGVzY2VuZGluZ1NvcnQgPSBmYWxzZTsgLy8gVE9ETzogdGhpcyBkb2VzIG5vdCBzZWVtIHRvIGJlIGluIHVzZVxuICAgIH0sXG5cbiAgICBzb3J0T246IGZ1bmN0aW9uKGNvbElkeCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckluZGV4KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIGZvciB1c2UgaW4gZ2V0VmFsdWVcbiAgICAgICAgICAgICAgICBzdGFibGVTb3J0LnNvcnQodGhpcy5idWlsZEluZGV4KCksIGdldFZhbHVlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUocm93SWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsT3JGdW5jQ2FsbChzZWxmLmRhdGFTb3VyY2UuZ2V0VmFsdWUoY29sSWR4LCByb3dJZHgpKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiB2YWxPckZ1bmNDYWxsKHZhbE9yRnVuYykge1xuICAgIHJldHVybiB0eXBlb2YgdmFsT3JGdW5jID09PSAnZnVuY3Rpb24nID8gdmFsT3JGdW5jKCkgOiB2YWxPckZ1bmM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZVNvcnRlcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcbnZhciBEYXRhU291cmNlU29ydGVyID0gcmVxdWlyZSgnLi9EYXRhU291cmNlU29ydGVyJyk7XG5cbnZhciBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlID0gRGF0YVNvdXJjZUluZGV4ZWQuZXh0ZW5kKCdEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlJywge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNvcnRzID0gW107XG4gICAgICAgIHRoaXMubGFzdCA9IHRoaXMuZGF0YVNvdXJjZTtcbiAgICB9LFxuXG4gICAgLy8gQ2F2ZWF0cyByZWdhcmRpbmcgdGhpcy5zb3J0czpcbiAgICAvLyAxLiBDb2x1bW5zIHNob3VsZCBiZSB1bmlxdWVseSByZXByZXNlbnRlZCAoaS5lLiwgbm8gcmVwZWF0cyB3aXRoIHNhbWUgY29sdW1uSW5kZXgpXG4gICAgLy8gMi4gQ29sdW1ucyBzaG91bGQgYmUgYWRkZWQgbG93LSB0byBoaWdoLW9yZGVyIChpLmUuLCBtb3N0IGdyb3VwZWQgY29sdW1ucyBjb21lIGxhc3QpXG4gICAgc29ydE9uOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuc29ydHMucHVzaChbY29sdW1uSW5kZXgsIGRpcmVjdGlvbl0pO1xuICAgIH0sXG5cbiAgICBhcHBseVNvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVhY2ggPSB0aGlzLmRhdGFTb3VyY2U7XG5cbiAgICAgICAgdGhpcy5zb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHNvcnQpIHtcbiAgICAgICAgICAgIGVhY2ggPSBuZXcgRGF0YVNvdXJjZVNvcnRlcihlYWNoKTtcbiAgICAgICAgICAgIGVhY2guc29ydE9uLmFwcGx5KGVhY2gsIHNvcnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmxhc3QgPSBlYWNoO1xuICAgIH0sXG5cbiAgICBjbGVhclNvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zb3J0cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxhc3QgPSB0aGlzLmRhdGFTb3VyY2U7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3QuZ2V0VmFsdWUoeCwgeSk7XG4gICAgfSxcblxuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmxhc3Quc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBKU0RhdGFTb3VyY2U6IHJlcXVpcmUoJy4vRGF0YVNvdXJjZScpLFxuICAgIERhdGFTb3VyY2VTb3J0ZXI6IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlcicpLFxuICAgIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGU6IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZScpLFxuICAgIERhdGFTb3VyY2VGaWx0ZXI6IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUZpbHRlcicpLFxuICAgIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXI6IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUdsb2JhbEZpbHRlcicpLFxuICAgIERhdGFTb3VyY2VBZ2dyZWdhdG9yOiByZXF1aXJlKCcuL0RhdGFTb3VyY2VBZ2dyZWdhdG9yJyksXG4gICAgdXRpbDoge1xuICAgICAgICBhZ2dyZWdhdGlvbnM6IHJlcXVpcmUoJy4vdXRpbC9hZ2dyZWdhdGlvbnMnKVxuICAgIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBNYXBweSgpIHtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xufVxuXG5NYXBweS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogTWFwcHkucHJvdG90eXBlLmNvbnN0cnVjdG9yLCAvLyBwcmVzZXJ2ZSBjb25zdHJ1Y3RvclxuXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBoYXNoQ29kZSA9IGhhc2goa2V5KTtcbiAgICAgICAgaWYgKCEoaGFzaENvZGUgaW4gdGhpcy5kYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YVtoYXNoQ29kZV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGhhc2hDb2RlID0gaGFzaChrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2hhc2hDb2RlXTtcbiAgICB9LFxuXG4gICAgZ2V0SWZBYnNlbnQ6IGZ1bmN0aW9uKGtleSwgaWZBYnNlbnRGdW5jKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGlmQWJzZW50RnVuYyhrZXksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMua2V5cy5sZW5ndGggPSAwO1xuICAgICAgICAvLyBUT0RPOiBJcyB0aGVyZSBhIHJlYXNvbiB3aHkgdGhpcy52YWx1ZXMgaXMgbm90IGJlaW5nIHRydW5jYXRlZCBoZXJlIGFzIHdlbGw/XG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIH0sXG5cbiAgICBkZWxldGU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgaGFzaENvZGUgPSBoYXNoKGtleSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFbaGFzaENvZGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGJldHRlckluZGV4T2YodGhpcy5rZXlzLCBrZXkpO1xuICAgICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtoYXNoQ29kZV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cyxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChrZXkpO1xuICAgICAgICAgICAgZnVuYyh2YWx1ZSwga2V5LCBzZWxmKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG1hcDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cyxcbiAgICAgICAgICAgIG5ld01hcCA9IG5ldyBNYXBweSgpLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlbGYuZ2V0KGtleSksXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWQgPSBmdW5jKHZhbHVlLCBrZXksIHNlbGYpO1xuICAgICAgICAgICAgbmV3TWFwLnNldChrZXksIHRyYW5zZm9ybWVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdNYXA7XG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cyxcbiAgICAgICAgICAgIG5ld01hcCA9IG5ldyBNYXBweSgpLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlbGYuZ2V0KGtleSk7XG4gICAgICAgICAgICBuZXdNYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld01hcDtcbiAgICB9XG5cbn07XG5cbnZhciBPSURfUFJFRklYID0gJy5+LiMlXyc7IC8vdGhpcyBzaG91bGQgYmUgc29tZXRoaW5nIHdlIG5ldmVyIHdpbGwgc2VlIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBzdHJpbmdcbnZhciBjb3VudGVyID0gMDtcblxuZnVuY3Rpb24gaGFzaChrZXkpIHtcbiAgICB2YXIgdHlwZU9mID0gdHlwZW9mIGtleTtcblxuICAgIHN3aXRjaCAodHlwZU9mKSB7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgcmV0dXJuIE9JRF9QUkVGSVggKyB0eXBlT2YgKyAnXycgKyBrZXk7XG5cbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgIHJldHVybiBPSURfUFJFRklYICsgJ3VuZGVmaW5lZCc7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgYWJvdXQgaGFuZGxpbmcgbnVsbCAoc3BlY2lhbCBjYXNlIG9mIG9iamVjdCk/XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiAoa2V5Ll9fX2Zpbmhhc2ggPSBrZXkuX19fZmluaGFzaCB8fCBPSURfUFJFRklYICsgY291bnRlcisrKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH1cbn1cblxuLy8gT2JqZWN0LmlzIHBvbHlmaWxsLCBjb3VydGVzeSBvZiBAV2ViUmVmbGVjdGlvblxudmFyIGlzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiA/IGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGIgOiBhICE9IGEgJiYgYiAhPSBiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59O1xuXG4vLyBNb3JlIHJlbGlhYmxlIGluZGV4T2YsIGNvdXJ0ZXN5IG9mIEBXZWJSZWZsZWN0aW9uXG5mdW5jdGlvbiBiZXR0ZXJJbmRleE9mKGFyciwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IDApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aDsgaS0tICYmICFpcyhhcnJbaV0sIHZhbHVlKTspIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IFtdLmluZGV4T2YuY2FsbChhcnIsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwcHk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjb3VudChncm91cCkge1xuICAgIHJldHVybiBncm91cC5nZXRSb3dDb3VudCgpO1xufVxuXG5mdW5jdGlvbiBzdW0oY29sdW1uSW5kZXgsIGdyb3VwKSB7XG4gICAgdmFyIHIgPSBncm91cC5nZXRSb3dDb3VudCgpLFxuICAgICAgICBuID0gMDtcblxuICAgIHdoaWxlIChyLS0pIHtcbiAgICAgICAgbiArPSBncm91cC5nZXRWYWx1ZShjb2x1bW5JbmRleCwgcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIG1pbm1heChjb2x1bW5JbmRleCwgbWV0aG9kLCBuLCBncm91cCkge1xuICAgIHZhciByID0gZ3JvdXAuZ2V0Um93Q291bnQoKTtcblxuICAgIHdoaWxlIChyLS0pIHtcbiAgICAgICAgbiA9IG1ldGhvZChuLCBncm91cC5nZXRWYWx1ZShjb2x1bW5JbmRleCwgcikpO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBhdmcoY29sdW1uSW5kZXgsIGdyb3VwKSB7XG4gICAgcmV0dXJuIHN1bShjb2x1bW5JbmRleCwgZ3JvdXApIC8gZ3JvdXAuZ2V0Um93Q291bnQoKTtcbn1cblxuZnVuY3Rpb24gZmlyc3QoY29sdW1uSW5kZXgsIGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLmdldFZhbHVlKGNvbHVtbkluZGV4LCAwKTtcbn1cblxuZnVuY3Rpb24gbGFzdChjb2x1bW5JbmRleCwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIGdyb3VwLmdldFJvd0NvdW50KCkgLSAxKTtcbn1cblxuZnVuY3Rpb24gc3RkZGV2KGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHZhciByb3dzID0gZ3JvdXAuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgbWVhbiA9IGF2Zyhjb2x1bW5JbmRleCwgZ3JvdXApO1xuXG4gICAgZm9yICh2YXIgZGV2LCByID0gcm93cywgdmFyaWFuY2UgPSAwOyByLS07IHZhcmlhbmNlICs9IGRldiAqIGRldikge1xuICAgICAgICBkZXYgPSBncm91cC5nZXRWYWx1ZShjb2x1bW5JbmRleCwgcikgLSBtZWFuO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLnNxcnQodmFyaWFuY2UgLyByb3dzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY291bnQ6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuICAgIHN1bTogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHN1bS5iaW5kKHRoaXMsIGNvbHVtbkluZGV4KTtcbiAgICB9LFxuICAgIG1pbjogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1pbm1heC5iaW5kKHRoaXMsIGNvbHVtbkluZGV4LCBNYXRoLm1pbiwgSW5maW5pdHkpO1xuICAgIH0sXG4gICAgbWF4OiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gbWlubWF4LmJpbmQodGhpcywgY29sdW1uSW5kZXgsIE1hdGgubWF4LCAtSW5maW5pdHkpO1xuICAgIH0sXG4gICAgYXZnOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gYXZnLmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH0sXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBmaXJzdC5iaW5kKHRoaXMsIGNvbHVtbkluZGV4KTtcbiAgICB9LFxuICAgIGxhc3Q6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBsYXN0LmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH0sXG4gICAgc3RkZGV2OiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gc3RkZGV2LmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBoZWFkZXJpZnkoc3RyaW5nKSB7XG4gICAgcmV0dXJuICgvW2Etel0vLnRlc3Qoc3RyaW5nKSA/IHN0cmluZyA6IHN0cmluZy50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAucmVwbGFjZSgvW1xcc1xcLV9dKihbXlxcc1xcLV9dKShbXlxcc1xcLV9dKykvZywgcmVwbGFjZXIpXG4gICAgICAgIC5yZXBsYWNlKC9bQS1aXS9nLCAnICQmJylcbiAgICAgICAgLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZXIoYSwgYiwgYykge1xuICAgIHJldHVybiBiLnRvVXBwZXJDYXNlKCkgKyBjO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhlYWRlcmlmeTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHN0YWJpbGl6ZShjb21wYXJhdG9yLCBkZXNjZW5kaW5nLCBhcnIxLCBhcnIyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2hhZG93XG4gICAgdmFyIHggPSBhcnIxWzBdO1xuICAgIHZhciB5ID0gYXJyMlswXTtcblxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHggPSBkZXNjZW5kaW5nID8gYXJyMlsxXSA6IGFycjFbMV07XG4gICAgICAgIHkgPSBkZXNjZW5kaW5nID8gYXJyMVsxXSA6IGFycjJbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGFyYXRvcih4LCB5KTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nTnVtYmVycyh4LCB5KSB7XG4gICAgcmV0dXJuIHggLSB5O1xufVxuXG5mdW5jdGlvbiBkZXNjZW5kaW5nTnVtYmVycyh4LCB5KSB7XG4gICAgcmV0dXJuIHkgLSB4O1xufVxuXG5mdW5jdGlvbiBhc2NlbmRpbmdBbGxPdGhlcnMoeCwgeSkge1xuICAgIHJldHVybiB4IDwgeSA/IC0xIDogMTtcbn1cblxuZnVuY3Rpb24gZGVzY2VuZGluZ0FsbE90aGVycyh4LCB5KSB7XG4gICAgcmV0dXJuIHkgPCB4ID8gLTEgOiAxO1xufVxuXG5mdW5jdGlvbiBhc2NlbmRpbmcodHlwZU9mRGF0YSkge1xuICAgIHJldHVybiBzdGFiaWxpemUuYmluZCh0aGlzLCB0eXBlT2ZEYXRhID09PSAnbnVtYmVyJyA/IGFzY2VuZGluZ051bWJlcnMgOiBhc2NlbmRpbmdBbGxPdGhlcnMsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZGVzY2VuZGluZyh0eXBlT2ZEYXRhKSB7XG4gICAgcmV0dXJuIHN0YWJpbGl6ZS5iaW5kKHRoaXMsIHR5cGVPZkRhdGEgPT09ICdudW1iZXInID8gZGVzY2VuZGluZ051bWJlcnMgOiBkZXNjZW5kaW5nQWxsT3RoZXJzLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gc29ydChpbmRleCwgZ2V0VmFsdWUsIGRpcmVjdGlvbikge1xuXG4gICAgdmFyIGNvbXBhcmUsIGk7XG5cbiAgICAvLyBhcHBseSBkZWZhdWx0c1xuICAgIGlmIChkaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXJlY3Rpb24gPSAxO1xuICAgIH1cblxuICAgIGlmIChpbmRleC5sZW5ndGgpIHsgLy8gc29tZXRoaW5nIHRvIGRvXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBiYWlsOiBub3RoaW5nIHRvIHNvcnRcblxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNvbXBhcmUgPSBhc2NlbmRpbmcodHlwZW9mIGdldFZhbHVlKDApKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICBjb21wYXJlID0gZGVzY2VuZGluZyh0eXBlb2YgZ2V0VmFsdWUoMCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBzb3J0Li4uLi5cbiAgICAgICAgdmFyIHRtcCA9IG5ldyBBcnJheShpbmRleC5sZW5ndGgpO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgaW5kZXggZm9yIFwic3RhYmlsaXR5XCJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0bXBbaV0gPSBbZ2V0VmFsdWUoaSksIGldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gdGhlIGFjdHVhbCBzb3J0XG4gICAgICAgIHRtcC5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIC8vIGNvcHkgdGhlIHNvcnRlZCB2YWx1ZXMgaW50byBvdXIgaW5kZXggdmVjdG9yXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5kZXhbaV0gPSB0bXBbaV1bMV07XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0cy5zb3J0ID0gc29ydDsiLCIvLyBsaXN0LWRyYWdvbiBub2RlIG1vZHVsZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5maW4vbGlzdC1kcmFnb25cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuKGZ1bmN0aW9uIChtb2R1bGUpIHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgICAvLyBUaGlzIGNsb3N1cmUgc3VwcG9ydHMgTm9kZUpTLWxlc3MgY2xpZW50IHNpZGUgaW5jbHVkZXMgd2l0aCA8c2NyaXB0PiB0YWdzLiBTZWUgbm90ZXMgYXQgYm90dG9tIG9mIHRoaXMgZmlsZS5cblxuICAgIHZhciBmb3JtYXQgPSB3aW5kb3cudGVtcGxleCB8fCByZXF1aXJlKCd0ZW1wbGV4Jyk7XG5cbiAgICB2YXIgUkVWRVJUX1RPX1NUWUxFU0hFRVRfVkFMVUUgPSBudWxsOyAgLy8gbnVsbCByZW1vdmVzIHRoZSBzdHlsZVxuXG4gICAgdmFyIGJvZHksIHRyYW5zZm9ybSwgdGltZXIsIHNjcm9sbFZlbG9jaXR5O1xuXG4gICAgLyogaW5qZWN0OmNzcyAqL1xuICAgIChmdW5jdGlvbigpe3ZhciBhPVwiZGl2LmRyYWdvbi1saXN0e3Bvc2l0aW9uOnJlbGF0aXZlO2JhY2tncm91bmQtY29sb3I6I2ZmZn1kaXYuZHJhZ29uLWxpc3Q+ZGl2LGRpdi5kcmFnb24tbGlzdD51bHtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7cmlnaHQ6MH1kaXYuZHJhZ29uLWxpc3Q+ZGl2e3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6IzAwNzk2Yjtjb2xvcjojZmZmO2JveC1zaGFkb3c6MCAzcHggNnB4IHJnYmEoMCwwLDAsLjE2KSwwIDNweCA2cHggcmdiYSgwLDAsMCwuMjMpO292ZXJmbG93OmhpZGRlbjt3aGl0ZS1zcGFjZTpub3dyYXB9ZGl2LmRyYWdvbi1saXN0PnVse292ZXJmbG93LXk6YXV0bztib3R0b206MDttYXJnaW46MDtwYWRkaW5nOjA7Ym94LXNoYWRvdzowIDFweCAzcHggcmdiYSgwLDAsMCwuMTIpLDAgMXB4IDJweCByZ2JhKDAsMCwwLC4yNCl9ZGl2LmRyYWdvbi1saXN0PnVsPmxpLGxpLmRyYWdvbi1wb3B7d2hpdGUtc3BhY2U6bm93cmFwO2xpc3Qtc3R5bGUtdHlwZTpub25lO2JvcmRlcjowIHNvbGlkICNmNGY0ZjQ7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2UwZTBlMDtjdXJzb3I6bW92ZTt0cmFuc2l0aW9uOmJvcmRlci10b3Atd2lkdGggLjJzfWRpdi5kcmFnb24tbGlzdD51bD5saTpsYXN0LWNoaWxke2hlaWdodDowO2JvcmRlci1ib3R0b206bm9uZX1saS5kcmFnb24tcG9we3Bvc2l0aW9uOmZpeGVkO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNlMGUwZTA7bGVmdDowO3RvcDowO292ZXJmbG93LXg6aGlkZGVuO2JveC1zaGFkb3c6cmdiYSgwLDAsMCwuMTg4MjM1KSAwIDEwcHggMjBweCxyZ2JhKDAsMCwwLC4yMjc0NTEpIDAgNnB4IDZweH1cIixiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSxoZWFkPWRvY3VtZW50LmhlYWR8fGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtiLnR5cGU9XCJ0ZXh0L2Nzc1wiO2lmKGIuc3R5bGVTaGVldCliLnN0eWxlU2hlZXQuY3NzVGV4dD1hO2Vsc2UgYi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKSk7aGVhZC5pbnNlcnRCZWZvcmUoYixoZWFkLmZpcnN0Q2hpbGQpfSkoKTtcbiAgICAvKiBlbmRpbmplY3QgKi9cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvciBMaXN0RHJhZ29uXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIG9iamVjdCBzZXJ2aWNlcyBhIHNldCBvZiBpdGVtIGxpc3RzIHRoYXQgYWxsb3cgZHJhZ2dpbmcgYW5kIGRyb3BwaW5nIGl0ZW1zIHdpdGhpbiBhbmQgYmV0d2VlbiBsaXN0cyBpbiBhIHNldC5cbiAgICAgKlxuICAgICAqIFR3byBzdHJhdGVnaWVzIGFyZSBzdXBwb3J0ZWQ6XG4gICAgICpcbiAgICAgKiAxLiBTdXBwbHkgeW91ciBvd24gSFRNTCBtYXJrdXAgYW5kIGxldCB0aGUgQVBJIGJ1aWxkIHRoZSBpdGVtIG1vZGVscyBmb3IgeW91LlxuICAgICAqICAgIFRvIHVzZSB0aGlzIHN0cmF0ZWd5LCBzY3JpcHQgeW91ciBIVE1MIGFuZCBwcm92aWRlIG9uZSBvZiB0aGVzZTpcbiAgICAgKiAgICAqIGFuIGFycmF5IG9mIGFsbCB0aGUgbGlzdCBpdGVtIChgPGxpPmApIHRhZ3NcbiAgICAgKiAgICAqIGEgQ1NTIHNlbGVjdG9yIHRoYXQgcG9pbnRzIHRvIGFsbCB0aGUgbGlzdCBpdGVtIHRhZ3NcbiAgICAgKiAyLiBTdXBwbHkgeW91ciBvd24gaXRlbSBtb2RlbHMgYW5kIGxldCB0aGUgQVBJIGJ1aWxkIHRoZSBIVE1MIG1hcmt1cCBmb3IgeW91LlxuICAgICAqICAgIFRvIHVzZSB0aGlzIHN0cmF0ZWd5LCBwcm92aWRlIGFuIGFycmF5IG9mIG1vZGVsIGxpc3RzLlxuICAgICAqXG4gICAgICogVGhlIG5ldyBMaXN0RHJhZ29uIG9iamVjdCdzIGBtb2RlbExpc3RzYCBwcm9wZXJ0eSByZWZlcmVuY2VzIHRoZSBhcnJheSBvZiBtb2RlbCBsaXN0cyB0aGUgQVBJIGNvbnN0cnVjdGVkIGZvciB5b3UgaW4gc3RyYXRlZ3kgIzEgb3IgdGhlIGFycmF5IG9mIG1vZGVsIGxpc3RzIHlvdSBzdXBwbGllZCBmb3Igc3RyYXRlZ3kgIzIuXG4gICAgICpcbiAgICAgKiBBZnRlciB0aGUgdXNlciBwZXJmb3JtcyBhIHN1Y2Nlc3NmdWwgZHJhZy1hbmQtZHJvcCBvcGVyYXRpb24sIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW9kZWwgcmVmZXJlbmNlcyB3aXRoaW4gdGhlIGBtb2RlbExpc3RzYCBhcnJheSBpcyByZWFycmFuZ2VkLiAoVGhlIG1vZGVscyB0aGVtc2VsdmVzIGFyZSB0aGUgb3JpZ2luYWwgb2JqZWN0cyBhcyBzdXBwbGllZCBpbiB0aGUgbW9kZWwgbGlzdHM7IHRoZXkgYXJlIG5vdCByZWJ1aWx0IG9yIGFsdGVyZWQgaW4gYW55IHdheS4gSnVzdCB0aGUgcmVmZXJlbmNlcyB0byB0aGVtIGFyZSBtb3ZlZCBhcm91bmQuKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudFtdfG1vZGVsTGlzdFR5cGVbXX0gc2VsZWN0b3JPck1vZGVsTGlzdHMgLSBZb3UgbXVzdCBzdXBwbHkgb25lIG9mIHRoZSBpdGVtcyBpbiAqKmJvbGQqKiBiZWxvdzpcbiAgICAgKlxuICAgICAqIDEuIF9Gb3Igc3RyYXRlZ3kgIzEgYWJvdmUgKEFQSSBjcmVhdGVzIG1vZGVscyBmcm9tIHN1cHBsaWVkIGVsZW1lbnRzKTpfIEFsbCB0aGUgbGlzdCBpdGVtIChgPGxpPmApIERPTSBlbGVtZW50cyBvZiBhbGwgdGhlIGxpc3RzIHlvdSB3YW50IHRoZSBuZXcgb2JqZWN0IHRvIG1hbmFnZSwgYXMgZWl0aGVyOlxuICAgICAqICAgIDEuICoqQSBDU1Mgc2VsZWN0b3I7KiogX29yX1xuICAgICAqICAgIDIuICoqQW4gYXJyYXkgb2YgRE9NIGVsZW1lbnRzKipcbiAgICAgKiAyLiBfRm9yIHN0cmF0ZWd5ICMyIGFib3ZlIChBUEkgY3JlYXRlcyBlbGVtZW50cyBmcm9tIHN1cHBsaWVkIG1vZGVscyk6XyAqKkFuIGFycmF5IG9mIG1vZGVsIGxpc3RzLCoqIGVhY2ggb2Ygd2hpY2ggaXMgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4gICAgICogICAgMS4gQW4gYXJyYXkgb2YgaXRlbSBtb2RlbHMgKHdpdGggdmFyaW91cyBvcHRpb24gcHJvcGVydGllcyBoYW5naW5nIG9mZiBvZiBpdCk7IF9hbmQvb3JfXG4gICAgICogICAgMi4gQSB7QGxpbmsgbW9kZWxMaXN0VHlwZX0gb2JqZWN0IHdpdGggdGhvc2Ugc2FtZSB2YXJpb3VzIG9wdGlvbiBwcm9wZXJ0aWVzIGluY2x1ZGluZyB0aGUgcmVxdWlyZWQgYG1vZGVsc2AgcHJvcGVydHkgY29udGFpbmluZyB0aGF0IHNhbWUgYXJyYXkgb2YgaXRlbSBtb2RlbHMuXG4gICAgICpcbiAgICAgKiBJbiBlaXRoZXIgY2FzZSAoMi4xIG9yIDIuMiksIGVhY2ggZWxlbWVudCBvZiBzdWNoIGFycmF5cyBvZiBpdGVtIG1vZGVscyBtYXkgdGFrZSB0aGUgZm9ybSBvZjpcbiAgICAgKiAqIEEgc3RyaW5nIHByaW1pdGl2ZTsgX29yX1xuICAgICAqICogQSB7QGxpbmsgaXRlbU1vZGVsVHlwZX0gb2JqZWN0IHdpdGggYSB2YXJpb3VzIG9wdGlvbiBwcm9wZXJ0aWVzIGluY2x1ZGluZyB0aGUgcmVxdWlyZWQgYGxhYmVsYCBwcm9wZXJ0eSBjb250YWluaW5nIGEgc3RyaW5nIHByaW1pdGl2ZS5cbiAgICAgKlxuICAgICAqIFJlZ2FyZGluZyB0aGVzZSBzdHJpbmcgcHJpbWl0aXZlcywgZWFjaCBpcyBlaXRoZXI6XG4gICAgICogKiBBIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGxpc3QgaXRlbTsgX29yX1xuICAgICAqICogQSBmb3JtYXQgc3RyaW5nIHdpdGggb3RoZXIgcHJvcGVydHkgdmFsdWVzIG1lcmdlZCBpbiwgdGhlIHJlc3VsdCBvZiB3aGljaCBpcyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGxpc3QgaXRlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gLSBUaGVyZSBhcmUgbm8gZm9ybWFsIG9wdGlvbnMsIGJ1dCB5b3UgY2FuIHN1cHBseSBcImdsb2JhbFwiIHRlbXBsYXRlIHZhcmlhYmxlcyBoZXJlLCByZXByZXNlbnRpbmcgdGhlIFwib3V0ZXIgc2NvcGUsXCIgYWZ0ZXIgZmlyc3Qgc2VhcmNoaW5nIGVhY2ggbW9kZWwgYW5kIHRoZW4gZWFjaCBtb2RlbCBsaXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3REcmFnb24oc2VsZWN0b3JPck1vZGVsTGlzdHMsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGlzdERyYWdvbikpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yKCdOb3QgY2FsbGVkIHdpdGggXCJuZXdcIiBrZXl3b3JkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBtb2RlbExpc3RzLCBpdGVtcztcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yT3JNb2RlbExpc3RzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaXRlbXMgPSB0b0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JPck1vZGVsTGlzdHMpKTtcbiAgICAgICAgICAgIG1vZGVsTGlzdHMgPSBjcmVhdGVNb2RlbExpc3RzRnJvbUxpc3RFbGVtZW50cyhpdGVtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3JPck1vZGVsTGlzdHNbMF0gaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBpdGVtcyA9IHRvQXJyYXkoc2VsZWN0b3JPck1vZGVsTGlzdHMpO1xuICAgICAgICAgICAgbW9kZWxMaXN0cyA9IGNyZWF0ZU1vZGVsTGlzdHNGcm9tTGlzdEVsZW1lbnRzKGl0ZW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcmFtIGlzIGFycmF5IG9mIG1vZGVsIGxpc3RzXG4gICAgICAgICAgICAvLyBidWlsZCBuZXcgPHVsPiBlbGVtZW50KHMpIGZvciBlYWNoIGxpc3QgYW5kIHB1dCBpbiBgLm1vZGVsTGlzdHNgO1xuICAgICAgICAgICAgLy8gZmlsbCBgLml0ZW1zYCBhcnJheSB3aXRoIDxsaT4gZWxlbWVudHMgZnJvbSB0aGVzZSBuZXcgPHVsPiBlbGVtZW50c1xuICAgICAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgIG1vZGVsTGlzdHMgPSBjcmVhdGVMaXN0RWxlbWVudHNGcm9tTW9kZWxMaXN0cyhzZWxlY3Rvck9yTW9kZWxMaXN0cywgb3B0aW9ucyk7XG4gICAgICAgICAgICBtb2RlbExpc3RzLmZvckVhY2goZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdCh0b0FycmF5KGxpc3QuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaScpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW1FbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSAoaXRlbUVsZW1lbnQgIT09IGl0ZW1FbGVtZW50LnBhcmVudEVsZW1lbnQubGFzdEVsZW1lbnRDaGlsZClcbiAgICAgICAgICAgICAgICA/IHNlbGYuYWRkRXZ0KGl0ZW1FbGVtZW50LCAnbW91c2Vkb3duJywgaXRlbUVsZW1lbnQsIHRydWUpXG4gICAgICAgICAgICAgICAgOiB7IGVsZW1lbnQ6IGl0ZW1FbGVtZW50IH07XG5cbiAgICAgICAgICAgIC8qIGBpdGVtLm1vZGVsYCBub3QgY3VycmVudGx5IG5lZWRlZCBzbyBjb21tZW50ZWQgb3V0IGhlcmUuXG4gICAgICAgICAgICAgKiAoT3JpZ2luYWxseSB1c2VkIGZvciByZWJ1aWxkaW5nIG1vZGVsTGlzdHMgZm9yIGZpbmFsXG4gICAgICAgICAgICAgKiByZXBvcnRpbmcsIG1vZGVsTGlzdHMgYXJlIG5vdyBzcGxpY2VkIG9uIGV2ZXJ5IHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAqIGRyYWctYW5kLWRyb3Agb3BlcmF0aW9uIHNvIHRoZXkncmUgYWx3YXlzIHVwIHRvIGRhdGUuKVxuXG4gICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMuaXRlbUNvb3JkaW5hdGVzKGl0ZW1FbGVtZW50KTtcbiAgICAgICAgICAgICBpdGVtLm1vZGVsID0gdGhpcy5tb2RlbExpc3RzW29yaWdpbi5saXN0XS5tb2RlbHNbb3JpZ2luLml0ZW1dO1xuXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgaXRlbXNbaW5kZXhdID0gaXRlbTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYm9keSA9IGJvZHkgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcblxuICAgICAgICB0cmFuc2Zvcm0gPSAndHJhbnNmb3JtJyBpbiBpdGVtc1swXS5lbGVtZW50LnN0eWxlXG4gICAgICAgICAgICA/ICd0cmFuc2Zvcm0nIC8vIENocm9tZSA0NSBhbmQgRmlyZWZveCA0MFxuICAgICAgICAgICAgOiAnLXdlYmtpdC10cmFuc2Zvcm0nOyAvLyBTYWZhcmkgOFxuXG4gICAgICAgIC8vIHNldCB1cCB0aGUgbmV3IG9iamVjdFxuICAgICAgICB0aGlzLm1vZGVsTGlzdHMgPSBtb2RlbExpc3RzO1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IHt9O1xuXG4gICAgfVxuXG4gICAgTGlzdERyYWdvbi5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgYWRkRXZ0OiBmdW5jdGlvbiAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgZG9Ob3RCaW5kKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZyA9IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyc1t0eXBlXS5iaW5kKHRhcmdldCwgdGhpcyksXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbGlzdGVuZXIgfHwgd2luZG93XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIWRvTm90QmluZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZV0gPSBiaW5kaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiaW5kaW5nLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBiaW5kaW5nLmhhbmRsZXIpO1xuXG4gICAgICAgICAgICByZXR1cm4gYmluZGluZztcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVFdnQ6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbdHlwZV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5iaW5kaW5nc1t0eXBlXTtcbiAgICAgICAgICAgIGJpbmRpbmcuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGJpbmRpbmcuaGFuZGxlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBkcmFnICYgZHJvcCBldmVudHMgKG1vdXNlbW92ZSwgbW91c2V1cCwgYW5kIHRyYW5zaXRpb25lbmQpXG4gICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMuYmluZGluZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbdHlwZV07XG4gICAgICAgICAgICAgICAgYmluZGluZy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgYmluZGluZy5oYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgbW91c2Vkb3duIGV2ZW50cyBmcm9tIGFsbCBsaXN0IGl0ZW1zXG4gICAgICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBpdGVtLmhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvaW50SW5MaXN0UmVjdHM6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxMaXN0cy5maW5kKGZ1bmN0aW9uIChtb2RlbExpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IG1vZGVsTGlzdC5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogICB3aW5kb3cuc2Nyb2xsWCArIHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAgICB3aW5kb3cuc2Nyb2xsWSArIHJlY3QudG9wLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogIHdpbmRvdy5zY3JvbGxYICsgcmVjdC5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiB3aW5kb3cuc2Nyb2xsWSArIHJlY3QuYm90dG9tLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogIHJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbW9kZWxMaXN0LnJlY3QgPSByZWN0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50SW5SZWN0KHBvaW50LCByZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbExpc3QucmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBmb3VuZFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludEluSXRlbVJlY3RzOiBmdW5jdGlvbiAocG9pbnQsIGV4Y2VwdDEsIGV4Y2VwdDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGl0ZW0uZWxlbWVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ICE9PSBleGNlcHQxICYmXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgIT09IGV4Y2VwdDIgJiZcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRJblJlY3QocG9pbnQsIGl0ZW0ucmVjdClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZ2V0IHBvc2l0aW9ucyBvZiBhbGwgbGlzdCBpdGVtcyBpbiBwYWdlIGNvb3JkcyAobm9ybWFsaXplZCBmb3Igd2luZG93IGFuZCBsaXN0IHNjcm9sbGluZylcbiAgICAgICAgZ2V0QWxsSXRlbUJvdW5kaW5nUmVjdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbExpc3RzID0gdGhpcy5tb2RlbExpc3RzLCBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUVsZW1lbnQgPSBpdGVtLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RFbGVtZW50ID0gaXRlbUVsZW1lbnQucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IG1vZGVsTGlzdHMuZmluZChmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdC5lbGVtZW50ID09PSBsaXN0RWxlbWVudDsgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIG9taXR0ZWQ6IGRlZmF1bHQgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBsaXN0LmlzRHJvcFRhcmdldCA9PT0gdW5kZWZpbmVkIHx8XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb246IHVzZSByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGxpc3QuaXNEcm9wVGFyZ2V0ID09PSAnZnVuY3Rpb24nICYmIGxpc3QuaXNEcm9wVGFyZ2V0KCkgfHxcblxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2U6IHVzZSB0cnV0aGluZXNzIG9mIGdpdmVuIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGxpc3QuaXNEcm9wVGFyZ2V0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gaXRlbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSByZWN0LmJvdHRvbTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUVsZW1lbnQgPT09IGxpc3RFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IGxpc3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib3R0b20gPCByZWN0LnRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHJlY3QudG9wICsgKGhlaWdodCB8fCA1MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAgIHdpbmRvdy5zY3JvbGxYICsgcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6ICB3aW5kb3cuc2Nyb2xsWCArIHJlY3QucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6ICAgIHdpbmRvdy5zY3JvbGxZICsgcmVjdC50b3AgICAgKyBsaXN0RWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHdpbmRvdy5zY3JvbGxZICsgYm90dG9tICsgbGlzdEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5yZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWluc2VydDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlO1xuICAgICAgICAgICAgc3R5bGUud2lkdGggPSBzdHlsZVt0cmFuc2Zvcm1dID0gc3R5bGUudHJhbnNpdGlvbiA9IFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFO1xuXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ29uLXBvcCcpO1xuXG4gICAgICAgICAgICB0aGlzLmRyb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgICAgICAgICAgIHRoaXMuZHJvcC5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFO1xuICAgICAgICAgICAgdGhpcy5kcm9wLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRhcmdldCwgdGhpcy5kcm9wKTtcblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZHJvcDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyByZXR1cm4gYW4gb2JqZWN0IHsgaXRlbTogPGl0ZW0gaW5kZXggd2l0aGluIGxpc3Q+LCBsaXN0OiA8bGlzdCBpbmRleCB3aXRoaW4gbGlzdCBvZiBsaXN0cz4gfVxuICAgICAgICBpdGVtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgbGlzdEVsZW1lbnQgPSBpdGVtLnBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgY29vcmRzID0geyBpdGVtOiAwIH07XG5cbiAgICAgICAgICAgIHdoaWxlICgoaXRlbSA9IGl0ZW0ucHJldmlvdXNFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgICAgICArK2Nvb3Jkcy5pdGVtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm1vZGVsTGlzdHMuZmluZChmdW5jdGlvbiAobGlzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb29yZHMubGlzdCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0LmVsZW1lbnQgPT09IGxpc3RFbGVtZW50OyAvLyBzdG9wIHdoZW4gd2UgZmluZCB0aGUgb25lIHdlIGJlbG9uZyB0b1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB2YXIgaGFuZGxlcnMgPSB7XG4gICAgICAgIG1vdXNlZG93bjogZnVuY3Rpb24gKGRyYWdvbiwgZXZ0KSB7XG5cbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAgLy9wcmV2ZW50cyB1c2VyIHNlbGVjdGlvbiBvZiByZW5kZXJlZCBub2RlcyBkdXJpbmcgZHJhZ1xuXG4gICAgICAgICAgICBpZiAoZHJhZ29uLmRyb3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgZHJhZ29uLnJlY3QgPSByZWN0ID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6ICAgTWF0aC5yb3VuZChyZWN0LmxlZnQgLSAxKSxcbiAgICAgICAgICAgICAgICB0b3A6ICAgIE1hdGgucm91bmQocmVjdC50b3AgLSAxKSxcbiAgICAgICAgICAgICAgICByaWdodDogIE1hdGgucm91bmQocmVjdC5yaWdodCksXG4gICAgICAgICAgICAgICAgYm90dG9tOiBNYXRoLnJvdW5kKHJlY3QuYm90dG9tKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogIE1hdGgucm91bmQocmVjdC53aWR0aCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHJlY3QuaGVpZ2h0KVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZHJhZ29uLnBpbiA9IHtcbiAgICAgICAgICAgICAgICB4OiB3aW5kb3cuc2Nyb2xsWCArIGV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IHdpbmRvdy5zY3JvbGxZICsgZXZ0LmNsaWVudFlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRyYWdvbi5vcmlnaW4gPSBkcmFnb24uaXRlbUNvb3JkaW5hdGVzKHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoZHJhZ29uLmNhbGxiYWNrLmdyYWJiZWQpIHtcbiAgICAgICAgICAgICAgICBkcmFnb24uY2FsbGJhY2suZ3JhYmJlZC5jYWxsKHRoaXMsIGRyYWdvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyYWdvbi5nZXRBbGxJdGVtQm91bmRpbmdSZWN0cygpO1xuXG4gICAgICAgICAgICBkcmFnb24uZHJvcCA9IHRoaXMubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgZHJhZ29uLmRyb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgICAgICAgICAgIGRyYWdvbi5kcm9wLnN0eWxlLmJvcmRlclRvcFdpZHRoID0gcmVjdC5oZWlnaHQgKyAncHgnO1xuXG4gICAgICAgICAgICB0aGlzLnN0eWxlLndpZHRoID0gcmVjdC53aWR0aCArICdweCc7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gICAgICAgICAgICB0aGlzLnN0eWxlW3RyYW5zZm9ybV0gPSB0cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgcmVjdC5sZWZ0IC0gd2luZG93LnNjcm9sbFgsXG4gICAgICAgICAgICAgICAgcmVjdC50b3AgIC0gd2luZG93LnNjcm9sbFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2RyYWdvbi1wb3AnKTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuekluZGV4ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZHJhZ29uLm1vZGVsTGlzdHNbMF0uY29udGFpbmVyLnBhcmVudEVsZW1lbnQpLnpJbmRleDtcblxuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZCh0aGlzKTtcblxuICAgICAgICAgICAgcmVjdC5sZWZ0ICAgKz0gd2luZG93LnNjcm9sbFg7XG4gICAgICAgICAgICByZWN0LnRvcCAgICArPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgICAgIHJlY3QucmlnaHQgICs9IHdpbmRvdy5zY3JvbGxYO1xuICAgICAgICAgICAgcmVjdC5ib3R0b20gKz0gd2luZG93LnNjcm9sbFk7XG5cbiAgICAgICAgICAgIGRyYWdvbi5hZGRFdnQodGhpcywgJ21vdXNlbW92ZScpO1xuICAgICAgICAgICAgZHJhZ29uLmFkZEV2dCh0aGlzLCAnbW91c2V1cCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGRyYWdvbiwgZXZ0KSB7XG4gICAgICAgICAgICBkcmFnb24uZHJvcC5zdHlsZS50cmFuc2l0aW9uID0gUkVWRVJUX1RPX1NUWUxFU0hFRVRfVkFMVUU7XG5cbiAgICAgICAgICAgIHZhciBob3Zlckxpc3QgPSBkcmFnb24ucG9pbnRJbkxpc3RSZWN0cyh7IHg6IGV2dC5jbGllbnRYLCB5OiBldnQuY2xpZW50WSB9KSB8fCBkcmFnb24ubW9zdFJlY2VudEhvdmVyTGlzdDtcblxuICAgICAgICAgICAgaWYgKGhvdmVyTGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBkeCA9IGV2dC5jbGllbnRYIC0gZHJhZ29uLnBpbi54LFxuICAgICAgICAgICAgICAgICAgICBkeSA9IGV2dC5jbGllbnRZIC0gZHJhZ29uLnBpbi55O1xuXG4gICAgICAgICAgICAgICAgZHJhZ29uLm1vc3RSZWNlbnRIb3Zlckxpc3QgPSBob3Zlckxpc3Q7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF4U2Nyb2xsWSA9IGhvdmVyTGlzdC5lbGVtZW50LnNjcm9sbEhlaWdodCAtIGhvdmVyTGlzdC5yZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgeSA9IGV2dC5jbGllbnRZICsgd2luZG93LnNjcm9sbFksXG4gICAgICAgICAgICAgICAgICAgIG1hZ25pdHVkZTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXhTY3JvbGxZID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0IGlzIHNjcm9sbGFibGUgKGlzIHRhbGxlciB0aGFuIHJlY3QpXG4gICAgICAgICAgICAgICAgICAgIGlmIChob3Zlckxpc3QuZWxlbWVudC5zY3JvbGxUb3AgPiAwICYmIChtYWduaXR1ZGUgPSB5IC0gKGhvdmVyTGlzdC5yZWN0LnRvcCArIDUpKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdXNlIG5lYXIgb3IgYWJvdmUgdG9wIGFuZCBsaXN0IGlzIG5vdCBzY3JvbGxlZCB0byB0b3AgeWV0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldEF1dG9TY3JvbGxUaW1lcihtYWduaXR1ZGUsIDAsIGhvdmVyTGlzdC5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChob3Zlckxpc3QuZWxlbWVudC5zY3JvbGxUb3AgPCBtYXhTY3JvbGxZICYmIChtYWduaXR1ZGUgPSB5IC0gKGhvdmVyTGlzdC5yZWN0LmJvdHRvbSAtIDEgLSA1KSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3VzZSBuZWFyIG9yIGJlbG93IGJvdHRvbSBhbmQgbGlzdCBub3Qgc2Nyb2xsZWQgdG8gYm90dG9tIHlldFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRBdXRvU2Nyb2xsVGltZXIobWFnbml0dWRlLCBtYXhTY3JvbGxZLCBob3Zlckxpc3QuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3VzZSBpbnNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0QXV0b1Njcm9sbFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBkcmFnb24ucG9pbnRJbkl0ZW1SZWN0cyh7XG4gICAgICAgICAgICAgICAgICAgIHg6IGV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICB5OiBkcmFnb24ucmVjdC5ib3R0b20gKyB3aW5kb3cuc2Nyb2xsWSArIGR5ICsgaG92ZXJMaXN0LmVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgfSwgdGhpcywgZHJhZ29uLmRyb3ApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZVt0cmFuc2Zvcm1dID0gdHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgICAgICBkcmFnb24ucmVjdC5sZWZ0IC0gd2luZG93LnNjcm9sbFggKyBkeCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ29uLnJlY3QudG9wIC0gd2luZG93LnNjcm9sbFkgKyBkeVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBvdGhlci5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb24gPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IGRyYWdvbi5kcm9wLnN0eWxlLmJvcmRlclRvcFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBkcmFnb24uZHJvcC5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdvbi5kcm9wID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2V1cDogZnVuY3Rpb24gKGRyYWdvbiwgZXZ0KSB7XG4gICAgICAgICAgICByZXNldEF1dG9TY3JvbGxUaW1lcigpO1xuICAgICAgICAgICAgZHJhZ29uLnJlbW92ZUV2dCgnbW91c2Vtb3ZlJyk7XG4gICAgICAgICAgICBkcmFnb24ucmVtb3ZlRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgdmFyIG5ld1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFggKyBuZXdSZWN0LmxlZnQgPT09IGRyYWdvbi5yZWN0LmxlZnQgJiZcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsWSArIG5ld1JlY3QudG9wID09PSBkcmFnb24ucmVjdC50b3BcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRyYWdvbi5yZWluc2VydCh0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyb3BSZWN0ID0gZHJhZ29uLmRyb3AuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgICAgICBkcmFnb24uYWRkRXZ0KHRoaXMsICd0cmFuc2l0aW9uZW5kJywgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTsgLy9yZXZlcnRzIHRvIDIwMG1zXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZVt0cmFuc2Zvcm1dID0gdHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgICAgICBkcm9wUmVjdC5sZWZ0IC0gd2luZG93LnNjcm9sbFgsXG4gICAgICAgICAgICAgICAgICAgIGRyb3BSZWN0LnRvcCAtIHdpbmRvdy5zY3JvbGxZXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2l0aW9uZW5kOiBmdW5jdGlvbiAoZHJhZ29uLCBldnQpIHtcbiAgICAgICAgICAgIGlmIChldnQucHJvcGVydHlOYW1lID09PSB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBkcmFnb24ucmVtb3ZlRXZ0KCd0cmFuc2l0aW9uZW5kJyk7XG4gICAgICAgICAgICAgICAgZHJhZ29uLnJlaW5zZXJ0KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTsgLy9yZXZlcnRzIHRvIGJvcmRlci10b3Atd2lkdGhcblxuICAgICAgICAgICAgICAgIHZhciBtb2RlbCA9IGRyYWdvbi5tb2RlbExpc3RzW2RyYWdvbi5vcmlnaW4ubGlzdF0uc3BsaWNlKGRyYWdvbi5vcmlnaW4uaXRlbSwgMSlbMF07XG4gICAgICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gZHJhZ29uLml0ZW1Db29yZGluYXRlcyh0aGlzKTtcbiAgICAgICAgICAgICAgICBkcmFnb24ubW9kZWxMaXN0c1tkZXN0aW5hdGlvbi5saXN0XS5zcGxpY2UoZGVzdGluYXRpb24uaXRlbSwgMCwgbW9kZWwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdvbi5jYWxsYmFjay5kcm9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdvbi5jYWxsYmFjay5kcm9wcGVkLmNhbGwodGhpcywgZHJhZ29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVzZXRBdXRvU2Nyb2xsVGltZXIobWFnbml0dWRlLCBsaW1pdCwgZWxlbWVudCkge1xuICAgICAgICBpZiAoIW1hZ25pdHVkZSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgICAgICBzY3JvbGxWZWxvY2l0eSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlRGlyZWN0aW9uID1cbiAgICAgICAgICAgICAgICBzY3JvbGxWZWxvY2l0eSAgPCAgMCAmJiBtYWduaXR1ZGUgID49IDAgfHxcbiAgICAgICAgICAgICAgICBzY3JvbGxWZWxvY2l0eSA9PT0gMCAmJiBtYWduaXR1ZGUgIT09IDAgfHxcbiAgICAgICAgICAgICAgICBzY3JvbGxWZWxvY2l0eSAgPiAgMCAmJiBtYWduaXR1ZGUgIDw9IDA7XG4gICAgICAgICAgICBzY3JvbGxWZWxvY2l0eSA9IG1hZ25pdHVkZSA+IDAgPyBNYXRoLm1pbig1MCwgbWFnbml0dWRlKSA6IE1hdGgubWF4KC01MCwgbWFnbml0dWRlKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uIChsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3AgKyBzY3JvbGxWZWxvY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbFZlbG9jaXR5IDwgMCAmJiBzY3JvbGxUb3AgPCBsaW1pdCB8fCBzY3JvbGxWZWxvY2l0eSA+IDAgJiYgc2Nyb2xsVG9wID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gbGltaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMTI1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkoYXJyYXlMaWtlT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheUxpa2VPYmplY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50SW5SZWN0KHBvaW50LCByZWN0KSB7XG4gICAgICAgIHJldHVybiByZWN0LnRvcCA8PSBwb2ludC55ICYmIHBvaW50LnkgPD0gcmVjdC5ib3R0b21cbiAgICAgICAgICAgICYmIHJlY3QubGVmdCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gcmVjdC5yaWdodDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobGVmdCwgdG9wKSB7XG4gICAgICAgIHJldHVybiAndHJhbnNsYXRlKCdcbiAgICAgICAgICAgICsgTWF0aC5mbG9vcihsZWZ0ICsgd2luZG93LnNjcm9sbFgpICsgJ3B4LCdcbiAgICAgICAgICAgICsgTWF0aC5mbG9vcih0b3AgKyB3aW5kb3cuc2Nyb2xsWSkgKyAncHgpJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodG1sRW5jb2RlKHN0cmluZykge1xuICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHJpbmcpO1xuXG4gICAgICAgIHJldHVybiBkb2N1bWVudFxuICAgICAgICAgICAgLmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICAgICAgLmFwcGVuZENoaWxkKHRleHROb2RlKVxuICAgICAgICAgICAgLnBhcmVudE5vZGVcbiAgICAgICAgICAgIC5pbm5lckhUTUw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBgPHVsPi4uLjwvdWw+YCBlbGVtZW50cyBhbmQgaW5zZXJ0cyB0aGVtIGludG8gYW4gYGVsZW1lbnRgIHByb3BlcnR5IG9uIGVhY2ggbW9kZWwuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1vZGVsTGlzdHNcbiAgICAgKiBAcmV0dXJucyBgbW9kZWxMaXN0c2BcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVMaXN0RWxlbWVudHNGcm9tTW9kZWxMaXN0cyhtb2RlbExpc3RzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZUxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCAne2xhYmVsfSc7XG5cbiAgICAgICAgbW9kZWxMaXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbExpc3QsIGxpc3RJbmRleCkge1xuICAgICAgICAgICAgdmFyIGxpc3RMYWJlbCA9IG1vZGVsTGlzdC5sYWJlbCB8fCB0ZW1wbGF0ZUxhYmVsLFxuICAgICAgICAgICAgICAgIGxpc3RIdG1sRW5jb2RlID0gbW9kZWxMaXN0Lmh0bWxFbmNvZGUgIT09IHVuZGVmaW5lZCAmJiBtb2RlbExpc3QuaHRtbEVuY29kZSB8fCBvcHRpb25zLmh0bWxFbmNvZGUsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICAgICAgbGlzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXG4gICAgICAgICAgICBpZiAobW9kZWxMaXN0Lm1vZGVscykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG1vZGVsTGlzdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdtb2RlbHMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbExpc3QubW9kZWxzW2tleV0gPSBtb2RlbExpc3Rba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1vZGVsTGlzdHNbbGlzdEluZGV4XSA9IG1vZGVsTGlzdCA9IG1vZGVsTGlzdC5tb2RlbHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsTGlzdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgbW9kZWxMaXN0Lm1vZGVscyA9IG1vZGVsTGlzdDsgLy8gcG9pbnQgdG8gc2VsZlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcignTGlzdCBbezF9XSBub3QgYW4gYXJyYXkgb2YgbW9kZWxzICh3aXRoIG9yIHdpdGhvdXQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzKSBPUiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2FuIG9iamVjdCAod2l0aCBhIGBtb2RlbHNgIHByb3BlcnR5IGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgbW9kZWxzKS4nLCBsaXN0SW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb2RlbExpc3QuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kZWxMYWJlbCA9IG1vZGVsLmxhYmVsIHx8IGxpc3RMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxIdG1sRW5jb2RlID0gbW9kZWwuaHRtbEVuY29kZSAhPT0gdW5kZWZpbmVkICYmIG1vZGVsLmh0bWxFbmNvZGUgfHwgbGlzdEh0bWxFbmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsT2JqZWN0ID0gdHlwZW9mIG1vZGVsID09PSAnb2JqZWN0JyA/IG1vZGVsIDogeyBsYWJlbDogbW9kZWx9LFxuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGZvcm1hdC5jYWxsKFttb2RlbE9iamVjdCwgbW9kZWxMaXN0LCBvcHRpb25zXSwgbW9kZWxMYWJlbCksXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblxuICAgICAgICAgICAgICAgIGl0ZW1FbGVtZW50LmlubmVySFRNTCA9IG1vZGVsSHRtbEVuY29kZSA/IGh0bWxFbmNvZGUobGFiZWwpIDogbGFiZWw7XG5cbiAgICAgICAgICAgICAgICBsaXN0RWxlbWVudC5hcHBlbmRDaGlsZChpdGVtRWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYXBwZW5kIHRoZSBmaW5hbCBcImZlbmNlcG9zdFwiIGl0ZW0gLS0gZHJvcCB0YXJnZXQgYXQgYm90dG9tIG9mIGxpc3QgYWZ0ZXIgYWxsIGl0ZW1zXG4gICAgICAgICAgICB2YXIgaXRlbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgaXRlbUVsZW1lbnQuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG4gICAgICAgICAgICBsaXN0RWxlbWVudC5hcHBlbmRDaGlsZChpdGVtRWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIGFwcGVuZCBoZWFkZXIgdG8gY29udGFpbmVyXG4gICAgICAgICAgICBpZiAobW9kZWxMaXN0LnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGhlYWRlci5pbm5lckhUTUwgPSBsaXN0SHRtbEVuY29kZSA/IGh0bWxFbmNvZGUobW9kZWxMaXN0LnRpdGxlKSA6IG1vZGVsTGlzdC50aXRsZTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxpc3RFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBtb2RlbExpc3QuY3NzQ2xhc3NOYW1lcyB8fCBvcHRpb25zLmNzc0NsYXNzTmFtZXMgfHwgJ2RyYWdvbi1saXN0JztcbiAgICAgICAgICAgIG1vZGVsTGlzdC5lbGVtZW50ID0gbGlzdEVsZW1lbnQ7XG4gICAgICAgICAgICBtb2RlbExpc3QuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbW9kZWxMaXN0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgLm1vZGVsTGlzdHNgIGFycmF5IHdpdGggdGhlc2UgPGxpPiBlbGVtZW50cycgcGFyZW50IDx1bD4gZWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnRbXX0gbGlzdEl0ZW1FbGVtZW50c1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVNb2RlbExpc3RzRnJvbUxpc3RFbGVtZW50cyhsaXN0SXRlbUVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBtb2RlbExpc3RzID0gW107XG5cbiAgICAgICAgbGlzdEl0ZW1FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGxpc3RFbGVtZW50ID0gaXRlbUVsZW1lbnQucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBsaXN0RWxlbWVudC5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIG1vZGVscyA9IFtdO1xuICAgICAgICAgICAgaWYgKCFtb2RlbExpc3RzLmZpbmQoZnVuY3Rpb24gKGxpc3QpIHsgcmV0dXJuIGxpc3QuZWxlbWVudCA9PT0gbGlzdEVsZW1lbnQ7IH0pKSB7XG4gICAgICAgICAgICAgICAgdG9BcnJheShsaXN0RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaScpKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUVsZW1lbnQgIT09IGxpc3RFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVscy5wdXNoKGl0ZW1FbGVtZW50LmlubmVySFRNTCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtb2RlbHMuZWxlbWVudCA9IGxpc3RFbGVtZW50O1xuICAgICAgICAgICAgICAgIG1vZGVscy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgICAgICAgICAgbW9kZWxMaXN0cy5wdXNoKG1vZGVscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtb2RlbExpc3RzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKCkge1xuICAgICAgICByZXR1cm4gJ2xpc3QtZHJhZ29uOiAnICsgZm9ybWF0LmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIC8vIHRoaXMgaW50ZXJmYWNlIGNvbnNpc3RzIHNvbGVseSBvZiB0aGUgcHJvdG90eXBhbCBvYmplY3QgY29uc3RydWN0b3JcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpc3REcmFnb247XG5cbn0pKFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSB8fCAod2luZG93Lkxpc3REcmFnb24gPSB7fSksXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgfHwgKHdpbmRvdy5MaXN0RHJhZ29uLmV4cG9ydHMgPSB7fSlcbikgfHwgKFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnIHx8ICh3aW5kb3cuTGlzdERyYWdvbiA9IHdpbmRvdy5MaXN0RHJhZ29uLmV4cG9ydHMpXG4pO1xuXG4vKiBBYm91dCB0aGUgYWJvdmUgSUlGRTpcbiAqIFRoaXMgZmlsZSBpcyBhIFwibW9kaWZpZWQgbm9kZSBtb2R1bGUuXCIgSXQgZnVuY3Rpb25zIGFzIHVzdWFsIGluIE5vZGUuanMgKmFuZCogaXMgYWxzbyB1c2FibGUgZGlyZWN0bHkgaW4gdGhlIGJyb3dzZXIuXG4gKiAxLiBOb2RlLmpzOiBUaGUgSUlGRSBpcyBzdXBlcmZsdW91cyBidXQgaW5ub2N1b3VzLlxuICogMi4gSW4gdGhlIGJyb3dzZXI6IFRoZSBJSUZFIGNsb3N1cmUgc2VydmVzIHRvIGtlZXAgaW50ZXJuYWwgZGVjbGFyYXRpb25zIHByaXZhdGUuXG4gKiAyLmEuIEluIHRoZSBicm93c2VyIGFzIGEgZ2xvYmFsOiBUaGUgbG9naWMgaW4gdGhlIGFjdHVhbCBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgKyB0aGUgcG9zdC1pbnZvY2F0aW9uIGV4cHJlc3Npb25cbiAqIHdpbGwgcHV0IHlvdXIgQVBJIGluIGB3aW5kb3cuTGlzdERyYWdvbmAuXG4gKiAyLmIuIEluIHRoZSBicm93c2VyIGFzIGEgbW9kdWxlOiBJZiB5b3UgcHJlZGVmaW5lIGEgYHdpbmRvdy5tb2R1bGVgIG9iamVjdCwgdGhlIHJlc3VsdHMgd2lsbCBiZSBpbiBgbW9kdWxlLmV4cG9ydHNgLlxuICogVGhlIGJvd2VyIGNvbXBvbmVudCBgbW5tYCBtYWtlcyB0aGlzIGVhc3kgYW5kIGFsc28gcHJvdmlkZXMgYSBnbG9iYWwgYHJlcXVpcmUoKWAgZnVuY3Rpb24gZm9yIHJlZmVyZW5jaW5nIHlvdXIgbW9kdWxlXG4gKiBmcm9tIG90aGVyIGNsb3N1cmVzLiBJbiBlaXRoZXIgY2FzZSwgdGhpcyB3b3JrcyB3aXRoIGJvdGggTm9kZUpzLXN0eWxlIGV4cG9ydCBtZWNoYW5pc21zIC0tIGEgc2luZ2xlIEFQSSBhc3NpZ25tZW50LFxuICogYG1vZHVsZS5leHBvcnRzID0geW91ckFQSWAgKm9yKiBhIHNlcmllcyBvZiBpbmRpdmlkdWFsIHByb3BlcnR5IGFzc2lnbm1lbnRzLCBgbW9kdWxlLmV4cG9ydHMucHJvcGVydHkgPSBwcm9wZXJ0eWAuXG4gKlxuICogQmVmb3JlIHRoZSBJSUZFIHJ1bnMsIHRoZSBhY3R1YWwgcGFyYW1ldGVyIGV4cHJlc3Npb25zIGFyZSBleGVjdXRlZDpcbiAqIDEuIElmIGB3aW5kb3dgIG9iamVjdCB1bmRlZmluZWQsIHdlJ3JlIGluIE5vZGVKcyBzbyBhc3N1bWUgdGhlcmUgaXMgYSBgbW9kdWxlYCBvYmplY3Qgd2l0aCBhbiBgZXhwb3J0c2AgcHJvcGVydHlcbiAqIDIuIElmIGB3aW5kb3dgIG9iamVjdCBkZWZpbmVkLCB3ZSdyZSBpbiBicm93c2VyXG4gKiAyLmEuIElmIGBtb2R1bGVgIG9iamVjdCBwcmVkZWZpbmVkLCB1c2UgaXRcbiAqIDIuYi4gSWYgYG1vZHVsZWAgb2JqZWN0IHVuZGVmaW5lZCwgY3JlYXRlIGEgYExpc3REcmFnb25gIG9iamVjdFxuICpcbiAqIEFmdGVyIHRoZSBJSUZFIHJldHVybnM6XG4gKiBCZWNhdXNlIGl0IGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCwgdGhlIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIHx8IHdpbGwgZXhlY3V0ZTpcbiAqIDEuIElmIGB3aW5kb3dgIG9iamVjdCB1bmRlZmluZWQsIHRoZW4gd2UncmUgaW4gTm9kZUpzIHNvIHdlJ3JlIGRvbmVcbiAqIDIuIElmIGB3aW5kb3dgIG9iamVjdCBkZWZpbmVkLCB0aGVuIHdlJ3JlIGluIGJyb3dzZXJcbiAqIDIuYS4gSWYgYG1vZHVsZWAgb2JqZWN0IHByZWRlZmluZWQsIHdlJ3JlIGRvbmU7IHJlc3VsdHMgYXJlIGluIGBtb3VkdWxlLmV4cG9ydHNgXG4gKiAyLmIuIElmIGBtb2R1bGVgIG9iamVjdCB1bmRlZmluZWQsIHJlZGVmaW5lYExpc3REcmFnb25gIHRvIGJlIHRoZSBgTGlzdERyYWdvbi5leHBvcnRzYCBvYmplY3RcbiAqL1xuIiwiOyhmdW5jdGlvbiAoKSB7IC8vIGNsb3N1cmUgZm9yIHdlYiBicm93c2Vyc1xuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZVxufSBlbHNlIHtcbiAgLy8ganVzdCBzZXQgdGhlIGdsb2JhbCBmb3Igbm9uLW5vZGUgcGxhdGZvcm1zLlxuICB0aGlzLkxSVUNhY2hlID0gTFJVQ2FjaGVcbn1cblxuZnVuY3Rpb24gaE9QIChvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG5mdW5jdGlvbiBuYWl2ZUxlbmd0aCAoKSB7IHJldHVybiAxIH1cblxudmFyIGRpZFR5cGVXYXJuaW5nID0gZmFsc2VcbmZ1bmN0aW9uIHR5cGVDaGVja0tleShrZXkpIHtcbiAgaWYgKCFkaWRUeXBlV2FybmluZyAmJiB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Yga2V5ICE9PSAnbnVtYmVyJykge1xuICAgIGRpZFR5cGVXYXJuaW5nID0gdHJ1ZVxuICAgIGNvbnNvbGUuZXJyb3IobmV3IFR5cGVFcnJvcihcIkxSVToga2V5IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLiBBbG1vc3QgY2VydGFpbmx5IGEgYnVnISBcIiArIHR5cGVvZiBrZXkpLnN0YWNrKVxuICB9XG59XG5cbmZ1bmN0aW9uIExSVUNhY2hlIChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMUlVDYWNoZSkpXG4gICAgcmV0dXJuIG5ldyBMUlVDYWNoZShvcHRpb25zKVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpXG4gICAgb3B0aW9ucyA9IHsgbWF4OiBvcHRpb25zIH1cblxuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9XG5cbiAgdGhpcy5fbWF4ID0gb3B0aW9ucy5tYXhcbiAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICBpZiAoIXRoaXMuX21heCB8fCAhKHR5cGVvZiB0aGlzLl9tYXggPT09IFwibnVtYmVyXCIpIHx8IHRoaXMuX21heCA8PSAwIClcbiAgICB0aGlzLl9tYXggPSBJbmZpbml0eVxuXG4gIHRoaXMuX2xlbmd0aENhbGN1bGF0b3IgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aFxuICBpZiAodHlwZW9mIHRoaXMuX2xlbmd0aENhbGN1bGF0b3IgIT09IFwiZnVuY3Rpb25cIilcbiAgICB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yID0gbmFpdmVMZW5ndGhcblxuICB0aGlzLl9hbGxvd1N0YWxlID0gb3B0aW9ucy5zdGFsZSB8fCBmYWxzZVxuICB0aGlzLl9tYXhBZ2UgPSBvcHRpb25zLm1heEFnZSB8fCBudWxsXG4gIHRoaXMuX2Rpc3Bvc2UgPSBvcHRpb25zLmRpc3Bvc2VcbiAgdGhpcy5yZXNldCgpXG59XG5cbi8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcIm1heFwiLFxuICB7IHNldCA6IGZ1bmN0aW9uIChtTCkge1xuICAgICAgaWYgKCFtTCB8fCAhKHR5cGVvZiBtTCA9PT0gXCJudW1iZXJcIikgfHwgbUwgPD0gMCApIG1MID0gSW5maW5pdHlcbiAgICAgIHRoaXMuX21heCA9IG1MXG4gICAgICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KSB0cmltKHRoaXMpXG4gICAgfVxuICAsIGdldCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21heCB9XG4gICwgZW51bWVyYWJsZSA6IHRydWVcbiAgfSlcblxuLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcImxlbmd0aENhbGN1bGF0b3JcIixcbiAgeyBzZXQgOiBmdW5jdGlvbiAobEMpIHtcbiAgICAgIGlmICh0eXBlb2YgbEMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yID0gbmFpdmVMZW5ndGhcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5faXRlbUNvdW50XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9jYWNoZSkge1xuICAgICAgICAgIHRoaXMuX2NhY2hlW2tleV0ubGVuZ3RoID0gMVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yID0gbENcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gMFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICB0aGlzLl9jYWNoZVtrZXldLmxlbmd0aCA9IHRoaXMuX2xlbmd0aENhbGN1bGF0b3IodGhpcy5fY2FjaGVba2V5XS52YWx1ZSlcbiAgICAgICAgICB0aGlzLl9sZW5ndGggKz0gdGhpcy5fY2FjaGVba2V5XS5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KSB0cmltKHRoaXMpXG4gICAgfVxuICAsIGdldCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xlbmd0aENhbGN1bGF0b3IgfVxuICAsIGVudW1lcmFibGUgOiB0cnVlXG4gIH0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsXG4gIHsgZ2V0IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGVuZ3RoIH1cbiAgLCBlbnVtZXJhYmxlIDogdHJ1ZVxuICB9KVxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsIFwiaXRlbUNvdW50XCIsXG4gIHsgZ2V0IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faXRlbUNvdW50IH1cbiAgLCBlbnVtZXJhYmxlIDogdHJ1ZVxuICB9KVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciBpID0gMFxuICB2YXIgaXRlbUNvdW50ID0gdGhpcy5faXRlbUNvdW50XG5cbiAgZm9yICh2YXIgayA9IHRoaXMuX21ydSAtIDE7IGsgPj0gMCAmJiBpIDwgaXRlbUNvdW50OyBrLS0pIGlmICh0aGlzLl9scnVMaXN0W2tdKSB7XG4gICAgaSsrXG4gICAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3Rba11cbiAgICBpZiAoaXNTdGFsZSh0aGlzLCBoaXQpKSB7XG4gICAgICBkZWwodGhpcywgaGl0KVxuICAgICAgaWYgKCF0aGlzLl9hbGxvd1N0YWxlKSBoaXQgPSB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKGhpdCkge1xuICAgICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGtleXMgPSBuZXcgQXJyYXkodGhpcy5faXRlbUNvdW50KVxuICB2YXIgaSA9IDBcbiAgZm9yICh2YXIgayA9IHRoaXMuX21ydSAtIDE7IGsgPj0gMCAmJiBpIDwgdGhpcy5faXRlbUNvdW50OyBrLS0pIGlmICh0aGlzLl9scnVMaXN0W2tdKSB7XG4gICAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3Rba11cbiAgICBrZXlzW2krK10gPSBoaXQua2V5XG4gIH1cbiAgcmV0dXJuIGtleXNcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheSh0aGlzLl9pdGVtQ291bnQpXG4gIHZhciBpID0gMFxuICBmb3IgKHZhciBrID0gdGhpcy5fbXJ1IC0gMTsgayA+PSAwICYmIGkgPCB0aGlzLl9pdGVtQ291bnQ7IGstLSkgaWYgKHRoaXMuX2xydUxpc3Rba10pIHtcbiAgICB2YXIgaGl0ID0gdGhpcy5fbHJ1TGlzdFtrXVxuICAgIHZhbHVlc1tpKytdID0gaGl0LnZhbHVlXG4gIH1cbiAgcmV0dXJuIHZhbHVlc1xufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaXNwb3NlICYmIHRoaXMuX2NhY2hlKSB7XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLl9jYWNoZSkge1xuICAgICAgdGhpcy5fZGlzcG9zZShrLCB0aGlzLl9jYWNoZVtrXS52YWx1ZSlcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCkgLy8gaGFzaCBvZiBpdGVtcyBieSBrZXlcbiAgdGhpcy5fbHJ1TGlzdCA9IE9iamVjdC5jcmVhdGUobnVsbCkgLy8gbGlzdCBvZiBpdGVtcyBpbiBvcmRlciBvZiB1c2UgcmVjZW5jeVxuICB0aGlzLl9tcnUgPSAwIC8vIG1vc3QgcmVjZW50bHkgdXNlZFxuICB0aGlzLl9scnUgPSAwIC8vIGxlYXN0IHJlY2VudGx5IHVzZWRcbiAgdGhpcy5fbGVuZ3RoID0gMCAvLyBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAgdGhpcy5faXRlbUNvdW50ID0gMFxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IFtdXG4gIHZhciBpID0gMFxuXG4gIGZvciAodmFyIGsgPSB0aGlzLl9tcnUgLSAxOyBrID49IDAgJiYgaSA8IHRoaXMuX2l0ZW1Db3VudDsgay0tKSBpZiAodGhpcy5fbHJ1TGlzdFtrXSkge1xuICAgIHZhciBoaXQgPSB0aGlzLl9scnVMaXN0W2tdXG4gICAgaWYgKCFpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICAgIC8vRG8gbm90IHN0b3JlIHN0YWxlZCBoaXRzXG4gICAgICArK2lcbiAgICAgIGFyci5wdXNoKHtcbiAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvL2FyciBoYXMgdGhlIG1vc3QgcmVhZCBmaXJzdFxuICByZXR1cm4gYXJyXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kdW1wTHJ1ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fbHJ1TGlzdFxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG1heEFnZSkge1xuICBtYXhBZ2UgPSBtYXhBZ2UgfHwgdGhpcy5fbWF4QWdlXG4gIHR5cGVDaGVja0tleShrZXkpXG5cbiAgdmFyIG5vdyA9IG1heEFnZSA/IERhdGUubm93KCkgOiAwXG4gIHZhciBsZW4gPSB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yKHZhbHVlKVxuXG4gIGlmIChoT1AodGhpcy5fY2FjaGUsIGtleSkpIHtcbiAgICBpZiAobGVuID4gdGhpcy5fbWF4KSB7XG4gICAgICBkZWwodGhpcywgdGhpcy5fY2FjaGVba2V5XSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvLyBkaXNwb3NlIG9mIHRoZSBvbGQgb25lIGJlZm9yZSBvdmVyd3JpdGluZ1xuICAgIGlmICh0aGlzLl9kaXNwb3NlKVxuICAgICAgdGhpcy5fZGlzcG9zZShrZXksIHRoaXMuX2NhY2hlW2tleV0udmFsdWUpXG5cbiAgICB0aGlzLl9jYWNoZVtrZXldLm5vdyA9IG5vd1xuICAgIHRoaXMuX2NhY2hlW2tleV0ubWF4QWdlID0gbWF4QWdlXG4gICAgdGhpcy5fY2FjaGVba2V5XS52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5fbGVuZ3RoICs9IChsZW4gLSB0aGlzLl9jYWNoZVtrZXldLmxlbmd0aClcbiAgICB0aGlzLl9jYWNoZVtrZXldLmxlbmd0aCA9IGxlblxuICAgIHRoaXMuZ2V0KGtleSlcblxuICAgIGlmICh0aGlzLl9sZW5ndGggPiB0aGlzLl9tYXgpXG4gICAgICB0cmltKHRoaXMpXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdmFyIGhpdCA9IG5ldyBFbnRyeShrZXksIHZhbHVlLCB0aGlzLl9tcnUrKywgbGVuLCBub3csIG1heEFnZSlcblxuICAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuICBpZiAoaGl0Lmxlbmd0aCA+IHRoaXMuX21heCkge1xuICAgIGlmICh0aGlzLl9kaXNwb3NlKSB0aGlzLl9kaXNwb3NlKGtleSwgdmFsdWUpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0aGlzLl9sZW5ndGggKz0gaGl0Lmxlbmd0aFxuICB0aGlzLl9scnVMaXN0W2hpdC5sdV0gPSB0aGlzLl9jYWNoZVtrZXldID0gaGl0XG4gIHRoaXMuX2l0ZW1Db3VudCArK1xuXG4gIGlmICh0aGlzLl9sZW5ndGggPiB0aGlzLl9tYXgpXG4gICAgdHJpbSh0aGlzKVxuXG4gIHJldHVybiB0cnVlXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHR5cGVDaGVja0tleShrZXkpXG4gIGlmICghaE9QKHRoaXMuX2NhY2hlLCBrZXkpKSByZXR1cm4gZmFsc2VcbiAgdmFyIGhpdCA9IHRoaXMuX2NhY2hlW2tleV1cbiAgaWYgKGlzU3RhbGUodGhpcywgaGl0KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHR5cGVDaGVja0tleShrZXkpXG4gIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdHlwZUNoZWNrS2V5KGtleSlcbiAgcmV0dXJuIGdldCh0aGlzLCBrZXksIGZhbHNlKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGl0ID0gdGhpcy5fbHJ1TGlzdFt0aGlzLl9scnVdXG4gIGRlbCh0aGlzLCBoaXQpXG4gIHJldHVybiBoaXQgfHwgbnVsbFxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKGtleSkge1xuICB0eXBlQ2hlY2tLZXkoa2V5KVxuICBkZWwodGhpcywgdGhpcy5fY2FjaGVba2V5XSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIC8vcmVzZXQgdGhlIGNhY2hlXG4gIHRoaXMucmVzZXQoKTtcblxuICB2YXIgbm93ID0gRGF0ZS5ub3coKVxuICAvL0EgcHJldmlvdXMgc2VyaWFsaXplZCBjYWNoZSBoYXMgdGhlIG1vc3QgcmVjZW50IGl0ZW1zIGZpcnN0XG4gIGZvciAodmFyIGwgPSBhcnIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0gKSB7XG4gICAgdmFyIGhpdCA9IGFycltsXVxuICAgIHR5cGVDaGVja0tleShoaXQuaylcbiAgICB2YXIgZXhwaXJlc0F0ID0gaGl0LmUgfHwgMFxuICAgIGlmIChleHBpcmVzQXQgPT09IDApIHtcbiAgICAgIC8vdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heEFnZSA9IGV4cGlyZXNBdCAtIG5vd1xuICAgICAgLy9kb250IGFkZCBhbHJlYWR5IGV4cGlyZWQgaXRlbXNcbiAgICAgIGlmIChtYXhBZ2UgPiAwKSB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0IChzZWxmLCBrZXksIGRvVXNlKSB7XG4gIHR5cGVDaGVja0tleShrZXkpXG4gIHZhciBoaXQgPSBzZWxmLl9jYWNoZVtrZXldXG4gIGlmIChoaXQpIHtcbiAgICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgICBkZWwoc2VsZiwgaGl0KVxuICAgICAgaWYgKCFzZWxmLl9hbGxvd1N0YWxlKSBoaXQgPSB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB1c2Uoc2VsZiwgaGl0KVxuICAgIH1cbiAgICBpZiAoaGl0KSBoaXQgPSBoaXQudmFsdWVcbiAgfVxuICByZXR1cm4gaGl0XG59XG5cbmZ1bmN0aW9uIGlzU3RhbGUoc2VsZiwgaGl0KSB7XG4gIGlmICghaGl0IHx8ICghaGl0Lm1heEFnZSAmJiAhc2VsZi5fbWF4QWdlKSkgcmV0dXJuIGZhbHNlXG4gIHZhciBzdGFsZSA9IGZhbHNlO1xuICB2YXIgZGlmZiA9IERhdGUubm93KCkgLSBoaXQubm93XG4gIGlmIChoaXQubWF4QWdlKSB7XG4gICAgc3RhbGUgPSBkaWZmID4gaGl0Lm1heEFnZVxuICB9IGVsc2Uge1xuICAgIHN0YWxlID0gc2VsZi5fbWF4QWdlICYmIChkaWZmID4gc2VsZi5fbWF4QWdlKVxuICB9XG4gIHJldHVybiBzdGFsZTtcbn1cblxuZnVuY3Rpb24gdXNlIChzZWxmLCBoaXQpIHtcbiAgc2hpZnRMVShzZWxmLCBoaXQpXG4gIGhpdC5sdSA9IHNlbGYuX21ydSArK1xuICBzZWxmLl9scnVMaXN0W2hpdC5sdV0gPSBoaXRcbn1cblxuZnVuY3Rpb24gdHJpbSAoc2VsZikge1xuICB3aGlsZSAoc2VsZi5fbHJ1IDwgc2VsZi5fbXJ1ICYmIHNlbGYuX2xlbmd0aCA+IHNlbGYuX21heClcbiAgICBkZWwoc2VsZiwgc2VsZi5fbHJ1TGlzdFtzZWxmLl9scnVdKVxufVxuXG5mdW5jdGlvbiBzaGlmdExVIChzZWxmLCBoaXQpIHtcbiAgZGVsZXRlIHNlbGYuX2xydUxpc3RbIGhpdC5sdSBdXG4gIHdoaWxlIChzZWxmLl9scnUgPCBzZWxmLl9tcnUgJiYgIXNlbGYuX2xydUxpc3Rbc2VsZi5fbHJ1XSkgc2VsZi5fbHJ1ICsrXG59XG5cbmZ1bmN0aW9uIGRlbCAoc2VsZiwgaGl0KSB7XG4gIGlmIChoaXQpIHtcbiAgICBpZiAoc2VsZi5fZGlzcG9zZSkgc2VsZi5fZGlzcG9zZShoaXQua2V5LCBoaXQudmFsdWUpXG4gICAgc2VsZi5fbGVuZ3RoIC09IGhpdC5sZW5ndGhcbiAgICBzZWxmLl9pdGVtQ291bnQgLS1cbiAgICBkZWxldGUgc2VsZi5fY2FjaGVbIGhpdC5rZXkgXVxuICAgIHNoaWZ0TFUoc2VsZiwgaGl0KVxuICB9XG59XG5cbi8vIGNsYXNzeSwgc2luY2UgVjggcHJlZmVycyBwcmVkaWN0YWJsZSBvYmplY3RzLlxuZnVuY3Rpb24gRW50cnkgKGtleSwgdmFsdWUsIGx1LCBsZW5ndGgsIG5vdywgbWF4QWdlKSB7XG4gIHRoaXMua2V5ID0ga2V5XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB0aGlzLmx1ID0gbHVcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5ub3cgPSBub3dcbiAgaWYgKG1heEFnZSkgdGhpcy5tYXhBZ2UgPSBtYXhBZ2Vcbn1cblxufSkoKVxuIiwiLyohXG4gKiBtdXN0YWNoZS5qcyAtIExvZ2ljLWxlc3Mge3ttdXN0YWNoZX19IHRlbXBsYXRlcyB3aXRoIEphdmFTY3JpcHRcbiAqIGh0dHA6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanNcbiAqL1xuXG4vKmdsb2JhbCBkZWZpbmU6IGZhbHNlIE11c3RhY2hlOiB0cnVlKi9cblxuKGZ1bmN0aW9uIGRlZmluZU11c3RhY2hlIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmIHR5cGVvZiBleHBvcnRzLm5vZGVOYW1lICE9PSAnc3RyaW5nJykge1xuICAgIGZhY3RvcnkoZXhwb3J0cyk7IC8vIENvbW1vbkpTXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTsgLy8gQU1EXG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLk11c3RhY2hlID0ge307XG4gICAgZmFjdG9yeShNdXN0YWNoZSk7IC8vIHNjcmlwdCwgd3NoLCBhc3BcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiBtdXN0YWNoZUZhY3RvcnkgKG11c3RhY2hlKSB7XG5cbiAgdmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXlQb2x5ZmlsbCAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3JlIGNvcnJlY3QgdHlwZW9mIHN0cmluZyBoYW5kbGluZyBhcnJheVxuICAgKiB3aGljaCBub3JtYWxseSByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuICAgKi9cbiAgZnVuY3Rpb24gdHlwZVN0ciAob2JqKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdhcnJheScgOiB0eXBlb2Ygb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gIH1cblxuICAvKipcbiAgICogTnVsbCBzYWZlIHdheSBvZiBjaGVja2luZyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QsXG4gICAqIGluY2x1ZGluZyBpdHMgcHJvdG90eXBlLCBoYXMgYSBnaXZlbiBwcm9wZXJ0eVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzUHJvcGVydHkgKG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKHByb3BOYW1lIGluIG9iaik7XG4gIH1cblxuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2lzc3Vlcy5hcGFjaGUub3JnL2ppcmEvYnJvd3NlL0NPVUNIREItNTc3XG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg5XG4gIHZhciByZWdFeHBUZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xuICBmdW5jdGlvbiB0ZXN0UmVnRXhwIChyZSwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlZ0V4cFRlc3QuY2FsbChyZSwgc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBub25TcGFjZVJlID0gL1xcUy87XG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAoc3RyaW5nKSB7XG4gICAgcmV0dXJuICF0ZXN0UmVnRXhwKG5vblNwYWNlUmUsIHN0cmluZyk7XG4gIH1cblxuICB2YXIgZW50aXR5TWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7JyxcbiAgICAnLyc6ICcmI3gyRjsnXG4gIH07XG5cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoL1smPD5cIidcXC9dL2csIGZ1bmN0aW9uIGZyb21FbnRpdHlNYXAgKHMpIHtcbiAgICAgIHJldHVybiBlbnRpdHlNYXBbc107XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2hpdGVSZSA9IC9cXHMqLztcbiAgdmFyIHNwYWNlUmUgPSAvXFxzKy87XG4gIHZhciBlcXVhbHNSZSA9IC9cXHMqPS87XG4gIHZhciBjdXJseVJlID0gL1xccypcXH0vO1xuICB2YXIgdGFnUmUgPSAvI3xcXF58XFwvfD58XFx7fCZ8PXwhLztcblxuICAvKipcbiAgICogQnJlYWtzIHVwIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHN0cmluZyBpbnRvIGEgdHJlZSBvZiB0b2tlbnMuIElmIHRoZSBgdGFnc2BcbiAgICogYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvIHN0cmluZyB2YWx1ZXM6IHRoZVxuICAgKiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy4gWyBcIjwlXCIsIFwiJT5cIiBdKS4gT2ZcbiAgICogY291cnNlLCB0aGUgZGVmYXVsdCBpcyB0byB1c2UgbXVzdGFjaGVzIChpLmUuIG11c3RhY2hlLnRhZ3MpLlxuICAgKlxuICAgKiBBIHRva2VuIGlzIGFuIGFycmF5IHdpdGggYXQgbGVhc3QgNCBlbGVtZW50cy4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlXG4gICAqIG11c3RhY2hlIHN5bWJvbCB0aGF0IHdhcyB1c2VkIGluc2lkZSB0aGUgdGFnLCBlLmcuIFwiI1wiIG9yIFwiJlwiLiBJZiB0aGUgdGFnXG4gICAqIGRpZCBub3QgY29udGFpbiBhIHN5bWJvbCAoaS5lLiB7e215VmFsdWV9fSkgdGhpcyBlbGVtZW50IGlzIFwibmFtZVwiLiBGb3JcbiAgICogYWxsIHRleHQgdGhhdCBhcHBlYXJzIG91dHNpZGUgYSBzeW1ib2wgdGhpcyBlbGVtZW50IGlzIFwidGV4dFwiLlxuICAgKlxuICAgKiBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgYSB0b2tlbiBpcyBpdHMgXCJ2YWx1ZVwiLiBGb3IgbXVzdGFjaGUgdGFncyB0aGlzIGlzXG4gICAqIHdoYXRldmVyIGVsc2Ugd2FzIGluc2lkZSB0aGUgdGFnIGJlc2lkZXMgdGhlIG9wZW5pbmcgc3ltYm9sLiBGb3IgdGV4dCB0b2tlbnNcbiAgICogdGhpcyBpcyB0aGUgdGV4dCBpdHNlbGYuXG4gICAqXG4gICAqIFRoZSB0aGlyZCBhbmQgZm91cnRoIGVsZW1lbnRzIG9mIHRoZSB0b2tlbiBhcmUgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyxcbiAgICogcmVzcGVjdGl2ZWx5LCBvZiB0aGUgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlLlxuICAgKlxuICAgKiBUb2tlbnMgdGhhdCBhcmUgdGhlIHJvb3Qgbm9kZSBvZiBhIHN1YnRyZWUgY29udGFpbiB0d28gbW9yZSBlbGVtZW50czogMSkgYW5cbiAgICogYXJyYXkgb2YgdG9rZW5zIGluIHRoZSBzdWJ0cmVlIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlIGF0XG4gICAqIHdoaWNoIHRoZSBjbG9zaW5nIHRhZyBmb3IgdGhhdCBzZWN0aW9uIGJlZ2lucy5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgaWYgKCF0ZW1wbGF0ZSlcbiAgICAgIHJldHVybiBbXTtcblxuICAgIHZhciBzZWN0aW9ucyA9IFtdOyAgICAgLy8gU3RhY2sgdG8gaG9sZCBzZWN0aW9uIHRva2Vuc1xuICAgIHZhciB0b2tlbnMgPSBbXTsgICAgICAgLy8gQnVmZmVyIHRvIGhvbGQgdGhlIHRva2Vuc1xuICAgIHZhciBzcGFjZXMgPSBbXTsgICAgICAgLy8gSW5kaWNlcyBvZiB3aGl0ZXNwYWNlIHRva2VucyBvbiB0aGUgY3VycmVudCBsaW5lXG4gICAgdmFyIGhhc1RhZyA9IGZhbHNlOyAgICAvLyBJcyB0aGVyZSBhIHt7dGFnfX0gb24gdGhlIGN1cnJlbnQgbGluZT9cbiAgICB2YXIgbm9uU3BhY2UgPSBmYWxzZTsgIC8vIElzIHRoZXJlIGEgbm9uLXNwYWNlIGNoYXIgb24gdGhlIGN1cnJlbnQgbGluZT9cblxuICAgIC8vIFN0cmlwcyBhbGwgd2hpdGVzcGFjZSB0b2tlbnMgYXJyYXkgZm9yIHRoZSBjdXJyZW50IGxpbmVcbiAgICAvLyBpZiB0aGVyZSB3YXMgYSB7eyN0YWd9fSBvbiBpdCBhbmQgb3RoZXJ3aXNlIG9ubHkgc3BhY2UuXG4gICAgZnVuY3Rpb24gc3RyaXBTcGFjZSAoKSB7XG4gICAgICBpZiAoaGFzVGFnICYmICFub25TcGFjZSkge1xuICAgICAgICB3aGlsZSAoc3BhY2VzLmxlbmd0aClcbiAgICAgICAgICBkZWxldGUgdG9rZW5zW3NwYWNlcy5wb3AoKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGFjZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaGFzVGFnID0gZmFsc2U7XG4gICAgICBub25TcGFjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvcGVuaW5nVGFnUmUsIGNsb3NpbmdUYWdSZSwgY2xvc2luZ0N1cmx5UmU7XG4gICAgZnVuY3Rpb24gY29tcGlsZVRhZ3MgKHRhZ3NUb0NvbXBpbGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnc1RvQ29tcGlsZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHRhZ3NUb0NvbXBpbGUgPSB0YWdzVG9Db21waWxlLnNwbGl0KHNwYWNlUmUsIDIpO1xuXG4gICAgICBpZiAoIWlzQXJyYXkodGFnc1RvQ29tcGlsZSkgfHwgdGFnc1RvQ29tcGlsZS5sZW5ndGggIT09IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWdzOiAnICsgdGFnc1RvQ29tcGlsZSk7XG5cbiAgICAgIG9wZW5pbmdUYWdSZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMF0pICsgJ1xcXFxzKicpO1xuICAgICAgY2xvc2luZ1RhZ1JlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzFdKSk7XG4gICAgICBjbG9zaW5nQ3VybHlSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAoJ30nICsgdGFnc1RvQ29tcGlsZVsxXSkpO1xuICAgIH1cblxuICAgIGNvbXBpbGVUYWdzKHRhZ3MgfHwgbXVzdGFjaGUudGFncyk7XG5cbiAgICB2YXIgc2Nhbm5lciA9IG5ldyBTY2FubmVyKHRlbXBsYXRlKTtcblxuICAgIHZhciBzdGFydCwgdHlwZSwgdmFsdWUsIGNociwgdG9rZW4sIG9wZW5TZWN0aW9uO1xuICAgIHdoaWxlICghc2Nhbm5lci5lb3MoKSkge1xuICAgICAgc3RhcnQgPSBzY2FubmVyLnBvcztcblxuICAgICAgLy8gTWF0Y2ggYW55IHRleHQgYmV0d2VlbiB0YWdzLlxuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChvcGVuaW5nVGFnUmUpO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpIDwgdmFsdWVMZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNociA9IHZhbHVlLmNoYXJBdChpKTtcblxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2hyKSkge1xuICAgICAgICAgICAgc3BhY2VzLnB1c2godG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbnMucHVzaChbICd0ZXh0JywgY2hyLCBzdGFydCwgc3RhcnQgKyAxIF0pO1xuICAgICAgICAgIHN0YXJ0ICs9IDE7XG5cbiAgICAgICAgICAvLyBDaGVjayBmb3Igd2hpdGVzcGFjZSBvbiB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgICAgIGlmIChjaHIgPT09ICdcXG4nKVxuICAgICAgICAgICAgc3RyaXBTcGFjZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1hdGNoIHRoZSBvcGVuaW5nIHRhZy5cbiAgICAgIGlmICghc2Nhbm5lci5zY2FuKG9wZW5pbmdUYWdSZSkpXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBoYXNUYWcgPSB0cnVlO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB0eXBlLlxuICAgICAgdHlwZSA9IHNjYW5uZXIuc2Nhbih0YWdSZSkgfHwgJ25hbWUnO1xuICAgICAgc2Nhbm5lci5zY2FuKHdoaXRlUmUpO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB2YWx1ZS5cbiAgICAgIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhbihlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdDdXJseVJlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuKGN1cmx5UmUpO1xuICAgICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgICB0eXBlID0gJyYnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0aGUgY2xvc2luZyB0YWcuXG4gICAgICBpZiAoIXNjYW5uZXIuc2NhbihjbG9zaW5nVGFnUmUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHRhZyBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gICAgICB0b2tlbiA9IFsgdHlwZSwgdmFsdWUsIHN0YXJ0LCBzY2FubmVyLnBvcyBdO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJyMnIHx8IHR5cGUgPT09ICdeJykge1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJy8nKSB7XG4gICAgICAgIC8vIENoZWNrIHNlY3Rpb24gbmVzdGluZy5cbiAgICAgICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICAgICAgICBpZiAoIW9wZW5TZWN0aW9uKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5vcGVuZWQgc2VjdGlvbiBcIicgKyB2YWx1ZSArICdcIiBhdCAnICsgc3RhcnQpO1xuXG4gICAgICAgIGlmIChvcGVuU2VjdGlvblsxXSAhPT0gdmFsdWUpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICduYW1lJyB8fCB0eXBlID09PSAneycgfHwgdHlwZSA9PT0gJyYnKSB7XG4gICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICAgIC8vIFNldCB0aGUgdGFncyBmb3IgdGhlIG5leHQgdGltZSBhcm91bmQuXG4gICAgICAgIGNvbXBpbGVUYWdzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIG9wZW4gc2VjdGlvbnMgd2hlbiB3ZSdyZSBkb25lLlxuICAgIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgICBpZiAob3BlblNlY3Rpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICAgIHJldHVybiBuZXN0VG9rZW5zKHNxdWFzaFRva2Vucyh0b2tlbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lcyB0aGUgdmFsdWVzIG9mIGNvbnNlY3V0aXZlIHRleHQgdG9rZW5zIGluIHRoZSBnaXZlbiBgdG9rZW5zYCBhcnJheVxuICAgKiB0byBhIHNpbmdsZSB0b2tlbi5cbiAgICovXG4gIGZ1bmN0aW9uIHNxdWFzaFRva2VucyAodG9rZW5zKSB7XG4gICAgdmFyIHNxdWFzaGVkVG9rZW5zID0gW107XG5cbiAgICB2YXIgdG9rZW4sIGxhc3RUb2tlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlblswXSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbiAmJiBsYXN0VG9rZW5bMF0gPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGxhc3RUb2tlblsxXSArPSB0b2tlblsxXTtcbiAgICAgICAgICBsYXN0VG9rZW5bM10gPSB0b2tlblszXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcXVhc2hlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcXVhc2hlZFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtcyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgaW50byBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZSB3aGVyZVxuICAgKiB0b2tlbnMgdGhhdCByZXByZXNlbnQgYSBzZWN0aW9uIGhhdmUgdHdvIGFkZGl0aW9uYWwgaXRlbXM6IDEpIGFuIGFycmF5IG9mXG4gICAqIGFsbCB0b2tlbnMgdGhhdCBhcHBlYXIgaW4gdGhhdCBzZWN0aW9uIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsXG4gICAqIHRlbXBsYXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIHRoYXQgc2VjdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG5lc3RUb2tlbnMgKHRva2Vucykge1xuICAgIHZhciBuZXN0ZWRUb2tlbnMgPSBbXTtcbiAgICB2YXIgY29sbGVjdG9yID0gbmVzdGVkVG9rZW5zO1xuICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuXG4gICAgdmFyIHRva2VuLCBzZWN0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICBjYXNlICcjJzpcbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgICBjb2xsZWN0b3IgPSB0b2tlbls0XSA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICBzZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG4gICAgICAgIHNlY3Rpb25bNV0gPSB0b2tlblsyXTtcbiAgICAgICAgY29sbGVjdG9yID0gc2VjdGlvbnMubGVuZ3RoID4gMCA/IHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdWzRdIDogbmVzdGVkVG9rZW5zO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVzdGVkVG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxlIHN0cmluZyBzY2FubmVyIHRoYXQgaXMgdXNlZCBieSB0aGUgdGVtcGxhdGUgcGFyc2VyIHRvIGZpbmRcbiAgICogdG9rZW5zIGluIHRlbXBsYXRlIHN0cmluZ3MuXG4gICAqL1xuICBmdW5jdGlvbiBTY2FubmVyIChzdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnRhaWwgPSBzdHJpbmc7XG4gICAgdGhpcy5wb3MgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB0YWlsIGlzIGVtcHR5IChlbmQgb2Ygc3RyaW5nKS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLmVvcyA9IGZ1bmN0aW9uIGVvcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFpbCA9PT0gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWVzIHRvIG1hdGNoIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqIFJldHVybnMgdGhlIG1hdGNoZWQgdGV4dCBpZiBpdCBjYW4gbWF0Y2gsIHRoZSBlbXB0eSBzdHJpbmcgb3RoZXJ3aXNlLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbiA9IGZ1bmN0aW9uIHNjYW4gKHJlKSB7XG4gICAgdmFyIG1hdGNoID0gdGhpcy50YWlsLm1hdGNoKHJlKTtcblxuICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggIT09IDApXG4gICAgICByZXR1cm4gJyc7XG5cbiAgICB2YXIgc3RyaW5nID0gbWF0Y2hbMF07XG5cbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpO1xuICAgIHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTa2lwcyBhbGwgdGV4dCB1bnRpbCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGNhbiBiZSBtYXRjaGVkLiBSZXR1cm5zXG4gICAqIHRoZSBza2lwcGVkIHN0cmluZywgd2hpY2ggaXMgdGhlIGVudGlyZSB0YWlsIGlmIG5vIG1hdGNoIGNhbiBiZSBtYWRlLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblVudGlsID0gZnVuY3Rpb24gc2NhblVudGlsIChyZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudGFpbC5zZWFyY2gocmUpLCBtYXRjaDtcblxuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICBjYXNlIC0xOlxuICAgICAgbWF0Y2ggPSB0aGlzLnRhaWw7XG4gICAgICB0aGlzLnRhaWwgPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMDpcbiAgICAgIG1hdGNoID0gJyc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbWF0Y2ggPSB0aGlzLnRhaWwuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIH1cblxuICAgIHRoaXMucG9zICs9IG1hdGNoLmxlbmd0aDtcblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHJlbmRlcmluZyBjb250ZXh0IGJ5IHdyYXBwaW5nIGEgdmlldyBvYmplY3QgYW5kXG4gICAqIG1haW50YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIENvbnRleHQgKHZpZXcsIHBhcmVudENvbnRleHQpIHtcbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIHRoaXMuY2FjaGUgPSB7ICcuJzogdGhpcy52aWV3IH07XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29udGV4dCB1c2luZyB0aGUgZ2l2ZW4gdmlldyB3aXRoIHRoaXMgY29udGV4dFxuICAgKiBhcyB0aGUgcGFyZW50LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKHZpZXcpIHtcbiAgICByZXR1cm4gbmV3IENvbnRleHQodmlldywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoaXMgY29udGV4dCwgdHJhdmVyc2luZ1xuICAgKiB1cCB0aGUgY29udGV4dCBoaWVyYXJjaHkgaWYgdGhlIHZhbHVlIGlzIGFic2VudCBpbiB0aGlzIGNvbnRleHQncyB2aWV3LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gbG9va3VwIChuYW1lKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcblxuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHZhbHVlID0gY2FjaGVbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgbmFtZXMsIGluZGV4LCBsb29rdXBIaXQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignLicpID4gMCkge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dC52aWV3O1xuICAgICAgICAgIG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgIGluZGV4ID0gMDtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzaW5nIHRoZSBkb3Qgbm90aW9uIHBhdGggaW4gYG5hbWVgLCB3ZSBkZXNjZW5kIHRocm91Z2ggdGhlXG4gICAgICAgICAgICogbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUbyBiZSBjZXJ0YWluIHRoYXQgdGhlIGxvb2t1cCBoYXMgYmVlbiBzdWNjZXNzZnVsLCB3ZSBoYXZlIHRvXG4gICAgICAgICAgICogY2hlY2sgaWYgdGhlIGxhc3Qgb2JqZWN0IGluIHRoZSBwYXRoIGFjdHVhbGx5IGhhcyB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgKiB3ZSBhcmUgbG9va2luZyBmb3IuIFdlIHN0b3JlIHRoZSByZXN1bHQgaW4gYGxvb2t1cEhpdGAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGlzIGlzIHNwZWNpYWxseSBuZWNlc3NhcnkgZm9yIHdoZW4gdGhlIHZhbHVlIGhhcyBiZWVuIHNldCB0b1xuICAgICAgICAgICAqIGB1bmRlZmluZWRgIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGxvb2tpbmcgdXAgcGFyZW50IGNvbnRleHRzLlxuICAgICAgICAgICAqKi9cbiAgICAgICAgICB3aGlsZSAodmFsdWUgIT0gbnVsbCAmJiBpbmRleCA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBuYW1lcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICBsb29rdXBIaXQgPSBoYXNQcm9wZXJ0eSh2YWx1ZSwgbmFtZXNbaW5kZXhdKTtcblxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtuYW1lc1tpbmRleCsrXV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dC52aWV3W25hbWVdO1xuICAgICAgICAgIGxvb2t1cEhpdCA9IGhhc1Byb3BlcnR5KGNvbnRleHQudmlldywgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va3VwSGl0KVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgY2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpXG4gICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwodGhpcy52aWV3KTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQSBXcml0ZXIga25vd3MgaG93IHRvIHRha2UgYSBzdHJlYW0gb2YgdG9rZW5zIGFuZCByZW5kZXIgdGhlbSB0byBhXG4gICAqIHN0cmluZywgZ2l2ZW4gYSBjb250ZXh0LiBJdCBhbHNvIG1haW50YWlucyBhIGNhY2hlIG9mIHRlbXBsYXRlcyB0b1xuICAgKiBhdm9pZCB0aGUgbmVlZCB0byBwYXJzZSB0aGUgc2FtZSB0ZW1wbGF0ZSB0d2ljZS5cbiAgICovXG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGlzIHdyaXRlci5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHRva2Vuc1xuICAgKiB0aGF0IGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBwYXJzZS5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgIHZhciB0b2tlbnMgPSBjYWNoZVt0ZW1wbGF0ZV07XG5cbiAgICBpZiAodG9rZW5zID09IG51bGwpXG4gICAgICB0b2tlbnMgPSBjYWNoZVt0ZW1wbGF0ZV0gPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0YWdzKTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZ2gtbGV2ZWwgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgd2l0aFxuICAgKiB0aGUgZ2l2ZW4gYHZpZXdgLlxuICAgKlxuICAgKiBUaGUgb3B0aW9uYWwgYHBhcnRpYWxzYCBhcmd1bWVudCBtYXkgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlXG4gICAqIG5hbWVzIGFuZCB0ZW1wbGF0ZXMgb2YgcGFydGlhbHMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGVtcGxhdGUuIEl0IG1heVxuICAgKiBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGxvYWQgcGFydGlhbCB0ZW1wbGF0ZXMgb24gdGhlIGZseVxuICAgKiB0aGF0IHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50OiB0aGUgbmFtZSBvZiB0aGUgcGFydGlhbC5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpIHtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgdmFyIGNvbnRleHQgPSAodmlldyBpbnN0YW5jZW9mIENvbnRleHQpID8gdmlldyA6IG5ldyBDb250ZXh0KHZpZXcpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCB0ZW1wbGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvdy1sZXZlbCBtZXRob2QgdGhhdCByZW5kZXJzIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCB1c2luZ1xuICAgKiB0aGUgZ2l2ZW4gYGNvbnRleHRgIGFuZCBgcGFydGlhbHNgLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgYG9yaWdpbmFsVGVtcGxhdGVgIGlzIG9ubHkgZXZlciB1c2VkIHRvIGV4dHJhY3QgdGhlIHBvcnRpb25cbiAgICogb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgd2FzIGNvbnRhaW5lZCBpbiBhIGhpZ2hlci1vcmRlciBzZWN0aW9uLlxuICAgKiBJZiB0aGUgdGVtcGxhdGUgZG9lc24ndCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLCB0aGlzIGFyZ3VtZW50IG1heVxuICAgKiBiZSBvbWl0dGVkLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbnMgPSBmdW5jdGlvbiByZW5kZXJUb2tlbnMgKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgYnVmZmVyID0gJyc7XG5cbiAgICB2YXIgdG9rZW4sIHN5bWJvbCwgdmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIHN5bWJvbCA9IHRva2VuWzBdO1xuXG4gICAgICBpZiAoc3ltYm9sID09PSAnIycpIHZhbHVlID0gdGhpcy5yZW5kZXJTZWN0aW9uKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICdeJykgdmFsdWUgPSB0aGlzLnJlbmRlckludmVydGVkKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICc+JykgdmFsdWUgPSB0aGlzLnJlbmRlclBhcnRpYWwodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJyYnKSB2YWx1ZSA9IHRoaXMudW5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnbmFtZScpIHZhbHVlID0gdGhpcy5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAndGV4dCcpIHZhbHVlID0gdGhpcy5yYXdWYWx1ZSh0b2tlbik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBidWZmZXIgKz0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiByZW5kZXJTZWN0aW9uICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZW5kZXIgYW4gYXJiaXRyYXJ5IHRlbXBsYXRlXG4gICAgLy8gaW4gdGhlIGN1cnJlbnQgY29udGV4dCBieSBoaWdoZXItb3JkZXIgc2VjdGlvbnMuXG4gICAgZnVuY3Rpb24gc3ViUmVuZGVyICh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHNlbGYucmVuZGVyKHRlbXBsYXRlLCBjb250ZXh0LCBwYXJ0aWFscyk7XG4gICAgfVxuXG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGogPCB2YWx1ZUxlbmd0aDsgKytqKSB7XG4gICAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlW2pdKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUZW1wbGF0ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMgd2l0aG91dCB0aGUgb3JpZ2luYWwgdGVtcGxhdGUnKTtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgcG9ydGlvbiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB0aGUgc2VjdGlvbiBjb250YWlucy5cbiAgICAgIHZhbHVlID0gdmFsdWUuY2FsbChjb250ZXh0LnZpZXcsIG9yaWdpbmFsVGVtcGxhdGUuc2xpY2UodG9rZW5bM10sIHRva2VuWzVdKSwgc3ViUmVuZGVyKTtcblxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJJbnZlcnRlZCA9IGZ1bmN0aW9uIHJlbmRlckludmVydGVkICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgICAvLyBVc2UgSmF2YVNjcmlwdCdzIGRlZmluaXRpb24gb2YgZmFsc3kuIEluY2x1ZGUgZW1wdHkgYXJyYXlzLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg2XG4gICAgaWYgKCF2YWx1ZSB8fCAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSlcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyUGFydGlhbCA9IGZ1bmN0aW9uIHJlbmRlclBhcnRpYWwgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscykge1xuICAgIGlmICghcGFydGlhbHMpIHJldHVybjtcblxuICAgIHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24ocGFydGlhbHMpID8gcGFydGlhbHModG9rZW5bMV0pIDogcGFydGlhbHNbdG9rZW5bMV1dO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRoaXMucGFyc2UodmFsdWUpLCBjb250ZXh0LCBwYXJ0aWFscywgdmFsdWUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUudW5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiB1bmVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiBlc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIG11c3RhY2hlLmVzY2FwZSh2YWx1ZSk7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yYXdWYWx1ZSA9IGZ1bmN0aW9uIHJhd1ZhbHVlICh0b2tlbikge1xuICAgIHJldHVybiB0b2tlblsxXTtcbiAgfTtcblxuICBtdXN0YWNoZS5uYW1lID0gJ211c3RhY2hlLmpzJztcbiAgbXVzdGFjaGUudmVyc2lvbiA9ICcyLjIuMCc7XG4gIG11c3RhY2hlLnRhZ3MgPSBbICd7eycsICd9fScgXTtcblxuICAvLyBBbGwgaGlnaC1sZXZlbCBtdXN0YWNoZS4qIGZ1bmN0aW9ucyB1c2UgdGhpcyB3cml0ZXIuXG4gIHZhciBkZWZhdWx0V3JpdGVyID0gbmV3IFdyaXRlcigpO1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhlIGRlZmF1bHQgd3JpdGVyLlxuICAgKi9cbiAgbXVzdGFjaGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLmNsZWFyQ2FjaGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIHRlbXBsYXRlIGluIHRoZSBkZWZhdWx0IHdyaXRlciBhbmQgcmV0dXJucyB0aGVcbiAgICogYXJyYXkgb2YgdG9rZW5zIGl0IGNvbnRhaW5zLiBEb2luZyB0aGlzIGFoZWFkIG9mIHRpbWUgYXZvaWRzIHRoZSBuZWVkIHRvXG4gICAqIHBhcnNlIHRlbXBsYXRlcyBvbiB0aGUgZmx5IGFzIHRoZXkgYXJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVzdGFjaGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGB0ZW1wbGF0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHZpZXdgIGFuZCBgcGFydGlhbHNgIHVzaW5nIHRoZVxuICAgKiBkZWZhdWx0IHdyaXRlci5cbiAgICovXG4gIG11c3RhY2hlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGVtcGxhdGUhIFRlbXBsYXRlIHNob3VsZCBiZSBhIFwic3RyaW5nXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdidXQgXCInICsgdHlwZVN0cih0ZW1wbGF0ZSkgKyAnXCIgd2FzIGdpdmVuIGFzIHRoZSBmaXJzdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50IGZvciBtdXN0YWNoZSNyZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKScpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLnJlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjQueC4sXG4gIC8qZXNsaW50LWRpc2FibGUgKi8gLy8gZXNsaW50IHdhbnRzIGNhbWVsIGNhc2VkIGZ1bmN0aW9uIG5hbWVcbiAgbXVzdGFjaGUudG9faHRtbCA9IGZ1bmN0aW9uIHRvX2h0bWwgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgc2VuZCkge1xuICAgIC8qZXNsaW50LWVuYWJsZSovXG5cbiAgICB2YXIgcmVzdWx0ID0gbXVzdGFjaGUucmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihzZW5kKSkge1xuICAgICAgc2VuZChyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIGVzY2FwaW5nIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIHVzZXIgbWF5IG92ZXJyaWRlIGl0LlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzI0NFxuICBtdXN0YWNoZS5lc2NhcGUgPSBlc2NhcGVIdG1sO1xuXG4gIC8vIEV4cG9ydCB0aGVzZSBtYWlubHkgZm9yIHRlc3RpbmcsIGJ1dCBhbHNvIGZvciBhZHZhbmNlZCB1c2FnZS5cbiAgbXVzdGFjaGUuU2Nhbm5lciA9IFNjYW5uZXI7XG4gIG11c3RhY2hlLkNvbnRleHQgPSBDb250ZXh0O1xuICBtdXN0YWNoZS5Xcml0ZXIgPSBXcml0ZXI7XG5cbn0pKTtcbiIsIi8qIG9iamVjdC1pdGVyYXRvcnMuanMgLSBNaW5pIFVuZGVyc2NvcmUgbGlicmFyeVxuICogYnkgSm9uYXRoYW4gRWl0ZW5cbiAqXG4gKiBUaGUgbWV0aG9kcyBiZWxvdyBvcGVyYXRlIG9uIG9iamVjdHMgKGJ1dCBub3QgYXJyYXlzKSBzaW1pbGFybHlcbiAqIHRvIFVuZGVyc2NvcmUgKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNjb2xsZWN0aW9ucykuXG4gKlxuICogUmVjb21tZW5kZWQgdXNhZ2U6XG4gKlxuICogICAgdmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN1bW1hcnkgV3JhcCBhbiBvYmplY3QgZm9yIG9uZSBtZXRob2QuXG4gKiBARGVzYyBOb3RlIHRoYXQgdGhlIGBuZXdgIGtleXdvcmQgaXMgbm90IG5lY2Vzc2FyeS5cbiAqIEBwYXJhbSB7b2JqZWN0fG51bGx8dW5kZWZpbmVkfSBvYmplY3QgLSBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgaXMgdHJlYXRlZCBhcyBhbiBlbXB0eSBwbGFpbiBvYmplY3QuXG4gKiBAcmV0dXJuIHtXcmFwcGVyfSBUaGUgd3JhcHBlZCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIFdyYXBwZXIob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyYXBwZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JhcHBlcihvYmplY3QpO1xuICAgIH1cbiAgICB0aGlzLm9yaWdpbmFsVmFsdWUgPSBvYmplY3Q7XG4gICAgdGhpcy5vID0gb2JqZWN0IHx8IHt9O1xufVxuXG4vKipcbiAqIEBuYW1lIFdyYXBwZXIuY2hhaW5cbiAqIEBzdW1tYXJ5IFdyYXAgYW4gb2JqZWN0IGZvciBhIGNoYWluIG9mIG1ldGhvZHMuXG4gKiBARGVzYyBDYWxscyB0aGUgY29uc3RydWN0b3IgYFdyYXBwZXIoKWAgYW5kIG1vZGlmaWVzIHRoZSB3cmFwcGVyIGZvciBjaGFpbmluZy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge1dyYXBwZXJ9IFRoZSB3cmFwcGVkIG9iamVjdC5cbiAqL1xuV3JhcHBlci5jaGFpbiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgd3JhcHBlZCA9IFdyYXBwZXIob2JqZWN0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgd3JhcHBlZC5jaGFpbmluZyA9IHRydWU7XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG59O1xuXG5XcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBVbndyYXAgYW4gb2JqZWN0IHdyYXBwZWQgd2l0aCB7QGxpbmsgV3JhcHBlci5jaGFpbnxXcmFwcGVyLmNoYWluKCl9LlxuICAgICAqIEByZXR1cm4ge29iamVjdHxudWxsfHVuZGVmaW5lZH0gVGhlIHZhbHVlIG9yaWdpbmFsbHkgd3JhcHBlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbZWFjaF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI2VhY2gpIG1ldGhvZDogSXRlcmF0ZSBvdmVyIHRoZSBtZW1iZXJzIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgY2FsbGluZyBgaXRlcmF0ZWUoKWAgd2l0aCBlYWNoLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IGAodmFsdWUsIGtleSwgb2JqZWN0KWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBpcyB1bmRlZmluZWQ7IGFuIGAuZWFjaGAgbG9vcCBjYW5ub3QgYmUgYnJva2VuIG91dCBvZiAodXNlIHtAbGluayBXcmFwcGVyI2ZpbmR8LmZpbmR9IGluc3RlYWQpLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYGl0ZXJhdGVlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHtXcmFwcGVyfSBUaGUgd3JhcHBlZCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uIChpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubztcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgbztcbiAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpdGVyYXRlZS5jYWxsKGNvbnRleHQsIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtmaW5kXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jZmluZCkgbWV0aG9kOiBMb29rIHRocm91Z2ggZWFjaCBtZW1iZXIgb2YgdGhlIHdyYXBwZWQgb2JqZWN0LCByZXR1cm5pbmcgdGhlIGZpcnN0IG9uZSB0aGF0IHBhc3NlcyBhIHRydXRoIHRlc3QgKHByZWRpY2F0ZSksIG9yIGB1bmRlZmluZWRgIGlmIG5vIHZhbHVlIHBhc3NlcyB0aGUgdGVzdC4gVGhlIGZ1bmN0aW9uIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBhY2NlcHRhYmxlIG1lbWJlciwgYW5kIGRvZXNuJ3QgbmVjZXNzYXJpbHkgdHJhdmVyc2UgdGhlIGVudGlyZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJlZGljYXRlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IGAodmFsdWUsIGtleSwgb2JqZWN0KWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgdHJ1dGh5IGlmIHRoZSBtZW1iZXIgcGFzc2VzIHRoZSB0ZXN0IGFuZCBmYWxzeSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIElmIGdpdmVuLCBgcHJlZGljYXRlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYHByZWRpY2F0ZWAuIChPdGhlcndpc2UsIHRoZSBgdGhpc2AgdmFsdWUgd2lsbCBiZSB0aGUgdW53cmFwcGVkIG9iamVjdC4pXG4gICAgICogQHJldHVybiB7Kn0gVGhlIGZvdW5kIHByb3BlcnR5J3MgdmFsdWUuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZmluZDogZnVuY3Rpb24gKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubztcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgbztcbiAgICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5rZXlzKG8pLmZpbmQoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9bcmVzdWx0XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbcmVkdWNlXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jcmVkdWNlKSBtZXRob2Q6IEJvaWwgZG93biB0aGUgdmFsdWVzIG9mIGFsbCB0aGUgbWVtYmVycyBvZiB0aGUgd3JhcHBlZCBvYmplY3QgaW50byBhIHNpbmdsZSB2YWx1ZS4gYG1lbW9gIGlzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24sIGFuZCBlYWNoIHN1Y2Nlc3NpdmUgc3RlcCBvZiBpdCBzaG91bGQgYmUgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlKClgLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogYChtZW1vLCB2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgdGhlIG5ldyB2YWx1ZSBvZiBgbWVtb2AgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFttZW1vXSAtIElmIG5vIG1lbW8gaXMgcGFzc2VkIHRvIHRoZSBpbml0aWFsIGludm9jYXRpb24gb2YgcmVkdWNlLCB0aGUgaXRlcmF0ZWUgaXMgbm90IGludm9rZWQgb24gdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3QuIFRoZSBmaXJzdCBlbGVtZW50IGlzIGluc3RlYWQgcGFzc2VkIGFzIHRoZSBtZW1vIGluIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBpdGVyYXRlZSBvbiB0aGUgbmV4dCBlbGVtZW50IGluIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYGl0ZXJhdGVlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgb2YgYG1lbW9gIFwicmVkdWNlZFwiIGFzIHBlciBgaXRlcmF0ZWVgLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlZHVjZTogZnVuY3Rpb24gKGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBvO1xuICAgICAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGlkeCkge1xuICAgICAgICAgICAgbWVtbyA9ICghaWR4ICYmIG1lbW8gPT09IHVuZGVmaW5lZCkgPyBvW2tleV0gOiBpdGVyYXRlZS5jYWxsKGNvbnRleHQsIG1lbW8sIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtleHRlbmRdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNleHRlbmQpIG1ldGhvZDogQ29weSBhbGwgb2YgdGhlIHByb3BlcnRpZXMgaW4gZWFjaCBvZiB0aGUgYHNvdXJjZWAgb2JqZWN0IHBhcmFtZXRlcihzKSBvdmVyIHRvIHRoZSAod3JhcHBlZCkgZGVzdGluYXRpb24gb2JqZWN0ICh0aHVzIG11dGF0aW5nIGl0KS4gSXQncyBpbi1vcmRlciwgc28gdGhlIHByb3BlcnRpZXMgb2YgdGhlIGxhc3QgYHNvdXJjZWAgb2JqZWN0IHdpbGwgb3ZlcnJpZGUgcHJvcGVydGllcyB3aXRoIHRoZSBzYW1lIG5hbWUgaW4gcHJldmlvdXMgYXJndW1lbnRzIG9yIGluIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogPiBUaGlzIG1ldGhvZCBjb3BpZXMgb3duIG1lbWJlcnMgYXMgd2VsbCBhcyBtZW1iZXJzIGluaGVyaXRlZCBmcm9tIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgKiBAcGFyYW0gey4uLm9iamVjdHxudWxsfHVuZGVmaW5lZH0gc291cmNlIC0gVmFsdWVzIG9mIGBudWxsYCBvciBgdW5kZWZpbmVkYCBhcmUgdHJlYXRlZCBhcyBlbXB0eSBwbGFpbiBvYmplY3RzLlxuICAgICAqIEByZXR1cm4ge1dyYXBwZXJ8b2JqZWN0fSBUaGUgd3JhcHBlZCBkZXN0aW5hdGlvbiBvYmplY3QgaWYgY2hhaW5pbmcgaXMgaW4gZWZmZWN0OyBvdGhlcndpc2UgdGhlIHVud3JhcHBlZCBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZXh0ZW5kOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb1trZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW5pbmcgPyB0aGlzIDogbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbZXh0ZW5kT3duXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jZXh0ZW5kT3duKSBtZXRob2Q6IExpa2Uge0BsaW5rIFdyYXBwZXIjZXh0ZW5kfGV4dGVuZH0sIGJ1dCBvbmx5IGNvcGllcyBpdHMgXCJvd25cIiBwcm9wZXJ0aWVzIG92ZXIgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLm9iamVjdHxudWxsfHVuZGVmaW5lZH0gc291cmNlIC0gVmFsdWVzIG9mIGBudWxsYCBvciBgdW5kZWZpbmVkYCBhcmUgdHJlYXRlZCBhcyBlbXB0eSBwbGFpbiBvYmplY3RzLlxuICAgICAqIEByZXR1cm4ge1dyYXBwZXJ8b2JqZWN0fSBUaGUgd3JhcHBlZCBkZXN0aW5hdGlvbiBvYmplY3QgaWYgY2hhaW5pbmcgaXMgaW4gZWZmZWN0OyBvdGhlcndpc2UgdGhlIHVud3JhcHBlZCBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZXh0ZW5kT3duOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgV3JhcHBlcihvYmplY3QpLmVhY2goZnVuY3Rpb24gKHZhbCwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgICAgICAgICAgICAgIG9ba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW5pbmcgPyB0aGlzIDogbztcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyYXBwZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG4vKiBbT05DRSBDQUxMSU5HIENPREUgSVMgVVBEQVRFRCBBTkQgVEVTVEVELCBSRU1PVkUgVEhJUyBDT01NRU5UICsgQUxMIExJTkVTIENPTlRBSU5JTkcgXCJGb3JtZXJseS4uLlwiXVxuICogVGhpcyBtb2R1bGUgcmVjdGFuZ3VsYXIuanMgZGlmZmVycyBmcm9tIHByZWRlY2Vzc29yIGZpbi1yZWN0YW5nbGUuanMgYXMgZm9sbG93czpcbiAqIDEuIEluc3RlYWQgb2YgY3JlYXRpbmcgUG9seW1lciBjb21wb25lbnQgYGZpbi1yZWN0YW5nbGVzYCwgbm93IGRvZXMgb25lIG9mIGZvbGxvd2luZzpcbiAqICBhLiBJZiBvYmplY3QgYGV4cG9ydHNgIGV4aXN0czogQWRkcyBvYmplY3QgYXMgbmV3IHByb3BlcnR5IGBleHBvcnRzLnJlY3Rhbmd1bGFyYFxuICogICAgIHRodXMgc3VwcG9ydGluZyBOb2RlIGFzIHdlbGwgYXMgZmlsZSBidW5kbGluZyBieSBCcm93c2VyaWZ5LlxuICogIGIuIElmIG9iamVjdCBgZXhwb3J0c2AgZG9lcyBub3QgZXhpc3Q6IEFkZHMgb2JqZWN0IGFzIG5ldyBwcm9wZXJ0eVxuICogICAgIGB3aW5kb3cuZmluLnJlY3Rhbmd1bGFyYCAoZmlyc3QgY3JlYXRpbmcgb2JqZWN0IGB3aW5kb3cuZmluYCBpZiBuZWNlc3NhcnkpXG4gKiAgICAgdGh1cyBzdXBwb3J0aW5nIGNsaWVudC1zaWRlIGluY2x1c2lvbiB2aWEgPHNjcmlwdD4gdGFnLlxuICogMi4gRmlsZSB3YXMgcmVvcmdhbml6ZWQgdG8gdXNlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2Ugc286XG4gKiAgYS4gY2hhbmdlICdyZWN0YW5nbGVzLnBvaW50LmNyZWF0ZSgnIHRvICduZXcgcmVjdGFuZ3VsYXIuUG9pbnQoJ1xuICogIGIuIGNoYW5nZSAncmVjdGFuZ2xlcy5yZWN0YW5nbGUuY3JlYXRlKCcgdG8gJ25ldyByZWN0YW5ndWxhci5SZWN0YW5nbGUoJ1xuICogMy4gQ2hhbmdlIGFsbCBpbnN0YW5jZXMgb2YgJ1RoYW5FcXVhbFRvJyB0byAnVGhhbk9yRXF1YWxUbydcbiAqIDQuIENoYW5nZSBhbGwgaW52b2NhdGlvbnMgb2YgUmVjdGFuZ2xlLnRvcCwgLmxlZnQsIC5ib3R0b20sIC5yaWdodCwgLndpZHRoLFxuICogICAgLmhlaWdodCwgYW5kIC5hcmVhIHRvIGdldHRlciByZWZlcmVuY2VzIGJ5IHJlbW92aW5nIHRoZSBpbnZvY2F0aW9uIG9wZXJhdG9yXG4gKiAgICAoaS5lLiwgdGhlIHBhcmVudGhlc2VzKS5cbiAqL1xuXG4oZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXG4gICAgLy8gVGhpcyBjbG9zdXJlIHN1cHBvcnRzIE5vZGVKUy1sZXNzIGNsaWVudCBzaWRlIGluY2x1ZGVzIHdpdGggPHNjcmlwdD4gdGFncy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25laXQvbW5tLlxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByZWFkLW9ubHkgcHJvcGVydHkgYW5kIGF0dGFjaGVzIGl0IHRvIHRoZSBwcm92aWRlZCBjb250ZXh0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIGZvciBuZXcgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIC0gVmFsdWUgb2YgbmV3IHByb3BlcnR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFJlYWRPbmx5UHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvciBQb2ludFxuICAgICAqXG4gICAgICogQGRlc2MgVGhpcyBvYmplY3QgcmVwcmVzZW50cyBhIHNpbmdsZSBwb2ludCBpbiBhbiBhYnN0cmFjdCAyLWRpbWVuc2lvbmFsIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIFRoZSB1bml0IG9mIG1lYXN1cmUgaXMgdHlwaWNhbGx5IHBpeGVscy5cbiAgICAgKiAoSWYgdXNlZCB0byBtb2RlbCBjb21wdXRlciBncmFwaGljcywgdmVydGljYWwgY29vcmRpbmF0ZXMgYXJlIHR5cGljYWxseSBtZWFzdXJlZCBkb3dud2FyZHNcbiAgICAgKiBmcm9tIHRoZSB0b3Agb2YgdGhlIHdpbmRvdy4gVGhpcyBjb252ZW50aW9uIGhvd2V2ZXIgaXMgbm90IGluaGVyZW50IGluIHRoaXMgb2JqZWN0LilcbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb2JqZWN0IHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIG5ldyBwb2ludCdzIGB4YCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIG5ldyBwb2ludCdzIGB5YCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgeFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAc3VtbWFyeSBUaGlzIHBvaW50J3MgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAgICAgKiBAZGVzYyBDcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFBvaW50fGNvbnN0cnVjdG9yfS5cbiAgICAgICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICovXG4gICAgICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAneCcsIE51bWJlcih4KSB8fCAwKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgeVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAc3VtbWFyeSBUaGlzIHBvaW50J3MgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBQb2ludHxjb25zdHJ1Y3Rvcn0uXG4gICAgICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ3knLCBOdW1iZXIoeSkgfHwgMCk7XG5cbiAgICB9XG5cbiAgICBQb2ludC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtQb2ludH0gQSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhpcyBwb2ludCdzIHBvc2l0aW9uIGluY3JlYXNlZCBieSBjb29yZGluYXRlcyBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBPZmZzZXQgLSBIb3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCB2YWx1ZXMgdG8gYWRkIHRvIHRoaXMgcG9pbnQncyBjb29yZGluYXRlcy5cbiAgICAgICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgcGx1czogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIHRoaXMueCArIG9mZnNldC54LFxuICAgICAgICAgICAgICAgIHRoaXMueSArIG9mZnNldC55XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IHBvaW50IHdoaWNoIGlzIHRoaXMgcG9pbnQncyBwb3NpdGlvbiBpbmNyZWFzZWQgYnkgZ2l2ZW4gb2Zmc2V0cy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRYPTBdIC0gVmFsdWUgdG8gYWRkIHRvIHRoaXMgcG9pbnQncyBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0WT0wXSAtIFZhbHVlIHRvIGFkZCB0byB0aGlzIHBvaW50J3MgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBwbHVzWFk6IGZ1bmN0aW9uKG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgdGhpcy54ICsgKG9mZnNldFggfHwgMCksXG4gICAgICAgICAgICAgICAgdGhpcy55ICsgKG9mZnNldFkgfHwgMClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtQb2ludH0gQSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhpcyBwb2ludCdzIHBvc2l0aW9uIGRlY3JlYXNlZCBieSBjb29yZGluYXRlcyBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBvZmZzZXQgLSBIb3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCB2YWx1ZXMgdG8gc3VidHJhY3QgZnJvbSB0aGlzIHBvaW50J3MgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIG1pbnVzOiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgdGhpcy54IC0gb2Zmc2V0LngsXG4gICAgICAgICAgICAgICAgdGhpcy55IC0gb2Zmc2V0LnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtQb2ludH0gQSBuZXcgYFBvaW50YCBwb3NpdGlvbmVkIHRvIGxlYXN0IHggYW5kIGxlYXN0IHkgb2YgdGhpcyBwb2ludCBhbmQgZ2l2ZW4gYHBvaW50YC5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludC5cbiAgICAgICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgbWluOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICBNYXRoLm1pbih0aGlzLngsIHBvaW50LngpLFxuICAgICAgICAgICAgICAgIE1hdGgubWluKHRoaXMueSwgcG9pbnQueSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtQb2ludH0gQSBuZXcgYFBvaW50YCBwb3NpdGlvbmVkIHRvIGdyZWF0ZXN0IHggYW5kIGdyZWF0ZXN0IHkgb2YgdGhpcyBwb2ludCBhbmQgZ2l2ZW4gYHBvaW50YC5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludC5cbiAgICAgICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgbWF4OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICBNYXRoLm1heCh0aGlzLngsIHBvaW50LngpLFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KHRoaXMueSwgcG9pbnQueSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IERpc3RhbmNlIGJldHdlZW4gZ2l2ZW4gYHBvaW50YCBhbmQgdGhpcyBwb2ludCB1c2luZyBQeXRoYWdvcmVhbiBUaGVvcmVtIGZvcm11bGEuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCBmcm9tIHdoaWNoIHRvIGNvbXB1dGUgdGhlIGRpc3RhbmNlIHRvIHRoaXMgcG9pbnQuXG4gICAgICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgdmFyIGRlbHRhWCA9IHBvaW50LnggLSB0aGlzLngsXG4gICAgICAgICAgICAgICAgZGVsdGFZID0gcG9pbnQueSAtIHRoaXMueTtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgICAgICBkZWx0YVggKiBkZWx0YVggK1xuICAgICAgICAgICAgICAgIGRlbHRhWSAqIGRlbHRhWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogXyhGb3JtZXJseTogYGVxdWFsYC4pX1xuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBfYm90aF8gY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludCBhcmUgZXhhY3RseSBlcXVhbCB0byB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50LlxuICAgICAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChwb2ludCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCA9PT0gcG9pbnQueCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPT09IHBvaW50Lnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBncmVhdGVyIHRoYW4gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludFxuICAgICAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBncmVhdGVyVGhhbjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy54ID4gcG9pbnQueCAmJlxuICAgICAgICAgICAgICAgIHRoaXMueSA+IHBvaW50LnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludFxuICAgICAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBsZXNzVGhhbjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy54IDwgcG9pbnQueCAmJlxuICAgICAgICAgICAgICAgIHRoaXMueSA8IHBvaW50LnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF8oRm9ybWVybHkgYGdyZWF0ZXJUaGFuRXF1YWxUb2AuKV9cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50XG4gICAgICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdyZWF0ZXJUaGFuT3JFcXVhbFRvOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0aGlzLnggPj0gcG9pbnQueCAmJlxuICAgICAgICAgICAgICAgIHRoaXMueSA+PSBwb2ludC55XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBfKEZvcm1lcmx5IGBsZXNzVGhhbkVxdWFsVG9gLilfXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludC5cbiAgICAgICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgbGVzc1RoYW5PckVxdWFsVG86IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRoaXMueCA8PSBwb2ludC54ICYmXG4gICAgICAgICAgICAgICAgdGhpcy55IDw9IHBvaW50LnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF8oRm9ybWVybHkgYGlzQ29udGFpbmVkV2l0aGluUmVjdGFuZ2xlYC4pX1xuICAgICAgICAgKiBAcGFyYW0gcmVjdCB7UmVjdGFuZ2xlfSAtIFJlY3RhbmdsZSB0byB0ZXN0IHRoaXMgcG9pbnQgYWdhaW5zdC5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgdGhpcyBwb2ludCBpcyB3aXRoaW4gZ2l2ZW4gYHJlY3RgLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB3aXRoaW46IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBtaW5YID0gcmVjdC5vcmlnaW4ueCxcbiAgICAgICAgICAgICAgICBtYXhYID0gbWluWCArIHJlY3QuZXh0ZW50Lng7XG4gICAgICAgICAgICB2YXIgbWluWSA9IHJlY3Qub3JpZ2luLnksXG4gICAgICAgICAgICAgICAgbWF4WSA9IG1pblkgKyByZWN0LmV4dGVudC55O1xuXG4gICAgICAgICAgICBpZiAocmVjdC5leHRlbnQueCA8IDApIHtcbiAgICAgICAgICAgICAgICBtaW5YID0gbWF4WDtcbiAgICAgICAgICAgICAgICBtYXhYID0gcmVjdC5vcmlnaW4ueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlY3QuZXh0ZW50LnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbWluWSA9IG1heFk7XG4gICAgICAgICAgICAgICAgbWF4WSA9IHJlY3Qub3JpZ2luLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgbWluWCA8PSB0aGlzLnggJiYgdGhpcy54IDwgbWF4WCAmJlxuICAgICAgICAgICAgICAgIG1pblkgPD0gdGhpcy55ICYmIHRoaXMueSA8IG1heFlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUG9pbnQucHJvdG90eXBlLkVRID0gUG9pbnQucHJvdG90eXBlLmVxdWFscztcbiAgICBQb2ludC5wcm90b3R5cGUuR1QgPSBQb2ludC5wcm90b3R5cGUuZ3JlYXRlclRoYW47XG4gICAgUG9pbnQucHJvdG90eXBlLkxUID0gUG9pbnQucHJvdG90eXBlLmxlc3NUaGFuO1xuICAgIFBvaW50LnByb3RvdHlwZS5HRSA9IFBvaW50LnByb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWxUbztcbiAgICBQb2ludC5wcm90b3R5cGUuTEUgPSBQb2ludC5wcm90b3R5cGUubGVzc1RoYW5PckVxdWFsVG87XG5cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvciBSZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBkZXNjIFRoaXMgb2JqZWN0IHJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIHdpdGhpbiBhbiBhYnN0cmFjdCAyLWRpbWVuc2lvbmFsIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIFRoZSB1bml0IG9mIG1lYXN1cmUgaXMgdHlwaWNhbGx5IHBpeGVscy5cbiAgICAgKiAoSWYgdXNlZCB0byBtb2RlbCBjb21wdXRlciBncmFwaGljcywgdmVydGljYWwgY29vcmRpbmF0ZXMgYXJlIHR5cGljYWxseSBtZWFzdXJlZCBkb3dud2FyZHNcbiAgICAgKiBmcm9tIHRoZSB0b3Agb2YgdGhlIHdpbmRvdy4gVGhpcyBjb252ZW50aW9uIGhvd2V2ZXIgaXMgbm90IGluaGVyZW50IGluIHRoaXMgb2JqZWN0LilcbiAgICAgKlxuICAgICAqIE5vcm1hbGx5LCB0aGUgYHhgIGFuZCBgeWAgcGFyYW1ldGVycyB0byB0aGUgY29uc3RydWN0b3IgZGVzY3JpYmUgdGhlIHVwcGVyIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0LlxuICAgICAqIEhvd2V2ZXIsIG5lZ2F0aXZlIHZhbHVlcyBvZiBgd2lkdGhgIGFuZCBgaGVpZ2h0YCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBnaXZlbiBgeGAgYW5kIGB5YC4gVGhhdCBpcyxcbiAgICAgKiBhIG5lZ2F0aXZlIHZhbHVlIG9mIHRoZSBgd2lkdGhgIHBhcmFtZXRlciB3aWxsIGV4dGVuZCB0aGUgcmVjdCB0byB0aGUgbGVmdCBvZiB0aGUgZ2l2ZW4gYHhgIGFuZFxuICAgICAqIGEgbmVnYXRpdmUgdmFsdWUgb2YgdGhlIGBoZWlnaHRgIHBhcmFtZXRlciB3aWxsIGV4dGVuZCB0aGUgcmVjdCBhYm92ZSB0aGUgZ2l2ZW4gYHlgLlxuICAgICAqIEluIGFueSBjYXNlLCBhZnRlciBpbnN0YW50aWF0aW9uIHRoZSBmb2xsb3dpbmcgYXJlIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIHRydWU6XG4gICAgICogKiBUaGUgYGV4dGVudGAsIGB3aWR0aGAsIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzIF9hbHdheXNfIGdpdmUgcG9zaXRpdmUgdmFsdWVzLlxuICAgICAqICogVGhlIGBvcmlnaW5gLCBgdG9wYCwgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzIF9hbHdheXNfIHJlZmxlY3QgdGhlIHVwcGVyIGxlZnQgY29ybmVyLlxuICAgICAqICogVGhlIGBjb3JuZXJgLCBgYm90dG9tYCwgYW5kIGByaWdodGAgcHJvcGVydGllcyBfYWx3YXlzXyByZWZsZWN0IHRoZSBsb3dlciByaWdodCBjb3JuZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9iamVjdCBzaG91bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIGNvb3JkaW5hdGUgb2Ygc29tZSBjb3JuZXIgb2YgdGhlIHJlY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgY29vcmRpbmF0ZSBvZiBzb21lIGNvcm5lciBvZiB0aGUgcmVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTBdIC0gV2lkdGggb2YgdGhlIG5ldyByZWN0LiBNYXkgYmUgbmVnYXRpdmUgKHNlZSBhYm92ZSkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MF0gLSBIZWlnaHQgb2YgdGhlIG5ldyByZWN0LiBNYXkgYmUgbmVnYXRpdmUgKHNlZSBhYm92ZSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgICB4ID0gTnVtYmVyKHgpIHx8IDA7XG4gICAgICAgIHkgPSBOdW1iZXIoeSkgfHwgMDtcbiAgICAgICAgd2lkdGggPSBOdW1iZXIod2lkdGgpIHx8IDA7XG4gICAgICAgIGhlaWdodCA9IE51bWJlcihoZWlnaHQpIHx8IDA7XG5cbiAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgeCArPSB3aWR0aDtcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIHkgKz0gaGVpZ2h0O1xuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBvcmlnaW5cbiAgICAgICAgICogQHR5cGUge1BvaW50fVxuICAgICAgICAgKiBAc3VtbWFyeSBVcHBlciBsZWZ0IGNvcm5lciBvZiB0aGlzIHJlY3QuXG4gICAgICAgICAqIEBkZXNjIENyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmtwbGFpbiBSZWN0YW5nbGV8Y29uc3RydWN0b3J9LlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICovXG4gICAgICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAnb3JpZ2luJywgbmV3IFBvaW50KHgsIHkpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgZXh0ZW50XG4gICAgICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgICAgICogQHN1bW1hcnkgdGhpcyByZWN0J3Mgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgICAgICogQGRlc2MgVW5saWtlIHRoZSBvdGhlciBgUG9pbnRgIHByb3BlcnRpZXMsIGBleHRlbnRgIGlzIG5vdCBhIGdsb2JhbCBjb29yZGluYXRlIHBhaXI7IHJhdGhlciBpdCBjb25zaXN0cyBvZiBhIF93aWR0aF8gKGB4YCwgYWx3YXlzIHBvc2l0aXZlKSBhbmQgYSBfaGVpZ2h0XyAoYHlgLCBhbHdheXMgcG9zaXRpdmUpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG9iamVjdCBtaWdodCBiZSBtb3JlIGxlZ2l0aW1hdGVseSB0eXBlZCBhcyBzb21ldGhpbmcgbGlrZSBgQXJlYWAgd2l0aCBwcm9wZXJ0aWVzIGB3aWR0aGAgYW5kIGBoZWlnaHRgOyBob3dldmVyIHdlIHdhbnRlZCBpdCB0byBiZSBhYmxlIHRvIHVzZSBpdCBlZmZpY2llbnRseSB3aXRoIGEgcG9pbnQncyBgcGx1c2AgYW5kIGBtaW51c2AgbWV0aG9kcyAodGhhdCBpcywgd2l0aG91dCB0aG9zZSBtZXRob2RzIGhhdmluZyB0byBjaGVjayBhbmQgYnJhbmNoIG9uIHRoZSB0eXBlIG9mIGl0cyBwYXJhbWV0ZXIpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rcGxhaW4gUmVjdGFuZ2xlfGNvbnN0cnVjdG9yfS5cbiAgICAgICAgICogQHNlZSBUaGUge0BsaW5rIFJlY3RhbmdsZSNjb3JuZXJ8Y29ybmVyfSBtZXRob2QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICdleHRlbnQnLCBuZXcgUG9pbnQod2lkdGgsIGhlaWdodCkpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBjb3JuZXJcbiAgICAgICAgICogQHR5cGUge1BvaW50fVxuICAgICAgICAgKiBAc3VtbWFyeSBMb3dlciByaWdodCBjb3JuZXIgb2YgdGhpcyByZWN0LlxuICAgICAgICAgKiBAZGVzYyBUaGlzIGlzIGEgY2FsY3VsYXRlZCB2YWx1ZSBjcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rcGxhaW4gUmVjdGFuZ2xlfGNvbnN0cnVjdG9yfS4gSXQgaXMgYG9yaWdpbmAgb2Zmc2V0IGJ5IGBleHRlbnRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5vdGU6KiogVGhlc2UgY29vcmRpbmF0ZXMgYWN0dWFsbHkgcG9pbnQgdG8gdGhlIHBpeGVsIG9uZSBiZWxvdyBhbmQgb25lIHRvIHRoZSByaWdodCBvZiB0aGUgcmVjdCdzIGFjdHVhbCBsb3dlciByaWdodCBwaXhlbC5cbiAgICAgICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ2Nvcm5lcicsIG5ldyBQb2ludCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgY2VudGVyXG4gICAgICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgICAgICogQHN1bW1hcnkgQ2VudGVyIG9mIHRoaXMgcmVjdC5cbiAgICAgICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGlua3BsYWluIFJlY3RhbmdsZXxjb25zdHJ1Y3Rvcn0uXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICdjZW50ZXInLCBuZXcgUG9pbnQoeCArICh3aWR0aCAvIDIpLCB5ICsgKGhlaWdodCAvIDIpKSk7XG5cbiAgICB9XG5cbiAgICBSZWN0YW5nbGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAgICAgKiBAc3VtbWFyeSBNaW5pbXVtIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0LlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbi55O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAgICAgKiBAc3VtbWFyeSBNaW5pbXVtIGhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGlzIHJlY3QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbi54O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAgICAgKiBAc3VtbWFyeSBNYXhpbXVtIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0ICsgMS5cbiAgICAgICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldCBib3R0b20oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3JuZXIueTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgICAgICogQHN1bW1hcnkgTWF4aW11bSBob3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0ICsgMS5cbiAgICAgICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcm5lci54O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAgICAgKiBAc3VtbWFyeSBXaWR0aCBvZiB0aGlzIHJlY3QgKGFsd2F5cyBwb3NpdGl2ZSkuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnQueDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgICAgICogQHN1bW1hcnkgSGVpZ2h0IG9mIHRoaXMgcmVjdCAoYWx3YXlzIHBvc2l0aXZlKS5cbiAgICAgICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnQueTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgICAgICogQHN1bW1hcnkgQXJlYSBvZiB0aGlzIHJlY3QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgYXJlYSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IEEgY29weSBvZiB0aGlzIHJlY3QgYnV0IHdpdGggaG9yaXpvbnRhbCBwb3NpdGlvbiByZXNldCB0byBnaXZlbiBgeGAgYW5kIG5vIHdpZHRoLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIEhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHJlY3QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBmbGF0dGVuWEF0OiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB0aGlzLm9yaWdpbi55LCAwLCB0aGlzLmV4dGVudC55KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQSBjb3B5IG9mIHRoaXMgcmVjdCBidXQgd2l0aCB2ZXJ0aWNhbCBwb3NpdGlvbiByZXNldCB0byBnaXZlbiBgeWAgYW5kIG5vIGhlaWdodC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBWZXJ0aWNhbCBjb29yZGluYXRlIG9mIHRoZSBuZXcgcmVjdC5cbiAgICAgICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGZsYXR0ZW5ZQXQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMub3JpZ2luLngsIHksIHRoaXMuZXh0ZW50LngsIDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBnaXZlbiBgcG9pbnRgIGVudGlyZWx5IGNvbnRhaW5lZCB3aXRoaW4gdGhpcyByZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludE9yUmVjdCAtIFRoZSBwb2ludCBvciByZWN0IHRvIHRlc3QgZm9yIGNvbnRhaW5tZW50LlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50T3JSZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRPclJlY3Qud2l0aGluKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBfKEZvcm1lcmx5IGBpc0NvbnRhaW5lZFdpdGhpblJlY3RhbmdsZWAuKV9cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHRoaXNgIHJlY3QgaXMgZW50aXJlbHkgY29udGFpbmVkIHdpdGhpbiBnaXZlbiBgcmVjdGAuXG4gICAgICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gUmVjdGFuZ2xlIHRvIHRlc3QgYWdhaW5zdCB0aGlzIHJlY3QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB3aXRoaW46IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgcmVjdC5vcmlnaW4ubGVzc1RoYW5PckVxdWFsVG8odGhpcy5vcmlnaW4pICYmXG4gICAgICAgICAgICAgICAgcmVjdC5jb3JuZXIuZ3JlYXRlclRoYW5PckVxdWFsVG8odGhpcy5jb3JuZXIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBfKEZvcm1lcmx5OiBgaW5zZXRCeWAuKV9cbiAgICAgICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gVGhhdCBpcyBlbmxhcmdlZC9zaHJ1bmsgYnkgZ2l2ZW4gYHBhZGRpbmdgLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyAtIEFtb3VudCBieSB3aGljaCB0byBpbmNyZWFzZSAoKykgb3IgZGVjcmVhc2UgKC0pIHRoaXMgcmVjdFxuICAgICAgICAgKiBAc2VlIFRoZSB7QGxpbmsgUmVjdGFuZ2xlI3Nocmlua0J5fHNocmlua0J5fSBtZXRob2QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBncm93Qnk6IGZ1bmN0aW9uKHBhZGRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luLnggKyBwYWRkaW5nLFxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luLnkgKyBwYWRkaW5nLFxuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW50LnggLSBwYWRkaW5nIC0gcGFkZGluZyxcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVudC55IC0gcGFkZGluZyAtIHBhZGRpbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBUaGF0IGlzIGVubGFyZ2VkL3NocnVuayBieSBnaXZlbiBgcGFkZGluZ2AuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nIC0gQW1vdW50IGJ5IHdoaWNoIHRvIGRlY3JlYXNlICgrKSBvciBpbmNyZWFzZSAoLSkgdGhpcyByZWN0LlxuICAgICAgICAgKiBAc2VlIFRoZSB7QGxpbmsgUmVjdGFuZ2xlI2dyb3dCeXxncm93Qnl9IG1ldGhvZC5cbiAgICAgICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHNocmlua0J5OiBmdW5jdGlvbihwYWRkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncm93QnkoLXBhZGRpbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBCb3VuZGluZyByZWN0IHRoYXQgY29udGFpbnMgYm90aCB0aGlzIHJlY3QgYW5kIHRoZSBnaXZlbiBgcmVjdGAuXG4gICAgICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byB1bmlvbiB3aXRoIHRoaXMgcmVjdC5cbiAgICAgICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW4ubWluKHJlY3Qub3JpZ2luKSxcbiAgICAgICAgICAgICAgICBjb3JuZXIgPSB0aGlzLmNvcm5lci5tYXgocmVjdC5jb3JuZXIpLFxuICAgICAgICAgICAgICAgIGV4dGVudCA9IGNvcm5lci5taW51cyhvcmlnaW4pO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICBvcmlnaW4ueCwgb3JpZ2luLnksXG4gICAgICAgICAgICAgICAgZXh0ZW50LngsIGV4dGVudC55XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpdGVyYXRlIG92ZXIgYWxsIHBvaW50cyB3aXRoaW4gdGhpcyByZWN0LCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvciBlYWNoLlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcixudW1iZXIpfSBpdGVyYXRlZSAtIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggcG9pbnQuXG4gICAgICAgICAqIEJvdW5kIHRvIGBjb250ZXh0YCB3aGVuIGdpdmVuOyBvdGhlcndpc2UgaXQgaXMgYm91bmQgdG8gdGhpcyByZWN0LlxuICAgICAgICAgKiBFYWNoIGludm9jYXRpb24gb2YgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuICAgICAgICAgKiB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50LlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHQ9dGhpc10gLSBDb250ZXh0IHRvIGJpbmQgdG8gYGl0ZXJhdGVlYCAod2hlbiBub3QgYHRoaXNgKS5cbiAgICAgICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGZvckVhY2g6IGZ1bmN0aW9uKGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IHRoaXMub3JpZ2luLngsIHgyID0gdGhpcy5jb3JuZXIueDsgeCA8IHgyOyB4KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gdGhpcy5vcmlnaW4ueSwgeTIgPSB0aGlzLmNvcm5lci55OyB5IDwgeTI7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlZS5jYWxsKGNvbnRleHQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gT25lIG9mOlxuICAgICAgICAgKiAqIF9JZiB0aGlzIHJlY3QgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBgcmVjdGA6X1xuICAgICAgICAgKiAgICAgIGEgbmV3IHJlY3QgcmVwcmVzZW50aW5nIHRoYXQgaW50ZXJzZWN0aW9uLlxuICAgICAgICAgKiAqIF9JZiBpdCBkb2Vzbid0IGludGVyc2VjdCBhbmQgYGlmTm9uZUFjdGlvbmAgZGVmaW5lZDpfXG4gICAgICAgICAqICAgICAgcmVzdWx0IG9mIGNhbGxpbmcgYGlmTm9uZUFjdGlvbmAuXG4gICAgICAgICAqICogX0lmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IGFuZCBgaWZOb25lQWN0aW9uYCB1bmRlZmluZWQ6X1xuICAgICAgICAgKiAgICAgIGBudWxsYC5cbiAgICAgICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGludGVyc2VjdCB3aXRoIHRoaXMgcmVjdC5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihSZWN0YW5nbGUpfSBbaWZOb25lQWN0aW9uXSAtIFdoZW4gbm8gaW50ZXJzZWN0aW9uLCBpbnZva2UgYW5kIHJldHVybiByZXN1bHQuXG4gICAgICAgICAqIEJvdW5kIHRvIGBjb250ZXh0YCB3aGVuIGdpdmVuOyBvdGhlcndpc2UgYm91bmQgdG8gdGhpcyByZWN0LlxuICAgICAgICAgKiBJbnZva2VkIHdpdGggYHJlY3RgIGFzIHNvbGUgcGFyYW1ldGVyLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHQ9dGhpc10gLSBDb250ZXh0IHRvIGJpbmQgdG8gYGlmTm9uZUFjdGlvbmAgKHdoZW4gbm90IGB0aGlzYCkuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKHJlY3QsIGlmTm9uZUFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGwsXG4gICAgICAgICAgICAgICAgb3JpZ2luID0gdGhpcy5vcmlnaW4ubWF4KHJlY3Qub3JpZ2luKSxcbiAgICAgICAgICAgICAgICBjb3JuZXIgPSB0aGlzLmNvcm5lci5taW4ocmVjdC5jb3JuZXIpLFxuICAgICAgICAgICAgICAgIGV4dGVudCA9IGNvcm5lci5taW51cyhvcmlnaW4pO1xuXG4gICAgICAgICAgICBpZiAoZXh0ZW50LnggPiAwICYmIGV4dGVudC55ID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi54LCBvcmlnaW4ueSxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50LngsIGV4dGVudC55XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlmTm9uZUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlmTm9uZUFjdGlvbi5jYWxsKGNvbnRleHQgfHwgdGhpcywgcmVjdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIHRoaXMgcmVjdCBvdmVybGFwcyB3aXRoIGdpdmVuIGByZWN0YC5cbiAgICAgICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGludGVyc2VjdCB3aXRoIHRoaXMgcmVjdC5cbiAgICAgICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGludGVyc2VjdHM6IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgcmVjdC5jb3JuZXIueCA+IHRoaXMub3JpZ2luLnggJiZcbiAgICAgICAgICAgICAgICByZWN0LmNvcm5lci55ID4gdGhpcy5vcmlnaW4ueSAmJlxuICAgICAgICAgICAgICAgIHJlY3Qub3JpZ2luLnggPCB0aGlzLmNvcm5lci54ICYmXG4gICAgICAgICAgICAgICAgcmVjdC5vcmlnaW4ueSA8IHRoaXMuY29ybmVyLnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW50ZXJmYWNlXG4gICAgZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xuICAgIGV4cG9ydHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xufSkoXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlIHx8ICh3aW5kb3cucmVjdGFuZ3VsYXIgPSB7fSksXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgfHwgKHdpbmRvdy5yZWN0YW5ndWxhci5leHBvcnRzID0ge30pXG4pIHx8IChcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyB8fCAod2luZG93LnJlY3Rhbmd1bGFyID0gd2luZG93LnJlY3Rhbmd1bGFyLmV4cG9ydHMpXG4pO1xuXG4vKiBBYm91dCB0aGUgYWJvdmUgSUlGRTpcbiAqIFRoaXMgZmlsZSBpcyBhIFwibW9kaWZpZWQgbm9kZSBtb2R1bGUuXCIgSXQgZnVuY3Rpb25zIGFzIHVzdWFsIGluIE5vZGUuanMgKmFuZCogaXMgYWxzbyB1c2FibGUgZGlyZWN0bHkgaW4gdGhlIGJyb3dzZXIuXG4gKiAxLiBOb2RlLmpzOiBUaGUgSUlGRSBpcyBzdXBlcmZsdW91cyBidXQgaW5ub2N1b3VzLlxuICogMi4gSW4gdGhlIGJyb3dzZXI6IFRoZSBJSUZFIGNsb3N1cmUgc2VydmVzIHRvIGtlZXAgaW50ZXJuYWwgZGVjbGFyYXRpb25zIHByaXZhdGUuXG4gKiAyLmEuIEluIHRoZSBicm93c2VyIGFzIGEgZ2xvYmFsOiBUaGUgbG9naWMgaW4gdGhlIGFjdHVhbCBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgKyB0aGUgcG9zdC1pbnZvY2F0aW9uIGV4cHJlc3Npb25cbiAqIHdpbGwgcHV0IHlvdXIgQVBJIGluIGB3aW5kb3cucmVjdGFuZ3VsYXJgLlxuICogMi5iLiBJbiB0aGUgYnJvd3NlciBhcyBhIG1vZHVsZTogSWYgeW91IHByZWRlZmluZSBhIGB3aW5kb3cubW9kdWxlYCBvYmplY3QsIHRoZSByZXN1bHRzIHdpbGwgYmUgaW4gYG1vZHVsZS5leHBvcnRzYC5cbiAqIFRoZSBib3dlciBjb21wb25lbnQgYG1ubWAgbWFrZXMgdGhpcyBlYXN5IGFuZCBhbHNvIHByb3ZpZGVzIGEgZ2xvYmFsIGByZXF1aXJlKClgIGZ1bmN0aW9uIGZvciByZWZlcmVuY2luZyB5b3VyIG1vZHVsZVxuICogZnJvbSBvdGhlciBjbG9zdXJlcy4gSW4gZWl0aGVyIGNhc2UsIHRoaXMgd29ya3Mgd2l0aCBib3RoIE5vZGVKcy1zdHlsZSBleHBvcnQgbWVjaGFuaXNtcyAtLSBhIHNpbmdsZSBBUEkgYXNzaWdubWVudCxcbiAqIGBtb2R1bGUuZXhwb3J0cyA9IHlvdXJBUElgICpvciogYSBzZXJpZXMgb2YgaW5kaXZpZHVhbCBwcm9wZXJ0eSBhc3NpZ25tZW50cywgYG1vZHVsZS5leHBvcnRzLnByb3BlcnR5ID0gcHJvcGVydHlgLlxuICpcbiAqIEJlZm9yZSB0aGUgSUlGRSBydW5zLCB0aGUgYWN0dWFsIHBhcmFtZXRlciBleHByZXNzaW9ucyBhcmUgZXhlY3V0ZWQ6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB3ZSdyZSBpbiBOb2RlSnMgc28gYXNzdW1lIHRoZXJlIGlzIGEgYG1vZHVsZWAgb2JqZWN0IHdpdGggYW4gYGV4cG9ydHNgIHByb3BlcnR5XG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgd2UncmUgaW4gYnJvd3NlclxuICogMi5hLiBJZiBgbW9kdWxlYCBvYmplY3QgcHJlZGVmaW5lZCwgdXNlIGl0XG4gKiAyLmIuIElmIGBtb2R1bGVgIG9iamVjdCB1bmRlZmluZWQsIGNyZWF0ZSBhIGByZWN0YW5ndWxhcmAgb2JqZWN0XG4gKlxuICogQWZ0ZXIgdGhlIElJRkUgcmV0dXJuczpcbiAqIEJlY2F1c2UgaXQgYWx3YXlzIHJldHVybnMgdW5kZWZpbmVkLCB0aGUgZXhwcmVzc2lvbiBhZnRlciB0aGUgfHwgd2lsbCBleGVjdXRlOlxuICogMS4gSWYgYHdpbmRvd2Agb2JqZWN0IHVuZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBOb2RlSnMgc28gd2UncmUgZG9uZVxuICogMi4gSWYgYHdpbmRvd2Agb2JqZWN0IGRlZmluZWQsIHRoZW4gd2UncmUgaW4gYnJvd3NlclxuICogMi5hLiBJZiBgbW9kdWxlYCBvYmplY3QgcHJlZGVmaW5lZCwgd2UncmUgZG9uZTsgcmVzdWx0cyBhcmUgaW4gYG1vdWR1bGUuZXhwb3J0c2BcbiAqIDIuYi4gSWYgYG1vZHVsZWAgb2JqZWN0IHVuZGVmaW5lZCwgcmVkZWZpbmVgcmVjdGFuZ3VsYXJgIHRvIGJlIHRoZSBgcmVjdGFuZ3VsYXIuZXhwb3J0c2Agb2JqZWN0XG4gKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBub2RlLCBicm93c2VyICovXG5cbihmdW5jdGlvbiAobW9kdWxlKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXG4gICAgLy8gVGhpcyBjbG9zdXJlIHN1cHBvcnRzIE5vZGVKUy1sZXNzIGNsaWVudCBzaWRlIGluY2x1ZGVzIHdpdGggPHNjcmlwdD4gdGFncy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25laXQvbW5tLlxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yIFJhbmdlU2VsZWN0aW9uTW9kZWxcbiAgICAgKlxuICAgICAqIEBkZXNjIFRoaXMgb2JqZWN0IG1vZGVscyBzZWxlY3Rpb24gb2YgXCJjZWxsc1wiIHdpdGhpbiBhbiBhYnN0cmFjdCBzaW5nbGUtZGltZW5zaW9uYWwgbWF0cml4LlxuICAgICAqXG4gICAgICogRGlzam9pbnQgc2VsZWN0aW9ucyBjYW4gYmUgYnVpbHQgd2l0aCBjYWxscyB0byB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG4gICAgICogKiB7QGxpbmsgUmFuZ2VTZWxlY3Rpb25Nb2RlbCNzZWxlY3R8c2VsZWN0KHN0YXJ0LCBzdG9wKX0gLSBBZGQgYSByYW5nZSB0byB0aGUgbWF0cml4LlxuICAgICAqICoge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjZGVzZWxlY3R8ZGVzZWxlY3Qoc3RhcnQsIHN0b3ApfSAtIFJlbW92ZSBhIHJhbmdlIGZyb20gdGhlIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIFR3byBtb3JlIG1ldGhvZHMgYXJlIGF2YWlsYWJsZTpcbiAgICAgKiAqIFRlc3QgYSBjZWxsIHRvIHNlZSBpZiBpdCB7QGxpbmsgUmFuZ2VTZWxlY3Rpb25Nb2RlbCNpc1NlbGVjdGVkfGlzU2VsZWN0ZWQoY2VsbCl9XG4gICAgICogKiB7QGxpbmsgUmFuZ2VTZWxlY3Rpb25Nb2RlbCNjbGVhcnxjbGVhcigpfSB0aGUgbWF0cml4XG4gICAgICpcbiAgICAgKiBJbnRlcm5hbGx5LCB0aGUgc2VsZWN0aW9uIGlzIHJ1bi1sZW5ndGgtZW5jb2RlZC4gSXQgaXMgdGhlcmVmb3JlIGEgXCJzcGFyc2VcIiBtYXRyaXhcbiAgICAgKiB3aXRoIHVuZGVmaW5lZCBib3VuZHMuIEEgc2luZ2xlIGRhdGEgcHJvcGVydHkgY2FsbGVkIGBzZWxlY3Rpb25gIGlzIGFuIGFycmF5IHRoYXRcbiAgICAgKiBjb250YWlucyBhbGwgdGhlIFwicnVuc1wiIChyYW5nZXMpIG9mIHNlbGVjdGVkIGNlbGxzIGFsYmVpdCBpbiBubyBwYXJ0aWN1bGFyIG9yZGVyLlxuICAgICAqIFRoaXMgcHJvcGVydHkgc2hvdWxkIG5vdCBub3JtYWxseSBuZWVkIHRvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBvYmplY3Qgc2hvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1JhbmdlU2VsZWN0aW9uTW9kZWx9IFNlbGYgKGkuZS4sIGB0aGlzYCBvYmplY3QpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJhbmdlU2VsZWN0aW9uTW9kZWwoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBzZWxlY3Rpb25cbiAgICAgICAgICogQHR5cGUge0FycmF5LkFycmF5Lm51bWJlcn1cbiAgICAgICAgICogQHN1bW1hcnkgVW5vcmRlcmVkIGxpc3Qgb2YgcnVucy5cbiAgICAgICAgICogQGRlc2MgQSBcInJ1blwiIGlzIGRlZmluZWQgYXMgYW4gQXJyYXkoMikgd2hlcmU6XG4gICAgICAgICAqICogZWxlbWVudCBbMF0gaXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgcnVuXG4gICAgICAgICAqICogZWxlbWVudCBbMV0gaXMgdGhlIGVuZCBvZiB0aGUgcnVuIChpbmNsdXNpdmUpIGFuZCBpcyBhbHdheXMgPj0gZWxlbWVudCBbMF1cbiAgICAgICAgICogVGhlIG9yZGVyIG9mIHRoZSBydW5zIHdpdGhpbiBpcyB1bmRlZmluZWQuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gW107XG5cbiAgICAgICAgLy93ZSBuZWVkIHRvIGJlIGFibGUgdG8gZ28gYmFjayBpbiB0aW1lXG4gICAgICAgIC8vdGhlIHN0YXRlcyBmaWVsZFxuICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuXG4gICAgICAgIC8vY2xvbmUgYW5kIHN0b3JlIG15IGN1cnJlbnQgc3RhdGVcbiAgICAgICAgLy9zbyB3ZSBjYW4gdW53aW5kIGNoYW5nZXMgaWYgbmVlZCBiZVxuICAgICAgICB0aGlzLnN0b3JlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VscyA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gW107XG4gICAgICAgICAgICB2YXIgY29weTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvcHkgPSBbXS5jb25jYXQoc2Vsc1tpXSk7XG4gICAgICAgICAgICAgICAgc3RhdGUucHVzaChjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBBZGQgYSBjb250aWd1b3VzIHJ1biBvZiBwb2ludHMgdG8gdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICogQGRlc2MgSW5zZXJ0IGEgbmV3IHJ1biBpbnRvIGB0aGlzLnNlbGVjdGlvbmAuXG4gICAgICAgICAqIFRoZSBuZXcgcnVuIHdpbGwgYmUgbWVyZ2VkIHdpdGggb3ZlcmxhcHBpbmcgYW5kIGFkamFjZW50IHJ1bnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB0d28gcGFyYW1ldGVycyBtYXkgYmUgZ2l2ZW4gaW4gZWl0aGVyIG9yZGVyLlxuICAgICAgICAgKiBUaGUgc3RhcnQgYW5kIHN0b3AgZWxlbWVudHMgaW4gdGhlIHJlc3VsdGluZyBydW4gd2lsbCBob3dldmVyIGFsd2F5cyBiZSBvcmRlcmVkLlxuICAgICAgICAgKiAoSG93ZXZlciwgbm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgcnVucyB3aXRoaW4gYHRoaXMuc2VsZWN0aW9uYCBpcyBpdHNlbGYgYWx3YXlzIHVub3JkZXJlZC4pXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCBgdGhpcy5zZWxlY3Rpb25gIGlzIHVwZGF0ZWQgaW4gcGxhY2UsIHByZXNlcnZpbmcgdmFsaWRpdHkgb2YgYW55IGV4dGVybmFsIHJlZmVyZW5jZXMuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFN0YXJ0IG9mIHJ1bi4gTWF5IGJlIGdyZWF0ZXIgdGhhbiBgc3RvcGAuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RvcD1zdG9wXSAtIEVuZCBvZiBydW4gKGluY2x1c2l2ZSkuIE1heSBiZSBsZXNzIHRoYW4gYHN0YXJ0YC5cbiAgICAgICAgICogQHJldHVybnMge1JhbmdlU2VsZWN0aW9uTW9kZWx9IFNlbGYgKGkuZS4sIGB0aGlzYCksIGZvciBjaGFpbmluZy5cbiAgICAgICAgICogQG1lbWJlck9mIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIChzdGFydCwgc3RvcCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZVN0YXRlKCk7XG4gICAgICAgICAgICB2YXIgcnVuID0gbWFrZVJ1bihzdGFydCwgc3RvcCk7XG4gICAgICAgICAgICB2YXIgc3BsaWNlciA9IFswLCAxXTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGVhY2gpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcHMoZWFjaCwgcnVuKSB8fCBhYnV0cyhlYWNoLCBydW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1biA9IG1lcmdlKGVhY2gsIHJ1bik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaWNlci5wdXNoKGVhY2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3BsaWNlci5wdXNoKHJ1bik7XG4gICAgICAgICAgICBzcGxpY2VyWzFdID0gdGhpcy5zZWxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3BsaWNlLmFwcGx5KHRoaXMuc2VsZWN0aW9uLCBzcGxpY2VyKTsgLy8gdXBkYXRlIGluIHBsYWNlIHRvIHByZXNlcnZlIGV4dGVybmFsIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBSZW1vdmUgYSBjb250aWd1b3VzIHJ1biBvZiBwb2ludHMgZnJvbSB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgKiBAZGVzYyBUcnVuY2F0ZSBhbmQvb3IgcmVtb3ZlIHJ1bihzKSBmcm9tIGB0aGlzLnNlbGVjdGlvbmAuXG4gICAgICAgICAqIFJlbW92aW5nIHBhcnQgb2YgZXhpc3RpbmcgcnVucyB3aWxsIChjb3JyZWN0bHkpIHNob3J0ZW4gdGhlbSBvciBicmVhayB0aGVtIGludG8gdHdvIGZyYWdtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHR3byBwYXJhbWV0ZXJzIG1heSBiZSBnaXZlbiBpbiBlaXRoZXIgb3JkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCBgdGhpcy5zZWxlY3Rpb25gIGlzIHVwZGF0ZWQgaW4gcGxhY2UsIHByZXNlcnZpbmcgdmFsaWRpdHkgb2YgYW55IGV4dGVybmFsIHJlZmVyZW5jZXMuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFN0YXJ0IG9mIHJ1bi4gTWF5IGJlIGdyZWF0ZXIgdGhhbiBgc3RvcGAuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RvcD1zdG9wXSAtIEVuZCBvZiBydW4gKGluY2x1c2l2ZSkuIE1heSBiZSBsZXNzIHRoYW4gYHN0YXJ0YC5cbiAgICAgICAgICogQHJldHVybnMge1JhbmdlU2VsZWN0aW9uTW9kZWx9IFNlbGYgKGkuZS4sIGB0aGlzYCksIGZvciBjaGFpbmluZy5cbiAgICAgICAgICogQG1lbWJlck9mIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBkZXNlbGVjdDogZnVuY3Rpb24gKHN0YXJ0LCBzdG9wKSB7XG4gICAgICAgICAgICB2YXIgcnVuID0gbWFrZVJ1bihzdGFydCwgc3RvcCk7XG4gICAgICAgICAgICB2YXIgc3BsaWNlciA9IFswLCAwXTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGVhY2gpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcHMoZWFjaCwgcnVuKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGllY2VzID0gc3VidHJhY3QoZWFjaCwgcnVuKTtcbiAgICAgICAgICAgICAgICAgICAgc3BsaWNlciA9IHNwbGljZXIuY29uY2F0KHBpZWNlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaWNlci5wdXNoKGVhY2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3BsaWNlclsxXSA9IHRoaXMuc2VsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNwbGljZS5hcHBseSh0aGlzLnNlbGVjdGlvbiwgc3BsaWNlcik7IC8vIHVwZGF0ZSBpbiBwbGFjZSB0byBwcmVzZXJ2ZSBleHRlcm5hbCByZWZlcmVuY2VzXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgRW1wdGllcyBgdGhpcy5zZWxlY3Rpb25gLCBlZmZlY3RpdmVseSByZW1vdmluZyBhbGwgcnVucy5cbiAgICAgICAgICogQHJldHVybnMge1JhbmdlU2VsZWN0aW9uTW9kZWx9IFNlbGYgKGkuZS4sIGB0aGlzYCksIGZvciBjaGFpbmluZy5cbiAgICAgICAgICogQG1lbWJlck9mIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhck1vc3RSZWNlbnRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBgY2VsbGAgaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIGdpdmVuIGBjZWxsYCBpcyB3aXRoaW4gYW55IG9mIHRoZSBydW5zIGluIGB0aGlzLnNlbGVjdGlvbmAuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsIC0gVGhlIGNlbGwgdG8gdGVzdCBmb3IgaW5jbHVzaW9uIGluIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5zb21lKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVhY2hbMF0gPD0gY2VsbCAmJiBjZWxsIDw9IGVhY2hbMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5sZW5ndGggPT09IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IFJldHVybiB0aGUgaW5kZXhlcyB0aGF0IGFyZSBzZWxlY3RlZC5cbiAgICAgICAgICogQGRlc2MgUmV0dXJuIHRoZSBpbmRleGVzIHRoYXQgYXJlIHNlbGVjdGVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXkuQXJyYXkubnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoZWFjaCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBlYWNoWzBdOyBpIDw9IGVhY2hbMV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5zb3J0KGZ1bmN0aW9uIChhLCBiKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdW1tYXJ5IFByZXBzIGBzdGFydGAgYW5kIGBzdG9wYCBwYXJhbXMgaW50byBvcmRlciBhcnJheVxuICAgICAqIEBmdW5jdGlvbiBtYWtlUnVuXG4gICAgICogQGRlc2MgVXRpbGl0eSBmdW5jdGlvbiBjYWxsZWQgYnkgYm90aCBgc2VsZWN0KClgIGFuZCBgZGVzZWxlY3QoKWAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IHN0YXJ0IC0gU3RhcnQgb2YgcnVuLiBpZiBhcnJheSwgYHN0YXJ0YCBhbmQgYHN0b3BgIGFyZSB0YWtlbiBmcm9tIGZpcnN0IHR3byBlbGVtZW50cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0b3A9c3RhcnRdIC0gRW5kIG9mIHJ1biAoaW5jbHVzaXZlKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlUnVuKHN0YXJ0LCBzdG9wKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzdGFydCBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICAgICAgPyBtYWtlUnVuLmFwcGx5KHRoaXMsIHN0YXJ0KSAvLyBleHRyYWN0IHBhcmFtcyBmcm9tIGdpdmVuIGFycmF5XG4gICAgICAgICAgICAgICAgOiBzdG9wID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFsgc3RhcnQsIHN0YXJ0IF0gLy8gc2luZ2xlIHBhcmFtIGlzIGEgcnVuIHRoYXQgc3RvcHMgd2hlcmUgaXQgc3RhcnRzXG4gICAgICAgICAgICAgICAgOiBzdGFydCA8PSBzdG9wXG4gICAgICAgICAgICAgICAgPyBbIHN0YXJ0LCBzdG9wIF1cbiAgICAgICAgICAgICAgICA6IFsgc3RvcCwgc3RhcnQgXSAvLyByZXZlcnNlIGRlc2NlbmRpbmcgcGFyYW1zIGludG8gYXNjZW5kaW5nIG9yZGVyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gb3ZlcmxhcHNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBgcnVuMWAgb3ZlcmxhcHMgYHJ1bjJgXG4gICAgICogQHN1bW1hcnkgQ29tcGFyaXNvbiBvcGVyYXRvciB0aGF0IGRldGVybWluZXMgaWYgZ2l2ZW4gcnVucyBvdmVybGFwIHdpdGggb25lIGFub3RoZXIuXG4gICAgICogQGRlc2MgQm90aCBwYXJhbWV0ZXJzIGFyZSBhc3N1bWVkIHRvIGJlIF9vcmRlcmVkXyBhcnJheXMuXG4gICAgICpcbiAgICAgKiBPdmVybGFwIGlzIGRlZmluZWQgdG8gaW5jbHVkZSB0aGUgY2FzZSB3aGVyZSBvbmUgcnVuIGNvbXBsZXRlbHkgY29udGFpbnMgdGhlIG90aGVyLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBvcGVyYXRvciBpcyBjb21tdXRhdGl2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4xIC0gZmlyc3QgcnVuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcnVuMiAtIHNlY29uZCBydW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvdmVybGFwcyhydW4xLCBydW4yKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBydW4xWzBdIDw9IHJ1bjJbMF0gJiYgcnVuMlswXSA8PSBydW4xWzFdIHx8IC8vIHJ1bjIncyBzdGFydCBpcyB3aXRoaW4gcnVuMSBPUi4uLlxuICAgICAgICAgICAgcnVuMVswXSA8PSBydW4yWzFdICYmIHJ1bjJbMV0gPD0gcnVuMVsxXSB8fCAvLyBydW4yJ3Mgc3RvcCBpcyB3aXRoaW4gcnVuMSBPUi4uLlxuICAgICAgICAgICAgcnVuMlswXSA8ICBydW4xWzBdICYmIHJ1bjFbMV0gPCAgcnVuMlsxXSAgICAvLyBydW4yIGNvbXBsZXRlbHkgY29udGFpbnMgcnVuMVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIGFidXRzXG4gICAgICogQHN1bW1hcnkgQ29tcGFyaXNvbiBvcGVyYXRvciB0aGF0IGRldGVybWluZXMgaWYgZ2l2ZW4gcnVucyBhcmUgY29uc2VjdXRpdmUgd2l0aCBvbmUgYW5vdGhlci5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBgcnVuMWAgaXMgY29uc2VjdXRpdmUgd2l0aCBgcnVuMmBcbiAgICAgKiBAZGVzYyBCb3RoIHBhcmFtZXRlcnMgYXJlIGFzc3VtZWQgdG8gYmUgX29yZGVyZWRfIGFycmF5cy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb3BlcmF0b3IgaXMgY29tbXV0YXRpdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcnVuMSAtIGZpcnN0IHJ1blxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjIgLSBzZWNvbmQgcnVuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWJ1dHMocnVuMSwgcnVuMikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcnVuMVsxXSA9PT0gcnVuMlswXSAtIDEgfHwgLy8gcnVuMSdzIHRvcCBpbW1lZGlhdGVseSBwcmVjZWRlcyBydW4yJ3Mgc3RhcnQgT1IuLi5cbiAgICAgICAgICAgIHJ1bjJbMV0gPT09IHJ1bjFbMF0gLSAxICAgIC8vIHJ1bjIncyB0b3AgaW1tZWRpYXRlbHkgcHJlY2VkZXMgcnVuMSdzIHN0YXJ0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gc3VidHJhY3RcbiAgICAgKiBAc3VtbWFyeSBPcGVyYXRvciB0aGF0IHN1YnRyYWN0cyBvbmUgcnVuIGZyb20gYW5vdGhlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuQXJyYXkubnVtYmVyfSBUaGUgcmVtYWluaW5nIHBpZWNlcyBvZiBgbWludWVuZGAgYWZ0ZXIgcmVtb3ZpbmcgYHN1YnRyYWhlbmRgLlxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBfZG9lcyBub3QgYXNzdW1lc18gdGhhdCBgb3ZlcmxhcCgpYCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCB3aXRoIHRoZSBzYW1lIHJ1bnMgYW5kIGhhcyByZXR1cm5lZCBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5lZCBhcnJheSBjb250YWlucyAwLCAxLCBvciAyIHJ1bnMgd2hpY2ggYXJlIHRoZSBwb3J0aW9uKHMpIG9mIGBtaW51ZW5kYCB0aGF0IGRvIF9ub3RfIGluY2x1ZGUgYHN1YnRyYWhlbmRgLlxuICAgICAqXG4gICAgICogQ2F2ZWF0OiBUaGlzIG9wZXJhdG9yIGlzICpub3QqIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IG1pbnVlbmQgLSBhIHJ1biBmcm9tIHdoaWNoIHRvIFwic3VidHJhY3RcIiBgc3VidHJhaGVuZGBcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBzdWJ0cmFoZW5kIC0gYSBydW4gdG8gXCJzdWJ0cmFjdGVkXCIgZnJvbSBgbWludWVuZGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChtaW51ZW5kLCBzdWJ0cmFoZW5kKSB7XG4gICAgICAgIHZhciBtMCA9IG1pbnVlbmRbMF07XG4gICAgICAgIHZhciBtMSA9IG1pbnVlbmRbMV07XG4gICAgICAgIHZhciBzMCA9IHN1YnRyYWhlbmRbMF07XG4gICAgICAgIHZhciBzMSA9IHN1YnRyYWhlbmRbMV07XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAoczAgPD0gbTAgJiYgczEgPCBtMSkge1xuICAgICAgICAgICAgLy9zdWJ0cmFoZW5kIGV4dGVuZHMgYmVmb3JlIG1pbnVlbmQ6IHJldHVybiByZW1haW5pbmcgcGllY2Ugb2YgYG1pbnVlbmRgXG4gICAgICAgICAgICByZXN1bHQucHVzaChbczEgKyAxLCBtMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHMwID4gbTAgJiYgczEgPj0gbTEpIHtcbiAgICAgICAgICAgIC8vc3VidHJhaGVuZCBleHRlbmRzIGFmdGVyIG1pbnVlbmQ6IHJldHVybiByZW1haW5pbmcgcGllY2Ugb2YgYG1pbnVlbmRgXG4gICAgICAgICAgICByZXN1bHQucHVzaChbbTAsIHMwIC0gMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKG0wIDwgczAgJiYgczEgPCBtMSkge1xuICAgICAgICAgICAgLy9jb21wbGV0ZWx5IGluc2lkZTogcmV0dXJuIDIgc21hbGxlciBwaWVjZXMgcmVzdWx0aW5nIGZyb20gdGhlIGhvbGVcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFttMCwgczAgLSAxXSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbczEgKyAxLCBtMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHMxIDwgbTAgfHwgczAgPiBtMSkge1xuICAgICAgICAgICAgLy8gY29tcGxldGVseSBvdXRzaWRlOiByZXR1cm4gYG1pbnVlbmRgIHVudG91Y2hlZFxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWludWVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2Vsc2Ugc3VidHJhaGVuZCBtdXN0IGNvbXBsZXRlbHkgb3ZlcmxhcCBtaW51ZW5kIHNvIHJldHVybiBubyBwaWVjZXNcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuXG4gICAgLy8gTG9jYWwgdXRpbGl0eSBmdW5jdGlvbnNcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIG1lcmdlXG4gICAgICogQHN1bW1hcnkgT3BlcmF0b3IgdGhhdCBtZXJnZXMgZ2l2ZW4gcnVucy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IEEgc2luZ2xlIG1lcmdlZCBydW4uXG4gICAgICogQGRlc2MgQm90aCBwYXJhbWV0ZXJzIGFyZSBhc3N1bWVkIHRvIGJlIF9vcmRlcmVkXyBhcnJheXMuXG4gICAgICpcbiAgICAgKiBUaGUgcnVucyBhcmUgYXNzdW1lZCB0byBiZSBvdmVybGFwcGluZyBvciBhZGphY2VudCB0byBvbmUgYW5vdGhlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb3BlcmF0b3IgaXMgY29tbXV0YXRpdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcnVuMSAtIGEgcnVuIHRvIG1lcmdlIHdpdGggYHJ1bjJgXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcnVuMiAtIGEgcnVuIHRvIG1lcmdlIHdpdGggYHJ1bjFgXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2UocnVuMSwgcnVuMikge1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oTWF0aC5taW4uYXBwbHkoTWF0aCwgcnVuMSksIE1hdGgubWluLmFwcGx5KE1hdGgsIHJ1bjIpKTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KE1hdGgubWF4LmFwcGx5KE1hdGgsIHJ1bjEpLCBNYXRoLm1heC5hcHBseShNYXRoLCBydW4yKSk7XG4gICAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH1cblxuICAgIC8vIEludGVyZmFjZVxuICAgIG1vZHVsZS5leHBvcnRzID0gUmFuZ2VTZWxlY3Rpb25Nb2RlbDtcbn0pKFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSB8fCAod2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWwgPSB7fSksXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgfHwgKHdpbmRvdy5SYW5nZVNlbGVjdGlvbk1vZGVsLmV4cG9ydHMgPSB7fSlcbikgfHwgKFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnIHx8ICh3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbCA9IHdpbmRvdy5SYW5nZVNlbGVjdGlvbk1vZGVsLmV4cG9ydHMpXG4pO1xuXG4vKiBBYm91dCB0aGUgYWJvdmUgSUlGRTpcbiAqIFRoaXMgZmlsZSBpcyBhIFwibW9kaWZpZWQgbm9kZSBtb2R1bGUuXCIgSXQgZnVuY3Rpb25zIGFzIHVzdWFsIGluIE5vZGUuanMgKmFuZCogaXMgYWxzbyB1c2FibGUgZGlyZWN0bHkgaW4gdGhlIGJyb3dzZXIuXG4gKiAxLiBOb2RlLmpzOiBUaGUgSUlGRSBpcyBzdXBlcmZsdW91cyBidXQgaW5ub2N1b3VzLlxuICogMi4gSW4gdGhlIGJyb3dzZXI6IFRoZSBJSUZFIGNsb3N1cmUgc2VydmVzIHRvIGtlZXAgaW50ZXJuYWwgZGVjbGFyYXRpb25zIHByaXZhdGUuXG4gKiAyLmEuIEluIHRoZSBicm93c2VyIGFzIGEgZ2xvYmFsOiBUaGUgbG9naWMgaW4gdGhlIGFjdHVhbCBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgKyB0aGUgcG9zdC1pbnZvY2F0aW9uIGV4cHJlc3Npb25cbiAqIHdpbGwgcHV0IHlvdXIgQVBJIGluIGB3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbGAuXG4gKiAyLmIuIEluIHRoZSBicm93c2VyIGFzIGEgbW9kdWxlOiBJZiB5b3UgcHJlZGVmaW5lIGEgYHdpbmRvdy5tb2R1bGVgIG9iamVjdCwgdGhlIHJlc3VsdHMgd2lsbCBiZSBpbiBgbW9kdWxlLmV4cG9ydHNgLlxuICogVGhlIGJvd2VyIGNvbXBvbmVudCBgbW5tYCBtYWtlcyB0aGlzIGVhc3kgYW5kIGFsc28gcHJvdmlkZXMgYSBnbG9iYWwgYHJlcXVpcmUoKWAgZnVuY3Rpb24gZm9yIHJlZmVyZW5jaW5nIHlvdXIgbW9kdWxlXG4gKiBmcm9tIG90aGVyIGNsb3N1cmVzLiBJbiBlaXRoZXIgY2FzZSwgdGhpcyB3b3JrcyB3aXRoIGJvdGggTm9kZUpzLXN0eWxlIGV4cG9ydCBtZWNoYW5pc21zIC0tIGEgc2luZ2xlIEFQSSBhc3NpZ25tZW50LFxuICogYG1vZHVsZS5leHBvcnRzID0geW91ckFQSWAgKm9yKiBhIHNlcmllcyBvZiBpbmRpdmlkdWFsIHByb3BlcnR5IGFzc2lnbm1lbnRzLCBgbW9kdWxlLmV4cG9ydHMucHJvcGVydHkgPSBwcm9wZXJ0eWAuXG4gKlxuICogQmVmb3JlIHRoZSBJSUZFIHJ1bnMsIHRoZSBhY3R1YWwgcGFyYW1ldGVyIGV4cHJlc3Npb25zIGFyZSBleGVjdXRlZDpcbiAqIDEuIElmIGB3aW5kb3dgIG9iamVjdCB1bmRlZmluZWQsIHdlJ3JlIGluIE5vZGVKcyBzbyBhc3N1bWUgdGhlcmUgaXMgYSBgbW9kdWxlYCBvYmplY3Qgd2l0aCBhbiBgZXhwb3J0c2AgcHJvcGVydHlcbiAqIDIuIElmIGB3aW5kb3dgIG9iamVjdCBkZWZpbmVkLCB3ZSdyZSBpbiBicm93c2VyXG4gKiAyLmEuIElmIGBtb2R1bGVgIG9iamVjdCBwcmVkZWZpbmVkLCB1c2UgaXRcbiAqIDIuYi4gSWYgYG1vZHVsZWAgb2JqZWN0IHVuZGVmaW5lZCwgY3JlYXRlIGEgYFJhbmdlU2VsZWN0aW9uTW9kZWxgIG9iamVjdFxuICpcbiAqIEFmdGVyIHRoZSBJSUZFIHJldHVybnM6XG4gKiBCZWNhdXNlIGl0IGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCwgdGhlIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIHx8IHdpbGwgZXhlY3V0ZTpcbiAqIDEuIElmIGB3aW5kb3dgIG9iamVjdCB1bmRlZmluZWQsIHRoZW4gd2UncmUgaW4gTm9kZUpzIHNvIHdlJ3JlIGRvbmVcbiAqIDIuIElmIGB3aW5kb3dgIG9iamVjdCBkZWZpbmVkLCB0aGVuIHdlJ3JlIGluIGJyb3dzZXJcbiAqIDIuYS4gSWYgYG1vZHVsZWAgb2JqZWN0IHByZWRlZmluZWQsIHdlJ3JlIGRvbmU7IHJlc3VsdHMgYXJlIGluIGBtb3VkdWxlLmV4cG9ydHNgXG4gKiAyLmIuIElmIGBtb2R1bGVgIG9iamVjdCB1bmRlZmluZWQsIHJlZGVmaW5lYFJhbmdlU2VsZWN0aW9uTW9kZWxgIHRvIGJlIHRoZSBgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5leHBvcnRzYCBvYmplY3RcbiAqL1xuIiwiLy8gdGVtcGxleCBub2RlIG1vZHVsZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pvbmVpdC90ZW1wbGV4XG5cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqLyAvL3RvIGFsbG93IHJlZnMgdG8gYHdpbmRvd2AgaW4gSUlGRSdzIGNhbGwncyBhY3R1YWwgcGFyYW1zXG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby11bnVzZWQtdmFyc1xuXG4gICAgLy8gVGhpcyBjbG9zdXJlIHN1cHBvcnRzIE5vZGVKUy1sZXNzIGNsaWVudCBzaWRlIGluY2x1ZGVzIHdpdGggPHNjcmlwdD4gdGFncy4gU2VlIG5vdGVzIGF0IGJvdHRvbSBvZiB0aGlzIGZpbGUuXG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdmFsdWVzIG9mIGV4ZWN1dGlvbiBjb250ZXh0IHByb3BlcnRpZXMgbmFtZWQgaW4gdGVtcGxhdGUgYnkge3Byb3AxfSxcbiAgICAgKiB7cHJvcDJ9LCBldGMuLCBvciBhbnkgamF2YXNjcmlwdCBleHByZXNzaW9uIGluY29ycG9yYXRpbmcgc3VjaCBwcm9wIG5hbWVzLlxuICAgICAqIFRoZSBjb250ZXh0IGFsd2F5cyBpbmNsdWRlcyB0aGUgZ2xvYmFsIG9iamVjdC4gSW4gYWRkaXRpb24geW91IGNhbiBzcGVjaWZ5IGEgc2luZ2xlXG4gICAgICogY29udGV4dCBvciBhbiBhcnJheSBvZiBjb250ZXh0cyB0byBzZWFyY2ggKGluIHRoZSBvcmRlciBnaXZlbikgYmVmb3JlIGZpbmFsbHlcbiAgICAgKiBzZWFyY2hpbmcgdGhlIGdsb2JhbCBjb250ZXh0LlxuICAgICAqXG4gICAgICogTWVyZ2UgZXhwcmVzc2lvbnMgY29uc2lzdGluZyBvZiBzaW1wbGUgbnVtZXJpYyB0ZXJtcywgc3VjaCBhcyB7MH0sIHsxfSwgZXRjLiwgZGVyZWZcbiAgICAgKiB0aGUgZmlyc3QgY29udGV4dCBnaXZlbiwgd2hpY2ggaXMgYXNzdW1lZCB0byBiZSBhbiBhcnJheS4gQXMgYSBjb252ZW5pZW5jZSBmZWF0dXJlLFxuICAgICAqIGlmIGFkZGl0aW9uYWwgYXJncyBhcmUgZ2l2ZW4gYWZ0ZXIgYHRlbXBsYXRlYCwgYGFyZ3VtZW50c2AgaXMgdW5zaGlmdGVkIG9udG8gdGhlIGNvbnRleHRcbiAgICAgKiBhcnJheSwgdGh1cyBtYWtpbmcgZmlyc3QgYWRkaXRpb25hbCBhcmcgYXZhaWxhYmxlIGFzIHsxfSwgc2Vjb25kIGFzIHsyfSwgZXRjLiwgYXMgaW5cbiAgICAgKiBgdGVtcGxleCgnSGVsbG8sIHsxfSEnLCAnV29ybGQnKWAuICh7MH0gaXMgdGhlIHRlbXBsYXRlIHNvIGNvbnNpZGVyIHRoaXMgdG8gYmUgMS1iYXNlZC4pXG4gICAgICpcbiAgICAgKiBJZiB5b3UgcHJlZmVyIHNvbWV0aGluZyBvdGhlciB0aGFuIGJyYWNlcywgcmVkZWZpbmUgYHRlbXBsZXgucmVnZXhwYC5cbiAgICAgKlxuICAgICAqIFNlZSB0ZXN0cyBmb3IgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gW2FyZ3NdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxleCh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzIGluc3RhbmNlb2YgQXJyYXkgPyB0aGlzIDogW3RoaXNdO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHsgY29udGV4dHMudW5zaGlmdChhcmd1bWVudHMpOyB9XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKHRlbXBsZXgucmVnZXhwLCB0ZW1wbGV4Lm1lcmdlci5iaW5kKGNvbnRleHRzKSk7XG4gICAgfVxuXG4gICAgdGVtcGxleC5yZWdleHAgPSAvXFx7KC4qPylcXH0vZztcblxuICAgIHRlbXBsZXgud2l0aCA9IGZ1bmN0aW9uIChpLCBzKSB7XG4gICAgICAgIHJldHVybiAnd2l0aCh0aGlzWycgKyBpICsgJ10peycgKyBzICsgJ30nO1xuICAgIH07XG5cbiAgICB0ZW1wbGV4LmNhY2hlID0gW107XG5cbiAgICB0ZW1wbGV4LmRlcmVmID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoISh0aGlzLmxlbmd0aCBpbiB0ZW1wbGV4LmNhY2hlKSkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSAncmV0dXJuIGV2YWwoZXhwciknO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gdGVtcGxleC53aXRoKGksIGNvZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZW1wbGV4LmNhY2hlW3RoaXMubGVuZ3RoXSA9IGV2YWwoJyhmdW5jdGlvbihleHByKXsnICsgY29kZSArICd9KScpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVtcGxleC5jYWNoZVt0aGlzLmxlbmd0aF0uY2FsbCh0aGlzLCBrZXkpO1xuICAgIH07XG5cbiAgICB0ZW1wbGV4Lm1lcmdlciA9IGZ1bmN0aW9uIChtYXRjaCwga2V5KSB7XG4gICAgICAgIC8vIEFkdmFuY2VkIGZlYXR1cmVzOiBDb250ZXh0IGNhbiBiZSBhIGxpc3Qgb2YgY29udGV4dHMgd2hpY2ggYXJlIHNlYXJjaGVkIGluIG9yZGVyLlxuICAgICAgICB2YXIgcmVwbGFjZW1lbnQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gaXNOYU4oa2V5KSA/IHRlbXBsZXguZGVyZWYuY2FsbCh0aGlzLCBrZXkpIDogdGhpc1swXVtrZXldO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXBsYWNlbWVudCA9ICd7JyArIGtleSArICd9JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgICB9O1xuXG4gICAgLy8gdGhpcyBpbnRlcmZhY2UgY29uc2lzdHMgc29sZWx5IG9mIHRoZSB0ZW1wbGV4IGZ1bmN0aW9uIG9iamVjdFxuICAgIG1vZHVsZS5leHBvcnRzID0gdGVtcGxleDtcblxufSkoXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlIHx8ICh3aW5kb3cudGVtcGxleCA9IHt9KSxcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyB8fCAod2luZG93LnRlbXBsZXguZXhwb3J0cyA9IHt9KVxuKSB8fCAoXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgfHwgKHdpbmRvdy50ZW1wbGV4ID0gd2luZG93LnRlbXBsZXguZXhwb3J0cylcbik7XG5cbi8qIEFib3V0IHRoZSBhYm92ZSBJSUZFOlxuICogVGhpcyBmaWxlIGlzIGEgXCJtb2RpZmllZCBub2RlIG1vZHVsZS5cIiBJdCBmdW5jdGlvbnMgYXMgdXN1YWwgaW4gTm9kZS5qcyAqYW5kKiBpcyBhbHNvIHVzYWJsZSBkaXJlY3RseSBpbiB0aGUgYnJvd3Nlci5cbiAqIDEuIE5vZGUuanM6IFRoZSBJSUZFIGlzIHN1cGVyZmx1b3VzIGJ1dCBpbm5vY3VvdXMuXG4gKiAyLiBJbiB0aGUgYnJvd3NlcjogVGhlIElJRkUgY2xvc3VyZSBzZXJ2ZXMgdG8ga2VlcCBpbnRlcm5hbCBkZWNsYXJhdGlvbnMgcHJpdmF0ZS5cbiAqIDIuYS4gSW4gdGhlIGJyb3dzZXIgYXMgYSBnbG9iYWw6IFRoZSBsb2dpYyBpbiB0aGUgYWN0dWFsIHBhcmFtZXRlciBleHByZXNzaW9ucyArIHRoZSBwb3N0LWludm9jYXRpb24gZXhwcmVzc2lvblxuICogd2lsbCBwdXQgeW91ciBBUEkgaW4gYHdpbmRvdy50ZW1wbGV4YC5cbiAqIDIuYi4gSW4gdGhlIGJyb3dzZXIgYXMgYSBtb2R1bGU6IElmIHlvdSBwcmVkZWZpbmUgYSBgd2luZG93Lm1vZHVsZWAgb2JqZWN0LCB0aGUgcmVzdWx0cyB3aWxsIGJlIGluIGBtb2R1bGUuZXhwb3J0c2AuXG4gKiBUaGUgYm93ZXIgY29tcG9uZW50IGBtbm1gIG1ha2VzIHRoaXMgZWFzeSBhbmQgYWxzbyBwcm92aWRlcyBhIGdsb2JhbCBgcmVxdWlyZSgpYCBmdW5jdGlvbiBmb3IgcmVmZXJlbmNpbmcgeW91ciBtb2R1bGVcbiAqIGZyb20gb3RoZXIgY2xvc3VyZXMuIEluIGVpdGhlciBjYXNlLCB0aGlzIHdvcmtzIHdpdGggYm90aCBOb2RlSnMtc3R5bGUgZXhwb3J0IG1lY2hhbmlzbXMgLS0gYSBzaW5nbGUgQVBJIGFzc2lnbm1lbnQsXG4gKiBgbW9kdWxlLmV4cG9ydHMgPSB5b3VyQVBJYCAqb3IqIGEgc2VyaWVzIG9mIGluZGl2aWR1YWwgcHJvcGVydHkgYXNzaWdubWVudHMsIGBtb2R1bGUuZXhwb3J0cy5wcm9wZXJ0eSA9IHByb3BlcnR5YC5cbiAqXG4gKiBCZWZvcmUgdGhlIElJRkUgcnVucywgdGhlIGFjdHVhbCBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgYXJlIGV4ZWN1dGVkOlxuICogMS4gSWYgYG1vZHVsZWAgb2JqZWN0IGRlZmluZWQsIHdlJ3JlIGluIE5vZGVKcyBzbyBhc3N1bWUgdGhlcmUgaXMgYSBgbW9kdWxlYCBvYmplY3Qgd2l0aCBhbiBgZXhwb3J0c2Agb2JqZWN0XG4gKiAyLiBJZiBgbW9kdWxlYCBvYmplY3QgdW5kZWZpbmVkLCB3ZSdyZSBpbiBicm93c2VyIHNvIGRlZmluZSBhIGB3aW5kb3cudGVtcGxleGAgb2JqZWN0IHdpdGggYW4gYGV4cG9ydHNgIG9iamVjdFxuICpcbiAqIEFmdGVyIHRoZSBJSUZFIHJldHVybnM6XG4gKiBCZWNhdXNlIGl0IGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCwgdGhlIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIHx8IHdpbGwgYWx3YXlzIGV4ZWN1dGU6XG4gKiAxLiBJZiBgbW9kdWxlYCBvYmplY3QgZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBOb2RlSnMgc28gd2UncmUgZG9uZVxuICogMi4gSWYgYG1vZHVsZWAgb2JqZWN0IHVuZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBicm93c2VyIHNvIHJlZGVmaW5lYHdpbmRvdy50ZW1wbGV4YCBhcyBpdHMgYGV4cG9ydHNgIG9iamVjdFxuICovXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnZXh0ZW5kLW1lJykuQmFzZTtcblxuLyoqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgSW5zdGFuY2VzIG9mIGZlYXR1cmVzIGFyZSBjb25uZWN0ZWQgdG8gb25lIGFub3RoZXIgdG8gbWFrZSBhIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5IGZvciBoYW5kbGluZyBhbGwgdGhlIGlucHV0IHRvIHRoZSBoeXBlcmdyaWQuXG4gKlxuICogU2VlIHtAbGluayBDZWxsUHJvdmlkZXIjaW5pdGlhbGl6ZXxpbml0aWFsaXplfSB3aGljaCBpcyBjYWxsZWQgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICovXG52YXIgQ2VsbFByb3ZpZGVyID0gQmFzZS5leHRlbmQoJ0NlbGxQcm92aWRlcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENvbnN0cnVjdG9yIGxvZ2ljXG4gICAgICogQGRlc2MgVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgdXBvbiBpbnN0YW50aWF0aW9uIG9mIHRoaXMgY2xhc3Mgb3Igb2YgYW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBmcm9tIHRoaXMgY2xhc3MuXG4gICAgICogPiBBbGwgYGluaXRpYWxpemUoKWAgbWV0aG9kcyBpbiB0aGUgaW5oZXJpdGFuY2UgY2hhaW4gYXJlIGNhbGxlZCwgaW4gdHVybiwgZWFjaCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IsIGJlZ2lubmluZyB3aXRoIHRoYXQgb2YgdGhlIG1vc3QgXCJzZW5pb3JcIiBjbGFzcyB0aHJvdWdoIHRoYXQgb2YgdGhlIGNsYXNzIG9mIHRoZSBuZXcgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jZWxsQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQ2VsbHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgcmVwbGFjZSB0aGlzIGZ1bmN0aW9uIGluIG9uIHlvdXIgaW5zdGFuY2Ugb2YgY2VsbFByb3ZpZGVyXG4gICAgICogQHJldHVybnMgY2VsbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSBhbiBvYmplY3Qgd2l0aCBldmVyeXRoaW5nIHlvdSBtaWdodCBuZWVkIGZvciByZW5kZXJlcmluZyBhIGNlbGxcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFByb3ZpZGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldENlbGw6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbENhY2hlLnNpbXBsZUNlbGxSZW5kZXJlcjtcbiAgICAgICAgY2VsbC5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyByZXBsYWNlIHRoaXMgZnVuY3Rpb24gaW4gb24geW91ciBpbnN0YW5jZSBvZiBjZWxsUHJvdmlkZXJcbiAgICAgKiBAcmV0dXJucyBjZWxsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIGFuIG9iamVjdCB3aXRoIGV2ZXJ5dGhpbmcgeW91IG1pZ2h0IG5lZWQgZm9yIHJlbmRlcmVyaW5nIGEgY2VsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Q29sdW1uSGVhZGVyQ2VsbDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsQ2FjaGUuc2ltcGxlQ2VsbFJlbmRlcmVyO1xuICAgICAgICBjZWxsLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHJlcGxhY2UgdGhpcyBmdW5jdGlvbiBpbiBvbiB5b3VyIGluc3RhbmNlIG9mIGNlbGxQcm92aWRlclxuICAgICAqIEByZXR1cm5zIGNlbGxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIC0gYW4gb2JqZWN0IHdpdGggZXZlcnl0aGluZyB5b3UgbWlnaHQgbmVlZCBmb3IgcmVuZGVyZXJpbmcgYSBjZWxsXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRSb3dIZWFkZXJDZWxsOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxDYWNoZS5zaW1wbGVDZWxsUmVuZGVyZXI7XG4gICAgICAgIGNlbGwuY29uZmlnID0gY29uZmlnO1xuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9LFxuXG4gICAgcGFpbnRCdXR0b246IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHZhbCA9IGNvbmZpZy52YWx1ZTtcbiAgICAgICAgdmFyIGMgPSBjb25maWcueDtcbiAgICAgICAgdmFyIHIgPSBjb25maWcueTtcbiAgICAgICAgdmFyIGJvdW5kcyA9IGNvbmZpZy5ib3VuZHM7XG4gICAgICAgIHZhciB4ID0gYm91bmRzLnggKyAyO1xuICAgICAgICB2YXIgeSA9IGJvdW5kcy55ICsgMjtcbiAgICAgICAgdmFyIHdpZHRoID0gYm91bmRzLndpZHRoIC0gMztcbiAgICAgICAgdmFyIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSAzO1xuICAgICAgICB2YXIgcmFkaXVzID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIGFyY0dyYWRpZW50ID0gZ2MuY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeCwgeSArIGhlaWdodCk7XG4gICAgICAgIGlmIChjb25maWcubW91c2VEb3duKSB7XG4gICAgICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyNCNUNCRUQnKTtcbiAgICAgICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzRkNzRlYScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjZmZmZmZmJyk7XG4gICAgICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJyNhYWFhYWEnKTtcbiAgICAgICAgfVxuICAgICAgICBnYy5maWxsU3R5bGUgPSBhcmNHcmFkaWVudDtcbiAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSAnIzAwMDAwMCc7XG4gICAgICAgIHJvdW5kUmVjdChnYywgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzLCBhcmNHcmFkaWVudCwgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIG94ID0gKHdpZHRoIC0gY29uZmlnLmdldFRleHRXaWR0aChnYywgdmFsKSkgLyAyO1xuICAgICAgICB2YXIgb3kgPSAoaGVpZ2h0IC0gY29uZmlnLmdldFRleHRIZWlnaHQoZ2MuZm9udCkuZGVzY2VudCkgLyAyO1xuXG4gICAgICAgIGlmIChnYy50ZXh0QmFzZWxpbmUgIT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICBnYy50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGdjLmZpbGxTdHlsZSA9ICcjMDAwMDAwJztcblxuICAgICAgICBjb25maWcuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICBnYy5maWxsVGV4dCh2YWwsIHggKyBveCwgeSArIG95KTtcblxuICAgICAgICAvL2lkZW50aWZ5IHRoYXQgd2UgYXJlIGEgYnV0dG9uXG4gICAgICAgIGNvbmZpZy5idXR0b25DZWxsc1tjICsgJywnICsgcl0gPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgZGVmYXVsdCBjZWxsIHJlbmRlcmluZyBmdW5jdGlvbiBmb3IgcmVuZGVyaW5nIGEgdmFuaWxsYSBjZWxsLlxuICAgICAqIEBkZXNjIEdyZWF0IGNhcmUgaGFzIGJlZW4gdGFrZW4gaW4gY3JhZnRpbmcgdGhpcyBmdW5jdGlvbiBhcyBpdCBuZWVkcyB0byBwZXJmb3JtIGV4dHJlbWVseSBmYXN0LiBSZWFkcyBvbiB0aGUgZ2Mgb2JqZWN0IGFyZSBleHBlbnNpdmUgYnV0IG5vdCBxdWl0ZSBhcyBleHBlbnNpdmUgYXMgd3JpdGVzIHRvIGl0LiBXZSBkbyBvdXIgYmVzdCB0byBhdm9pZCB3cml0ZXMsIHRoZW4gYXZvaWQgcmVhZHMuIENsaXBwaW5nIGJvdW5kcyBhcmUgbm90IHNldCBoZXJlIGFzIHRoaXMgaXMgYWxzbyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uLiBJbnN0ZWFkLCB3ZSB0cnVuY2F0ZSBvdmVyZmxvd2luZyB0ZXh0IGFuZCBjb250ZW50IGJ5IGZpbGxpbmcgYSByZWN0YW5nbGUgd2l0aCBiYWNrZ3JvdW5kIGNvbG9yIGNvbHVtbiBieSBjb2x1bW4gaW5zdGVhZCBvZiBjZWxsIGJ5IGNlbGwuICBUaGlzIGNvbHVtbiBieSBjb2x1bW4gZmlsbCBoYXBwZW5zIGhpZ2hlciB1cCBvbiB0aGUgc3RhY2sgaW4gYSBjYWxsaW5nIGZ1bmN0aW9uIGZyb20gZmluLWh5cGVyZ3JpZC1yZW5kZXJlci4gIFRha2Ugbm90ZSB3ZSBkbyBub3QgZG8gY2VsbCBieSBjZWxsIGJvcmRlciByZW5kZXJlcmluZyBhcyB0aGF0IGlzIGV4cGVuc2l2ZS4gIEluc3RlYWQgd2UgcmVuZGVyIG1hbnkgZmV3ZXIgZ3JpZGxpbmVzIGFmdGVyIGFsbCBjZWxscyBhcmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjIC0gdGhlIFwicGVuXCIgaW4gdGhlIG12YyBtb2RlbCwgd2UgaXNzdWUgZHJhd2luZyBjb21tYW5kcyB0b1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMaW5rIC0gaXMgdGhpcyBhIGh5cGVybGluayBjZWxsXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkZWZhdWx0Q2VsbFBhaW50OiBmdW5jdGlvbihnYywgY29uZmlnKSB7XG4gICAgICAgIHZhciB2YWwgPSBjb25maWcudmFsdWUsXG4gICAgICAgICAgICB4ID0gY29uZmlnLmJvdW5kcy54LFxuICAgICAgICAgICAgeSA9IGNvbmZpZy5ib3VuZHMueSxcbiAgICAgICAgICAgIHdpZHRoID0gY29uZmlnLmJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmZpZy5ib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgICAgd3JhcEhlYWRlcnMgPSBjb25maWcuaGVhZGVyVGV4dFdyYXBwaW5nLFxuICAgICAgICAgICAgbGVmdFBhZGRpbmcgPSAyLCAvL1RPRE86IGZpeCB0aGlzXG4gICAgICAgICAgICBpc0hlYWRlciA9IGNvbmZpZy55ID09PSAwO1xuXG4gICAgICAgIHZhciBsZWZ0SWNvbiwgcmlnaHRJY29uLCBjZW50ZXJJY29uLCBpeG9mZnNldCwgaXlvZmZzZXQ7XG5cbiAgICAgICAgLy9zZXR0aW5nIGdjIHByb3BlcnRpZXMgYXJlIGV4cGVuc2l2ZSwgbGV0cyBub3QgZG8gaXQgdW5uZWNlc3NhcmlseVxuXG4gICAgICAgIGlmICh2YWwgJiYgdmFsLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgbGVmdEljb24gPSB2YWxbMF07XG4gICAgICAgICAgICByaWdodEljb24gPSB2YWxbMl07XG4gICAgICAgICAgICB2YWwgPSB2YWxbMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHsgLy8gbXVzdCBiZSBhbiBpbWFnZVxuICAgICAgICAgICAgICAgIGNlbnRlckljb24gPSB2YWw7XG4gICAgICAgICAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0SWNvbiAmJiBsZWZ0SWNvbi5ub2RlTmFtZSAhPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICBsZWZ0SWNvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmlnaHRJY29uICYmIHJpZ2h0SWNvbi5ub2RlTmFtZSAhPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICByaWdodEljb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbnRlckljb24gJiYgY2VudGVySWNvbi5ub2RlTmFtZSAhPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICBjZW50ZXJJY29uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhbCA9IHZhbHVlT3JGdW5jdGlvbkV4ZWN1dGUoY29uZmlnLCB2YWwpO1xuXG4gICAgICAgIGlmIChnYy5mb250ICE9PSBjb25maWcuZm9udCkge1xuICAgICAgICAgICAgZ2MuZm9udCA9IGNvbmZpZy5mb250O1xuICAgICAgICB9XG4gICAgICAgIGlmIChnYy50ZXh0QWxpZ24gIT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgZ2MudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnYy50ZXh0QmFzZWxpbmUgIT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICBnYy50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZmlsbCBiYWNrZ3JvdW5kIG9ubHkgaWYgb3VyIGJnQ29sb3IgaXMgcG9wdWxhdGVkIG9yIHdlIGFyZSBhIHNlbGVjdGVkIGNlbGxcbiAgICAgICAgaWYgKGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgfHwgY29uZmlnLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9IHZhbHVlT3JGdW5jdGlvbkV4ZWN1dGUoY29uZmlnLCBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5iYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgOiBjb25maWcuYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgIGdjLmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9kcmF3IHRleHRcbiAgICAgICAgdmFyIHRoZUNvbG9yID0gdmFsdWVPckZ1bmN0aW9uRXhlY3V0ZShjb25maWcsIGNvbmZpZy5pc1NlbGVjdGVkID8gY29uZmlnLmZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA6IGNvbmZpZy5jb2xvcik7XG4gICAgICAgIGlmIChnYy5maWxsU3R5bGUgIT09IHRoZUNvbG9yKSB7XG4gICAgICAgICAgICBnYy5maWxsU3R5bGUgPSB0aGVDb2xvcjtcbiAgICAgICAgICAgIGdjLnN0cm9rZVN0eWxlID0gdGhlQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNIZWFkZXIgJiYgd3JhcEhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTXVsdGlMaW5lVGV4dCh4LCB5LCBoZWlnaHQsIHdpZHRoLCBnYywgY29uZmlnLCB2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJTaW5nbGVMaW5lVGV4dCh4LCB5LCBoZWlnaHQsIHdpZHRoLCBnYywgY29uZmlnLCB2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5pc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZSkge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMC4yKSc7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWNvbldpZHRoID0gMDtcbiAgICAgICAgaWYgKGxlZnRJY29uKSB7XG4gICAgICAgICAgICBpeW9mZnNldCA9IE1hdGgucm91bmQoKGhlaWdodCAtIGxlZnRJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGdjLmRyYXdJbWFnZShsZWZ0SWNvbiwgeCArIGxlZnRQYWRkaW5nLCB5ICsgaXlvZmZzZXQpO1xuICAgICAgICAgICAgaWNvbldpZHRoID0gTWF0aC5tYXgobGVmdEljb24ud2lkdGggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHRJY29uKSB7XG4gICAgICAgICAgICBpeW9mZnNldCA9IE1hdGgucm91bmQoKGhlaWdodCAtIHJpZ2h0SWNvbi5oZWlnaHQpIC8gMik7XG4gICAgICAgICAgICBpeG9mZnNldCA9IDA7IC8vTWF0aC5yb3VuZCgoaGFsaWduT2Zmc2V0IC0gcmlnaHRJY29uLndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgZ2MuZHJhd0ltYWdlKHJpZ2h0SWNvbiwgeCArIHdpZHRoIC0gaXhvZmZzZXQgLSByaWdodEljb24ud2lkdGgsIHkgKyBpeW9mZnNldCk7XG4gICAgICAgICAgICBpY29uV2lkdGggPSBNYXRoLm1heChyaWdodEljb24ud2lkdGggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VudGVySWNvbikge1xuICAgICAgICAgICAgaXlvZmZzZXQgPSBNYXRoLnJvdW5kKChoZWlnaHQgLSBjZW50ZXJJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGl4b2Zmc2V0ID0gTWF0aC5yb3VuZCgod2lkdGggLSBjZW50ZXJJY29uLndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgZ2MuZHJhd0ltYWdlKGNlbnRlckljb24sIHggKyB3aWR0aCAtIGl4b2Zmc2V0IC0gY2VudGVySWNvbi53aWR0aCwgeSArIGl5b2Zmc2V0KTtcbiAgICAgICAgICAgIGljb25XaWR0aCA9IE1hdGgubWF4KGNlbnRlckljb24ud2lkdGggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmNlbGxCb3JkZXJUaGlja25lc3MpIHtcbiAgICAgICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgZ2MucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGdjLmxpbmVXaWR0aCA9IGNvbmZpZy5jZWxsQm9yZGVyVGhpY2tuZXNzO1xuICAgICAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSBjb25maWcuY2VsbEJvcmRlclN0eWxlO1xuXG4gICAgICAgICAgICAvLyBhbmltYXRlIHRoZSBkYXNoZWQgbGluZSBhIGJpdCBoZXJlIGZvciBmdW5cblxuICAgICAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcubWluV2lkdGggPSBjb25maWcubWluV2lkdGggKyAyICogKGljb25XaWR0aCk7XG4gICAgfSxcblxuICAgIHJlbmRlck11bHRpTGluZVRleHQ6IGZ1bmN0aW9uKHgsIHksIGhlaWdodCwgd2lkdGgsIGdjLCBjb25maWcsIHZhbCkge1xuICAgICAgICB2YXIgbGluZXMgPSBmaXRUZXh0KGdjLCBjb25maWcsIHZhbCwgd2lkdGgpO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJTaW5nbGVMaW5lVGV4dCh4LCB5LCBoZWlnaHQsIHdpZHRoLCBnYywgY29uZmlnLCBzcXVlZXplKHZhbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbEhFZGdlT2Zmc2V0ID0gY29uZmlnLmNlbGxQYWRkaW5nLFxuICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIHZhbGlnbk9mZnNldCA9IGNvbmZpZy52b2Zmc2V0LFxuICAgICAgICAgICAgaGFsaWduID0gY29uZmlnLmhhbGlnbixcbiAgICAgICAgICAgIHRleHRIZWlnaHQgPSBjb25maWcuZ2V0VGV4dEhlaWdodChjb25maWcuZm9udCkuaGVpZ2h0O1xuXG4gICAgICAgIHN3aXRjaCAoaGFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gd2lkdGggLSBjb2xIRWRnZU9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gY29sSEVkZ2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaE1pbiA9IDAsIHZNaW4gPSBNYXRoLmNlaWwodGV4dEhlaWdodCAvIDIpO1xuXG4gICAgICAgIHZhbGlnbk9mZnNldCArPSBNYXRoLmNlaWwoKGhlaWdodCAtIChsaW5lcy5sZW5ndGggLSAxKSAqIHRleHRIZWlnaHQpIC8gMik7XG5cbiAgICAgICAgaGFsaWduT2Zmc2V0ID0gTWF0aC5tYXgoaE1pbiwgaGFsaWduT2Zmc2V0KTtcbiAgICAgICAgdmFsaWduT2Zmc2V0ID0gTWF0aC5tYXgodk1pbiwgdmFsaWduT2Zmc2V0KTtcblxuICAgICAgICBnYy5zYXZlKCk7IC8vIGRlZmluZSBhIGNsaXBwaW5nIHJlZ2lvbiBmb3IgY2VsbFxuICAgICAgICBnYy5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIGdjLmxpbmVUbyh4ICsgd2lkdGgsIHkpO1xuICAgICAgICBnYy5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgZ2MubGluZVRvKHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICBnYy5saW5lVG8oeCwgeSk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICBnYy5jbGlwKCk7XG5cbiAgICAgICAgZ2MudGV4dEFsaWduID0gaGFsaWduO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdjLmZpbGxUZXh0KGxpbmVzW2ldLCB4ICsgaGFsaWduT2Zmc2V0LCB5ICsgdmFsaWduT2Zmc2V0ICsgKGkgKiB0ZXh0SGVpZ2h0KSk7XG4gICAgICAgIH1cblxuICAgICAgICBnYy5yZXN0b3JlKCk7IC8vIGRpc2NhcmQgY2xpcHBpbmcgcmVnaW9uXG4gICAgfSxcblxuICAgIHJlbmRlclNpbmdsZUxpbmVUZXh0OiBmdW5jdGlvbih4LCB5LCBoZWlnaHQsIHdpZHRoLCBnYywgY29uZmlnLCB2YWwpIHtcbiAgICAgICAgdmFyIGNvbEhFZGdlT2Zmc2V0ID0gY29uZmlnLmNlbGxQYWRkaW5nLFxuICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIHZhbGlnbk9mZnNldCA9IGNvbmZpZy52b2Zmc2V0LFxuICAgICAgICAgICAgaGFsaWduID0gY29uZmlnLmhhbGlnbixcbiAgICAgICAgICAgIGlzQ29sdW1uSG92ZXJlZCA9IGNvbmZpZy5pc0NvbHVtbkhvdmVyZWQsXG4gICAgICAgICAgICBpc1Jvd0hvdmVyZWQgPSBjb25maWcuaXNSb3dIb3ZlcmVkLFxuICAgICAgICAgICAgaXNMaW5rID0gaXNMaW5rIHx8IGZhbHNlO1xuXG4gICAgICAgIHZhciBmb250TWV0cmljcyA9IGNvbmZpZy5nZXRUZXh0SGVpZ2h0KGNvbmZpZy5mb250KTtcbiAgICAgICAgdmFyIHRleHRXaWR0aCA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIHZhbCk7XG5cbiAgICAgICAgLy93ZSBtdXN0IHNldCB0aGlzIGluIG9yZGVyIHRvIGNvbXB1dGUgdGhlIG1pbmltdW0gd2lkdGhcbiAgICAgICAgLy9mb3IgY29sdW1uIGF1dG9zaXppbmcgcHVycG9zZXNcbiAgICAgICAgY29uZmlnLm1pbldpZHRoID0gdGV4dFdpZHRoICsgKDIgKiBjb2xIRWRnZU9mZnNldCk7XG5cbiAgICAgICAgc3dpdGNoIChoYWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAvL3RleHRXaWR0aCA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIGNvbmZpZy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gd2lkdGggLSBjb2xIRWRnZU9mZnNldCAtIHRleHRXaWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgLy90ZXh0V2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCBjb25maWcudmFsdWUpO1xuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9ICh3aWR0aCAtIHRleHRXaWR0aCkgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gY29sSEVkZ2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBoYWxpZ25PZmZzZXQgPSBNYXRoLm1heCgwLCBoYWxpZ25PZmZzZXQpO1xuICAgICAgICB2YWxpZ25PZmZzZXQgPSB2YWxpZ25PZmZzZXQgKyBNYXRoLmNlaWwoaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZ2MuZmlsbFRleHQodmFsLCB4ICsgaGFsaWduT2Zmc2V0LCB5ICsgdmFsaWduT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NvbHVtbkhvdmVyZWQgJiYgaXNSb3dIb3ZlcmVkKSB7XG4gICAgICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmIChpc0xpbmspIHtcbiAgICAgICAgICAgICAgICB1bmRlcmxpbmUoY29uZmlnLCBnYywgdmFsLCB4ICsgaGFsaWduT2Zmc2V0LCB5ICsgdmFsaWduT2Zmc2V0ICsgTWF0aC5mbG9vcihmb250TWV0cmljcy5oZWlnaHQgLyAyKSwgMSk7XG4gICAgICAgICAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0dyYXBoaWNzQ29udGV4dH0gZ2MgLSB0aGUgXCJwZW5cIiBpbiB0aGUgbXZjIG1vZGVsLCB3ZSBpc3N1ZSBkcmF3aW5nIGNvbW1hbmRzIHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSB5IHNjcmVlbiBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xpbmsgLSBpcyB0aGlzIGEgaHlwZXJsaW5rIGNlbGxcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFByb3ZpZGVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGVtZXJzb25zIHBhaW50IGZ1bmN0aW9uIGZvciBhIHNsaWRlciBidXR0b24uIGN1cnJlbnRseSB0aGUgdXNlciBjYW5ub3QgaW50ZXJhY3Qgd2l0aCBpdFxuICAgICAqL1xuICAgIHBhaW50U2xpZGVyOiBmdW5jdGlvbihnYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvLyBnYy5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIC8vIHZhciB2YWwgPSB0aGlzLmNvbmZpZy52YWx1ZTtcbiAgICAgICAgLy8gdmFyIHJhZGl1cyA9IGhlaWdodCAvIDI7XG4gICAgICAgIC8vIHZhciBvZmZzZXQgPSB3aWR0aCAqIHZhbDtcbiAgICAgICAgLy8gdmFyIGJnQ29sb3IgPSB0aGlzLmNvbmZpZy5pc1NlbGVjdGVkID8gdGhpcy5jb25maWcuYmdTZWxDb2xvciA6ICcjMzMzMzMzJztcbiAgICAgICAgLy8gdmFyIGJ0bkdyYWRpZW50ID0gZ2MuY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeCwgeSArIGhlaWdodCk7XG4gICAgICAgIC8vIGJ0bkdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBiZ0NvbG9yKTtcbiAgICAgICAgLy8gYnRuR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjNjY2NjY2Jyk7XG4gICAgICAgIC8vIHZhciBhcmNHcmFkaWVudCA9IGdjLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAvLyBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyNhYWFhYWEnKTtcbiAgICAgICAgLy8gYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjNzc3Nzc3Jyk7XG4gICAgICAgIC8vIGdjLmZpbGxTdHlsZSA9IGJ0bkdyYWRpZW50O1xuICAgICAgICAvLyByb3VuZFJlY3QoZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgYnRuR3JhZGllbnQpO1xuICAgICAgICAvLyBpZiAodmFsIDwgMS4wKSB7XG4gICAgICAgIC8vICAgICBnYy5maWxsU3R5bGUgPSBhcmNHcmFkaWVudDtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAgIGdjLmZpbGxTdHlsZSA9ICcjZWVlZWVlJztcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgLy8gZ2MuYXJjKHggKyBNYXRoLm1heChvZmZzZXQgLSByYWRpdXMsIHJhZGl1cyksIHkgKyByYWRpdXMsIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAvLyBnYy5maWxsKCk7XG4gICAgICAgIC8vIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICAvLyB0aGlzLmNvbmZpZy5taW5XaWR0aCA9IDEwMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgYSBzcGFya2xpbmUsIGJlY2F1c2UgaXQncyBhIGJhcmNoYXJ0IHdlJ3ZlIGNoYW5nZWQgdGhlIG5hbWUgOykuXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjIC0gdGhlIFwicGVuXCIgaW4gdGhlIG12YyBtb2RlbCwgd2UgaXNzdWUgZHJhd2luZyBjb21tYW5kcyB0b1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMaW5rIC0gaXMgdGhpcyBhIGh5cGVybGluayBjZWxsXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludFNwYXJrYmFyOiBmdW5jdGlvbihnYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuY29uZmlnLnZhbHVlO1xuICAgICAgICBpZiAoIXZhbCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIHZhciBlV2lkdGggPSB3aWR0aCAvIGNvdW50O1xuICAgICAgICB2YXIgZmdDb2xvciA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5mZ1NlbENvbG9yIDogdGhpcy5jb25maWcuZmdDb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmJnQ29sb3IgfHwgdGhpcy5jb25maWcuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhpcy5jb25maWcuaXNTZWxlY3RlZCA/IHRoaXMuY29uZmlnLmJnU2VsQ29sb3IgOiB0aGlzLmNvbmZpZy5iZ0NvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiYXJoZWlnaHQgPSB2YWxbaV0gLyAxMTAgKiBoZWlnaHQ7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4ICsgNSwgeSArIGhlaWdodCAtIGJhcmhlaWdodCwgZVdpZHRoICogMC42NjY2LCBiYXJoZWlnaHQpO1xuICAgICAgICAgICAgeCA9IHggKyBlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuY29uZmlnLm1pbldpZHRoID0gY291bnQgKiAxMDtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBBIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHNwYXJrbGluZS4gIHNlZSBbRWR3YXJkIFR1ZnRlIHNwYXJrbGluZV0oaHR0cDovL3d3dy5lZHdhcmR0dWZ0ZS5jb20vYmJvYXJkL3EtYW5kLWEtZmV0Y2gtbXNnP21zZ19pZD0wMDAxT1IpXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjIC0gdGhlIFwicGVuXCIgaW4gdGhlIG12YyBtb2RlbCwgd2UgaXNzdWUgZHJhd2luZyBjb21tYW5kcyB0b1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMaW5rIC0gaXMgdGhpcyBhIGh5cGVybGluayBjZWxsXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludFNwYXJrbGluZTogZnVuY3Rpb24oZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmNvbmZpZy52YWx1ZTtcbiAgICAgICAgaWYgKCF2YWwgfHwgIXZhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY291bnQgPSB2YWwubGVuZ3RoO1xuICAgICAgICB2YXIgZVdpZHRoID0gd2lkdGggLyBjb3VudDtcblxuICAgICAgICB2YXIgZmdDb2xvciA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5mZ1NlbENvbG9yIDogdGhpcy5jb25maWcuZmdDb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmJnQ29sb3IgfHwgdGhpcy5jb25maWcuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhpcy5jb25maWcuaXNTZWxlY3RlZCA/IHRoaXMuY29uZmlnLmJnU2VsQ29sb3IgOiB0aGlzLmNvbmZpZy5iZ0NvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSBmZ0NvbG9yO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBmZ0NvbG9yO1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmFyaGVpZ2h0ID0gdmFsW2ldIC8gMTEwICogaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IGJhcmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdjLmxpbmVUbyh4ICsgNSwgeSArIGhlaWdodCAtIGJhcmhlaWdodCk7XG4gICAgICAgICAgICBnYy5hcmMoeCArIDUsIHkgKyBoZWlnaHQgLSBiYXJoZWlnaHQsIDEsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICB4ID0geCArIGVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZy5taW5XaWR0aCA9IGNvdW50ICogMTA7XG4gICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgYSB0cmVlIGNlbGwgcmVuZGVyZXIgZm9yIHVzZSBtYWlubHkgd2l0aCB0aGUgcXRyZWUuXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjIC0gdGhlIFwicGVuXCIgaW4gdGhlIG12YyBtb2RlbCwgd2UgaXNzdWUgZHJhd2luZyBjb21tYW5kcyB0b1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMaW5rIC0gaXMgdGhpcyBhIGh5cGVybGluayBjZWxsXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0cmVlQ2VsbFJlbmRlcmVyOiBmdW5jdGlvbihnYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5jb25maWcudmFsdWUuZGF0YTtcbiAgICAgICAgdmFyIGluZGVudCA9IHRoaXMuY29uZmlnLnZhbHVlLmluZGVudDtcbiAgICAgICAgdmFyIGljb24gPSB0aGlzLmNvbmZpZy52YWx1ZS5pY29uO1xuXG4gICAgICAgIC8vZmlsbCBiYWNrZ3JvdW5kIG9ubHkgaWYgb3VyIGJnQ29sb3IgaXMgcG9wdWxhdGVkIG9yIHdlIGFyZSBhIHNlbGVjdGVkIGNlbGxcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmJnQ29sb3IgfHwgdGhpcy5jb25maWcuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhpcy5jb25maWcuaXNTZWxlY3RlZCA/IHRoaXMuY29uZmlnLmJnU2VsQ29sb3IgOiB0aGlzLmNvbmZpZy5iZ0NvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZhbCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZ25PZmZzZXQgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhpcy5jb25maWcuaXNTZWxlY3RlZCA/IHRoaXMuY29uZmlnLmZnU2VsQ29sb3IgOiB0aGlzLmNvbmZpZy5mZ0NvbG9yO1xuICAgICAgICBnYy5maWxsVGV4dChpY29uICsgdmFsLCB4ICsgaW5kZW50LCB5ICsgdmFsaWduT2Zmc2V0KTtcblxuICAgICAgICB2YXIgdGV4dFdpZHRoID0gdGhpcy5jb25maWcuZ2V0VGV4dFdpZHRoKGdjLCBpY29uICsgdmFsKTtcbiAgICAgICAgdmFyIG1pbldpZHRoID0geCArIGluZGVudCArIHRleHRXaWR0aCArIDEwO1xuICAgICAgICB0aGlzLmNvbmZpZy5taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBBbiBlbXB0eSBpbXBsZW1lbnRhdGlvbiBvZiBhIGNlbGwgcmVuZGVyZXIsIHNlZSBbdGhlIG51bGwgb2JqZWN0IHBhdHRlcm5dKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/TnVsbE9iamVjdCkuXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjIC0gdGhlIFwicGVuXCIgaW4gdGhlIG12YyBtb2RlbCwgd2UgaXNzdWUgZHJhd2luZyBjb21tYW5kcyB0b1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBtZW1iZXJPZiBDZWxsUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xpbmsgLSBpcyB0aGlzIGEgaHlwZXJsaW5rIGNlbGxcbiAgICAgKi9cbiAgICBlbXB0eUNlbGxSZW5kZXJlcjogZnVuY3Rpb24oZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXRpYWxpemVDZWxsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5jZWxsQ2FjaGUuc2ltcGxlQ2VsbFJlbmRlcmVyID0ge1xuICAgICAgICAgICAgcGFpbnQ6IHRoaXMuZGVmYXVsdENlbGxQYWludCxcbiAgICAgICAgICAgIHJlbmRlclNpbmdsZUxpbmVUZXh0OiB0aGlzLnJlbmRlclNpbmdsZUxpbmVUZXh0LFxuICAgICAgICAgICAgcmVuZGVyTXVsdGlMaW5lVGV4dDogdGhpcy5yZW5kZXJNdWx0aUxpbmVUZXh0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2VsbENhY2hlLnNsaWRlckNlbGxSZW5kZXJlciA9IHtcbiAgICAgICAgICAgIHBhaW50OiB0aGlzLnBhaW50U2xpZGVyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2VsbENhY2hlLnNwYXJrYmFyQ2VsbFJlbmRlcmVyID0ge1xuICAgICAgICAgICAgcGFpbnQ6IHRoaXMucGFpbnRTcGFya2JhclxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNlbGxDYWNoZS5zcGFya2xpbmVDZWxsUmVuZGVyZXIgPSB7XG4gICAgICAgICAgICBwYWludDogdGhpcy5wYWludFNwYXJrbGluZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNlbGxDYWNoZS50cmVlQ2VsbFJlbmRlcmVyID0ge1xuICAgICAgICAgICAgcGFpbnQ6IHRoaXMudHJlZUNlbGxSZW5kZXJlclxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNlbGxDYWNoZS5lbXB0eUNlbGxSZW5kZXJlciA9IHtcbiAgICAgICAgICAgIHBhaW50OiB0aGlzLmVtcHR5Q2VsbFJlbmRlcmVyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2VsbENhY2hlLmJ1dHRvblJlbmRlcmVyID0ge1xuICAgICAgICAgICAgcGFpbnQ6IHRoaXMucGFpbnRCdXR0b24sXG4gICAgICAgICAgICAvL2RlZmF1bHRDZWxsUGFpbnQ6IHRoaXMuZGVmYXVsdENlbGxQYWludFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNlbGxDYWNoZS5saW5rQ2VsbFJlbmRlcmVyID0ge1xuICAgICAgICAgICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgICAgICBzZWxmLmRlZmF1bHRDZWxsUGFpbnQoZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiB2YWx1ZU9yRnVuY3Rpb25FeGVjdXRlKGNvbmZpZywgdmFsdWVPckZ1bmN0aW9uKSB7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSAoKCh0eXBlb2YgdmFsdWVPckZ1bmN0aW9uKVswXSkgPT09ICdmJyk7XG4gICAgdmFyIHJlc3VsdCA9IGlzRnVuY3Rpb24gPyB2YWx1ZU9yRnVuY3Rpb24oY29uZmlnKSA6IHZhbHVlT3JGdW5jdGlvbjtcbiAgICBpZiAoIXJlc3VsdCAmJiByZXN1bHQgIT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1bmRlcmxpbmUoY29uZmlnLCBnYywgdGV4dCwgeCwgeSwgdGhpY2tuZXNzKSB7XG4gICAgdmFyIHdpZHRoID0gY29uZmlnLmdldFRleHRXaWR0aChnYywgdGV4dCk7XG5cbiAgICBzd2l0Y2ggKGdjLnRleHRBbGlnbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgeCAtPSAod2lkdGggLyAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICB4IC09IHdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy9nYy5iZWdpblBhdGgoKTtcbiAgICBnYy5saW5lV2lkdGggPSB0aGlja25lc3M7XG4gICAgZ2MubW92ZVRvKHggKyAwLjUsIHkgKyAwLjUpO1xuICAgIGdjLmxpbmVUbyh4ICsgd2lkdGggKyAwLjUsIHkgKyAwLjUpO1xufVxuXG5mdW5jdGlvbiBmaW5kTGluZXMoZ2MsIGNvbmZpZywgd29yZHMsIHdpZHRoKSB7XG5cbiAgICBpZiAod29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB3b3JkcztcbiAgICB9XG5cbiAgICAvLyBzdGFydGluZyB3aXRoIGp1c3QgdGhlIGZpcnN0IHdvcmTigKZcbiAgICB2YXIgc3RpbGxGaXRzLCBsaW5lID0gW3dvcmRzLnNoaWZ0KCldO1xuICAgIHdoaWxlIChcbiAgICAgICAgLy8gc28gbG9uZSBhcyBsaW5lIHN0aWxsIGZpdHMgd2l0aGluIGN1cnJlbnQgY29sdW1u4oCmXG4gICAgKHN0aWxsRml0cyA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIGxpbmUuam9pbignICcpKSA8IHdpZHRoKVxuICAgICAgICAvLyDigKZBTkQgdGhlcmUgYXJlIG1vcmUgd29yZHMgYXZhaWxhYmxl4oCmXG4gICAgJiYgd29yZHMubGVuZ3RoXG4gICAgICAgICkge1xuICAgICAgICAvLyDigKZhZGQgYW5vdGhlciB3b3JkIHRvIGVuZCBvZiBsaW5lIGFuZCByZXRlc3RcbiAgICAgICAgbGluZS5wdXNoKHdvcmRzLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICAgIXN0aWxsRml0cyAvLyBpZiBsaW5lIGlzIG5vdyB0b28gbG9uZ+KAplxuICAgICAgICAmJiBsaW5lLmxlbmd0aCA+IDEgLy8g4oCmQU5EIGlzIG11bHRpcGxlIHdvcmRz4oCmXG4gICAgKSB7XG4gICAgICAgIHdvcmRzLnVuc2hpZnQobGluZS5wb3AoKSk7IC8vIOKApmJhY2sgb2ZmIGJ5IChpLmUuLCByZW1vdmUpIG9uZSB3b3JkXG4gICAgfVxuXG4gICAgbGluZSA9IFtsaW5lLmpvaW4oJyAnKV07XG5cbiAgICBpZiAod29yZHMubGVuZ3RoKSB7IC8vIGlmIHRoZXJlJ3MgYW55dGhpbmcgbGVmdOKAplxuICAgICAgICBsaW5lID0gbGluZS5jb25jYXQoZmluZExpbmVzKGdjLCBjb25maWcsIHdvcmRzLCB3aWR0aCkpOyAvLyDigKZicmVhayBpdCB1cCBhcyB3ZWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmU7XG59XG5cbmZ1bmN0aW9uIGZpdFRleHQoZ2MsIGNvbmZpZywgc3RyaW5nLCB3aWR0aCkge1xuICAgIHJldHVybiBmaW5kTGluZXMoZ2MsIGNvbmZpZywgc3F1ZWV6ZShzdHJpbmcpLnNwbGl0KCcgJyksIHdpZHRoKTtcbn1cblxuLy8gdHJpbSBzdHJpbmc7IHRoZW4gcmVkdWNlIGFsbCBydW5zIG9mIG11bHRpcGxlIHNwYWNlcyB0byBhIHNpbmdsZSBzcGFjZVxuZnVuY3Rpb24gc3F1ZWV6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnRvU3RyaW5nKCkudHJpbSgpLnJlcGxhY2UoL1xcc1xccysvZywgJyAnKTtcbn1cblxuZnVuY3Rpb24gcm91bmRSZWN0KGdjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMsIGZpbGwsIHN0cm9rZSkge1xuXG4gICAgaWYgKCFzdHJva2UpIHtcbiAgICAgICAgc3Ryb2tlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFyYWRpdXMpIHtcbiAgICAgICAgcmFkaXVzID0gNTtcbiAgICB9XG4gICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgZ2MubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgIGdjLmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuICAgIGdjLmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgIGdjLmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICBnYy5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgIGdjLmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgICBnYy5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGdjLmZpbGwoKTtcbiAgICB9XG4gICAgZ2MuY2xvc2VQYXRoKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbFByb3ZpZGVyO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1tZScpO1xudmFyIEZpbkJhciA9IHJlcXVpcmUoJ2ZpbmJhcnMnKTtcbnZhciBDYW52YXMgPSByZXF1aXJlKCdmaW5jYW52YXMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3JlY3Rhbmd1bGFyJykuUG9pbnQ7XG52YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKS5SZWN0YW5nbGU7XG52YXIgTFJVQ2FjaGUgPSByZXF1aXJlKCdscnUtY2FjaGUnKTtcbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xuXG52YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuL1JlbmRlcmVyJyk7XG52YXIgU2VsZWN0aW9uTW9kZWwgPSByZXF1aXJlKCcuL1NlbGVjdGlvbk1vZGVsJyk7XG52YXIgYWRkU3R5bGVzaGVldCA9IHJlcXVpcmUoJy4vc3R5bGVzaGVldHMnKTtcblxudmFyIGdsb2JhbENlbGxFZGl0b3JzID0ge30sXG4gICAgcHJvcGVydGllc0luaXRpYWxpemVkID0gZmFsc2UsXG4gICAgdGV4dFdpZHRoQ2FjaGUgPSBuZXcgTFJVQ2FjaGUoMjAwMCksXG4gICAgZGVmYXVsdHMgPSBkZWZhdWx0UHJvcGVydGllcygpLFxuICAgIHBvbHltZXJUaGVtZSA9IE9iamVjdC5jcmVhdGUoZGVmYXVsdHMpLFxuICAgIGdsb2JhbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKHBvbHltZXJUaGVtZSk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fSBkaXYgLSBDU1Mgc2VsZWN0b3Igb3IgRWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGJlaGF2aW9yTmFtZSAtIG5hbWUgb2YgYSBiZWhhdmlvciBjb25zc3RydWN0b3IgZnJvbSAuL2JlaGF2aW9yc1xuICovXG5mdW5jdGlvbiBIeXBlcmdyaWQoZGl2LCBiZWhhdmlvckZhY3RvcnkpIHtcblxuICAgIGV4dGVuZC5kZWJ1ZyA9IHRydWU7XG5cbiAgICBpbnN0YWxsUG9seWZpbGxzKCk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmRpdiA9ICh0eXBlb2YgZGl2ID09PSAnc3RyaW5nJykgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRpdikgOiBkaXY7XG5cbiAgICBhZGRTdHlsZXNoZWV0KCdncmlkJyk7XG5cbiAgICB0aGlzLmxhc3RFZGdlU2VsZWN0aW9uID0gWzAsIDBdO1xuXG4gICAgdGhpcy5sbmZQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShnbG9iYWxQcm9wZXJ0aWVzKTtcblxuICAgIHRoaXMuaXNXZWJraXQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2Via2l0JykgPiAtMTtcbiAgICB0aGlzLnNlbGVjdGlvbk1vZGVsID0gbmV3IFNlbGVjdGlvbk1vZGVsKCk7XG4gICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRHcmlkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgdGhpcy5jZWxsRWRpdG9ycyA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsQ2VsbEVkaXRvcnMpO1xuICAgIHRoaXMucmVuZGVyT3ZlcnJpZGVzQ2FjaGUgPSB7fTtcblxuICAgIHRoaXMuYmVoYXZpb3IgPSBiZWhhdmlvckZhY3RvcnkodGhpcyk7XG5cbiAgICAvL3ByZXZlbnQgdGhlIGRlZmF1bHQgY29udGV4dCBtZW51IGZvciBhcHBlYXJpbmdcbiAgICB0aGlzLmRpdi5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyTW91c2VEb3duKCk7XG4gICAgdGhpcy5kcmFnRXh0ZW50ID0gbmV3IFBvaW50KDAsIDApO1xuICAgIHRoaXMubnVtUm93cyA9IDA7XG4gICAgdGhpcy5udW1Db2x1bW5zID0gMDtcblxuICAgIC8vaW5zdGFsbCBhbnkgcGx1Z2luc1xuICAgIHRoaXMucGx1Z2luc0RvKGZ1bmN0aW9uKGVhY2gpIHtcbiAgICAgICAgaWYgKGVhY2guaW5zdGFsbE9uKSB7XG4gICAgICAgICAgICBlYWNoLmluc3RhbGxPbihzZWxmKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy9pbml0aWFsaXplIG91ciB2YXJpb3VzIHBpZWNlc1xuICAgIHRoaXMuaW5pdFJlbmRlcmVyKCk7XG4gICAgdGhpcy5pbml0Q2FudmFzKCk7XG4gICAgdGhpcy5pbml0U2Nyb2xsYmFycygpO1xuICAgIHRoaXMuaW5pdEdsb2JhbENlbGxFZGl0b3JzKCk7XG5cbiAgICB0aGlzLmNoZWNrU2Nyb2xsYmFyVmlzaWJpbGl0eSgpO1xuICAgIC8vUmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgdGhlIGNvcHkgZXZlbnQgc28gd2UgY2FuIGNvcHkgb3VyIHNlbGVjdGVkIHJlZ2lvbiB0byB0aGUgcGFzdGVidWZmZXIgaWYgY29uZGl0aW9ucyBhcmUgcmlnaHQuXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjb3B5JywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHNlbGYuY2hlY2tDbGlwYm9hcmRDb3B5KGV2dCk7XG4gICAgfSk7XG4gICAgdGhpcy5nZXRDYW52YXMoKS5yZXNpemUoKTtcbiAgICAvL3RoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG59XG5cbkh5cGVyZ3JpZC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IEh5cGVyZ3JpZC5wcm90b3R5cGUuY29uc3RydWN0b3IsXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEEgbnVsbCBvYmplY3QgYmVoYXZpb3Igc2VydmVzIGFzIGEgcGxhY2UgaG9sZGVyLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBiZWhhdmlvcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCByZXN1bHQgb2YgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gd2Via2l0LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgaXNXZWJraXQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgYW4gaW5pdGlhbCBtb3VzZWRvd24gY2xpY2ssIGVpdGhlciBmb3IgZWRpdGluZyBhIGNlbGwgb3IgZm9yIGRyYWdnaW5nIGEgc2VsZWN0aW9uLlxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIG1vdXNlRG93bjogW10sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXh0ZW50IGZyb20gdGhlIG1vdXNlZG93biBwb2ludCBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIGRyYWdFeHRlbnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBBIGZsb2F0IHZhbHVlIGJldHdlZW4gMC4wIC0gMS4wIG9mIHRoZSB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHZTY3JvbGxWYWx1ZTogMCxcblxuICAgIC8qKlxuICAgICAqIEEgZmxvYXQgdmFsdWUgYmV0d2VlbiAwLjAgLSAxLjAgb2YgdGhlIGhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoU2Nyb2xsVmFsdWU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXJ9IHJlY3Rhbmd1bGFyIC0gTmFtZXNwYWNlIGZvciBQb2ludCBhbmQgUmVjdGFuZ2xlIFwiY2xhc3Nlc1wiIChjb25zdHJ1Y3RvcnMpLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVjdGFuZ3VsYXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Zpbi1oeXBlcmdyaWQtc2VsZWN0aW9uLW1vZGVsfSBzZWxlY3Rpb25Nb2RlbCAtIEEgW2Zpbi1oeXBlcmdyaWQtc2VsZWN0aW9uLW1vZGVsXShtb2R1bGUtLl9zZWxlY3Rpb24tbW9kZWwuaHRtbCkgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Nb2RlbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7ZmluLWh5cGVyZ3JpZC1jZWxsLWVkaXRvcn0gY2VsbEVkaXRvciAtIFRoZSBjdXJyZW50IGluc3RhbmNlIG9mIFtmaW4taHlwZXJncmlkLWNlbGwtZWRpdG9yXShtb2R1bGUtY2VsbC1lZGl0b3JzX2Jhc2UuaHRtbCkuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjZWxsRWRpdG9yOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtmaW4tdmFtcGlyZS1iYXJ9IHNiSFNjcm9sbGVyIC0gQW4gaW5zdGFuY2Ugb2YgW2Zpbi12YW1waXJlLWJhcl0oaHR0cDovL2RhdGFtYWRpYy5naXRodWIuaW8vZmluLXZhbXBpcmUtYmFyL2NvbXBvbmVudHMvZmluLXZhbXBpcmUtYmFyLykuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkhTY3JvbGxlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7ZmluLXZhbXBpcmUtYmFyfSBzYlZTY3JvbGxlciAtIEFuIGluc3RhbmNlIG9mIFtmaW4tdmFtcGlyZS1iYXJdKGh0dHA6Ly9kYXRhbWFkaWMuZ2l0aHViLmlvL2Zpbi12YW1waXJlLWJhci9jb21wb25lbnRzL2Zpbi12YW1waXJlLWJhci8pLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JWU2Nyb2xsZXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJldmlvdXMgdmFsdWUgb2Ygc2JWU2Nyb2xsVmFsLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYlByZXZWU2Nyb2xsVmFsdWU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJldmlvdXMgdmFsdWUgb2Ygc2JIU2Nyb2xsVmFsdWUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiUHJldkhTY3JvbGxWYWx1ZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYWNoZSBvZiBzaW5nbGV0b24gY2VsbEVkaXRvcnMuXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNlbGxFZGl0b3JzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogaXMgdGhlIHNob3J0IHRlcm0gbWVtb3J5IG9mIHdoYXQgY29sdW1uIEkgbWlnaHQgYmUgZHJhZ2dpbmcgYXJvdW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgcmVuZGVyT3ZlcnJpZGVzQ2FjaGU6IHt9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjdXJyZW50IGhvdmVyZWQgY2VsbC5cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBob3ZlckNlbGw6IG51bGwsXG5cbiAgICBzY3JvbGxpbmdOb3c6IGZhbHNlLFxuXG4gICAgbGFzdEVkZ2VTZWxlY3Rpb246IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgIGNsZWFyIG91dCB0aGUgTFJVIGNhY2hlIG9mIHRleHQgd2lkdGhzXG4gICAgICovXG4gICAgc2V0QXR0cmlidXRlOiBmdW5jdGlvbihhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICBjbGVhciBvdXQgYWxsIHN0YXRlIGFuZCBkYXRhIG9mIHRoZSBncmlkXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb24gPSBbMCwgMF07XG4gICAgICAgIHRoaXMubG5mUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsUHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwgPSBuZXcgU2VsZWN0aW9uTW9kZWwoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRHcmlkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jZWxsRWRpdG9ycyA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsQ2VsbEVkaXRvcnMpO1xuICAgICAgICB0aGlzLnJlbmRlck92ZXJyaWRlc0NhY2hlID0ge307XG4gICAgICAgIHRoaXMuY2xlYXJNb3VzZURvd24oKTtcbiAgICAgICAgdGhpcy5kcmFnRXh0ZW50ID0gbmV3IFBvaW50KDAsIDApO1xuXG4gICAgICAgIHRoaXMubnVtUm93cyA9IDA7XG4gICAgICAgIHRoaXMubnVtQ29sdW1ucyA9IDA7XG5cbiAgICAgICAgdGhpcy52U2Nyb2xsVmFsdWUgPSAwO1xuICAgICAgICB0aGlzLmhTY3JvbGxWYWx1ZSA9IDA7XG5cbiAgICAgICAgdGhpcy5jZWxsRWRpdG9yID0gbnVsbDtcblxuICAgICAgICB0aGlzLnNiUHJldlZTY3JvbGxWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2JQcmV2SFNjcm9sbFZhbHVlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmhvdmVyQ2VsbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2Nyb2xsaW5nTm93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb24gPSBbMCwgMF07XG5cbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZ2V0UmVuZGVyZXIoKS5yZXNldCgpO1xuICAgICAgICB0aGlzLmdldENhbnZhcygpLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICByZXNldFRleHRXaWR0aENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGV4dFdpZHRoQ2FjaGUgPSBuZXcgTFJVQ2FjaGUoMjAwMCk7XG4gICAgfSxcblxuICAgIGdldFByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgX2dldFByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sbmZQcm9wZXJ0aWVzO1xuICAgIH0sXG5cbiAgICBjb21wdXRlQ2VsbHNCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKCk7XG4gICAgICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJlci5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICB9LFxuXG4gICAgaW5pdENlbGxFZGl0b3I6IGZ1bmN0aW9uKGNlbGxFZGl0b3IpIHtcbiAgICAgICAgdmFyIGRpdkNlbGxFZGl0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoZGl2Q2VsbEVkaXRvcik7XG5cbiAgICAgICAgZ2xvYmFsQ2VsbEVkaXRvcnNbY2VsbEVkaXRvci5hbGlhc10gPSBjZWxsRWRpdG9yO1xuICAgIH0sXG5cbiAgICBpbml0R2xvYmFsQ2VsbEVkaXRvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXByb3BlcnRpZXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcHJvcGVydGllc0luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgYnVpbGRQb2x5bWVyVGhlbWUoKTtcblxuICAgICAgICAgICAgdmFyIGNlbGxFZGl0b3JzID0gW1xuICAgICAgICAgICAgICAgICdUZXh0ZmllbGQnLFxuICAgICAgICAgICAgICAgICdDaG9pY2UnLFxuICAgICAgICAgICAgICAgIC8vJ0NvbWJvJyxcbiAgICAgICAgICAgICAgICAnQ29sb3InLFxuICAgICAgICAgICAgICAgICdEYXRlJyxcbiAgICAgICAgICAgICAgICAnU2xpZGVyJyxcbiAgICAgICAgICAgICAgICAnU3Bpbm5lcidcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGNlbGxFZGl0b3JzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuaW5pdENlbGxFZGl0b3IobmV3IEh5cGVyZ3JpZC5jZWxsRWRpdG9yc1tuYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0b2dnbGVDb2x1bW5QaWNrZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkudG9nZ2xlQ29sdW1uUGlja2VyKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBwb2ludGVyIGlzIG92ZXIgdGhlIGdpdmVuIGNlbGwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgaXNIb3ZlcmVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5nZXRIb3ZlckNlbGwoKTtcbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAueCA9PT0geCAmJiBwLnkgPT09IHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgYm9vbGVhbn0gVGhlIHBvaW50ZXIgaXMgaG92ZXJpbmcgb3ZlciB0aGUgZ2l2ZW4gY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgY2VsbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIGlzQ29sdW1uSG92ZXJlZDogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0SG92ZXJDZWxsKCk7XG4gICAgICAgIGlmICghcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwLnggPT09IHg7XG4gICAgfSxcblxuICAgIGlzUm93UmVzaXplYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgncm93UmVzaXplJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgcG9pbnRlciBpcyBob3ZlcmluZyBvdmVyIHRoZSByb3cgYHlgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNlbGwgY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICBpc1Jvd0hvdmVyZWQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmdldEhvdmVyQ2VsbCgpO1xuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcC55ID09PSB5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gVGhlIGNlbGwgb3ZlciB3aGljaCB0aGUgY3Vyc29yIGlzIGhvdmVyaW5nLlxuICAgICAqL1xuICAgIGdldEhvdmVyQ2VsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdmVyQ2VsbDtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgY2VsbCB1bmRlciB0aGUgY3Vyc29yLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gICAgICovXG4gICAgc2V0SG92ZXJDZWxsOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzLmhvdmVyQ2VsbDtcbiAgICAgICAgdmFyIG5ld1BvaW50ID0gbmV3IFBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBpZiAobWUgJiYgbWUuZXF1YWxzKG5ld1BvaW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG92ZXJDZWxsID0gbmV3UG9pbnQ7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY09uQ2VsbEVudGVyRXZlbnQobmV3UG9pbnQpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBbW1lbmQgcHJvcGVydGllcyBmb3IgYWxsIGh5cGVyZ3JpZHMgaW4gdGhpcyBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gQSBzaW1wbGUgcHJvcGVydGllcyBoYXNoLlxuICAgICAqL1xuICAgIGFkZEdsb2JhbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgLy93ZSBjaGVjayBmb3IgZXhpc3RlbmNlIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uIGluIGluaXRpYWxpemF0aW9uXG4gICAgICAgIGlmICghZ2xvYmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFkZEdsb2JhbFByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRHbG9iYWxQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBbW1lbmQgcHJvcGVydGllcyBmb3IgYWxsIGh5cGVyZ3JpZHMgaW4gdGhpcyBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gQSBzaW1wbGUgcHJvcGVydGllcyBoYXNoLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEdsb2JhbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgXyhwcm9wZXJ0aWVzKS5lYWNoKGZ1bmN0aW9uKHByb3BlcnR5LCBrZXkpIHtcbiAgICAgICAgICAgIGdsb2JhbFByb3BlcnRpZXNba2V5XSA9IHByb3BlcnR5O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBbW1lbmQgcHJvcGVydGllcyBmb3IgdGhpcyBoeXBlcmdyaWQgb25seS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllcyAtIEEgc2ltcGxlIHByb3BlcnRpZXMgaGFzaC5cbiAgICAgKi9cbiAgICBhZGRQcm9wZXJ0aWVzOiBmdW5jdGlvbihtb3JlUHJvcGVydGllcykge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICBfKG1vcmVQcm9wZXJ0aWVzKS5lYWNoKGZ1bmN0aW9uKHByb3BlcnR5LCBrZXkpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNba2V5XSA9IG1vcmVQcm9wZXJ0aWVzW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZnJlc2hQcm9wZXJ0aWVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVXRpbGl0eSBmdW5jdGlvbiB0byBwdXNoIG91dCBwcm9wZXJ0aWVzIGlmIHdlIGNoYW5nZSB0aGVtLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gQW4gb2JqZWN0IG9mIHZhcmlvdXMga2V5IHZhbHVlIHBhaXJzLlxuICAgICAqL1xuXG4gICAgcmVmcmVzaFByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB0aGlzLmNhbnZhcyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdmaW4tY2FudmFzJyk7XG4gICAgICAgIC8vdGhpcy5jYW52YXMgPSBuZXcgQ2FudmFzKHRoaXMuZGl2Q2FudmFzLCB0aGlzLnJlbmRlcmVyKTsgLy9UT0RPOiBEbyB3ZSByZWFsbHkgbmVlZCB0byBiZSByZWNyZWF0aW5nIGl0IGhlcmU/XG4gICAgICAgIHRoaXMuY2hlY2tTY3JvbGxiYXJWaXNpYmlsaXR5KCk7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5kZWZhdWx0Um93SGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNDb2x1bW5BdXRvc2l6aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5hdXRvc2l6ZUFsbENvbHVtbnMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBzdGF0ZSBvYmplY3QgZm9yIHJlbWVtYmVyaW5nIG91ciBzdGF0ZS5cbiAgICAgKiBAc2VlIFtNZW1lbnRvIHBhdHRlcm5dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVtZW50b19wYXR0ZXJuKVxuICAgICAqL1xuICAgIGdldFByaXZhdGVTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBzdGF0ZSBvYmplY3QgdG8gcmV0dXJuIHRvIHRoZSBnaXZlbiB1c2VyIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gQSBtZW1lbnRvIG9iamVjdC5cbiAgICAgKiBAc2VlIFtNZW1lbnRvIHBhdHRlcm5dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVtZW50b19wYXR0ZXJuKVxuICAgICAqL1xuICAgIHNldFN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmJlaGF2aW9yQ2hhbmdlZCgpO1xuICAgICAgICAgICAgc2VsZi5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllcygpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0U3RhdGUoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIGluaXRpYWwgbW91c2UgcG9zaXRpb24gb24gYSBtb3VzZSBkb3duIGV2ZW50IGZvciBjZWxsIGVkaXRpbmcgb3IgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldE1vdXNlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5tb3VzZURvd24ubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZURvd25bbGFzdF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVtb3ZlIHRoZSBsYXN0IGl0ZW0gZnJvbSB0aGUgbW91c2UgZG93biBzdGFjay5cbiAgICAgKi9cbiAgICBwb3BNb3VzZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZURvd24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZURvd24ubGVuZ3RoID0gdGhpcy5tb3VzZURvd24ubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBFbXB0eSBvdXQgdGhlIG1vdXNlIGRvd24gc3RhY2suXG4gICAgICovXG4gICAgY2xlYXJNb3VzZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IFtuZXcgUG9pbnQoLTEsIC0xKV07XG4gICAgICAgIHRoaXMuZHJhZ0V4dGVudCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgIHNldCB0aGUgbW91c2UgcG9pbnQgdGhhdCBpbml0YXRlZCBhIGNlbGwgZWRpdCBvciBkcmFnIG9wZXJhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKi9cbiAgICBzZXRNb3VzZURvd246IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHRoaXMubW91c2VEb3duLnB1c2gocG9pbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gVGhlIGV4dGVudCBwb2ludCBvZiB0aGUgY3VycmVudCBkcmFnIHNlbGVjdGlvbiByZWN0YW5nbGUuXG4gICAgICovXG4gICAgZ2V0RHJhZ0V4dGVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdFeHRlbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2V0cyB0aGUgZXh0ZW50IHBvaW50IG9mIHRoZSBjdXJyZW50IGRyYWcgc2VsZWN0aW9uIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICAgICAqL1xuICAgIHNldERyYWdFeHRlbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHRoaXMuZHJhZ0V4dGVudCA9IHBvaW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEl0ZXJhdGUgb3ZlciB0aGUgcGx1Z2lucyBpbnZva2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb24gd2l0aCBlYWNoLlxuICAgICAqIEB0b2RvIFdlIG5lZWQgYSBuZXcgcGx1Z2luIG1lY2hhbmlzbSFcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGludm9rZSBvbiBhbGwgdGhlIHBsdWdpbnMuXG4gICAgICovXG4gICAgcGx1Z2luc0RvOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIC8vVE9ETzogV2UgbmVlZCBhIG5ldyBwbHVnaW4gbWVjaGFuaXNtIVxuICAgICAgICAvL3ZhciB1c2VyUGx1Z2lucyA9IHRoaXMuY2hpbGRyZW4uYXJyYXkoKTtcbiAgICAgICAgLy92YXIgcGx1Z2luc1RhZyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdmaW4tcGx1Z2lucycpO1xuICAgICAgICAvL1xuICAgICAgICAvL3ZhciBwbHVnaW5zID0gdXNlclBsdWdpbnM7XG4gICAgICAgIC8vaWYgKHBsdWdpbnNUYWcpIHtcbiAgICAgICAgLy8gICAgdmFyIHN5c3RlbVBsdWdpbnMgPSBwbHVnaW5zVGFnLmNoaWxkcmVuLmFycmF5KCk7XG4gICAgICAgIC8vICAgIHBsdWdpbnMgPSBzeXN0ZW1QbHVnaW5zLmNvbmNhdChwbHVnaW5zKTtcbiAgICAgICAgLy99XG4gICAgICAgIC8vXG4gICAgICAgIC8vcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuICAgICAgICAvLyAgICBmdW5jKHBsdWdpbik7XG4gICAgICAgIC8vfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhlIENlbGxQcm92aWRlciBpcyBhY2Nlc3NlZCB0aHJvdWdoIEh5cGVyZ3JpZCBiZWNhdXNlIEh5cGVyZ3JpZCBpcyB0aGUgbWVkaWF0b3IgYW5kIHNob3VsZCBoYXZlIHVsdGltYXRlIGNvbnRyb2wgb24gd2hlcmUgaXQgY29tZXMgZnJvbS4gVGhlIGRlZmF1bHQgaXMgdG8gZGVsZWdhdGUgdGhyb3VnaCB0aGUgYmVoYXZpb3Igb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtmaW4taHlwZXJncmlkLWNlbGwtcHJvdmlkZXJ9XG4gICAgICovXG4gICAgZ2V0Q2VsbFByb3ZpZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdGhpcy5nZXRCZWhhdmlvcigpLmdldENlbGxQcm92aWRlcigpO1xuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBmdW5jdGlvbiBpcyBhIGNhbGxiYWNrIGZyb20gdGhlIEh5cGVyZ3JpZFJlbmRlcmVyIHN1Yi1jb21wb25lbnQuIEl0IGlzIGNhbGxlZCBhZnRlciBlYWNoIHBhaW50IG9mIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGVSZW5kZXJlZFNpemVzKCk7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5ncmlkUmVuZGVyZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrQ29sdW1uQXV0b3NpemluZygpO1xuICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNHcmlkUmVuZGVyZWRFdmVudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBncmlkIGhhcyBqdXN0IGJlZW4gcmVuZGVyZWQsIG1ha2Ugc3VyZSB0aGUgY29sdW1uIHdpZHRocyBhcmUgb3B0aW1hbC5cbiAgICAgKi9cbiAgICBjaGVja0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIGJlaGF2aW9yLmF1dG9TaXplUm93TnVtYmVyQ29sdW1uKCk7XG4gICAgICAgIGlmICh0aGlzLmlzQ29sdW1uQXV0b3NpemluZygpKSB7XG4gICAgICAgICAgICBiZWhhdmlvci5jaGVja0NvbHVtbkF1dG9zaXppbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIE5vdGlmeSB0aGUgR3JpZEJlaGF2aW9yIGhvdyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgd2UganVzdCByZW5kZXJlZC5cbiAgICAgKi9cbiAgICB1cGRhdGVSZW5kZXJlZFNpemVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICAvL2FkZCBvbmUgdG8gZWFjaCBvZiB0aGVzZSB2YWx1ZXMgYXMgd2Ugd2FudCBhbHNvIHRvIGluY2x1ZGVcbiAgICAgICAgLy90aGUgY29sdW1ucyBhbmQgcm93cyB0aGF0IGFyZSBwYXJ0aWFsbHkgdmlzaWJsZVxuICAgICAgICBiZWhhdmlvci5zZXRSZW5kZXJlZENvbHVtbkNvdW50KHRoaXMuZ2V0VmlzaWJsZUNvbHVtbnMoKSArIDEpO1xuICAgICAgICBiZWhhdmlvci5zZXRSZW5kZXJlZFJvd0NvdW50KHRoaXMuZ2V0VmlzaWJsZVJvd3MoKSArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IENvbmRpdGlvbmFsbHkgY29weSB0byBjbGlwYm9hcmQuXG4gICAgICogQGRlc2MgSWYgd2UgaGF2ZSBmb2N1cywgY29weSBvdXIgY3VycmVudCBzZWxlY3Rpb24gZGF0YSB0byB0aGUgc3lzdGVtIGNsaXBib2FyZC5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBjb3B5IHN5c3RlbSBldmVudC5cbiAgICAgKi9cbiAgICBjaGVja0NsaXBib2FyZENvcHk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGNzdkRhdGEgPSB0aGlzLmdldFNlbGVjdGlvbkFzVFNWKCk7XG4gICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIGNzdkRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXZSBoYXZlIGFueSBzZWxlY3Rpb25zLlxuICAgICAqL1xuICAgIGhhc1NlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gd2VyZSBub3QgZnVsbHkgaW5pdGlhbGl6ZWQgeWV0XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5oYXNTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGFiIHNlcGFyYXRlZCB2YWx1ZSBzdHJpbmcgZnJvbSB0aGUgc2VsZWN0aW9uIGFuZCBvdXIgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25Bc1RTVjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzbSA9IHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKTtcbiAgICAgICAgaWYgKHNtLmhhc1NlbGVjdGlvbnMoKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAgICAgc2VsZWN0aW9ucyA9IHNlbGVjdGlvbnNbc2VsZWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1hdHJpeFNlbGVjdGlvbkFzVFNWKHNlbGVjdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHNtLmhhc1Jvd1NlbGVjdGlvbnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF0cml4U2VsZWN0aW9uQXNUU1YodGhpcy5nZXRSb3dTZWxlY3Rpb25NYXRyaXgoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc20uaGFzQ29sdW1uU2VsZWN0aW9ucygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXRyaXhTZWxlY3Rpb25Bc1RTVih0aGlzLmdldENvbHVtblNlbGVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRNYXRyaXhTZWxlY3Rpb25Bc1RTVjogZnVuY3Rpb24oc2VsZWN0aW9ucykge1xuICAgICAgICAvL29ubHkgdXNlIHRoZSBkYXRhIGZyb20gdGhlIGxhc3Qgc2VsZWN0aW9uXG4gICAgICAgIGlmIChzZWxlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2VsZWN0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2VsZWN0aW9uc1swXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYXJlYSA9IHdpZHRoICogaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbGxlY3RvciA9IFtdO1xuXG4gICAgICAgICAgICAvL2Rpc2FsbG93IGlmIHNlbGVjdGlvbiBpcyB0b28gYmlnXG4gICAgICAgICAgICBpZiAoYXJlYSA+IDIwMDAwKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ3NlbGVjdGlvbiBzaXplIGlzIHRvbyBiaWcgdG8gY29weSB0byB0aGUgcGFzdGUgYnVmZmVyJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgaGVpZ2h0OyBoKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHdpZHRoOyB3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yLnB1c2goc2VsZWN0aW9uc1t3XVtoXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3IDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5wdXNoKCdcXHQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaCA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3IucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29sbGVjdG9yLmpvaW4oJycpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2UgaGF2ZSBmb2N1cy5cbiAgICAgKi9cbiAgICBoYXNGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENhbnZhcygpLmhhc0ZvY3VzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgQ2xlYXIgYWxsIHRoZSBzZWxlY3Rpb25zLlxuICAgICAqL1xuICAgIGNsZWFyU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5jbGVhcigpO1xuICAgICAgICB0aGlzLmNsZWFyTW91c2VEb3duKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgQ2xlYXIgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgQ2xlYXIgdGhlIG1vc3QgcmVjZW50IGNvbHVtbiBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIENsZWFyIHRoZSBtb3N0IHJlY2VudCByb3cgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5jbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZWxlY3QgZ2l2ZW4gcmVnaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveCAtIG9yaWdpbiB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG95IC0gb3JpZ2luIHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleCAtIGV4dGVudCB5XG4gICAgICovXG4gICAgc2VsZWN0OiBmdW5jdGlvbihveCwgb3ksIGV4LCBleSkge1xuICAgICAgICBpZiAob3ggPCAwIHx8IG95IDwgMCkge1xuICAgICAgICAgICAgLy93ZSBkb24ndCBzZWxlY3QgbmVnYXRpdmUgYXJlYVxuICAgICAgICAgICAgLy9hbHNvIHRoaXMgbWVhbnMgdGhlcmUgaXMgbm8gb3JpZ2luIG1vdXNlIGRvd24gZm9yIGEgc2VsZWN0aW9uIHJlY3RcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuc2VsZWN0KG94LCBveSwgZXgsIGV5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gR2l2ZW4gcG9pbnQgaXMgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmlzU2VsZWN0ZWQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjb2x1bW4gaXMgc2VsZWN0ZWQgYW55d2hlcmUgaW4gdGhlIGVudGlyZSB0YWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sIC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluUm93OiBmdW5jdGlvbihjb2wpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbk1vZGVsID0gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpO1xuICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IHNlbGVjdGlvbk1vZGVsLmlzQ2VsbFNlbGVjdGVkSW5Sb3coY29sKTtcbiAgICAgICAgcmV0dXJuIGlzU2VsZWN0ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiByb3cgaXMgc2VsZWN0ZWQgYW55d2hlcmUgaW4gdGhlIGVudGlyZSB0YWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93IC0gVGhlIHJvdyBpbmRleC5cbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluQ29sdW1uOiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbk1vZGVsID0gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpO1xuICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IHNlbGVjdGlvbk1vZGVsLmlzQ2VsbFNlbGVjdGVkSW5Db2x1bW4ocm93KTtcbiAgICAgICAgcmV0dXJuIGlzU2VsZWN0ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Zpbi1oeXBlcmdyaWQtc2VsZWN0aW9uLW1vZGVsfSBUaGUgc2VsZWN0aW9uIG1vZGVsLlxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbk1vZGVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0JlaGF2aW9yfSBUaGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKi9cbiAgICBnZXRCZWhhdmlvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgQmVoYXZpb3IgKG1vZGVsKSBvYmplY3QgZm9yIHRoaXMgZ3JpZCBjb250cm9sLlxuICAgICAqIEBkZXNjIFRoaXMgY2FuIGJlIGRvbmUgZHluYW1pY2FsbHkuXG4gICAgICogQHBhcmFtIHtCZWhhdmlvcn0gVGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICovXG4gICAgc2V0QmVoYXZpb3I6IGZ1bmN0aW9uKG5ld0JlaGF2aW9yKSB7XG5cbiAgICAgICAgdGhpcy5iZWhhdmlvciA9IG5ld0JlaGF2aW9yO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldEdyaWQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5iZWhhdmlvci5jaGFuZ2VkID0gdGhpcy5iZWhhdmlvckNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zaGFwZUNoYW5nZWQgPSB0aGlzLmJlaGF2aW9yU2hhcGVDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc3RhdGVDaGFuZ2VkID0gdGhpcy5iZWhhdmlvclN0YXRlQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEkndmUgYmVlbiBub3RpZmllZCB0aGF0IHRoZSBiZWhhdmlvciBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBiZWhhdmlvckNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5udW1Db2x1bW5zICE9PSB0aGlzLmdldENvbHVtbkNvdW50KCkgfHwgdGhpcy5udW1Sb3dzICE9PSB0aGlzLmdldFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMubnVtQ29sdW1ucyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgIHRoaXMubnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3JTaGFwZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBNeSBib3VuZHMuXG4gICAgICovXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpO1xuICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyLmdldEJvdW5kcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB2YWx1ZSBvZiBhIGxuZiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gQSBsb29rLWFuZC1mZWVsIGtleS5cbiAgICAgKi9cbiAgICByZXNvbHZlUHJvcGVydHk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9wZXJ0aWVzKClba2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZ3JpZCBkYXRhIGhhdmUgY2hhbmdlZC4gWW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgYmVoYXZpb3JTaGFwZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGdyaWQgZGF0YSBoYXZlIGNoYW5nZWQuIFlvdSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqL1xuICAgIGJlaGF2aW9yU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRSZW5kZXJlcigpLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgcmVwYWludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgncmVwYWludEltbWVkaWF0ZWx5Jyk7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBpZiAobm93ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLnBhaW50Tm93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZXBhaW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBQYWludCBpbW1lZGlhdGVseSBpbiB0aGlzIG1pY3JvdGFzay5cbiAgICAgKi9cbiAgICBwYWludE5vdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgICBjYW52YXMucGFpbnROb3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSW4gSGlEUEkgbW9kZSAoaGFzIGFuIGF0dHJpYnV0ZSBhcyBzdWNoKS5cbiAgICAgKi9cbiAgICB1c2VIaURQSTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgndXNlSGlEUEknKSAhPT0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgSW5pdGlhbGl6ZSBkcmF3aW5nIHN1cmZhY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0Q2FudmFzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRpdkNhbnZhcyA9IHRoaXMuZGl2Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKGRpdkNhbnZhcyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbmV3IENhbnZhcyhkaXZDYW52YXMsIHRoaXMucmVuZGVyZXIpO1xuXG4gICAgICAgIHZhciBzdHlsZSA9IGRpdkNhbnZhcy5zdHlsZTtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBzdHlsZS50b3AgPSAwO1xuICAgICAgICBzdHlsZS5yaWdodCA9ICctMjAwcHgnO1xuICAgICAgICAvL2xlYXZlIHJvb20gZm9yIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXJcbiAgICAgICAgLy9zdHlsZS5tYXJnaW5SaWdodCA9ICcxNXB4JztcbiAgICAgICAgc3R5bGUuYm90dG9tID0gMDtcbiAgICAgICAgLy9sZWF2ZSByb29tIGZvciB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXJcbiAgICAgICAgLy9zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMTVweCc7XG4gICAgICAgIHN0eWxlLmxlZnQgPSAwO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLnJlc2l6ZU5vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5yZXNpemVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGRGaW5FdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGU7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlTW91c2VNb3ZlKG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEZpbkV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9zZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQua2V5cyA9IGUuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIHNlbGYubW91c2VEb3duU3RhdGUgPSBtb3VzZUV2ZW50O1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZU1vdXNlRG93bihtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY01vdXNlRG93bkV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgc2VsZi5yZXBhaW50KCk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLy8gdGhpcy5hZGRGaW5FdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWNsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgLy9zZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIC8vICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgLy8gICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgLy8gICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAvLyAgICAgc2VsZi5maXJlU3ludGhldGljQ2xpY2tFdmVudChtb3VzZUV2ZW50KTtcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgdGhpcy5hZGRGaW5FdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRTY3JvbGxpbmdOb3coZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3NlbGYuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGU7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlTW91c2VVcChtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIGlmIChzZWxmLm1vdXNlRG93blN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljQnV0dG9uUHJlc3NlZEV2ZW50KHNlbGYubW91c2VEb3duU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5tb3VzZURvd25TdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmZpcmVTeW50aGV0aWNNb3VzZVVwRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRmluRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy10YXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3NlbGYuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIHRhcEV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIHRhcEV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIHRhcEV2ZW50LmtleXMgPSBlLmRldGFpbC5rZXlzO1xuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljQ2xpY2tFdmVudCh0YXBFdmVudCk7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlVGFwKHRhcEV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRGaW5FdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWRyYWcnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGU7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlTW91c2VEcmFnKG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEZpbkV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMta2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0tleWRvd25FdmVudChlKTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVLZXlEb3duKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEZpbkV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMta2V5dXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmZpcmVTeW50aGV0aWNLZXl1cEV2ZW50KGUpO1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZUtleVVwKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEZpbkV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtdHJhY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBlLmRldGFpbC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhwcmltRXZlbnQuZHkpID4gTWF0aC5hYnMocHJpbUV2ZW50LmR4KSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmltRXZlbnQueURpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxWQnkoLTIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJpbUV2ZW50LnlEaXJlY3Rpb24gPCAtMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbFZCeSgyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwcmltRXZlbnQueERpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxIQnkoLTEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJpbUV2ZW50LnhEaXJlY3Rpb24gPCAtMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbEhCeSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoaXMuYWRkRmluRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1ob2xkcHVsc2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZygnaG9sZHB1bHNlJyk7XG4gICAgICAgIC8vICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgLy8gICAgICAgICByZXR1cm47XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgLy8gICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgLy8gICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAvLyAgICAgc2VsZi5kZWxlZ2F0ZUhvbGRQdWxzZShtb3VzZUV2ZW50KTtcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgdGhpcy5hZGRGaW5FdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWRibGNsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0RvdWJsZUNsaWNrRXZlbnQobW91c2VFdmVudCwgZSk7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlRG91YmxlQ2xpY2sobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRmluRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy13aGVlbG1vdmVkJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZS5kZXRhaWwucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlV2hlZWxNb3ZlZChtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRGaW5FdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNlb3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZS5kZXRhaWwucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlTW91c2VFeGl0KG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIHRoaXMuYWRkRmluRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1jb250ZXh0LW1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlLmRldGFpbC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVDb250ZXh0TWVudShtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kaXYucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuXG4gICAgfSxcblxuICAgIGNvbnZlcnRWaWV3UG9pbnRUb0RhdGFQb2ludDogZnVuY3Rpb24odmlld1BvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuY29udmVydFZpZXdQb2ludFRvRGF0YVBvaW50KHZpZXdQb2ludCk7XG4gICAgfSxcblxuICAgIGNvbnZlcnREYXRhUG9pbnRUb1ZpZXdQb2ludDogZnVuY3Rpb24oZGF0YVBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuY29udmVydERhdGFQb2ludFRvVmlld1BvaW50KGRhdGFQb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIG1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBUaGUgdHlwZSBvZiBldmVudCB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBldmVudCBoYW5kbGVyLlxuICAgICAqL1xuICAgIGFkZEZpbkV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZXQgZm9yIGBzY3JvbGxpbmdOb3dgIGZpZWxkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNJdE5vdyAtIFRoZSB0eXBlIG9mIGV2ZW50IHdlIGFyZSBpbnRlcmVzdGVkIGluLlxuICAgICAqL1xuICAgIHNldFNjcm9sbGluZ05vdzogZnVuY3Rpb24oaXNJdE5vdykge1xuICAgICAgICB0aGlzLnNjcm9sbGluZ05vdyA9IGlzSXROb3c7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBgc2Nyb2xsaW5nTm93YCBmaWVsZC5cbiAgICAgKi9cbiAgICBpc1Njcm9sbGluZ05vdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbGluZ05vdztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGNvbHVtbiBkaXZpZGVyIHVuZGVyIHRoZSBtb3VzZSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBUaGUgZXZlbnQgdG8gaW50ZXJvZ2F0ZS5cbiAgICAgKi9cbiAgICBvdmVyQ29sdW1uRGl2aWRlcjogZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgICAgICB2YXIgeCA9IG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLng7XG4gICAgICAgIHZhciB3aGljaENvbCA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5vdmVyQ29sdW1uRGl2aWRlcih4KTtcbiAgICAgICAgcmV0dXJuIHdoaWNoQ29sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgcm93IGRpdmlkZXIgdW5kZXIgdGhlIG1vdXNlIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIFRoZSBldmVudCB0byBpbnRlcm9nYXRlLlxuICAgICAqL1xuICAgIG92ZXJSb3dEaXZpZGVyOiBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciB5ID0gbW91c2VFdmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueTtcbiAgICAgICAgdmFyIHdoaWNoID0gdGhpcy5nZXRSZW5kZXJlcigpLm92ZXJSb3dEaXZpZGVyKHkpO1xuICAgICAgICByZXR1cm4gd2hpY2g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3dpdGNoIHRoZSBjdXJzb3IgZm9yIHRoZSBncmlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJzb3JOYW1lIC0gQSB3ZWxsIGtub3cgY3Vyc29yIG5hbWUuXG4gICAgICogQHNlZSBbY3Vyc29yIG5hbWVzXShodHRwOi8vd3d3LmphdmFzY3JpcHRlci5uZXQvZmFxL3N0eWxlc2MuaHRtKVxuICAgICAqL1xuICAgIGJlQ3Vyc29yOiBmdW5jdGlvbihjdXJzb3JOYW1lKSB7XG4gICAgICAgIGlmICghY3Vyc29yTmFtZSkge1xuICAgICAgICAgICAgY3Vyc29yTmFtZSA9ICdkZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSBjdXJzb3JOYW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIHRoZSB3aGVlbCBtb3ZlZCBldmVudCB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlV2hlZWxNb3ZlZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICBiZWhhdmlvci5vbldoZWVsTW92ZWQodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIE1vdXNlRXhpdCB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVNb3VzZUV4aXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgYmVoYXZpb3IuaGFuZGxlTW91c2VFeGl0KHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBNb3VzZUV4aXQgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlQ29udGV4dE1lbnU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgYmVoYXZpb3Iub25Db250ZXh0TWVudSh0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgTW91c2VNb3ZlIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVNb3VzZU1vdmU6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIGJlaGF2aW9yLm9uTW91c2VNb3ZlKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgbW91c2Vkb3duIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVNb3VzZURvd246IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIGJlaGF2aW9yLmhhbmRsZU1vdXNlRG93bih0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIG1vdXNldXAgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlVXA6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIGJlaGF2aW9yLm9uTW91c2VVcCh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIHRhcCB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlVGFwOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICBiZWhhdmlvci5vblRhcCh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIG1vdXNlRHJhZyB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VEcmFnOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICBiZWhhdmlvci5vbk1vdXNlRHJhZyh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFdlJ3ZlIGJlZW4gZG91YmxlY2xpY2tlZCBvbi4gRGVsZWdhdGUgdGhyb3VnaCB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIGJlaGF2aW9yLm9uRG91YmxlQ2xpY2sodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBob2xkcHVsc2UgdGhyb3VnaCB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlSG9sZFB1bHNlOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICBiZWhhdmlvci5vbkhvbGRQdWxzZSh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEdlbmVyYXRlIGEgZnVuY3Rpb24gbmFtZSBhbmQgY2FsbCBpdCBvbiBzZWxmLlxuICAgICAqIEBkZXNjIFRoaXMgc2hvdWxkIGFsc28gYmUgZGVsZWdhdGVkIHRocm91Z2ggQmVoYXZpb3Iga2VlcGluZyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBoZXJlIHRob3VnaC5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVLZXlEb3duOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIGJlaGF2aW9yLm9uS2V5RG93bih0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgR2VuZXJhdGUgYSBmdW5jdGlvbiBuYW1lIGFuZCBjYWxsIGl0IG9uIHNlbGYuXG4gICAgICogQGRlc2MgVGhpcyBzaG91bGQgYWxzbyBiZSBkZWxlZ2F0ZWQgdGhyb3VnaCBCZWhhdmlvciBrZWVwaW5nIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhlcmUgdGhvdWdoLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZUtleVVwOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIGJlaGF2aW9yLm9uS2V5VXAodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNodXQgZG93biB0aGUgY3VycmVudCBjZWxsIGVkaXRvci5cbiAgICAgKi9cbiAgICBzdG9wRWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBhIGNlbGwgZWRpdG9yLlxuICAgICAqIEBkZXNjIFRoaXMgaXMgdHlwaWNhbGx5IGNhbGxlZCBmcm9tIHdpdGhpbiBhIGNlbGwtZWRpdG9yJ3MgYGluc3RhbGxPbmAgbWV0aG9kLCB3aGVuIGl0IGlzIGJlaW5nIGluaXRpYWxpemVkIGFzIGEgcGx1Z2luLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlhcyAtIFRoZSBuYW1lL2lkIG9mIHRoZSBjZWxsIGVkaXRvci5cbiAgICAgKiBAcGFyYW0ge2Zpbi1oeXBlcmdyaWQtY2VsbC1lZGl0b3ItYmFzZX0gY2VsbEVkaXRvciAtIHNlZSBbZmluLWh5cGVyZ3JpZC1jZWxsLWVkaXRvci1iYXNlXShtb2R1bGUtY2VsbC1lZGl0b3JzX2Jhc2UuaHRtbClcbiAgICAgKi9cbiAgICByZWdpc3RlckNlbGxFZGl0b3I6IGZ1bmN0aW9uKGFsaWFzLCBjZWxsRWRpdG9yKSB7XG4gICAgICAgIHRoaXMuY2VsbEVkaXRvcnNbYWxpYXNdID0gY2VsbEVkaXRvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBUaGUgcGl4ZWwgY29vcmRpbmF0ZXMgb2YganVzdCB0aGUgY2VudGVyICdtYWluXCIgZGF0YSBhcmVhLlxuICAgICAqL1xuICAgIGdldERhdGFCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sRE5ESGFja1dpZHRoID0gMjAwOyAvL3RoaXMgd2FzIGEgaGFjayB0byBoZWxwIHdpdGggY29sdW1uIGRuZCwgbmVlZCB0byBmYWN0b3IgdGhpcyBpbnRvIGEgc2hhcmVkIHZhcmlhYmxlXG4gICAgICAgIC8vdmFyIGJlaGF2aW9yID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICB2YXIgYiA9IHRoaXMuY2FudmFzLmJvdW5kcztcblxuICAgICAgICAvL3ZhciB4ID0gdGhpcy5nZXRSb3dOdW1iZXJzV2lkdGgoKTtcbiAgICAgICAgLy8gdmFyIHkgPSBiZWhhdmlvci5nZXRGaXhlZFJvd3NIZWlnaHQoKSArIDI7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgYi5vcmlnaW4ueCArIGIuZXh0ZW50LnggLSBjb2xETkRIYWNrV2lkdGgsIGIub3JpZ2luLnkgKyBiLmV4dGVudC55KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0Um93TnVtYmVyc1dpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaG93Um93TnVtYmVycygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmdldFJvd051bWJlcnNXaWR0aCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Q2FudmFzfSBPdXIgZmluLWNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgT3BlbiB0aGUgZ2l2ZW4gY2VsbC1lZGl0b3IgYXQgdGhlIHByb3ZpZGVkIG1vZGVsIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjZWxsRWRpdG9yIC0gVGhlIHNwZWNpZmljIGNlbGwgZWRpdG9yIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjb29yZGluYXRlcyAtIFRoZSBwaXhlbCBsb2NhaXRvbiBvZiB0aGUgY2VsbCB0byBlZGl0IGF0LlxuICAgICAqL1xuICAgIGVkaXRBdDogZnVuY3Rpb24oY2VsbEVkaXRvciwgY29vcmRpbmF0ZXMpIHtcblxuICAgICAgICB0aGlzLmNlbGxFZGl0b3IgPSBjZWxsRWRpdG9yO1xuXG4gICAgICAgIHZhciBjZWxsID0gY29vcmRpbmF0ZXMuZ3JpZENlbGw7XG5cbiAgICAgICAgdmFyIHggPSBjZWxsLng7XG4gICAgICAgIHZhciB5ID0gY2VsbC55O1xuXG4gICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdGhpcy5zZXRNb3VzZURvd24oZWRpdFBvaW50KTtcbiAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KG5ldyBQb2ludCgwLCAwKSk7XG5cbiAgICAgICAgaWYgKCFjZWxsRWRpdG9yLmlzQWRkZWQpIHtcbiAgICAgICAgICAgIGNlbGxFZGl0b3IuaXNBZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChjZWxsRWRpdG9yLmdldElucHV0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNlbGxFZGl0b3IuZ3JpZCA9IHRoaXM7XG4gICAgICAgIGNlbGxFZGl0b3IuYmVnaW5FZGl0QXQoZWRpdFBvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIGNvbHVtbiBpcyBmdWxseSB2aXNpYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIFRoZSBjb2x1bW4gaW5kZXggaW4gcXVlc3Rpb24uXG4gICAgICovXG4gICAgaXNDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICB2YXIgaXNWaXNpYmxlID0gdGhpcy5nZXRSZW5kZXJlcigpLmlzQ29sdW1uVmlzaWJsZShjb2x1bW5JbmRleCk7XG4gICAgICAgIHJldHVybiBpc1Zpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiByb3cgaXMgZnVsbHkgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqL1xuICAgIGlzRGF0YVJvd1Zpc2libGU6IGZ1bmN0aW9uKHJvd0luZGV4KSB7XG4gICAgICAgIHZhciBpc1Zpc2libGUgPSB0aGlzLmdldFJlbmRlcmVyKCkuaXNSb3dWaXNpYmxlKHJvd0luZGV4KTtcbiAgICAgICAgcmV0dXJuIGlzVmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIGNlbGwgaXMgZnVsbHkgaXMgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSBUaGUgY29sdW1uIGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFRoZSByb3cgaW5kZXggaW4gcXVlc3Rpb24uXG4gICAgICovXG4gICAgaXNEYXRhVmlzaWJsZTogZnVuY3Rpb24oY29sdW1uSW5kZXgsIHJvd0luZGV4KSB7XG4gICAgICAgIHZhciBpc1Zpc2libGUgPSB0aGlzLmlzRGF0YVJvd1Zpc2libGUocm93SW5kZXgpICYmIHRoaXMuaXNDb2x1bW5WaXNpYmxlKGNvbHVtbkluZGV4KTtcbiAgICAgICAgcmV0dXJuIGlzVmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgaW4gdGhlIGBvZmZzZXRYYCBkaXJlY3Rpb24gaWYgY29sdW1uIGluZGV4IGBjb2xJbmRleGAgaXMgbm90IHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIFRoZSBkaXJlY3Rpb24gYW5kIG1hZ25pdHVkZSB0byBzY3JvbGwgaWYgd2UgbmVlZCB0by5cbiAgICAgKi9cbiAgICBpbnN1cmVNb2RlbENvbElzVmlzaWJsZTogZnVuY3Rpb24oY29sSW5kZXgsIG9mZnNldFgpIHtcbiAgICAgICAgLy8tMSBiZWNhdXNlIHdlIHdhbnQgb25seSBmdWxseSB2aXNpYmxlIGNvbHVtbnMsIGRvbid0IGluY2x1ZGUgcGFydGlhbGx5XG4gICAgICAgIC8vdmlzaWJsZSBjb2x1bW5zXG4gICAgICAgIHZhciBtYXhDb2xzID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpIC0gMTtcbiAgICAgICAgdmFyIGluZGV4VG9DaGVjayA9IGNvbEluZGV4O1xuXG4gICAgICAgIGlmIChvZmZzZXRYID4gMCkge1xuICAgICAgICAgICAgaW5kZXhUb0NoZWNrKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNDb2x1bW5WaXNpYmxlKGluZGV4VG9DaGVjaykgfHwgY29sSW5kZXggPT09IG1heENvbHMpIHtcbiAgICAgICAgICAgIC8vdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyB0aGUgbGVmdG1vc3QgY29sdW1uIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnkob2Zmc2V0WCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIGluIHRoZSBvZmZzZXRZIGRpcmVjdGlvbiBpZiBjb2x1bW4gaW5kZXggYyBpcyBub3QgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgY29sdW1uIGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gVGhlIGRpcmVjdGlvbiBhbmQgbWFnbml0dWRlIHRvIHNjcm9sbCBpZiB3ZSBuZWVkIHRvLlxuICAgICAqL1xuICAgIGluc3VyZU1vZGVsUm93SXNWaXNpYmxlOiBmdW5jdGlvbihyb3dJbmRleCwgb2Zmc2V0WSkge1xuICAgICAgICAvLy0xIGJlY2F1c2Ugd2Ugd2FudCBvbmx5IGZ1bGx5IHZpc2libGUgcm93cywgZG9uJ3QgaW5jbHVkZSBwYXJ0aWFsbHlcbiAgICAgICAgLy92aWV3YWJsZSByb3dzXG4gICAgICAgIHZhciBtYXhSb3dzID0gdGhpcy5nZXRSb3dDb3VudCgpIC0gMTtcbiAgICAgICAgdmFyIGluZGV4VG9DaGVjayA9IHJvd0luZGV4O1xuXG4gICAgICAgIGlmIChvZmZzZXRZID4gMCkge1xuICAgICAgICAgICAgaW5kZXhUb0NoZWNrKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNEYXRhUm93VmlzaWJsZShpbmRleFRvQ2hlY2spIHx8IHJvd0luZGV4ID09PSBtYXhSb3dzKSB7XG4gICAgICAgICAgICAvL3RoZSBzY3JvbGwgcG9zaXRpb24gaXMgdGhlIHRvcG1vc3Qgcm93XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJ5KDAsIG9mZnNldFkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbGx5IGJ5IHRoZSBwcm92aWRlZCBvZmZzZXRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gU2Nyb2xsIGluIHRoZSB4IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSBTY3JvbGwgaW4gdGhlIHkgZGlyZWN0aW9uIHRoaXMgbXVjaC5cbiAgICAgKi9cbiAgICBzY3JvbGxCeTogZnVuY3Rpb24ob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICB0aGlzLnNjcm9sbEhCeShvZmZzZXRYKTtcbiAgICAgICAgdGhpcy5zY3JvbGxWQnkob2Zmc2V0WSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIHZlcnRpY2FsbHkgYnkgdGhlIHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIFNjcm9sbCBpbiB0aGUgeSBkaXJlY3Rpb24gdGhpcyBtdWNoLlxuICAgICAqL1xuICAgIHNjcm9sbFZCeTogZnVuY3Rpb24ob2Zmc2V0WSkge1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5zYlZTY3JvbGxlci5yYW5nZS5tYXg7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZ2V0VlNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMCwgb2xkVmFsdWUgKyBvZmZzZXRZKSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFZTY3JvbGxWYWx1ZShuZXdWYWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIGhvcml6b250YWxseSBieSB0aGUgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gU2Nyb2xsIGluIHRoZSB4IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICovXG4gICAgc2Nyb2xsSEJ5OiBmdW5jdGlvbihvZmZzZXRYKSB7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLnNiSFNjcm9sbGVyLnJhbmdlLm1heDtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gTWF0aC5taW4obWF4LCBNYXRoLm1heCgwLCBvbGRWYWx1ZSArIG9mZnNldFgpKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKG5ld1ZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBBbnN3ZXIgd2hpY2ggZGF0YSBjZWxsIGlzIHVuZGVyIGEgcGl4ZWwgdmFsdWUgbW91c2UgcG9pbnQuXG4gICAgICogQHBhcmFtIHttb3VzZVBvaW50fSBtb3VzZSAtIFRoZSBtb3VzZSBwb2ludCB0byBpbnRlcnJvZ2F0ZS5cbiAgICAgKi9cblxuICAgIGdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQ6IGZ1bmN0aW9uKG1vdXNlKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRSZW5kZXJlcigpLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gVGhlIHBpeGVsIGJhc2VkIGJvdW5kcyByZWN0YW5nbGUgZ2l2ZW4gYSBkYXRhIGNlbGwgcG9pbnQuXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgbW91c2UuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRCb3VuZHNPZkNlbGw6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0Qm91bmRzT2ZDZWxsKGNlbGwpO1xuXG4gICAgICAgIC8vd2UgbmVlZCB0byBjb252ZXJ0IHRoaXMgdG8gYSBwcm9wZXIgcmVjdGFuZ2xlXG4gICAgICAgIHZhciBuZXdCb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKGIueCwgYi55LCBiLndpZHRoLCBiLmhlaWdodCk7XG4gICAgICAgIHJldHVybiBuZXdCb3VuZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBpcyBjYWxsZWQgYnkgdGhlIGZpbi1jYW52YXMgd2hlbiBhIHJlc2l6ZSBvY2N1cnMuXG4gICAgICovXG4gICAgcmVzaXplZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVTY3JvbGxpbmdCb3VuZHJpZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBBIGNsaWNrIGV2ZW50IG9jY3VyZWQuXG4gICAgICogQGRlc2MgRGV0ZXJtaW5lIHRoZSBjZWxsIGFuZCBkZWxlZ2F0ZSB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIG1vdXNlIGV2ZW50IHRvIGludGVycm9nYXRlLlxuICAgICAqL1xuICAgIGNlbGxDbGlja2VkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgY2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgY29sQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICAvL2NsaWNrIG9jY3VyZWQgaW4gYmFja2dyb3VuZCBhcmVhXG4gICAgICAgIGlmIChjZWxsLnggPiBjb2xDb3VudCB8fCBjZWxsLnkgPiByb3dDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy92YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIHZhciBob3ZlcmVkID0gdGhpcy5nZXRIb3ZlckNlbGwoKTtcbiAgICAgICAgdmFyIHN5ID0gdGhpcy5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIHggPSBob3ZlcmVkLng7XG4gICAgICAgIC8vIGlmIChob3ZlcmVkLnggPiAtMSkge1xuICAgICAgICAvLyAgICAgeCA9IGJlaGF2aW9yLnRyYW5zbGF0ZUNvbHVtbkluZGV4KGhvdmVyZWQueCArIHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCkpO1xuICAgICAgICAvLyB9XG4gICAgICAgIGlmIChob3ZlcmVkLnkgPCAwKSB7XG4gICAgICAgICAgICBzeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaG92ZXJlZCA9IG5ldyBQb2ludCh4LCBob3ZlcmVkLnkgKyBzeSk7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5jZWxsQ2xpY2tlZChob3ZlcmVkLCBldmVudCk7XG4gICAgfSxcblxuICAgIHNldFRvdGFsc1ZhbHVlTm90aWZpY2F0aW9uOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNTZXRUb3RhbHNWYWx1ZSh4LCB5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNTZXRUb3RhbHNWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1zZXQtdG90YWxzLXZhbHVlJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleVVwRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwga2V5RXZlbnQpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1lZGl0b3Ita2V5LXVwJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29udHJvbCxcbiAgICAgICAgICAgICAgICBrZXlFdmVudDoga2V5RXZlbnRcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNFZGl0b3JLZXlEb3duRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwga2V5RXZlbnQpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1lZGl0b3Ita2V5LWRvd24nLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXRDb250cm9sLFxuICAgICAgICAgICAgICAgIGtleUV2ZW50OiBrZXlFdmVudFxuICAgICAgICAgICAgfSxcblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleVByZXNzRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwga2V5RXZlbnQpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1lZGl0b3Ita2V5LXByZXNzJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29udHJvbCxcbiAgICAgICAgICAgICAgICBrZXlFdmVudDoga2V5RXZlbnRcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNFZGl0b3JEYXRhQ2hhbmdlRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tZWRpdG9yLWRhdGEtY2hhbmdlJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29udHJvbCxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tcm93LXNlbGVjdGlvbi1jaGFuZ2VkYCBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tcm93LXNlbGVjdGlvbi1jaGFuZ2VkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5nZXRTZWxlY3Rpb25zKCksXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KHNlbGVjdGlvbkV2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0NvbHVtblNlbGVjdGlvbkNoYW5nZWRFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25FdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWNvbHVtbi1zZWxlY3Rpb24tY2hhbmdlZCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHJvd3M6IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKCksXG4gICAgICAgICAgICAgICAgY29sdW1uczogdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0aW9ucygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KHNlbGVjdGlvbkV2ZW50KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZGlzcGF0Y2ggYSBgZmluLXNlbGVjdGlvbi1jaGFuZ2VkYCBldmVudC5cbiAgICAgKi9cbiAgICBzZWxlY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkUm93cyA9IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgIHZhciBzZWxlY3Rpb25FdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLXNlbGVjdGlvbi1jaGFuZ2VkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgcm93czogc2VsZWN0ZWRSb3dzLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmdldFNlbGVjdGlvbnMoKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoc2VsZWN0aW9uRXZlbnQpO1xuICAgIH0sXG5cblxuICAgIGdldFJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjLCBjb2x1bW4sIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dJbmRleGVzID0gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgbnVtQ29scyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHNldFZhbHVlKHNlbGVjdGVkUm93SW5kZXgsIHIpIHtcbiAgICAgICAgICAgIGNvbHVtbltyXSA9IHZhbHVlT3JGdW5jdGlvbkV4ZWN1dGUoc2VsZi5nZXRWYWx1ZShjLCBzZWxlY3RlZFJvd0luZGV4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGMgPSAwOyBjIDwgbnVtQ29sczsgYysrKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSBuZXcgQXJyYXkoc2VsZWN0ZWRSb3dJbmRleGVzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXN1bHRbdGhpcy5nZXRGaWVsZChjKV0gPSBjb2x1bW47XG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMuZm9yRWFjaChzZXRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRSb3dTZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYywgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0ZWRSb3dzKCksXG4gICAgICAgICAgICBudW1Db2xzID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KG51bUNvbHMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKHNlbGVjdGVkUm93SW5kZXgsIHIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtjXVtyXSA9IHZhbHVlT3JGdW5jdGlvbkV4ZWN1dGUoc2VsZi5nZXRWYWx1ZShjLCBzZWxlY3RlZFJvd0luZGV4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGMgPSAwOyBjIDwgbnVtQ29sczsgYysrKSB7XG4gICAgICAgICAgICByZXN1bHRbY10gPSBuZXcgQXJyYXkoc2VsZWN0ZWRSb3dJbmRleGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMuZm9yRWFjaChnZXRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5TZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRDb2x1bW5JbmRleGVzID0gdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICAgICAgdmFyIG51bVJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoc2VsZWN0ZWRDb2x1bW5JbmRleGVzLmxlbmd0aCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZWN0ZWRDb2x1bW5JbmRleGVzLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0ZWRDb2x1bW5JbmRleCwgYykge1xuICAgICAgICAgICAgcmVzdWx0W2NdID0gbmV3IEFycmF5KG51bVJvd3MpO1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBudW1Sb3dzOyByKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY11bcl0gPSB2YWx1ZU9yRnVuY3Rpb25FeGVjdXRlKHNlbGYuZ2V0VmFsdWUoc2VsZWN0ZWRDb2x1bW5JbmRleCwgcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkQ29sdW1uSW5kZXhlcyA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGVjdGVkQ29sdW1uSW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGVkQ29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBuZXcgQXJyYXkocm93Q291bnQpO1xuICAgICAgICAgICAgcmVzdWx0W3NlbGYuZ2V0RmllbGQoc2VsZWN0ZWRDb2x1bW5JbmRleCldID0gY29sdW1uO1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uW3JdID0gdmFsdWVPckZ1bmN0aW9uRXhlY3V0ZShzZWxmLmdldFZhbHVlKHNlbGVjdGVkQ29sdW1uSW5kZXgsIHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShzZWxlY3Rpb25zLmxlbmd0aCk7XG4gICAgICAgIHNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3Rpb25SZWN0LCBpKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBzZWxmLl9nZXRTZWxlY3Rpb24oc2VsZWN0aW9uUmVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBfZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgIHJlY3QgPSBub3JtYWxpemVSZWN0KHJlY3QpO1xuICAgICAgICB2YXIgY29sQ291bnQgPSByZWN0LmV4dGVudC54ICsgMTtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gcmVjdC5leHRlbnQueSArIDE7XG4gICAgICAgIHZhciBveCA9IHJlY3Qub3JpZ2luLng7XG4gICAgICAgIHZhciBveSA9IHJlY3Qub3JpZ2luLnk7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gICAgICAgICAgICByZXN1bHRbdGhpcy5nZXRGaWVsZChjICsgb3gpXSA9IGNvbHVtbjtcbiAgICAgICAgICAgIGZvciAociA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uW3JdID0gdmFsdWVPckZ1bmN0aW9uRXhlY3V0ZSh0aGlzLmdldFZhbHVlKG94ICsgYywgb3kgKyByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHNlbGVjdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgc2VsZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGlvblJlY3QsIGkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGYuX2dldFNlbGVjdGlvbk1hdHJpeChzZWxlY3Rpb25SZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9nZXRTZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gICAgICAgIHZhciBjb2xDb3VudCA9IHJlY3QuZXh0ZW50LnggKyAxO1xuICAgICAgICB2YXIgcm93Q291bnQgPSByZWN0LmV4dGVudC55ICsgMTtcbiAgICAgICAgdmFyIG94ID0gcmVjdC5vcmlnaW4ueDtcbiAgICAgICAgdmFyIG95ID0gcmVjdC5vcmlnaW4ueTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbENvdW50OyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBuZXcgQXJyYXkocm93Q291bnQpO1xuICAgICAgICAgICAgcmVzdWx0W2NdID0gY29sdW1uO1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uW3JdID0gdmFsdWVPckZ1bmN0aW9uRXhlY3V0ZSh0aGlzLmdldFZhbHVlKG94ICsgYywgb3kgKyByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY29udGV4dC1tZW51YCBldmVudFxuICAgICAqIEBwYXJhbSB7a2V5RXZlbnR9IGV2ZW50IC0gVGhlIGNhbnZhcyBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljQ29udGV4dE1lbnVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICBlLmdyaWRDZWxsID0gdGhpcy5jb252ZXJ0Vmlld1BvaW50VG9EYXRhUG9pbnQoZS5ncmlkQ2VsbCk7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWNvbnRleHQtbWVudScsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGdyaWRDZWxsOiBlLmdyaWRDZWxsLFxuICAgICAgICAgICAgICAgIG1vdXNlUG9pbnQ6IGUubW91c2VQb2ludCxcbiAgICAgICAgICAgICAgICB2aWV3UG9pbnQ6IGUudmlld1BvaW50LFxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZUV2ZW50OiBlLnByaW1pdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICAgIHJvd3M6IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKCksXG4gICAgICAgICAgICAgICAgY29sdW1uczogdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0aW9ucygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY01vdXNlVXBFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1tb3VzZXVwJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGUuZ3JpZENlbGwsXG4gICAgICAgICAgICAgICAgbW91c2VQb2ludDogZS5tb3VzZVBvaW50LFxuICAgICAgICAgICAgICAgIHZpZXdQb2ludDogZS52aWV3UG9pbnQsXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlRXZlbnQ6IGUucHJpbWl0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljTW91c2VEb3duRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tbW91c2Vkb3duJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGUuZ3JpZENlbGwsXG4gICAgICAgICAgICAgICAgbW91c2VQb2ludDogZS5tb3VzZVBvaW50LFxuICAgICAgICAgICAgICAgIHZpZXdQb2ludDogZS52aWV3UG9pbnQsXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlRXZlbnQ6IGUucHJpbWl0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICBpc1ZpZXdhYmxlQnV0dG9uOiBmdW5jdGlvbihjLCByKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuaXNWaWV3YWJsZUJ1dHRvbihjLCByKTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0J1dHRvblByZXNzZWRFdmVudDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBkYXRhQ2VsbCA9IGV2dC5kYXRhQ2VsbDtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZ0LmdyaWRDZWxsO1xuICAgICAgICBpZiAoIXRoaXMuaXNWaWV3YWJsZUJ1dHRvbihkYXRhQ2VsbC54LCBkYXRhQ2VsbC55KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWJ1dHRvbi1wcmVzc2VkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGdyaWRDZWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1rZXlkb3duYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge2tleUV2ZW50fSBldmVudCAtIFRoZSBjYW52YXMgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0tleWRvd25FdmVudDogZnVuY3Rpb24oa2V5RXZlbnQpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1rZXlkb3duJywge1xuICAgICAgICAgICAgZGV0YWlsOiBrZXlFdmVudC5kZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4ta2V5dXBgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7a2V5RXZlbnR9IGV2ZW50IC0gVGhlIGNhbnZhcyBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljS2V5dXBFdmVudDogZnVuY3Rpb24oa2V5RXZlbnQpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1rZXl1cCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoga2V5RXZlbnQuZGV0YWlsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWNlbGwtZW50ZXJgIGV2ZW50XG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY2VsbCBpbiB3aGljaCB0aGUgY2xpY2sgZXZlbnQgb2NjdXJyZWQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBzeXN0ZW0gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY09uQ2VsbEVudGVyRXZlbnQ6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jZWxsLWVudGVyJywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNHcm91cHNDaGFuZ2VkRXZlbnQ6IGZ1bmN0aW9uKGdyb3Vwcykge1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgZ3JvdXBzOiBncm91cHMsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWdyb3Vwcy1jaGFuZ2VkJywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY2VsbC1leGl0YCBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjZWxsIGluIHdoaWNoIHRoZSBjbGljayBldmVudCBvY2N1cmVkLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgc3lzdGVtIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNPbkNlbGxFeGl0RXZlbnQ6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jZWxsLWV4aXQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1jZWxsLWNsaWNrYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjZWxsIGluIHdoaWNoIHRoZSBjbGljayBldmVudCBvY2N1cmVkLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgc3lzdGVtIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNDbGlja0V2ZW50OiBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsID0gbW91c2VFdmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdmFyIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgbW91c2VQb2ludDogbW91c2VFdmVudC5tb3VzZVBvaW50LFxuICAgICAgICAgICAga2V5czogbW91c2VFdmVudC5rZXlzLFxuICAgICAgICAgICAgcHJpbWl0aXZlRXZlbnQ6IG1vdXNlRXZlbnQsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkuZW5oYW5jZURvdWJsZUNsaWNrRXZlbnQoZGV0YWlsKTtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jbGljaycsIHtcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWRvdWJsZS1jbGlja2AgZXZlbnQuXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY2VsbCBpbiB3aGljaCB0aGUgY2xpY2sgZXZlbnQgb2NjdXJlZC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIHN5c3RlbSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljRG91YmxlQ2xpY2tFdmVudDogZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgICAgICB2YXIgY2VsbCA9IG1vdXNlRXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgbW91c2VQb2ludDogbW91c2VFdmVudC5tb3VzZVBvaW50LFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgYmVoYXZpb3IuZW5oYW5jZURvdWJsZUNsaWNrRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tZG91YmxlLWNsaWNrJywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIGJlaGF2aW9yLmNlbGxEb3VibGVDbGlja2VkKGNlbGwsIG1vdXNlRXZlbnQpO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSByZW5kZXJlZCBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljR3JpZFJlbmRlcmVkRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1ncmlkLXJlbmRlcmVkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgc2Nyb2xsIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gU2hvdWxkIGJlIGVpdGhlciBgZmluLXNjcm9sbC14YCBvciBgZmluLXNjcm9sbC15YC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2xkVmFsdWUgLSBUaGUgb2xkIHNjcm9sbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgLSBUaGUgbmV3IHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmaXJlU2Nyb2xsRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQodHlwZSwge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgdmVydGljYWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIHNldFZTY3JvbGxWYWx1ZTogZnVuY3Rpb24oeSkge1xuICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgICAgdmFyIG1heCA9IHRoaXMuc2JWU2Nyb2xsZXIucmFuZ2UubWF4O1xuICAgICAgICB5ID0gTWF0aC5taW4obWF4LCBNYXRoLm1heCgwLCB5KSk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHkgPT09IHRoaXMudlNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLl9zZXRTY3JvbGxQb3NpdGlvblkoeSk7XG4gICAgICAgIHZhciBvbGRZID0gdGhpcy52U2Nyb2xsVmFsdWU7XG4gICAgICAgIHRoaXMudlNjcm9sbFZhbHVlID0geTtcbiAgICAgICAgdGhpcy5zY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHNlbGYuc2JWUmFuZ2VBZGFwdGVyLnN1YmplY3RDaGFuZ2VkKCk7XG4gICAgICAgICAgICBzZWxmLmZpcmVTY3JvbGxFdmVudCgnZmluLXNjcm9sbC15Jywgb2xkWSwgeSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZlcnRpY2FsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRWU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52U2Nyb2xsVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBob3Jpem9udGFsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgLSBUaGUgbmV3IHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXRIU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLnNiSFNjcm9sbGVyLnJhbmdlLm1heDtcbiAgICAgICAgeCA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMCwgeCkpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICh4ID09PSB0aGlzLmhTY3JvbGxWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5fc2V0U2Nyb2xsUG9zaXRpb25YKHgpO1xuICAgICAgICB2YXIgb2xkWCA9IHRoaXMuaFNjcm9sbFZhbHVlO1xuICAgICAgICB0aGlzLmhTY3JvbGxWYWx1ZSA9IHg7XG4gICAgICAgIHRoaXMuc2Nyb2xsVmFsdWVDaGFuZ2VkTm90aWZpY2F0aW9uKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvL3NlbGYuc2JIUmFuZ2VBZGFwdGVyLnN1YmplY3RDaGFuZ2VkKCk7XG4gICAgICAgICAgICBzZWxmLmZpcmVTY3JvbGxFdmVudCgnZmluLXNjcm9sbC14Jywgb2xkWCwgeCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIFRoZSB2ZXJ0aWNhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0SFNjcm9sbFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFNjcm9sbFZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcXVlc3QgaW5wdXQgZm9jdXMuXG4gICAgICovXG4gICAgdGFrZUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFZGl0aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkudGFrZUZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXF1ZXN0IGZvY3VzIGZvciBvdXIgY2VsbCBlZGl0b3IuXG4gICAgICovXG4gICAgZWRpdG9yVGFrZUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbEVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbEVkaXRvci50YWtlRm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXZSBoYXZlIGEgY3VycmVudGx5IGFjdGl2ZSBjZWxsIGVkaXRvci5cbiAgICAgKi9cbiAgICBpc0VkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsRWRpdG9yLmlzRWRpdGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgSW5pdGlhbGl6ZSB0aGUgc2Nyb2xsIGJhcnMuXG4gICAgICovXG4gICAgaW5pdFNjcm9sbGJhcnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgaG9yekJhciA9IG5ldyBGaW5CYXIoe1xuICAgICAgICAgICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIG9uY2hhbmdlOiBzZWxmLnNldEhTY3JvbGxWYWx1ZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnQ6IHRoaXMuZGl2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB2ZXJ0QmFyID0gbmV3IEZpbkJhcih7XG4gICAgICAgICAgICBvcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICAgICAgICAgIG9uY2hhbmdlOiBzZWxmLnNldFZTY3JvbGxWYWx1ZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgcGFnaW5nOiB7XG4gICAgICAgICAgICAgICAgdXA6IHNlbGYucGFnZVVwLmJpbmQoc2VsZiksXG4gICAgICAgICAgICAgICAgZG93bjogc2VsZi5wYWdlRG93bi5iaW5kKHNlbGYpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIgPSBob3J6QmFyO1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyID0gdmVydEJhcjtcblxuICAgICAgICB2YXIgaFByZWZpeCA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdoU2Nyb2xsYmFyQ2xhc3NQcmVmaXgnKTtcbiAgICAgICAgdmFyIHZQcmVmaXggPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgndlNjcm9sbGJhckNsYXNzUHJlZml4Jyk7XG5cbiAgICAgICAgaWYgKGhQcmVmaXggJiYgaFByZWZpeCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuY2xhc3NQcmVmaXggPSBoUHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZQcmVmaXggJiYgdlByZWZpeCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIuY2xhc3NQcmVmaXggPSB2UHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoaG9yekJhci5iYXIpO1xuICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZCh2ZXJ0QmFyLmJhcik7XG5cbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGxiYXJzKCk7XG5cbiAgICB9LFxuXG4gICAgcmVzaXplU2Nyb2xsYmFyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuc2hvcnRlbkJ5KHRoaXMuc2JWU2Nyb2xsZXIpLnJlc2l6ZSgpO1xuICAgICAgICAvL3RoaXMuc2JWU2Nyb2xsZXIuc2hvcnRlbkJ5KHRoaXMuc2JIU2Nyb2xsZXIpO1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNjcm9sbCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLCB3ZSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqL1xuICAgIHNldFZTY3JvbGxiYXJWYWx1ZXM6IGZ1bmN0aW9uKG1heCkge1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLnJhbmdlID0ge1xuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2V0SFNjcm9sbGJhclZhbHVlczogZnVuY3Rpb24obWF4KSB7XG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIucmFuZ2UgPSB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IG1heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLmhTY3JvbGxWYWx1ZSA9PT0gdGhpcy5zYlByZXZIU2Nyb2xsVmFsdWUgJiYgdGhpcy52U2Nyb2xsVmFsdWUgPT09IHRoaXMuc2JQcmV2VlNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNiUHJldkhTY3JvbGxWYWx1ZSA9IHRoaXMuaFNjcm9sbFZhbHVlO1xuICAgICAgICB0aGlzLnNiUHJldlZTY3JvbGxWYWx1ZSA9IHRoaXMudlNjcm9sbFZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5zY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgR2V0IGRhdGEgdmFsdWUgYXQgZ2l2ZW4gY2VsbC5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldFZhbHVlKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCBhIGRhdGEgdmFsdWUgaW50byB0aGUgYmVoYXZpb3IgKG1vZGVsKSBhdCB0aGUgZ2l2ZW4gcG9pbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLnNldFZhbHVlKHgsIHksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uQWxpZ25tZW50OiBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0Q29sdW1uQWxpZ25tZW50KGMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBkYXRhIGRpbWVuc2lvbnMgaGF2ZSBjaGFuZ2VkLCBvciBvdXIgcGl4ZWwgYm91bmRyaWVzIGhhdmUgY2hhbmdlZC5cbiAgICAgKiBBZGp1c3QgdGhlIHNjcm9sbGJhciBwcm9wZXJ0aWVzIGFzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBzeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vMzI3LzY2NFxuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG5cbiAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IHRoaXMuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtRml4ZWRSb3dzID0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgdmFyIG51bUNvbHVtbnMgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBudW1Sb3dzID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JvbGxhYmxlSGVpZ2h0ID0gYm91bmRzLmhlaWdodCAtIGJlaGF2aW9yLmdldEZpeGVkUm93c01heEhlaWdodCgpIC0gMTU7IC8vNXB4IHBhZGRpbmcgYXQgYm90dG9tIGFuZCByaWdodCBzaWRlXG4gICAgICAgIHZhciBzY3JvbGxhYmxlV2lkdGggPSAoYm91bmRzLndpZHRoIC0gMjAwKSAtIGJlaGF2aW9yLmdldEZpeGVkQ29sdW1uc01heFdpZHRoKCkgLSAxNTtcblxuICAgICAgICB2YXIgbGFzdFBhZ2VDb2x1bW5Db3VudCA9IDA7XG4gICAgICAgIHZhciBjb2x1bW5zV2lkdGggPSAwO1xuICAgICAgICBmb3IgKDsgbGFzdFBhZ2VDb2x1bW5Db3VudCA8IG51bUNvbHVtbnM7IGxhc3RQYWdlQ29sdW1uQ291bnQrKykge1xuICAgICAgICAgICAgdmFyIGVhY2hXaWR0aCA9IHRoaXMuZ2V0Q29sdW1uV2lkdGgobnVtQ29sdW1ucyAtIGxhc3RQYWdlQ29sdW1uQ291bnQgLSAxKTtcbiAgICAgICAgICAgIGNvbHVtbnNXaWR0aCA9IGNvbHVtbnNXaWR0aCArIGVhY2hXaWR0aDtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zV2lkdGggPiBzY3JvbGxhYmxlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0UGFnZVJvd0NvdW50ID0gMDtcbiAgICAgICAgdmFyIHJvd3NIZWlnaHQgPSAwO1xuICAgICAgICBmb3IgKDsgbGFzdFBhZ2VSb3dDb3VudCA8IG51bVJvd3M7IGxhc3RQYWdlUm93Q291bnQrKykge1xuICAgICAgICAgICAgdmFyIGVhY2hIZWlnaHQgPSB0aGlzLmdldFJvd0hlaWdodChudW1Sb3dzIC0gbGFzdFBhZ2VSb3dDb3VudCAtIDEpO1xuICAgICAgICAgICAgcm93c0hlaWdodCA9IHJvd3NIZWlnaHQgKyBlYWNoSGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHJvd3NIZWlnaHQgPiBzY3JvbGxhYmxlSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaE1heCA9IDEgKyBNYXRoLm1heCgwLCBudW1Db2x1bW5zIC0gbnVtRml4ZWRDb2x1bW5zIC0gbGFzdFBhZ2VDb2x1bW5Db3VudCk7XG4gICAgICAgIHRoaXMuc2V0SFNjcm9sbGJhclZhbHVlcyhoTWF4KTtcblxuICAgICAgICB2YXIgdk1heCA9IE1hdGgubWF4KDAsIG51bVJvd3MgLSBudW1GaXhlZFJvd3MgLSBsYXN0UGFnZVJvd0NvdW50KTtcbiAgICAgICAgdGhpcy5zZXRWU2Nyb2xsYmFyVmFsdWVzKHZNYXgpO1xuXG4gICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKE1hdGgubWluKHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCksIGhNYXgpKTtcbiAgICAgICAgdGhpcy5zZXRWU2Nyb2xsVmFsdWUoTWF0aC5taW4odGhpcy5nZXRWU2Nyb2xsVmFsdWUoKSwgdk1heCkpO1xuXG4gICAgICAgIC8vdGhpcy5nZXRDYW52YXMoKS5yZXNpemUoKTtcbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG5cbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGxiYXJzKCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBOb3RlIHRoYXQgXCJ2aWV3YWJsZSByb3dzXCIgaW5jbHVkZXMgYW55IHBhcnRpYWxseSB2aWV3YWJsZSByb3dzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygdmlld2FibGUgcm93cy5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0VmlzaWJsZVJvd3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBOb3RlIHRoYXQgXCJ2aWV3YWJsZSBjb2x1bW5zXCIgaW5jbHVkZXMgYW55IHBhcnRpYWxseSB2aWV3YWJsZSBjb2x1bW5zLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygdmlld2FibGUgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0VmlzaWJsZUNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBJbml0aWFsaXplIHRoZSByZW5kZXJlciBzdWItY29tcG9uZW50LlxuICAgICAqL1xuICAgIGluaXRSZW5kZXJlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1JlbmRlcmVyfSBzdWItY29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0UmVuZGVyZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGdpdmVuIGNvbHVtbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSBUaGUgdW50cmFuc2xhdGVkIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIFRoZSB1bnRyYW5zbGF0ZWQgY29sdW1uIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5XaWR0aCAtIFRoZSB3aWR0aCBpbiBwaXhlbHMuXG4gICAgICovXG4gICAgc2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uKGNvbHVtbkluZGV4LCBjb2x1bW5XaWR0aCkge1xuICAgICAgICB0aGlzLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5zZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCwgY29sdW1uV2lkdGgpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5FZGdlOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0Q29sdW1uRWRnZShjLCB0aGlzLmdldFJlbmRlcmVyKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCB3aWR0aCBvZiBhbGwgdGhlIGZpeGVkIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5zV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldEZpeGVkQ29sdW1uc1dpZHRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgZ2l2ZW4gcm93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIHVudHJhbnNsYXRlZCBmaXhlZCBjb2x1bW4gaW5kZXguXG4gICAgICovXG4gICAgZ2V0Um93SGVpZ2h0OiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldFJvd0hlaWdodChyb3dJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGdpdmVuIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dIZWlnaHQgLSBUaGUgd2lkdGggaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHNldFJvd0hlaWdodDogZnVuY3Rpb24ocm93SW5kZXgsIHJvd0hlaWdodCkge1xuICAgICAgICB0aGlzLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5zZXRSb3dIZWlnaHQocm93SW5kZXgsIHJvd0hlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHRvdGFsIGZpeGVkIHJvd3MgaGVpZ2h0XG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dzSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRGaXhlZFJvd3NIZWlnaHQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldEZpeGVkUm93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBUaGUgdG9wIGxlZnQgYXJlYSBoYXMgYmVlbiBjbGlja2VkIG9uXG4gICAgICogQGRlc2MgRGVsZWdhdGVzIHRvIHRoZSBiZWhhdmlvci5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBldmVudCBkZXRhaWxzLlxuICAgICAqL1xuICAgIHRvcExlZnRDbGlja2VkOiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkudG9wTGVmdENsaWNrZWQodGhpcywgbW91c2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEEgZml4ZWQgcm93IGhhcyBiZWVuIGNsaWNrZWQuXG4gICAgICogQGRlc2MgRGVsZWdhdGVzIHRvIHRoZSBiZWhhdmlvci5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBldmVudCBkZXRhaWxzLlxuICAgICAqL1xuICAgIHJvd0hlYWRlckNsaWNrZWQ6IGZ1bmN0aW9uKG1vdXNlKSB7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5yb3dIZWFkZXJDbGlja2VkKHRoaXMsIG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBBIGZpeGVkIGNvbHVtbiBoYXMgYmVlbiBjbGlja2VkLlxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJDbGlja2VkOiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkuY29sdW1uSGVhZGVyQ2xpY2tlZCh0aGlzLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgQW4gZWRpdCBldmVudCBoYXMgb2NjdXJyZWQuIEFjdGl2YXRlIHRoZSBlZGl0b3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBfYWN0aXZhdGVFZGl0b3I6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB0aGlzLmFjdGl2YXRlRWRpdG9yKGdyaWRDZWxsLngsIGdyaWRDZWxsLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFjdGl2YXRlIHRoZSBlZGl0b3IgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7eH0geCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHt5fSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgYWN0aXZhdGVFZGl0b3I6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRWRpdGFibGUoKSAmJiAhdGhpcy5pc0ZpbHRlclJvdyh5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmdldENlbGxFZGl0b3JBdCh4LCB5KTtcbiAgICAgICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9pbnQgPSBlZGl0b3IuZWRpdG9yUG9pbnQ7XG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGlmIChwb2ludC54ID09PSB4ICYmIHBvaW50LnkgPT09IHkgJiYgZWRpdG9yLmlzRWRpdGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy93ZSdyZSBhbHJlYWR5IG9wZW4gYXQgdGhpcyBsb2NhdGlvblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRWRpdGluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpOyAvL290aGVyIGVkaXRvciBpcyBvcGVuLCBjbG9zZSBpdCBmaXJzdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQuZ3JpZENlbGwgPSB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5lZGl0QXQoZWRpdG9yLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGNlbGwgZWRpdG9yLlxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHJldHVybnMgVGhlIGNlbGwgZWRpdG9yIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge3h9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7eX0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIGdldENlbGxFZGl0b3JBdDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldENlbGxFZGl0b3JBdCh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBUb2dnbGUgSGlEUEkgc3VwcG9ydC5cbiAgICAgKiBAZGVzYyBIaURQSSBzdXBwb3J0IGlzIG5vdyAqb24qIGJ5IGRlZmF1bHQuXG4gICAgICogPiBUaGVyZSB1c2VkIHRvIGJlIGEgYnVnIGluIENocm9tZSB0aGF0IGNhdXNlZCBzZXZlcmUgc2xvdyBkb3duIG9uIGJpdCBibGl0IG9mIGxhcmdlIGltYWdlcywgc28gdGhpcyBIaURQSSBuZWVkZWQgdG8gYmUgb3B0aW9uYWwuXG4gICAgICovXG4gICAgdG9nZ2xlSGlEUEk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy51c2VIaURQSSgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnaGlkcGknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoaWRwaScsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FudmFzLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRlIEhpRFBJIHJhdGlvLlxuICAgICAqL1xuICAgIGdldEhpRFBJOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICYmIHRoaXMudXNlSGlEUEkoKSkge1xuICAgICAgICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICAgICAgdmFyIGJhY2tpbmdTdG9yZVJhdGlvID0gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgICAgICAgICByZXR1cm4gcmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gKHJlY2VudGx5IHJlbmRlcmVkKSBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZFdpZHRoOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRSZW5kZXJlZFdpZHRoKGNvbEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiAocmVjZW50bHkgcmVuZGVyZWQpIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUdGhlIHJvdyBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZEhlaWdodDogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0UmVuZGVyZWRIZWlnaHQocm93SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtDZWxsRWRpdG9yfSBUaGUgY2VsbCBlZGl0b3IgYXQgYWxpYXMgXCJuYW1lXCIgKGEgc3ViLWNvbXBvbmVudCkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKi9cbiAgICByZXNvbHZlQ2VsbEVkaXRvcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsRWRpdG9yc1tuYW1lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICB1cGRhdGUgdGhlIGN1cnNvciB1bmRlciB0aGUgaG92ZXIgY2VsbFxuICAgICAqL1xuICAgIHVwZGF0ZUN1cnNvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0cmFuc2xhdGUgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0cmFuc2xhdGUuZ2V0Q3Vyc29yQXQoLTEsIC0xKTtcbiAgICAgICAgdmFyIGhvdmVyQ2VsbCA9IHRoaXMuZ2V0SG92ZXJDZWxsKCk7XG4gICAgICAgIGlmIChob3ZlckNlbGwgJiYgaG92ZXJDZWxsLnggPiAtMSAmJiBob3ZlckNlbGwueSA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGhvdmVyQ2VsbC54ICsgdGhpcy5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgICAgIGN1cnNvciA9IHRyYW5zbGF0ZS5nZXRDdXJzb3JBdCh4LCBob3ZlckNlbGwueSArIHRoaXMuZ2V0VlNjcm9sbFZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVDdXJzb3IoY3Vyc29yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXBhaW50IHRoZSBnaXZlbiBjZWxsLlxuICAgICAqIEBwYXJhbSB7eH0geCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHt5fSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgcmVwYWludENlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdGhpcy5nZXRSZW5kZXJlcigpLnJlcGFpbnRDZWxsKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgdXNlciBpcyBjdXJyZW50bHkgZHJhZ2dpbmcgYSBjb2x1bW4gdG8gcmVvcmRlciBpdC5cbiAgICAgKi9cbiAgICBpc0RyYWdnaW5nQ29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNjcm9sbCB1cCBvbmUgZnVsbCBwYWdlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcGFnZVVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJvd051bSA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRQYWdlVXBSb3coKTtcbiAgICAgICAgdGhpcy5zZXRWU2Nyb2xsVmFsdWUocm93TnVtKTtcbiAgICAgICAgcmV0dXJuIHJvd051bTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTY3JvbGwgZG93biBvbmUgZnVsbCBwYWdlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcGFnZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm93TnVtID0gdGhpcy5nZXRSZW5kZXJlcigpLmdldFBhZ2VEb3duUm93KCk7XG4gICAgICAgIHRoaXMuc2V0VlNjcm9sbFZhbHVlKHJvd051bSk7XG4gICAgICAgIHJldHVybiByb3dOdW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgTm90IHlldCBpbXBsZW1lbnRlZC5cbiAgICAgKi9cbiAgICBwYWdlTGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwYWdlIGxlZnQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBOb3QgeWV0IGltcGxlbWVudGVkLlxuICAgICAqL1xuICAgIHBhZ2VSaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwYWdlIHJpZ2h0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfSBPYmplY3RzIHdpdGggdGhlIHZhbHVlcyB0aGF0IHdlcmUganVzdCByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBhc3N1bWVzIG9uZSByb3cgb2YgaGVhZGVyc1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCksXG4gICAgICAgICAgICByZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKSxcbiAgICAgICAgICAgIGNvbENvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgcm93Q291bnQgPSByZW5kZXJlci5nZXRWaXNpYmxlUm93cygpLFxuICAgICAgICAgICAgaGVhZGVycyA9IG5ldyBBcnJheShjb2xDb3VudCksXG4gICAgICAgICAgICByZXN1bHRzID0gbmV3IEFycmF5KHJvd0NvdW50KSxcbiAgICAgICAgICAgIHJvdztcblxuICAgICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyLCBjKSB7XG4gICAgICAgICAgICBoZWFkZXJzW2NdID0gYmVoYXZpb3IuZ2V0Q29sdW1uSWQoYywgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbihyZXN1bHQsIHIpIHtcbiAgICAgICAgICAgIHJvdyA9IHJlc3VsdHNbcl0gPSB7XG4gICAgICAgICAgICAgICAgaGllcmFyY2h5OiBiZWhhdmlvci5nZXRGaXhlZENvbHVtblZhbHVlKDAsIHIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBjKSB7XG4gICAgICAgICAgICAgICAgcm93W2ZpZWxkXSA9IGJlaGF2aW9yLmdldFZhbHVlKGMsIHIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnRseSBzZWxlY3Rpb24gcm93LlxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkUm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbHMgPSB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoc2Vscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKSxcbiAgICAgICAgICAgICAgICBjb2xDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgICAgICB0b3BSb3cgPSBzZWxzWzBdLm9yaWdpbi55LFxuICAgICAgICAgICAgICAgIHJvdyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy9oaWVyYXJjaHk6IGJlaGF2aW9yLmdldEZpeGVkQ29sdW1uVmFsdWUoMCwgdG9wUm93KVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHJvd1tiZWhhdmlvci5nZXRDb2x1bW5JZChjLCAwKV0gPSBiZWhhdmlvci5nZXRWYWx1ZShjLCB0b3BSb3cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpcmVSZXF1ZXN0Q2VsbEVkaXQ6IGZ1bmN0aW9uKGNlbGwsIHZhbHVlKSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tcmVxdWVzdC1jZWxsLWVkaXQnLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpOyAvL0kgd2Fzbid0IGNhbmNlbGxlZFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgZmluLWJlZm9yZS1jZWxsLWVkaXQgZXZlbnQuXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSB4LHkgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gVGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICovXG4gICAgZmlyZUJlZm9yZUNlbGxFZGl0OiBmdW5jdGlvbihjZWxsLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGNvbnRyb2wpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1iZWZvcmUtY2VsbC1lZGl0Jywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICBpbnB1dDogY29udHJvbFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHByb2NlZWQgPSB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgICAgICByZXR1cm4gcHJvY2VlZDsgLy9JIHdhc24ndCBjYW5jZWxsZWRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IHN1Yi1jb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHgseSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWUgLSBUaGUgb2xkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZSAtIFRoZSBuZXcgdmFsdWUuXG4gICAgICovXG4gICAgZmlyZUFmdGVyQ2VsbEVkaXQ6IGZ1bmN0aW9uKGNlbGwsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgY29udHJvbCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWFmdGVyLWNlbGwtZWRpdCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICBpbnB1dDogY29udHJvbFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBdXRvc2l6ZSB0aGUgY29sdW1uIGF0IGNvbEluZGV4IGZvciBiZXN0IGZpdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXggLSBUaGUgY29sdW1uIGluZGV4IHRvIG1vZGlmeSBhdFxuICAgICAqL1xuICAgIGF1dG9zaXplQ29sdW1uOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRCZWhhdmlvcigpLmdldENvbHVtbihjb2xJbmRleCk7XG4gICAgICAgIGNvbHVtbi5jaGVja0NvbHVtbkF1dG9zaXppbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRW5hYmxlL2Rpc2FibGUgaWYgdGhpcyBjb21wb25lbnQgY2FuIHJlY2VpdmUgdGhlIGZvY3VzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gLSBjYW5SZWNlaXZlRm9jdXNcbiAgICAgKi9cbiAgICBzZXRGb2N1c2FibGU6IGZ1bmN0aW9uKGNhblJlY2VpdmVGb2N1cykge1xuICAgICAgICB0aGlzLmdldENhbnZhcygpLnNldEZvY3VzYWJsZShjYW5SZWNlaXZlRm9jdXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29sdW1ucyB0aGF0IHdlcmUganVzdCByZW5kZXJlZFxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmdldFZpc2libGVDb2x1bW5zQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3MgdGhhdCB3ZXJlIGp1c3QgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93c0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRWaXNpYmxlUm93c0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgdXBkYXRlIHRoZSBzaXplIG9mIHRoZSBncmlkXG4gICAgICpcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICB1cGRhdGVTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuY2hlY2tzaXplKCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTdG9wIHRoZSBnbG9iYWwgcmVwYWludGluZyBmbGFnIHRocmVhZC5cbiAgICAgKi9cbiAgICBzdG9wUGFpbnRUaHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5zdG9wUGFpbnRUaHJlYWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTdG9wIHRoZSBnbG9iYWwgcmVzaXplIGNoZWNrIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHN0b3BSZXNpemVUaHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5zdG9wUmVzaXplVGhyZWFkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVzdGFydCB0aGUgZ2xvYmFsIHJlc2l6ZSBjaGVjayBmbGFnIHRocmVhZC5cbiAgICAgKi9cbiAgICByZXN0YXJ0UmVzaXplVGhyZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMucmVzdGFydFJlc2l6ZVRocmVhZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlc3RhcnQgdGhlIGdsb2JhbCByZXBhaW50aW5nIGNoZWNrIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHJlc3RhcnRQYWludFRocmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlc3RhcnRQYWludFRocmVhZCgpO1xuICAgIH0sXG5cbiAgICBzd2FwQ29sdW1uczogZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLnN3YXBDb2x1bW5zKHNvdXJjZSwgdGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5lbmREcmFnQ29sdW1uTm90aWZpY2F0aW9uKCk7XG4gICAgfSxcblxuICAgIGdldEZpeGVkQ29sdW1uc01heFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRGaXhlZENvbHVtbnNNYXhXaWR0aCgpO1xuICAgIH0sXG5cbiAgICBpc01vdXNlRG93bkluSGVhZGVyQXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW1IZWFkZXJDb2x1bW5zID0gdGhpcy5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtSGVhZGVyUm93cyA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIG1vdXNlRG93biA9IHRoaXMuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHJldHVybiBtb3VzZURvd24ueCA8IG51bUhlYWRlckNvbHVtbnMgfHwgbW91c2VEb3duLnkgPCBudW1IZWFkZXJSb3dzO1xuICAgIH0sXG5cbiAgICBpc0hlYWRlcldyYXBwaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdoZWFkZXJUZXh0V3JhcHBpbmcnKTtcbiAgICB9LFxuXG4gICAgX2dldEJvdW5kc09mQ2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRSZW5kZXJlcigpLl9nZXRCb3VuZHNPZkNlbGwoeCwgeSk7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfSxcblxuICAgIGdldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5nZXRCZWhhdmlvcigpLmdldENvbHVtblByb3BlcnRpZXMoY29sdW1uSW5kZXgpO1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9LFxuXG4gICAgc2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oY29sdW1uSW5kZXgsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLnNldENvbHVtblByb3BlcnRpZXMoY29sdW1uSW5kZXgsIHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5tb3ZlU2luZ2xlU2VsZWN0KHRoaXMsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RDZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5jbGVhcigpO1xuICAgICAgICB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuc2VsZWN0KHgsIHksIDAsIDApO1xuICAgIH0sXG5cbiAgICBnZXRIZWFkZXJDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlU29ydDogZnVuY3Rpb24oeCwga2V5cykge1xuICAgICAgICB0aGlzLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBiZWhhdmlvci50b2dnbGVTb3J0KHgsIGtleXMpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzKCk7XG4gICAgICAgICAgICAvL3NlbGYuYmVoYXZpb3JDaGFuZ2VkKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0NvbHVtbkF1dG9zaXppbmcoKSkge1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yLmF1dG9zaXplQWxsQ29sdW1ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yZXBhaW50KCk7XG4gICAgICAgIH0sIDEwKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlU2VsZWN0Q29sdW1uOiBmdW5jdGlvbih4LCBrZXlzKSB7XG4gICAgICAgIGtleXMgPSBrZXlzIHx8IFtdO1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCk7XG4gICAgICAgIHZhciBhbHJlYWR5U2VsZWN0ZWQgPSBtb2RlbC5pc0NvbHVtblNlbGVjdGVkKHgpO1xuICAgICAgICB2YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpID4gLTE7XG4gICAgICAgIHZhciBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSA+IC0xO1xuICAgICAgICBpZiAoIWhhc0NUUkwgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgICAgICBtb2RlbC5jbGVhcigpO1xuICAgICAgICAgICAgaWYgKCFhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5zZWxlY3RDb2x1bW4oeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ1RSTCkge1xuICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGVzZWxlY3RDb2x1bW4oeCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0Q29sdW1uKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNTSElGVCkge1xuICAgICAgICAgICAgICAgIG1vZGVsLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0Q29sdW1uKHRoaXMubGFzdEVkZ2VTZWxlY3Rpb25bMF0sIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxyZWFkeVNlbGVjdGVkICYmICFoYXNTSElGVCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvblswXSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0NvbHVtblNlbGVjdGlvbkNoYW5nZWRFdmVudCgpO1xuICAgIH0sXG5cbiAgICB0b2dnbGVTZWxlY3RSb3c6IGZ1bmN0aW9uKHksIGtleXMpIHtcblxuICAgICAgICAvL3dlIGNhbiBzZWxlY3QgdGhlIHRvdGFscyByb3dzIGlmIHRoZXkgZXhpc3QsXG4gICAgICAgIC8vYnV0IG5vdCByb3dzIGFib3ZlIHRoYXRcbiAgICAgICAgdmFyIHNlbGVjdGlvbkVkZ2UgPSB0aGlzLmdldEZpbHRlclJvd0luZGV4KCkgKyAxO1xuICAgICAgICBpZiAoeSA8IHNlbGVjdGlvbkVkZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMgPSBrZXlzIHx8IFtdO1xuXG4gICAgICAgIHZhciBpc1NpbmdsZVJvd1NlbGVjdGlvbiA9IHRoaXMuaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlKCk7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKTtcbiAgICAgICAgdmFyIGFscmVhZHlTZWxlY3RlZCA9IG1vZGVsLmlzUm93U2VsZWN0ZWQoeSk7XG4gICAgICAgIHZhciBoYXNDVFJMID0ga2V5cy5pbmRleE9mKCdDVFJMJykgPiAtMTtcbiAgICAgICAgdmFyIGhhc1NISUZUID0ga2V5cy5pbmRleE9mKCdTSElGVCcpID4gLTE7XG5cbiAgICAgICAgaWYgKCFoYXNDVFJMICYmICFoYXNTSElGVCkge1xuICAgICAgICAgICAgbW9kZWwuY2xlYXIoKTtcbiAgICAgICAgICAgIGlmICghYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0Um93KHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0NUUkwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRlc2VsZWN0Um93KHkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NpbmdsZVJvd1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuY2xlYXJSb3dTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zZWxlY3RSb3coeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5zZWxlY3RSb3codGhpcy5sYXN0RWRnZVNlbGVjdGlvblsxXSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbHJlYWR5U2VsZWN0ZWQgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RFZGdlU2VsZWN0aW9uWzFdID0geTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0Vmlld3BvcnRDZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpO1xuICAgICAgICB2YXIgcmVhbFggPSByZW5kZXJlci5nZXRWaXNpYmxlQ29sdW1ucygpW3hdO1xuICAgICAgICB2YXIgcmVhbFkgPSByZW5kZXJlci5nZXRWaXNpYmxlUm93cygpW3ldO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNlbGVjdChyZWFsWCwgcmVhbFkgKyBoZWFkZXJSb3dDb3VudCwgMCwgMCk7XG4gICAgICAgIHRoaXMuc2V0TW91c2VEb3duKHRoaXMubmV3UG9pbnQocmVhbFgsIHJlYWxZICsgaGVhZGVyUm93Q291bnQpKTtcbiAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0VG9WaWV3cG9ydENlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25zIHx8IHNlbGVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKCk7XG4gICAgICAgIHZhciByZWFsWCA9IHJlbmRlcmVyLmdldFZpc2libGVDb2x1bW5zKClbeF07XG4gICAgICAgIHZhciByZWFsWSA9IHJlbmRlcmVyLmdldFZpc2libGVSb3dzKClbeV0gKyBoZWFkZXJSb3dDb3VudDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbMF07XG4gICAgICAgIHZhciBvcmlnaW4gPSBzZWxlY3Rpb24ub3JpZ2luO1xuICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQodGhpcy5uZXdQb2ludChyZWFsWCAtIG9yaWdpbi54LCByZWFsWSAtIG9yaWdpbi55KSk7XG4gICAgICAgIHRoaXMuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgcmVhbFggLSBvcmlnaW4ueCwgcmVhbFkgLSBvcmlnaW4ueSk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RGaW5hbENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKVswXTtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNjcm9sbEJ5KHRoaXMuZ2V0Q29sdW1uQ291bnQoKSwgMCk7XG4gICAgICAgIHRoaXMuc2VsZWN0KHgsIHkgKyBoZWFkZXJSb3dDb3VudCwgMCwgMCk7XG4gICAgICAgIHRoaXMuc2V0TW91c2VEb3duKHRoaXMubmV3UG9pbnQoeCwgeSArIGhlYWRlclJvd0NvdW50KSk7XG4gICAgICAgIHRoaXMuc2V0RHJhZ0V4dGVudCh0aGlzLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNlbGVjdFRvRmluYWxDZWxsT2ZDdXJyZW50Um93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25zIHx8IHNlbGVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbMF07XG4gICAgICAgIHZhciBvcmlnaW4gPSBzZWxlY3Rpb24ub3JpZ2luO1xuICAgICAgICB2YXIgZXh0ZW50ID0gc2VsZWN0aW9uLmV4dGVudDtcbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB0aGlzLnNjcm9sbEJ5KGNvbHVtbkNvdW50LCAwKTtcblxuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIGNvbHVtbkNvdW50IC0gb3JpZ2luLnggLSAxLCBleHRlbnQueSk7XG5cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNlbGVjdEZpcnN0Q2VsbE9mQ3VycmVudFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldFNlbGVjdGVkUm93cygpWzBdO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKDApO1xuICAgICAgICB0aGlzLnNlbGVjdCh4LCB5ICsgaGVhZGVyUm93Q291bnQsIDAsIDApO1xuICAgICAgICB0aGlzLnNldE1vdXNlRG93bih0aGlzLm5ld1BvaW50KHgsIHkgKyBoZWFkZXJSb3dDb3VudCkpO1xuICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQodGhpcy5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RUb0ZpcnN0Q2VsbE9mQ3VycmVudFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmICghc2VsZWN0aW9ucyB8fCBzZWxlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBzZWxlY3Rpb25zWzBdO1xuICAgICAgICB2YXIgb3JpZ2luID0gc2VsZWN0aW9uLm9yaWdpbjtcbiAgICAgICAgdmFyIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQ7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgLW9yaWdpbi54LCBleHRlbnQueSk7XG4gICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKDApO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0RmluYWxDZWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RDZWxsKHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDEsIHRoaXMuZ2V0Um93Q291bnQoKSAtIDEpO1xuICAgICAgICB0aGlzLnNjcm9sbEJ5KHRoaXMuZ2V0Q29sdW1uQ291bnQoKSwgdGhpcy5nZXRSb3dDb3VudCgpKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNlbGVjdFRvRmluYWxDZWxsOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbnMgfHwgc2VsZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1swXTtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHNlbGVjdGlvbi5vcmlnaW47XG4gICAgICAgIHZhciBjb2x1bW5Db3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgY29sdW1uQ291bnQgLSBvcmlnaW4ueCAtIDEsIHJvd0NvdW50IC0gb3JpZ2luLnkgLSAxKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCeShjb2x1bW5Db3VudCwgcm93Q291bnQpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgaXNTaG93Um93TnVtYmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnc2hvd1Jvd051bWJlcnMnKTtcbiAgICB9LFxuICAgIGlzRWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2VkaXRhYmxlJykgPT09IHRydWU7XG4gICAgfSxcbiAgICBpc1Nob3dGaWx0ZXJSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Nob3dGaWx0ZXJSb3cnKTtcbiAgICB9LFxuICAgIGlzU2hvd0hlYWRlclJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnc2hvd0hlYWRlclJvdycpO1xuICAgIH0sXG4gICAgZ2V0SGVhZGVyUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgfSxcbiAgICBpc0ZpbHRlclJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4geSA9PT0gdGhpcy5nZXRGaWx0ZXJSb3dJbmRleCgpO1xuICAgIH0sXG4gICAgZ2V0RmlsdGVyUm93SW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTaG93RmlsdGVyUm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1Nob3dIZWFkZXJSb3coKSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0R3JvdXBzOiBmdW5jdGlvbihhcnJheU9mQ29sdW1uSW5kZXhlcykge1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkuc2V0R3JvdXBzKGFycmF5T2ZDb2x1bW5JbmRleGVzKTtcbiAgICB9LFxuICAgIGZpbHRlckNsaWNrZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVFZGl0b3IoZXZlbnQuZ3JpZENlbGwueCwgZXZlbnQuZ3JpZENlbGwueSk7XG4gICAgfSxcbiAgICBoYXNIaWVyYXJjaHlDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmhhc0hpZXJhcmNoeUNvbHVtbigpO1xuICAgIH0sXG4gICAgaXNIaWVyYXJjaHlDb2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0hpZXJhcmNoeUNvbHVtbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggPT09IDA7XG4gICAgfSxcbiAgICBjaGVja1Njcm9sbGJhclZpc2liaWxpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB2YXIgaG92ZXJDbGFzc092ZXIgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsYmFySG92ZXJPdmVyJyk7XG4gICAgICAgIC8vIHZhciBob3ZlckNsYXNzT2ZmID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGJhckhvdmVyT2ZmJyk7XG5cbiAgICAgICAgLy8gaWYgKGhvdmVyQ2xhc3NPZmYgPT09ICd2aXNpYmxlJykge1xuICAgICAgICAvLyAgICAgdGhpcy5zYkhTY3JvbGxlci5jbGFzc0xpc3QucmVtb3ZlKGhvdmVyQ2xhc3NPdmVyKTtcbiAgICAgICAgLy8gICAgIHRoaXMuc2JWU2Nyb2xsZXIuY2xhc3NMaXN0LnJlbW92ZShob3ZlckNsYXNzT2ZmKTtcbiAgICAgICAgLy8gICAgIHRoaXMuc2JIU2Nyb2xsZXIuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAvLyAgICAgdGhpcy5zYlZTY3JvbGxlci5jbGFzc0xpc3QuYWRkKCd2aXNpYmxlJyk7XG4gICAgICAgIC8vIH1cbiAgICB9LFxuICAgIGlzQ29sdW1uT3JSb3dTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuaXNDb2x1bW5PclJvd1NlbGVjdGVkKCk7XG4gICAgfSxcbiAgICBzZWxlY3RDb2x1bW46IGZ1bmN0aW9uKHgxLCB4Mikge1xuICAgICAgICB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuc2VsZWN0Q29sdW1uKHgxLCB4Mik7XG4gICAgfSxcbiAgICBzZWxlY3RSb3c6IGZ1bmN0aW9uKHkxLCB5Mikge1xuICAgICAgICBpZiAodGhpcy5pc1NpbmdsZVJvd1NlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmNsZWFyUm93U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB5MSA9IHkyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeTIgPSB5MiB8fCB5MTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oeTEsIHkyKTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHkxLCB5Mik7XG4gICAgICAgIHZhciBzZWxlY3Rpb25FZGdlID0gdGhpcy5nZXRGaWx0ZXJSb3dJbmRleCgpICsgMTtcbiAgICAgICAgaWYgKG1pbiA8IHNlbGVjdGlvbkVkZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuc2VsZWN0Um93KG1pbiwgbWF4KTtcbiAgICB9LFxuICAgIGlzUm93U2VsZWN0ZWQ6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5pc1Jvd1NlbGVjdGVkKHIpO1xuICAgIH0sXG4gICAgaXNDb2x1bW5TZWxlY3RlZDogZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmlzQ29sdW1uU2VsZWN0ZWQoYyk7XG4gICAgfSxcbiAgICBsb29rdXBGZWF0dXJlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5sb29rdXBGZWF0dXJlKGtleSk7XG4gICAgfSxcbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRSb3coeSk7XG4gICAgfSxcbiAgICBnZXRGaWVsZE5hbWU6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0RmllbGROYW1lKGluZGV4KTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uSW5kZXg6IGZ1bmN0aW9uKGZpZWxkTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldENvbHVtbkluZGV4KGZpZWxkTmFtZSk7XG4gICAgfSxcbiAgICBpc0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2NlbGxTZWxlY3Rpb24nKSA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIGlzUm93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdyb3dTZWxlY3Rpb24nKSA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIGlzQ29sdW1uU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdjb2x1bW5TZWxlY3Rpb24nKSA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIGdldENvbXB1dGVkUm93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0Q29tcHV0ZWRSb3coeSk7XG4gICAgfSxcbiAgICBpc0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2NvbHVtbkF1dG9zaXppbmcnKSA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIHNldEdsb2JhbEZpbHRlcjogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5zZXRHbG9iYWxGaWx0ZXIoc3RyaW5nKTtcbiAgICB9LFxuICAgIHNlbGVjdFJvd3NGcm9tQ2VsbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc20gPSB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCk7XG4gICAgICAgIGlmICh0aGlzLmlzU2luZ2xlUm93U2VsZWN0aW9uTW9kZSgpKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHNtLmdldExhc3RTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgICAgIHNtLmNsZWFyUm93U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Um93KG51bGwsIGxhc3QuY29ybmVyLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc20uc2VsZWN0Um93c0Zyb21DZWxscygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3RDb2x1bW5zRnJvbUNlbGxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLnNlbGVjdENvbHVtbnNGcm9tQ2VsbHMoKTtcbiAgICB9LFxuICAgIGdldFNlbGVjdGVkUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgfSxcbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0U2VsZWN0aW9ucygpO1xuICAgIH0sXG4gICAgZ2V0TGFzdFNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmdldExhc3RTZWxlY3Rpb25UeXBlKCk7XG4gICAgfSxcbiAgICBpc0NlbGxTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmlzQ2VsbFNlbGVjdGVkKHgsIHkpO1xuICAgIH0sXG4gICAgaXNJbkN1cnJlbnRTZWxlY3Rpb25SZWN0YW5nbGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5pc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZSh4LCB5KTtcbiAgICB9LFxuICAgIHNlbGVjdEFsbFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuc2VsZWN0QWxsUm93cygpO1xuICAgIH0sXG4gICAgYXJlQWxsUm93c1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5hcmVBbGxSb3dzU2VsZWN0ZWQoKTtcbiAgICB9LFxuICAgIHRvZ2dsZVNlbGVjdEFsbFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5hcmVBbGxSb3dzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmNsZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEFsbFJvd3MoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuICAgIGdldEZpZWxkOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0RmllbGQoeCk7XG4gICAgfSxcbiAgICBpc1NpbmdsZVJvd1NlbGVjdGlvbk1vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3NpbmdsZVJvd1NlbGVjdGlvbk1vZGUnKTtcbiAgICB9LFxuICAgIG5ld1BvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgfSxcbiAgICBuZXdSZWN0YW5nbGU6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZ2V0VGV4dFdpZHRoKGdjLCBzdHJpbmcpIHtcbiAgICBpZiAoc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBzdHJpbmcgPSBzdHJpbmcgKyAnJztcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIGtleSA9IGdjLmZvbnQgKyBzdHJpbmc7XG4gICAgdmFyIHdpZHRoID0gdGV4dFdpZHRoQ2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgICB3aWR0aCA9IGdjLm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgICAgIHRleHRXaWR0aENhY2hlLnNldChrZXksIHdpZHRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0SGVpZ2h0KGZvbnQpIHtcblxuICAgIHZhciByZXN1bHQgPSBnZXRUZXh0SGVpZ2h0LmZvbnREYXRhW2ZvbnRdO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVzdWx0ID0ge307XG4gICAgdmFyIHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdGV4dC50ZXh0Q29udGVudCA9ICdIZyc7XG4gICAgdGV4dC5zdHlsZS5mb250ID0gZm9udDtcblxuICAgIHZhciBibG9jayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJsb2NrLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICBibG9jay5zdHlsZS53aWR0aCA9ICcxcHgnO1xuICAgIGJsb2NrLnN0eWxlLmhlaWdodCA9ICcwcHgnO1xuXG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoYmxvY2spO1xuXG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG5cbiAgICB0cnkge1xuXG4gICAgICAgIGJsb2NrLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAnYmFzZWxpbmUnO1xuXG4gICAgICAgIHZhciBibG9ja1JlY3QgPSBibG9jay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICByZXN1bHQuYXNjZW50ID0gYmxvY2tSZWN0LnRvcCAtIHRleHRSZWN0LnRvcDtcblxuICAgICAgICBibG9jay5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICAgIHJlc3VsdC5oZWlnaHQgPSBibG9ja1JlY3QudG9wIC0gdGV4dFJlY3QudG9wO1xuXG4gICAgICAgIHJlc3VsdC5kZXNjZW50ID0gcmVzdWx0LmhlaWdodCAtIHJlc3VsdC5hc2NlbnQ7XG5cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuaGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgIGdldFRleHRIZWlnaHQuZm9udERhdGFbZm9udF0gPSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5nZXRUZXh0SGVpZ2h0LmZvbnREYXRhID0ge307XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcm9wZXJ0aWVzKCkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAvL3RoZXNlIGFyZSBmb3IgdGhlIHRoZW1lXG4gICAgICAgIGZvbnQ6ICcxM3B4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgY29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoMjQxLCAyNDEsIDI0MSknLFxuICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMTgzLCAyMTksIDI1NSknLFxuXG4gICAgICAgIGNvbHVtbkhlYWRlckZvbnQ6ICcxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgY29sdW1uSGVhZGVyQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuICAgICAgICBjb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoMjIzLCAyMjcsIDIzMiknLFxuICAgICAgICBjb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuICAgICAgICBjb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjU1LCAyMjAsIDk3KScsXG4gICAgICAgIGNvbHVtbkhlYWRlckZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG4gICAgICAgIGNvbHVtbkhlYWRlckJhY2tncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjogJ3JnYigyNTUsIDE4MCwgMCknLFxuXG4gICAgICAgIHJvd0hlYWRlckZvbnQ6ICcxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgcm93SGVhZGVyQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuICAgICAgICByb3dIZWFkZXJCYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoMjIzLCAyMjcsIDIzMiknLFxuICAgICAgICByb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuICAgICAgICByb3dIZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjU1LCAyMjAsIDk3KScsXG4gICAgICAgIHJvd0hlYWRlckZvcmVncm91bmRSb3dTZWxlY3Rpb25Db2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG4gICAgICAgIHJvd0hlYWRlckJhY2tncm91bmRSb3dTZWxlY3Rpb25Db2xvcjogJ3JnYigyNTUsIDE4MCwgMCknLFxuXG4gICAgICAgIGZpbHRlckZvbnQ6ICcxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgZmlsdGVyQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuICAgICAgICBmaWx0ZXJCYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgIGZpbHRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG4gICAgICAgIGZpbHRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYigyNTUsIDIyMCwgOTcpJyxcbiAgICAgICAgZmlsdGVyQ2VsbEJvcmRlclN0eWxlOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICAgICAgZmlsdGVyQ2VsbEJvcmRlclRoaWNrbmVzczogJzAuNCcsXG5cbiAgICAgICAgdHJlZUNvbHVtbkZvbnQ6ICcxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgdHJlZUNvbHVtbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcbiAgICAgICAgdHJlZUNvbHVtbkJhY2tncm91bmRDb2xvcjogJ3JnYigyMjMsIDIyNywgMjMyKScsXG4gICAgICAgIHRyZWVDb2x1bW5Gb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuICAgICAgICB0cmVlQ29sdW1uQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1NSwgMjIwLCA5NyknLFxuICAgICAgICB0cmVlQ29sdW1uRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcbiAgICAgICAgdHJlZUNvbHVtbkJhY2tncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjogJ3JnYigyNTUsIDE4MCwgMCknLFxuXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjI6ICdyZ2IoMjAxLCAyMDEsIDIwMSknLFxuICAgICAgICB2b2Zmc2V0OiAwLFxuICAgICAgICBzY3JvbGxiYXJIb3Zlck92ZXI6ICd2aXNpYmxlJyxcbiAgICAgICAgc2Nyb2xsYmFySG92ZXJPZmY6ICdoaWRkZW4nLFxuICAgICAgICBzY3JvbGxpbmdFbmFibGVkOiB0cnVlLFxuICAgICAgICB2U2Nyb2xsYmFyQ2xhc3NQcmVmaXg6ICcnLFxuICAgICAgICBoU2Nyb2xsYmFyQ2xhc3NQcmVmaXg6ICcnLFxuXG4gICAgICAgIC8vdGhlc2UgdXNlZCB0byBiZSBpbiB0aGUgY29uc3RhbnRzIGVsZW1lbnRcbiAgICAgICAgZml4ZWRSb3dBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIGZpeGVkQ29sQWxpZ246ICdjZW50ZXInLFxuICAgICAgICBjZWxsUGFkZGluZzogNSxcbiAgICAgICAgZ3JpZExpbmVzSDogdHJ1ZSxcbiAgICAgICAgZ3JpZExpbmVzVjogdHJ1ZSxcbiAgICAgICAgbGluZUNvbG9yOiAncmdiKDE5OSwgMTk5LCAxOTkpJyxcbiAgICAgICAgbGluZVdpZHRoOiAwLjQsXG5cbiAgICAgICAgZGVmYXVsdFJvd0hlaWdodDogMTUsXG4gICAgICAgIGRlZmF1bHRDb2x1bW5XaWR0aDogMTAwLFxuXG4gICAgICAgIC8vZm9yIGltbWVkaWF0ZSBwYWludGluZywgc2V0IHRoZXNlIHZhbHVlcyB0byAwLCB0cnVlIHJlc3BlY3RpdmVseVxuICAgICAgICByZXBhaW50SW50ZXJ2YWxSYXRlOiA2MCxcbiAgICAgICAgcmVwYWludEltbWVkaWF0ZWx5OiBmYWxzZSxcblxuICAgICAgICAvL2VuYWJsZSBvciBkaXNhYmxlIGRvdWJsZSBidWZmZXJpbmdcbiAgICAgICAgdXNlQml0QmxpdDogZmFsc2UsXG5cbiAgICAgICAgdXNlSGlEUEk6IHRydWUsXG4gICAgICAgIGVkaXRvckFjdGl2YXRpb25LZXlzOiBbJ2FsdCcsICdlc2MnXSxcbiAgICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuXG4gICAgICAgIC8vaW5oZXJ0aWVkIGJ5IGNlbGwgcmVuZGVyZXJzXG4gICAgICAgIGdldFRleHRXaWR0aDogZ2V0VGV4dFdpZHRoLFxuICAgICAgICBnZXRUZXh0SGVpZ2h0OiBnZXRUZXh0SGVpZ2h0LFxuXG4gICAgICAgIGZpeGVkQ29sdW1uQ291bnQ6IDAsXG4gICAgICAgIGZpeGVkUm93Q291bnQ6IDAsXG4gICAgICAgIGhlYWRlckNvbHVtbkNvdW50OiAwLFxuXG4gICAgICAgIHNob3dSb3dOdW1iZXJzOiB0cnVlLFxuICAgICAgICBzaG93SGVhZGVyUm93OiB0cnVlLFxuICAgICAgICBzaG93RmlsdGVyUm93OiB0cnVlLFxuXG4gICAgICAgIGNlbGxTZWxlY3Rpb246IHRydWUsXG4gICAgICAgIGNvbHVtblNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgcm93U2VsZWN0aW9uOiB0cnVlLFxuICAgICAgICBzaW5nbGVSb3dTZWxlY3Rpb25Nb2RlOiB0cnVlLFxuXG4gICAgICAgIGNvbHVtbkF1dG9zaXppbmc6IHRydWUsXG4gICAgICAgIGhlYWRlclRleHRXcmFwcGluZzogZmFsc2UsXG4gICAgICAgIHJvd1Jlc2l6ZTogZmFsc2VcblxuICAgIH07XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICAgIHZhciBvID0gcmVjdC5vcmlnaW47XG4gICAgdmFyIGMgPSByZWN0LmNvcm5lcjtcblxuICAgIHZhciBveCA9IE1hdGgubWluKG8ueCwgYy54KTtcbiAgICB2YXIgb3kgPSBNYXRoLm1pbihvLnksIGMueSk7XG5cbiAgICB2YXIgY3ggPSBNYXRoLm1heChvLngsIGMueCk7XG4gICAgdmFyIGN5ID0gTWF0aC5tYXgoby55LCBjLnkpO1xuXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBSZWN0YW5nbGUob3gsIG95LCBjeCAtIG94LCBjeSAtIG95KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUG9seW1lclRoZW1lKCkge1xuICAgIGNsZWFyT2JqZWN0UHJvcGVydGllcyhwb2x5bWVyVGhlbWUpO1xuICAgIHZhciBwYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BhcGVyLWJ1dHRvbicpO1xuXG4gICAgcGIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBwYi5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwYik7XG4gICAgdmFyIHAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYik7XG5cbiAgICB2YXIgc2VjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlY3Rpb24nKTtcbiAgICBzZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgc2VjdGlvbi5zZXRBdHRyaWJ1dGUoJ2hlcm8nLCB0cnVlKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNlY3Rpb24pO1xuXG4gICAgdmFyIGggPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sJykpO1xuICAgIHZhciBoYiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwsIGJvZHknKSk7XG4gICAgdmFyIHMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzZWN0aW9uKTtcblxuICAgIHBvbHltZXJUaGVtZS5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sb3IgPSBwLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5yb3dIZWFkZXJCYWNrZ3JvdW5kQ29sb3IgPSBwLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS50b3BMZWZ0QmFja2dyb3VuZENvbG9yID0gcC5jb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUubGluZUNvbG9yID0gcC5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICBwb2x5bWVyVGhlbWUuYmFja2dyb3VuZENvbG9yMiA9IGhiLmJhY2tncm91bmRDb2xvcjtcblxuICAgIHBvbHltZXJUaGVtZS5jb2xvciA9IGguY29sb3I7XG4gICAgcG9seW1lclRoZW1lLmZvbnRGYW1pbHkgPSBoLmZvbnRGYW1pbHk7XG4gICAgcG9seW1lclRoZW1lLmJhY2tncm91bmRDb2xvciA9IHMuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgcGIuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICBwYi5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeScsIHRydWUpO1xuICAgIHBiLnNldEF0dHJpYnV0ZSgncmFpc2VkJywgdHJ1ZSk7XG4gICAgcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBiKTtcblxuICAgIHBvbHltZXJUaGVtZS5jb2x1bW5IZWFkZXJDb2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLnJvd0hlYWRlckNvbG9yID0gcC5jb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUudG9wTGVmdENvbG9yID0gcC5jb2xvcjtcblxuXG4gICAgcG9seW1lclRoZW1lLmJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5mb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSBwLmNvbG9yO1xuXG4gICAgcGIuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnknLCBmYWxzZSk7XG4gICAgcGIuc2V0QXR0cmlidXRlKCd3YXJuaW5nJywgdHJ1ZSk7XG5cbiAgICBwb2x5bWVyVGhlbWUuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gcC5jb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gcC5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgcG9seW1lclRoZW1lLnJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLmZpeGVkQ29sdW1uQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gcC5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAvL2NoZWNrIGlmIHRoZXJlIGlzIGFjdHVhbGx5IGEgdGhlbWUgbG9hZGVkIGlmIG5vdCwgY2xlYXIgb3V0IGFsbCBib2d1cyB2YWx1ZXNcbiAgICAvL2Zyb20gbXkgY2FjaGVcbiAgICBpZiAocG9seW1lclRoZW1lLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9PT0gJ3JnYmEoMCwgMCwgMCwgMCknIHx8XG4gICAgICAgIHBvbHltZXJUaGVtZS5saW5lQ29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgY2xlYXJPYmplY3RQcm9wZXJ0aWVzKHBvbHltZXJUaGVtZSk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChwYik7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzZWN0aW9uKTtcbn1cblxuZnVuY3Rpb24gY2xlYXJPYmplY3RQcm9wZXJ0aWVzKG9iaikge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbcHJvcF07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbHVlT3JGdW5jdGlvbkV4ZWN1dGUodmFsdWVPckZ1bmN0aW9uKSB7XG4gICAgdmFyIHJlc3VsdCA9IHR5cGVvZiB2YWx1ZU9yRnVuY3Rpb24gPT09ICdmdW5jdGlvbicgPyB2YWx1ZU9yRnVuY3Rpb24oKSA6IHZhbHVlT3JGdW5jdGlvbjtcbiAgICByZXR1cm4gcmVzdWx0IHx8IHJlc3VsdCA9PT0gMCA/IHJlc3VsdCA6ICcnO1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsUG9seWZpbGxzKCkge1xuICAgIGlmICghQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRlbmQtbmF0aXZlXG4gICAgICAgICAgICBpZiAodGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5maW5kIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcmVkaWNhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGlzdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaSwgbGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEh5cGVyZ3JpZDtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyogZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xudmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgZmluLWh5cGVyZ3JpZC1yZW5kZXJlciBpcyB0aGUgY2FudmFzIGVuYWJsZWQgdG9wIGxldmVsIHN1YiBjb21wb25lbnQgdGhhdCBoYW5kbGVzIHRoZSByZW5kZXJlcmluZyBvZiB0aGUgR3JpZC5cbiAqXG4gKiBJdCByZWxpZXMgb24gdHdvIG90aGVyIGV4dGVybmFsIHN1YnByb2plY3RzXG4gKlxuICogMS4gZmluLWNhbnZhczogYSB3cmFwcGVyIHRvIHByb3ZpZGUgYSBzaW1wbGVyIGludGVyZmFjZSB0byB0aGUgSFRNTDUgY2FudmFzIGNvbXBvbmVudFxuICogMi4gcmVjdGFuZ3VsYXI6IGEgc21hbGwgbnBtIG1vZHVsZSBwcm92aWRpbmcgUG9pbnQgYW5kIFJlY3RhbmdsZSBvYmplY3RzXG4gKlxuICogVGhlIGZpbi1oeXBlcmdyaWQtcmVuZGVyZXIgaXMgaW4gYSB1bmlxdWUgcG9zaXRpb24gdG8gcHJvdmlkZSBjcml0aWNhbCBmdW5jdGlvbmFsaXR5IHRvIHRoZSBmaW4taHlwZXJncmlkIGluIGEgaGlnaHRseSBwZXJmb3JtYW50IG1hbm5lci5cbiAqIEJlY2F1c2UgaXQgTVVTVCBpdGVyYXRlIG92ZXIgYWxsIHRoZSB2aXNpYmxlIGNlbGxzIGl0IGNhbiBzdG9yZSB2YXJpb3VzIGJpdHMgb2YgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgZW5jYXBzdWxhdGVkIGFzIGEgc2VydmljZSBmb3IgY29uc3VtcHRpb24gYnkgdGhlIGZpbi1oeXBlcmdyaWQgY29tcG9uZW50LlxuICpcbiAqIEluc3RhbmNlcyBvZiB0aGlzIG9iamVjdCBoYXZlIGJhc2ljYWxseSBmb3VyIG1haW4gZnVuY3Rpb25zLlxuICpcbiAqIDEuIHJlbmRlciBmaXhlZCByb3cgaGVhZGVyc1xuICogMi4gcmVuZGVyIGZpeGVkIGNvbCBoZWFkZXJzXG4gKiAzLiByZW5kZXIgbWFpbiBkYXRhIGNlbGxzXG4gKiA0LiByZW5kZXIgZ3JpZCBsaW5lc1xuICpcbiAqIFNhbWUgcGFyYW1ldGVycyBhcyB7QGxpbmsgUmVuZGVyZXIjaW5pdGlhbGl6ZXxpbml0aWFsaXplfSwgd2hpY2ggaXMgY2FsbGVkIGJ5IHRoaXMgY29uc3RydWN0b3IuXG4gKlxuICovXG52YXIgUmVuZGVyZXIgPSBCYXNlLmV4dGVuZCgnUmVuZGVyZXInLCB7XG5cbiAgICAvL3RoZSBzaGFyZWQgc2luZ2xlIGl0ZW0gXCJwb29sZWRcIiBjZWxsIG9iamVjdCBmb3IgZHJhd2luZyBlYWNoIGNlbGxcbiAgICBjZWxsOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICB9LFxuXG4gICAgc2Nyb2xsSGVpZ2h0OiAwLFxuXG4gICAgdmlld0hlaWdodDogMCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSB7XG4gICAgICAgICAgICB3aWR0aDowLFxuICAgICAgICAgICAgaGVpZ2h0OjBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb2x1bW5FZGdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzSW5kZXhNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbk1pbldpZHRocyA9IFtdO1xuICAgICAgICB0aGlzLnJlbmRlcmVkSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5yb3dFZGdlcyA9IFtdO1xuICAgICAgICB0aGlzLnJvd0VkZ2VzSW5kZXhNYXAgPSB7fTtcbiAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLnZpc2libGVSb3dzID0gW107XG4gICAgICAgIHRoaXMuaW5zZXJ0aW9uQm91bmRzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENvbnN0cnVjdG9yIGxvZ2ljXG4gICAgICogQGRlc2MgVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgdXBvbiBpbnN0YW50aWF0aW9uIG9mIHRoaXMgY2xhc3Mgb3Igb2YgYW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBmcm9tIHRoaXMgY2xhc3MuXG4gICAgICogPiBBbGwgYGluaXRpYWxpemUoKWAgbWV0aG9kcyBpbiB0aGUgaW5oZXJpdGFuY2UgY2hhaW4gYXJlIGNhbGxlZCwgaW4gdHVybiwgZWFjaCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IsIGJlZ2lubmluZyB3aXRoIHRoYXQgb2YgdGhlIG1vc3QgXCJzZW5pb3JcIiBjbGFzcyB0aHJvdWdoIHRoYXQgb2YgdGhlIGNsYXNzIG9mIHRoZSBuZXcgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5ncmlkID0gZ3JpZDtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSB7XG4gICAgICAgICAgICB3aWR0aDowLFxuICAgICAgICAgICAgaGVpZ2h0OjBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb2x1bW5FZGdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzSW5kZXhNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbk1pbldpZHRocyA9IFtdO1xuICAgICAgICB0aGlzLnJlbmRlcmVkSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5yb3dFZGdlcyA9IFtdO1xuICAgICAgICB0aGlzLnJvd0VkZ2VzSW5kZXhNYXAgPSB7fTtcbiAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLnZpc2libGVSb3dzID0gW107XG4gICAgICAgIHRoaXMuaW5zZXJ0aW9uQm91bmRzID0gW107XG4gICAgfSxcblxuICAgIC8vdGhpcyBmdW5jdGlvbiBjb21wdXRlcyB0aGUgZ3JpZCBjb29yZGluYXRlcyB1c2VkIGZvciBleHRyZW1lbHkgZmFzdCBpdGVyYXRpb24gb3ZlclxuICAgIC8vcGFpbnRpbmcgdGhlIGdyaWQgY2VsbHMuIHRoaXMgZnVuY3Rpb24gaXMgdmVyeSBmYXN0LCBmb3IgdGhvdXNhbmQgcm93cyBYIDEwMCBjb2x1bW5zXG4gICAgLy9vbiBhIG1vZGVzdCBtYWNoaW5lIHRha2luZyB1c3VhbGx5IDBtcyBhbmQgbm8gbW9yZSB0aGF0IDMgbXMuXG4gICAgY29tcHV0ZUNlbGxzQm91bmRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvL3ZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLmdldFNjcm9sbFRvcCgpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuZ2V0U2Nyb2xsTGVmdCgpO1xuXG4gICAgICAgIHZhciBudW1Db2x1bW5zID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG5cbiAgICAgICAgdmFyIG51bVJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSB0aGlzLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgdmFyIHZpZXdXaWR0aCA9IGJvdW5kcy53aWR0aDtcblxuICAgICAgICAvL3dlIG11c3QgYmUgaW4gYm9vdHN0cmFwXG4gICAgICAgIGlmICh2aWV3V2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIC8vdmlld1dpZHRoID0gZ3JpZC5zYkhTY3JvbGxlci5nZXRDbGllbnRSZWN0cygpWzBdLndpZHRoO1xuICAgICAgICAgICAgdmlld1dpZHRoID0gZ3JpZC5jYW52YXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZXdIZWlnaHQgPSBib3VuZHMuaGVpZ2h0O1xuXG4gICAgICAgIHZhciB4LCB5LCBjLCByLCB2eCwgdnksIHdpZHRoLCBoZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5nZXRDb2x1bW5FZGdlcygpLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucm93RWRnZXMubGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzWzBdID0gMDtcbiAgICAgICAgdGhpcy5yb3dFZGdlc1swXSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gMDtcblxuICAgICAgICB0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudmlzaWJsZVJvd3MubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5FZGdlc0luZGV4TWFwID0ge307XG4gICAgICAgIHRoaXMucm93RWRnZXNJbmRleE1hcCA9IHt9O1xuXG4gICAgICAgIHRoaXMuaW5zZXJ0aW9uQm91bmRzID0gW107XG4gICAgICAgIHZhciBpbnNlcnRpb25Cb3VuZHNDdXJzb3IgPSAwO1xuICAgICAgICB2YXIgcHJldmlvdXNJbnNlcnRpb25Cb3VuZHNDdXJzb3JWYWx1ZSA9IDA7XG5cbiAgICAgICAgeCA9IDA7XG4gICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgIHZhciBmaXJzdFZYLCBsYXN0Vlg7XG4gICAgICAgIHZhciBmaXJzdFZZLCBsYXN0Vlk7XG4gICAgICAgIGlmIChncmlkLmlzU2hvd1Jvd051bWJlcnMoKSkge1xuICAgICAgICAgICAgc3RhcnQtLTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uRWRnZXNbLTFdID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjID0gc3RhcnQ7IGMgPCBudW1Db2x1bW5zOyBjKyspIHtcbiAgICAgICAgICAgIHZ4ID0gYztcbiAgICAgICAgICAgIGlmIChjID49IG51bUZpeGVkQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIHZ4ID0gdnggKyBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFZYID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RWWCA9IHZ4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0VlggPSB2eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gdmlld1dpZHRoIHx8IG51bUNvbHVtbnMgPD0gdngpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5nZXRDb2x1bW5XaWR0aCh2eCk7XG4gICAgICAgICAgICB4ID0geCArIHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5FZGdlc1tjICsgMV0gPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1uc1tjXSA9IHZ4O1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5FZGdlc0luZGV4TWFwW3Z4XSA9IGM7XG5cbiAgICAgICAgICAgIGluc2VydGlvbkJvdW5kc0N1cnNvciA9IGluc2VydGlvbkJvdW5kc0N1cnNvciArIE1hdGgucm91bmQod2lkdGggLyAyKSArIHByZXZpb3VzSW5zZXJ0aW9uQm91bmRzQ3Vyc29yVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmluc2VydGlvbkJvdW5kcy5wdXNoKGluc2VydGlvbkJvdW5kc0N1cnNvcik7XG4gICAgICAgICAgICBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlID0gTWF0aC5yb3VuZCh3aWR0aCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgeSA9IDA7XG4gICAgICAgIGZvciAociA9IDA7IHIgPCBudW1Sb3dzOyByKyspIHtcbiAgICAgICAgICAgIHZ5ID0gcjtcbiAgICAgICAgICAgIGlmIChyID49IG51bUZpeGVkUm93cykge1xuICAgICAgICAgICAgICAgIHZ5ID0gdnkgKyBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0VlkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFZZID0gdnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RWWSA9IHZ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPiB2aWV3SGVpZ2h0IHx8IG51bVJvd3MgPD0gdnkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0Um93SGVpZ2h0KHZ5KTtcbiAgICAgICAgICAgIHkgPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5yb3dFZGdlc1tyICsgMV0gPSBNYXRoLnJvdW5kKHkpO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlUm93c1tyXSA9IHZ5O1xuICAgICAgICAgICAgdGhpcy5yb3dFZGdlc0luZGV4TWFwW3Z5XSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3SGVpZ2h0ID0gdmlld0hlaWdodDtcbiAgICAgICAgdGhpcy5kYXRhV2luZG93ID0gZ3JpZC5uZXdSZWN0YW5nbGUoZmlyc3RWWCwgZmlyc3RWWSwgbGFzdFZYIC0gZmlyc3RWWCwgbGFzdFZZIC0gZmlyc3RWWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhIHByb3BlcnR5IHZhbHVlIGF0IGEga2V5LCBkZWxlZ2F0ZXMgdG8gdGhlIGdyaWRcbiAgICAgKi9cbiAgICByZXNvbHZlUHJvcGVydHk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkucmVzb2x2ZVByb3BlcnR5KGtleSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZ2V0R3JpZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBOb3RpZnkgdGhlIGZpbi1oeXBlcmdyaWQgZXZlcnl0aW1lIHdlJ3ZlIHJlcGFpbnRlZC5cbiAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjIC0gW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAgICAgKi9cbiAgICBfcGFpbnQ6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyR3JpZChnYyk7XG4gICAgICAgICAgICB0aGlzLmdldEdyaWQoKS5ncmlkUmVuZGVyZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQW5zd2VyIGhvdyBtYW55IHJvd3Mgd2UgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93c0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVJvd3MubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgZ2V0VmlzaWJsZVNjcm9sbEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCksXG4gICAgICAgICAgICBmcmggPSBncmlkLmdldEZpeGVkUm93c0hlaWdodCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdIZWlnaHQgLSBmcmg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IFJvd3Mgd2UganVzdCByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVSb3dzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtZXIgb2YgY29sdW1ucyB3ZSBqdXN0IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGggLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ29sdW1ucyB3ZSBqdXN0IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZUNvbHVtbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY29sdW1uIGluZGV4IHdobmUgdGhlIG1vdXNlRXZlbnQgY29vcmRpbmF0ZXMgYXJlIG92ZXIgYSBjb2x1bW4gZGl2aWRlci5cbiAgICAgKi9cbiAgICBvdmVyQ29sdW1uRGl2aWRlcjogZnVuY3Rpb24oeCkge1xuICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgd2hpY2hDb2wgPSBlZGdlcy5pbmRleE9mKHggLSAxKTtcbiAgICAgICAgaWYgKHdoaWNoQ29sIDwgMCkge1xuICAgICAgICAgICAgd2hpY2hDb2wgPSBlZGdlcy5pbmRleE9mKHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aGljaENvbCA8IDApIHtcbiAgICAgICAgICAgIHdoaWNoQ29sID0gZWRnZXMuaW5kZXhPZih4IC0gMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdoaWNoQ29sIDwgMCkge1xuICAgICAgICAgICAgd2hpY2hDb2wgPSBlZGdlcy5pbmRleE9mKHggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hpY2hDb2wgPCAwKSB7XG4gICAgICAgICAgICB3aGljaENvbCA9IGVkZ2VzLmluZGV4T2YoeCAtIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdoaWNoQ29sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdyBpbmRleCB3aGVuIHRoZSBtb3VzZUV2ZW50IGNvb3JkaW5hdGVzIGFyZSBvdmVyIGEgcm93IGRpdmlkZXIuXG4gICAgICovXG4gICAgb3ZlclJvd0RpdmlkZXI6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgeSA9IE1hdGgucm91bmQoeSk7XG4gICAgICAgIHZhciB3aGljaCA9IHRoaXMucm93RWRnZXMuaW5kZXhPZih5ICsgMSk7XG4gICAgICAgIGlmICh3aGljaCA8IDApIHtcbiAgICAgICAgICAgIHdoaWNoID0gdGhpcy5yb3dFZGdlcy5pbmRleE9mKHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aGljaCA8IDApIHtcbiAgICAgICAgICAgIHdoaWNoID0gdGhpcy5yb3dFZGdlcy5pbmRleE9mKHkgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2hpY2g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQm91bmRpbmcgcmVjdCBvZiB0aGUgZ2l2ZW4gYGNlbGxgLlxuICAgICAqL1xuICAgIGdldEJvdW5kc09mQ2VsbDogZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Qm91bmRzT2ZDZWxsKGNlbGwueCwgY2VsbC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gciAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IEJvdW5kaW5nIHJlY3Qgb2YgY2VsbCB3aXRoIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBfZ2V0Qm91bmRzT2ZDZWxsOiBmdW5jdGlvbihjLCByKSB7XG4gICAgICAgIHZhciB4T3V0c2lkZSA9IGZhbHNlO1xuICAgICAgICB2YXIgeU91dHNpZGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNvbHVtbkVkZ2VzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgcm93RWRnZXMgPSB0aGlzLmdldFJvd0VkZ2VzKCk7XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLmNvbHVtbkVkZ2VzSW5kZXhNYXBbY107XG4gICAgICAgIHZhciB5ID0gdGhpcy5yb3dFZGdlc0luZGV4TWFwW3JdO1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5jb2x1bW5FZGdlc0luZGV4TWFwW2MgLSAxXTtcbiAgICAgICAgICAgIHhPdXRzaWRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHkgPSB0aGlzLnJvd0VkZ2VzSW5kZXhNYXBbciAtIDFdO1xuICAgICAgICAgICAgeU91dHNpZGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG94ID0gY29sdW1uRWRnZXNbeF0sXG4gICAgICAgICAgICBveSA9IHJvd0VkZ2VzW3ldLFxuICAgICAgICAgICAgY3ggPSBjb2x1bW5FZGdlc1t4ICsgMV0sXG4gICAgICAgICAgICBjeSA9IHJvd0VkZ2VzW3kgKyAxXSxcbiAgICAgICAgICAgIGV4ID0gY3ggLSBveCxcbiAgICAgICAgICAgIGV5ID0gY3kgLSBveTtcblxuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbDtcbiAgICAgICAgY2VsbC54ID0geE91dHNpZGUgPyBjeCA6IG94O1xuICAgICAgICBjZWxsLnkgPSB5T3V0c2lkZSA/IGN5IDogb3k7XG4gICAgICAgIGNlbGwud2lkdGggPSB4T3V0c2lkZSA/IDAgOiBleDtcbiAgICAgICAgY2VsbC5oZWlnaHQgPSB5T3V0c2lkZSA/IDAgOiBleTtcblxuICAgICAgICByZXR1cm4gY2VsbDtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW5zd2VyIHRoZSBjb2x1bW4gaW5kZXggdW5kZXIgdGhlIGNvb3JkaW5hdGUgYXQgcGl4ZWxYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsWCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGNvbHVtbiBpbmRleCB1bmRlciB0aGUgY29vcmRpbmF0ZSBhdCBwaXhlbFguXG4gICAgICovXG4gICAgZ2V0Q29sdW1uRnJvbVBpeGVsWDogZnVuY3Rpb24ocGl4ZWxYKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgZm9yIChjID0gMTsgYyA8IGVkZ2VzLmxlbmd0aCAtIDE7IGMrKykge1xuICAgICAgICAgICAgd2lkdGggPSBlZGdlc1tjXSAtIChlZGdlc1tjXSAtIGVkZ2VzW2MgLSAxXSkgLyAyO1xuICAgICAgICAgICAgaWYgKHBpeGVsWCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPiBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBjICsgc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjID4gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgYyA9IGMgKyBzY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjIC0gMTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgQW5zd2VyIHNwZWNpZmljIGRhdGEgY2VsbCBjb29yZGluYXRlcyBnaXZlbiBtb3VzZSBjb29yZGluYXRlcyBpbiBwaXhlbHMuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IENlbGwgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBnZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IGdyaWQuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICAgIHZhciB4LCB5LCBjLCByO1xuICAgICAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgICAgICB2YXIgY29sdW1uRWRnZXMgPSB0aGlzLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCk7IC8vICsgZ3JpZFNpemU7XG4gICAgICAgIHZhciBmaXhlZFJvd0NvdW50ID0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgLy8gdmFyIGZpeGVkQ29sdW1uQ291bnQgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgLy8gdmFyIGZpeGVkUm93Q291bnQgPSB0aGlzLmdldEZpeGVkUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHNjcm9sbFggPSB0aGlzLmdldFNjcm9sbExlZnQoKTtcbiAgICAgICAgdmFyIHNjcm9sbFkgPSB0aGlzLmdldFNjcm9sbFRvcCgpO1xuXG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBjb2x1bW5FZGdlcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgd2lkdGggPSBjb2x1bW5FZGdlc1tjXTtcbiAgICAgICAgICAgIGlmIChwb2ludC54IDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5tYXgoMCwgcG9pbnQueCAtIHByZXZpb3VzIC0gMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91cyA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGMtLTtcbiAgICAgICAgcHJldmlvdXMgPSAwO1xuICAgICAgICBmb3IgKHIgPSAwOyByIDwgdGhpcy5yb3dFZGdlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5yb3dFZGdlc1tyXTtcbiAgICAgICAgICAgIGlmIChwb2ludC55IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWF4KDAsIHBvaW50LnkgLSBwcmV2aW91cyAtIDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgci0tO1xuICAgICAgICBpZiAocG9pbnQueCA8IDApIHtcbiAgICAgICAgICAgIGMgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnQueSA8IDApIHtcbiAgICAgICAgICAgIHIgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aWV3UG9pbnQgPSBncmlkLm5ld1BvaW50KGMsIHIpO1xuXG4gICAgICAgIC8vY29tcGVuc2F0ZSBpZiB3ZSBhcmUgc2Nyb2xsZWRcbiAgICAgICAgaWYgKGMgPj0gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgYyA9IGMgKyBzY3JvbGxYO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyID49IGZpeGVkUm93Q291bnQpIHtcbiAgICAgICAgICAgIHIgPSByICsgc2Nyb2xsWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cmFuc2xhdGVkSW5kZXggPSAtMTtcblxuICAgICAgICB2YXIgY29sdW1uID0gYmVoYXZpb3IuZ2V0Q29sdW1uKGMpO1xuICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGVkSW5kZXggPSBjb2x1bW4uaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JpZENlbGw6IGdyaWQubmV3UG9pbnQoYywgciksXG4gICAgICAgICAgICBtb3VzZVBvaW50OiBncmlkLm5ld1BvaW50KHgsIHkpLFxuICAgICAgICAgICAgdmlld1BvaW50OiB2aWV3UG9pbnQsXG4gICAgICAgICAgICBkYXRhQ2VsbDogZ3JpZC5uZXdQb2ludCh0cmFuc2xhdGVkSW5kZXgsIHIpLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbiBpcyB2aXNpYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleCAtIHRoZSBjb2x1bW4gaW5kZXgqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjb2x1bW4gaXMgZnVsbHkgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0NvbHVtblZpc2libGU6IGZ1bmN0aW9uKGNvbEluZGV4KSB7XG4gICAgICAgIHZhciBpc1Zpc2libGUgPSB0aGlzLnZpc2libGVDb2x1bW5zLmluZGV4T2YoY29sSW5kZXgpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIGlzVmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB3aWR0aCB4IGNvb3JkaW5hdGUgb2YgdGhlIGxhc3QgcmVuZGVyZWQgY29sdW1uXG4gICAgICovXG4gICAgZ2V0RmluYWxWaXNhYmxlQ29sdW1uQm91bmRyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpc01heFggPSB0aGlzLmlzTGFzdENvbHVtblZpc2libGUoKTtcbiAgICAgICAgdmFyIGNob3AgPSBpc01heFggPyAyIDogMTtcbiAgICAgICAgdmFyIGNvbFdhbGwgPSB0aGlzLmdldENvbHVtbkVkZ2VzKClbdGhpcy5nZXRDb2x1bW5FZGdlcygpLmxlbmd0aCAtIGNob3BdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gTWF0aC5taW4oY29sV2FsbCwgdGhpcy5nZXRCb3VuZHMoKS53aWR0aCAtIDIwMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIHZpc2liaWxpdHkgb2YgYSByb3cuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gdGhlIHJvdyBpbmRleFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gcm93IGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICovXG4gICAgaXNSb3dWaXNpYmxlOiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICB2YXIgaXNWaXNpYmxlID0gdGhpcy52aXNpYmxlUm93cy5pbmRleE9mKHJvd0luZGV4KSAhPT0gLTE7XG4gICAgICAgIHJldHVybiBpc1Zpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIGlmIGEgY2VsbCBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IGNlbGwgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgY2VsbCBjb29yZGluYXRlKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY2VsbCBpcyBmdWxseSB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmlzU2VsZWN0ZWQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBtYWluIGZvcmtpbmcgb2YgdGhlIHJlbmRlcmVyaW5nIHRhc2suXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjIC0gW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAgICAgKi9cbiAgICByZW5kZXJHcmlkOiBmdW5jdGlvbihnYykge1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcblxuICAgICAgICB0aGlzLnBhaW50Q2VsbHMoZ2MpO1xuICAgICAgICB0aGlzLnBhaW50R3JpZGxpbmVzKGdjKTtcbiAgICAgICAgLy90aGlzLmJsYW5rT3V0T3ZlcmZsb3coZ2MpOyAvLyBubyBsb25nZXIgbmVlZGVkXG4gICAgICAgIHRoaXMucmVuZGVyT3ZlcnJpZGVzKGdjKTtcbiAgICAgICAgdGhpcy5yZW5kZXJGb2N1c0NlbGwoZ2MpO1xuICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgZm9jdXNMaW5lU3RlcDogW1xuICAgICAgICBbNSwgNV0sXG4gICAgICAgIFswLCAxLCA1LCA0XSxcbiAgICAgICAgWzAsIDIsIDUsIDNdLFxuICAgICAgICBbMCwgMywgNSwgMl0sXG4gICAgICAgIFswLCA0LCA1LCAxXSxcbiAgICAgICAgWzAsIDUsIDUsIDBdLFxuICAgICAgICBbMSwgNSwgNCwgMF0sXG4gICAgICAgIFsyLCA1LCAzLCAwXSxcbiAgICAgICAgWzMsIDUsIDIsIDBdLFxuICAgICAgICBbNCwgNSwgMSwgMF1cbiAgICBdLFxuXG4gICAgcmVuZGVyRm9jdXNDZWxsOiBmdW5jdGlvbihnYykge1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyRm9jdXNDZWxsKGdjKTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJGb2N1c0NlbGw6IGZ1bmN0aW9uKGdjKSB7XG5cbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdldEdyaWQoKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSBncmlkLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbnMgfHwgc2VsZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1tzZWxlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbW91c2VEb3duID0gc2VsZWN0aW9uLm9yaWdpbjtcbiAgICAgICAgaWYgKG1vdXNlRG93bi54ID09PSAtMSkge1xuICAgICAgICAgICAgLy9ubyBzZWxlY3RlZCBhcmVhLCBsZXRzIGV4aXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aXNpYmxlQ29sdW1ucyA9IHRoaXMuZ2V0VmlzaWJsZUNvbHVtbnMoKTtcbiAgICAgICAgdmFyIHZpc2libGVSb3dzID0gdGhpcy5nZXRWaXNpYmxlUm93cygpO1xuICAgICAgICB2YXIgbGFzdFZpc2libGVDb2x1bW4gPSB2aXNpYmxlQ29sdW1uc1t2aXNpYmxlQ29sdW1ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGxhc3RWaXNpYmxlUm93ID0gdmlzaWJsZVJvd3NbdmlzaWJsZVJvd3MubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgdmFyIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQ7XG5cbiAgICAgICAgdmFyIGRwT1ggPSBNYXRoLm1pbihtb3VzZURvd24ueCwgbW91c2VEb3duLnggKyBleHRlbnQueCk7XG4gICAgICAgIHZhciBkcE9ZID0gTWF0aC5taW4obW91c2VEb3duLnksIG1vdXNlRG93bi55ICsgZXh0ZW50LnkpO1xuXG4gICAgICAgIC8vbGV0cyBjaGVjayBpZiBvdXIgc2VsZWN0aW9uIHJlY3RhbmdsZSBpcyBzY3JvbGxlZCBvdXRzaWRlIG9mIHRoZSB2aXNpYmxlIGFyZWFcbiAgICAgICAgaWYgKGRwT1ggPiBsYXN0VmlzaWJsZUNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuOyAvL3RoZSB0b3Agb2Ygb3VyIHJlY3RhbmdsZSBpcyBiZWxvdyB2aXNpYmxlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRwT1kgPiBsYXN0VmlzaWJsZVJvdykge1xuICAgICAgICAgICAgcmV0dXJuOyAvL3RoZSBsZWZ0IG9mIG91ciByZWN0YW5nbGUgaXMgdG8gdGhlIHJpZ2h0IG9mIGJlaW5nIHZpc2libGVcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcEVYID0gTWF0aC5tYXgobW91c2VEb3duLngsIG1vdXNlRG93bi54ICsgZXh0ZW50LngpICsgMTtcbiAgICAgICAgZHBFWCA9IE1hdGgubWluKGRwRVgsIDEgKyBsYXN0VmlzaWJsZUNvbHVtbik7XG5cbiAgICAgICAgdmFyIGRwRVkgPSBNYXRoLm1heChtb3VzZURvd24ueSwgbW91c2VEb3duLnkgKyBleHRlbnQueSkgKyAxO1xuICAgICAgICBkcEVZID0gTWF0aC5taW4oZHBFWSwgMSArIGxhc3RWaXNpYmxlUm93KTtcblxuICAgICAgICB2YXIgbyA9IHRoaXMuX2dldEJvdW5kc09mQ2VsbChkcE9YLCBkcE9ZKTtcbiAgICAgICAgdmFyIG94ID0gTWF0aC5yb3VuZCgoby54ID09PSB1bmRlZmluZWQpID8gZ3JpZC5nZXRGaXhlZENvbHVtbnNXaWR0aCgpIDogby54KTtcbiAgICAgICAgdmFyIG95ID0gTWF0aC5yb3VuZCgoby55ID09PSB1bmRlZmluZWQpID8gZ3JpZC5nZXRGaXhlZFJvd3NIZWlnaHQoKSA6IG8ueSk7XG4gICAgICAgIC8vIHZhciBvdyA9IG8ud2lkdGg7XG4gICAgICAgIC8vIHZhciBvaCA9IG8uaGVpZ2h0O1xuICAgICAgICB2YXIgZSA9IHRoaXMuX2dldEJvdW5kc09mQ2VsbChkcEVYLCBkcEVZKTtcbiAgICAgICAgdmFyIGV4ID0gTWF0aC5yb3VuZCgoZS54ID09PSB1bmRlZmluZWQpID8gZ3JpZC5nZXRGaXhlZENvbHVtbnNXaWR0aCgpIDogZS54KTtcbiAgICAgICAgdmFyIGV5ID0gTWF0aC5yb3VuZCgoZS55ID09PSB1bmRlZmluZWQpID8gZ3JpZC5nZXRGaXhlZFJvd3NIZWlnaHQoKSA6IGUueSk7XG4gICAgICAgIC8vIHZhciBldyA9IGUud2lkdGg7XG4gICAgICAgIC8vIHZhciBlaCA9IGUuaGVpZ2h0O1xuICAgICAgICB2YXIgeCA9IE1hdGgubWluKG94LCBleCk7XG4gICAgICAgIHZhciB5ID0gTWF0aC5taW4ob3ksIGV5KTtcbiAgICAgICAgdmFyIHdpZHRoID0gMSArIGV4IC0gb3g7XG4gICAgICAgIHZhciBoZWlnaHQgPSAxICsgZXkgLSBveTtcbiAgICAgICAgaWYgKHggPT09IGV4KSB7XG4gICAgICAgICAgICB3aWR0aCA9IG94IC0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPT09IGV5KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBveSAtIGV5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCAqIGhlaWdodCA8IDEpIHtcbiAgICAgICAgICAgIC8vaWYgd2UgYXJlIG9ubHkgYSBza2lubnkgbGluZSwgZG9uJ3QgcmVuZGVyIGFueXRoaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSAncmdiYSgwLCAwLCAwLCAwLjIpJztcbiAgICAgICAgZ2MuZmlsbCgpO1xuICAgICAgICBnYy5saW5lV2lkdGggPSAxO1xuICAgICAgICBnYy5zdHJva2VTdHlsZSA9ICdibGFjayc7XG5cbiAgICAgICAgLy8gYW5pbWF0ZSB0aGUgZGFzaGVkIGxpbmUgYSBiaXQgaGVyZSBmb3IgZnVuXG5cbiAgICAgICAgZ2Muc3Ryb2tlKCk7XG5cbiAgICAgICAgLy9nYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vZ2Muc3Ryb2tlU3R5bGUgPSAnd2hpdGUnO1xuXG4gICAgICAgIC8vIGFuaW1hdGUgdGhlIGRhc2hlZCBsaW5lIGEgYml0IGhlcmUgZm9yIGZ1blxuICAgICAgICAvL2djLnNldExpbmVEYXNoKHRoaXMuZm9jdXNMaW5lU3RlcFtNYXRoLmZsb29yKDEwICogKERhdGUubm93KCkgLyAzMDAgJSAxKSkgJSB0aGlzLmZvY3VzTGluZVN0ZXAubGVuZ3RoXSk7XG5cbiAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFBhaW50IHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG92ZXIgdGhlIG92ZXJmbG93IGZyb20gdGhlIGZpbmFsIGNvbHVtbiBwYWludFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnYyAtIFtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpXG4gICAgICovXG4gICAgYmxhbmtPdXRPdmVyZmxvdzogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgdmFyIGlzTWF4WCA9IHRoaXMuaXNMYXN0Q29sdW1uVmlzaWJsZSgpO1xuICAgICAgICB2YXIgY2hvcCA9IGlzTWF4WCA/IDEgOiAwO1xuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKVt0aGlzLmdldENvbHVtbkVkZ2VzKCkubGVuZ3RoIC0gY2hvcF07XG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgICB2YXIgd2lkdGggPSBib3VuZHMud2lkdGggLSAyMDAgLSB4O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2JhY2tncm91bmRDb2xvcjInKTtcbiAgICAgICAgZ2MuZmlsbFJlY3QoeCArIDEsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgaXRlcmF0ZSB0aGUgcmVuZGVyZXJpbmcgb3ZlcnJpZGVzIGFuZCBtYW5pZmVzdCBlYWNoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjIC0gW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAgICAgKi9cbiAgICByZW5kZXJPdmVycmlkZXM6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIHZhciBjYWNoZSA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGU7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgICAgICAgICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcnJpZGUgPSBjYWNoZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck92ZXJyaWRlKGdjLCBvdmVycmlkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjb3B5IGVhY2ggb3ZlcnJpZGVzIHNwZWNpZmllZCBhcmVhIHRvIGl0J3MgdGFyZ2V0IGFuZCBibGFuayBvdXQgdGhlIHNvdXJjZSBhcmVhXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjIC0gW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAgICAgKiBAcGFyYW0ge092ZXJyaWRlT2JqZWN0fSBvdmVycmlkZSAtIGFuIG9iamVjdCB3aXRoIGRldGFpbHMgY29udGFpbiBhbiBhcmVhIGFuZCBhIHRhcmdldCBjb250ZXh0XG4gICAgICovXG4gICAgcmVuZGVyT3ZlcnJpZGU6IGZ1bmN0aW9uKGdjLCBvdmVycmlkZSkge1xuICAgICAgICAvL2xldHMgYmxhbmsgb3V0IHRoZSBkcmFnIHJvd1xuICAgICAgICB2YXIgaGRwaVJhdGlvID0gb3ZlcnJpZGUuaGRwaXJhdGlvO1xuICAgICAgICAvL3ZhciBlZGdlcyA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgdmFyIHN0YXJ0WCA9IG92ZXJyaWRlLnN0YXJ0WDsgLy9oZHBpUmF0aW8gKiBlZGdlc1tvdmVycmlkZS5jb2x1bW5JbmRleF07XG4gICAgICAgIHZhciB3aWR0aCA9IG92ZXJyaWRlLndpZHRoICsgMTtcbiAgICAgICAgdmFyIGhlaWdodCA9IG92ZXJyaWRlLmhlaWdodDtcbiAgICAgICAgdmFyIHRhcmdldENUWCA9IG92ZXJyaWRlLmN0eDtcbiAgICAgICAgdmFyIGltZ0RhdGEgPSBnYy5nZXRJbWFnZURhdGEoc3RhcnRYLCAwLCBNYXRoLnJvdW5kKHdpZHRoICogaGRwaVJhdGlvKSwgTWF0aC5yb3VuZChoZWlnaHQgKiBoZHBpUmF0aW8pKTtcbiAgICAgICAgdGFyZ2V0Q1RYLnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2JhY2tncm91bmRDb2xvcjInKTtcbiAgICAgICAgZ2MuZmlsbFJlY3QoTWF0aC5yb3VuZChzdGFydFggLyBoZHBpUmF0aW8pLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBtb3VzZSBpcyBjdXJyZW50bHkgb3ZlciBjZWxsIHgsIHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlXG4gICAgICovXG4gICAgaXNIb3ZlcmVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5pc0hvdmVyZWQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gbW91c2UgaXMgY3VycmVudGx5IG92ZXIgcm93IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGlzUm93SG92ZXJlZDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuaXNSb3dIb3ZlcmVkKHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IG1vdXNlIGlzIGN1cnJlbnRseSBvdmVyIGNvbHVtbiB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBpc0NvbHVtbkhvdmVyZWQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmlzQ29sdW1uSG92ZXJlZCh4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNtYXJ0IHJlbmRlciB0aGUgbWFpbiBjZWxscy5cbiAgICAgKiBAZGVzYyBXZSBzbmFwc2hvdCB0aGUgY29udGV4dCB0byBpbnN1cmUgYWdhaW5zdCBpdHMgcG9sbHV0aW9uLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnYyAtIFtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpXG4gICAgICovXG4gICAgcGFpbnRDZWxsczogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdjLnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhaW50Q2VsbHMoZ2MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZ2MucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIGNvbHVtbiB3aXRoaW4gdGhlIGZpeGVkIHJvdyBhcmVhIGlzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkSW5Sb3c6IGZ1bmN0aW9uKGNvbEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5pc0NlbGxTZWxlY3RlZEluUm93KGNvbEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gcm93IHdpdGhpbiB0aGUgZml4ZWQgY29sdW1uIGFyZWEgaXMgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbjogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmlzQ2VsbFNlbGVjdGVkSW5Db2x1bW4ocm93SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ3VycmVudCB2ZXJ0aWNhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsVG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0ID0gdGhpcy5nZXRHcmlkKCkuZ2V0VlNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHJldHVybiBzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEN1cnJlbnQgaG9yaXpvbnRhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsTGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdCA9IHRoaXMuZ2V0R3JpZCgpLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7QmVoYXZpb3J9XG4gICAgICovXG4gICAgZ2V0QmVoYXZpb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0QmVoYXZpb3IoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uRWRnZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5FZGdlcztcbiAgICB9LFxuXG4gICAgZ2V0Um93RWRnZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dFZGdlcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IGhlaWdodCBvZiB0aGUgcm93IGF0IGluZGV4IHJvd0luZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4XG4gICAgICovXG4gICAgZ2V0Um93SGVpZ2h0OiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRCZWhhdmlvcigpLmdldFJvd0hlaWdodChyb3dJbmRleCk7XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY29sdW1uV2lkdGggb2YgdGhlIGNvbHVtbiBhdCBpbmRleCBjb2x1bW5JbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqL1xuICAgIGdldENvbHVtbldpZHRoOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldEdyaWQoKS5nZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCk7XG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgbGFzdCBjb2wgd2FzIHJlbmRlcmVkIChpcyB2aXNpYmxlKVxuICAgICAqL1xuICAgIGlzTGFzdENvbHVtblZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGFzdENvbHVtbkluZGV4ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpIC0gMTtcbiAgICAgICAgdmFyIGlzTWF4ID0gdGhpcy52aXNpYmxlQ29sdW1ucy5pbmRleE9mKGxhc3RDb2x1bW5JbmRleCkgIT09IC0xO1xuICAgICAgICByZXR1cm4gaXNNYXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVuZGVyZWQgY29sdW1uIHdpZHRoIGF0IGluZGV4XG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRXaWR0aDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uRWRnZXMoKVtpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVuZGVyZWQgcm93IGhlaWdodCBhdCBpbmRleFxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkSGVpZ2h0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dFZGdlc1tpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7ZmluLWNhbnZhc30gbXkgW2Zpbi1jYW52YXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9zdGV2ZXdpcnRzL2Zpbi1jYW52YXMpXG4gICAgICovXG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldENhbnZhcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFVzZXIgaXMgY3VycmVudGx5IGRyYWdnaW5nIGEgY29sdW1uIGZvciByZW9yZGVyaW5nLlxuICAgICAqL1xuICAgIGlzRHJhZ2dpbmdDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuaXNEcmFnZ2luZ0NvbHVtbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdyB0byBnb3RvIGZvciBhIHBhZ2UgdXAuXG4gICAgICovXG4gICAgZ2V0UGFnZVVwUm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5nZXRWaXNpYmxlU2Nyb2xsSGVpZ2h0KCk7XG4gICAgICAgIHZhciBoZWFkZXJSb3dzID0gdGhpcy5nZXRHcmlkKCkuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuICAgICAgICB2YXIgdG9wID0gdGhpcy5kYXRhV2luZG93Lm9yaWdpbi55IC0gaGVhZGVyUm93cztcbiAgICAgICAgdmFyIHNjYW5IZWlnaHQgPSAwO1xuICAgICAgICB3aGlsZSAoc2NhbkhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiB0b3AgPiAtMSkge1xuICAgICAgICAgICAgc2NhbkhlaWdodCA9IHNjYW5IZWlnaHQgKyBiZWhhdmlvci5nZXRSb3dIZWlnaHQodG9wKTtcbiAgICAgICAgICAgIHRvcC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3AgKyAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdyB0byBnb3RvIGZvciBhIHBhZ2UgZG93bi5cbiAgICAgKi9cbiAgICBnZXRQYWdlRG93blJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJSb3dzID0gdGhpcy5nZXRHcmlkKCkuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuICAgICAgICB2YXIgcm93TnVtID0gdGhpcy5kYXRhV2luZG93LmNvcm5lci55IC0gaGVhZGVyUm93cyAtIDE7XG4gICAgICAgIHJldHVybiByb3dOdW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cy5cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5nZXRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBoZWFkZXIgcm93cy5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBoZWFkZXIgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgRHVtYiByZW5kZXIgdGhlIGZpeGVkIGNvbHVtbnMgYWxvbmcgdGhlIGxlZnQgc2lkZS5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2MgLSBbQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKVxuICAgICAqL1xuICAgIF9wYWludENlbGxzOiBmdW5jdGlvbihnYykge1xuICAgICAgICB2YXIgeCwgeSwgYywgciA9IDA7XG5cbiAgICAgICAgdmFyIGNvbHVtbkVkZ2VzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgcm93RWRnZXMgPSB0aGlzLnJvd0VkZ2VzO1xuICAgICAgICB0aGlzLmJ1dHRvbkNlbGxzID0ge307XG4gICAgICAgIHZhciB2aXNpYmxlQ29scyA9IHRoaXMuZ2V0VmlzaWJsZUNvbHVtbnMoKTtcbiAgICAgICAgdmFyIHZpc2libGVSb3dzID0gdGhpcy5nZXRWaXNpYmxlUm93cygpO1xuXG4gICAgICAgIHZhciB3aWR0aCA9IGNvbHVtbkVkZ2VzW2NvbHVtbkVkZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcm93RWRnZXNbcm93RWRnZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgZ2MubW92ZVRvKDAsIDApO1xuICAgICAgICBnYy5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgZ2MuY2xpcCgpO1xuXG4gICAgICAgIHZhciBsb29wTGVuZ3RoID0gdmlzaWJsZUNvbHMubGVuZ3RoO1xuICAgICAgICB2YXIgbG9vcFN0YXJ0ID0gMDtcblxuICAgICAgICBpZiAodGhpcy5nZXRHcmlkKCkuaXNTaG93Um93TnVtYmVycygpKSB7XG4gICAgICAgICAgICAvL2xvb3BMZW5ndGgrKztcbiAgICAgICAgICAgIGxvb3BTdGFydC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh4ID0gbG9vcFN0YXJ0OyB4IDwgbG9vcExlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICBjID0gdmlzaWJsZUNvbHNbeF07XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzW2NdID0gMDtcbiAgICAgICAgICAgIGZvciAoeSA9IDA7IHkgPCB2aXNpYmxlUm93cy5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgICAgIHIgPSB2aXNpYmxlUm93c1t5XTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWludENlbGwoZ2MsIGMsIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0TnVtYmVyQ29sdW1uV2lkdGgoZ2MsIHRoaXMuZ2V0QmVoYXZpb3IoKSwgdGhpcy5nZXRHcmlkKCkuZ2V0Um93Q291bnQoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBXZSBvcHRlZCB0byBub3QgcGFpbnQgYm9yZGVycyBmb3IgZWFjaCBjZWxsIGFzIHRoYXQgd2FzIGV4dHJlbWVseSBleHBlbnNpdmUuIEluc3RlYWQgd2UgZHJhdyBncmlkbGluZXMgaGVyZS4gQWxzbyB3ZSByZWNvcmQgdGhlIHdpZHRocyBhbmQgaGVpZ2h0cyBmb3IgbGF0ZXIuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjIC0gW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAgICAgKi9cbiAgICBwYWludEdyaWRsaW5lczogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgdmFyIHgsIHksIGMsIHIgPSAwO1xuXG4gICAgICAgIHZhciBjb2xXaWR0aHMgPSB0aGlzLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIHZhciByb3dIZWlnaHRzID0gdGhpcy5yb3dFZGdlcztcblxuICAgICAgICB2YXIgdmlld1dpZHRoID0gY29sV2lkdGhzW2NvbFdpZHRocy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHZpZXdIZWlnaHQgPSByb3dIZWlnaHRzW3Jvd0hlaWdodHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgdmFyIGRyYXdUaGVtSCA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdncmlkTGluZXNIJyk7XG4gICAgICAgIHZhciBkcmF3VGhlbVYgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZ3JpZExpbmVzVicpO1xuICAgICAgICB2YXIgbGluZUNvbG9yID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2xpbmVDb2xvcicpO1xuXG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICBnYy5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcbiAgICAgICAgZ2MubGluZVdpZHRoID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2xpbmVXaWR0aCcpO1xuICAgICAgICBnYy5tb3ZlVG8oMCwgMCk7XG5cbiAgICAgICAgaWYgKGRyYXdUaGVtVikge1xuICAgICAgICAgICAgZm9yIChjID0gMDsgYyA8IGNvbFdpZHRocy5sZW5ndGggKyAxOyBjKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gY29sV2lkdGhzW2NdICsgMC41O1xuICAgICAgICAgICAgICAgIGdjLm1vdmVUbyh4LCAwKTtcbiAgICAgICAgICAgICAgICBnYy5saW5lVG8oeCwgdmlld0hlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhd1RoZW1IKSB7XG4gICAgICAgICAgICBmb3IgKHIgPSAwOyByIDwgcm93SGVpZ2h0cy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgIHkgPSByb3dIZWlnaHRzW3JdICsgMC41O1xuICAgICAgICAgICAgICAgIGdjLm1vdmVUbygwLCB5KTtcbiAgICAgICAgICAgICAgICBnYy5saW5lVG8odmlld1dpZHRoLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICovXG4gICAgcGFpbnRDZWxsOiBmdW5jdGlvbihnYywgeCwgeSkge1xuICAgICAgICBnYy5tb3ZlVG8oMCwgMCk7XG5cbiAgICAgICAgdmFyIGMgPSB0aGlzLmdldFZpc2libGVDb2x1bW5zKClbeF0sXG4gICAgICAgICAgICByID0gdGhpcy5nZXRWaXNpYmxlUm93cygpW3ldO1xuXG4gICAgICAgIGlmIChjKSB7IC8vc29tZXRoaW5nIGlzIGJlaW5nIHZpZXdlZCBhdCBhdCB0aGUgbW9tZW50IChvdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLl9wYWludENlbGwoZ2MsIGMsIHIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wYWludENlbGw6IGZ1bmN0aW9uKGdjLCBjLCByKSB7XG5cbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdldEdyaWQoKTtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICB2YXIgYmFzZVByb3BlcnRpZXMgPSBiZWhhdmlvci5nZXRDb2x1bW5Qcm9wZXJ0aWVzKGMpO1xuXG4gICAgICAgIGlmIChiYXNlUHJvcGVydGllcy5pc051bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2x1bW5Qcm9wZXJ0aWVzID0gYmFzZVByb3BlcnRpZXM7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IGJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIC8vdmFyIGhlYWRlckNvbHVtbkNvdW50ID0gYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcblxuICAgICAgICB2YXIgaXNTaG93Um93TnVtYmVycyA9IGdyaWQuaXNTaG93Um93TnVtYmVycygpO1xuICAgICAgICB2YXIgaXNIZWFkZXJSb3cgPSByIDwgaGVhZGVyUm93Q291bnQ7XG4gICAgICAgIC8vdmFyIGlzSGVhZGVyQ29sdW1uID0gYyA8IGhlYWRlckNvbHVtbkNvdW50O1xuICAgICAgICB2YXIgaXNGaWx0ZXJSb3cgPSBncmlkLmlzRmlsdGVyUm93KHIpO1xuICAgICAgICB2YXIgaXNIaWVyYXJjaHlDb2x1bW4gPSBncmlkLmlzSGllcmFyY2h5Q29sdW1uKGMpO1xuICAgICAgICB2YXIgaXNSb3dTZWxlY3RlZCA9IGdyaWQuaXNSb3dTZWxlY3RlZChyKTtcbiAgICAgICAgdmFyIGlzQ29sdW1uU2VsZWN0ZWQgPSBncmlkLmlzQ29sdW1uU2VsZWN0ZWQoYyk7XG4gICAgICAgIHZhciBpc0NlbGxTZWxlY3RlZCA9IGdyaWQuaXNDZWxsU2VsZWN0ZWQoYywgcik7XG4gICAgICAgIHZhciBpc0NlbGxTZWxlY3RlZEluQ29sdW1uID0gZ3JpZC5pc0NlbGxTZWxlY3RlZEluQ29sdW1uKGMpO1xuICAgICAgICB2YXIgaXNDZWxsU2VsZWN0ZWRJblJvdyA9IGdyaWQuaXNDZWxsU2VsZWN0ZWRJblJvdyhyKTtcbiAgICAgICAgdmFyIGFyZUFsbFJvd3NTZWxlY3RlZCA9IGdyaWQuYXJlQWxsUm93c1NlbGVjdGVkKCk7XG5cbiAgICAgICAgdmFyIGNlbGxQcm9wZXJ0aWVzO1xuXG4gICAgICAgIGlmICgoaXNTaG93Um93TnVtYmVycyAmJiBjID09PSAtMSkgfHwgaXNIaWVyYXJjaHlDb2x1bW4pIHtcbiAgICAgICAgICAgIGlmIChpc1Jvd1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgYmFzZVByb3BlcnRpZXMgPSBiYXNlUHJvcGVydGllcy5yb3dIZWFkZXJSb3dTZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFzZVByb3BlcnRpZXMgPSBiYXNlUHJvcGVydGllcy5yb3dIZWFkZXI7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1NlbGVjdGVkID0gaXNDZWxsU2VsZWN0ZWRJblJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzVXNlckRhdGFBcmVhID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNIZWFkZXJSb3cpIHtcbiAgICAgICAgICAgIGlmIChpc0ZpbHRlclJvdykge1xuICAgICAgICAgICAgICAgIGJhc2VQcm9wZXJ0aWVzID0gYmFzZVByb3BlcnRpZXMuZmlsdGVyUHJvcGVydGllcztcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDb2x1bW5TZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGJhc2VQcm9wZXJ0aWVzID0gYmFzZVByb3BlcnRpZXMuY29sdW1uSGVhZGVyQ29sdW1uU2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhc2VQcm9wZXJ0aWVzID0gYmFzZVByb3BlcnRpZXMuY29sdW1uSGVhZGVyO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IGlzQ2VsbFNlbGVjdGVkSW5Db2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1VzZXJEYXRhQXJlYSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzSGllcmFyY2h5Q29sdW1uKSB7XG4gICAgICAgICAgICBiYXNlUHJvcGVydGllcyA9IGJhc2VQcm9wZXJ0aWVzLnJvd0hlYWRlcjtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcyk7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1NlbGVjdGVkID0gaXNDZWxsU2VsZWN0ZWRJblJvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcyk7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1NlbGVjdGVkID0gaXNDZWxsU2VsZWN0ZWQgfHwgaXNSb3dTZWxlY3RlZCB8fCBpc0NvbHVtblNlbGVjdGVkO1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNVc2VyRGF0YUFyZWEgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvd051bSA9IHIgLSBoZWFkZXJSb3dDb3VudCArIDE7XG5cbiAgICAgICAgaWYgKGMgPT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2tlZEltYWdlID0gaXNSb3dTZWxlY3RlZCA/ICdjaGVja2VkJyA6ICd1bmNoZWNrZWQnO1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMudmFsdWUgPSBpc0hlYWRlclJvdyA/ICcnIDogW2JlaGF2aW9yLmdldEltYWdlKGNoZWNrZWRJbWFnZSksIHJvd051bSwgbnVsbF07XG4gICAgICAgICAgICBpZiAociA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNoZWNrZWRJbWFnZSA9IGFyZUFsbFJvd3NTZWxlY3RlZCA/ICdjaGVja2VkJyA6ICd1bmNoZWNrZWQnO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLnZhbHVlID0gW2JlaGF2aW9yLmdldEltYWdlKGNoZWNrZWRJbWFnZSksICcnLCBudWxsXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGaWx0ZXJSb3cpIHtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcy52YWx1ZSA9IFtiZWhhdmlvci5nZXRJbWFnZSgnZmlsdGVyLW9mZicpLCAnJywgbnVsbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5oYWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMudmFsdWUgPSBncmlkLmdldFZhbHVlKGMsIHIpO1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaGFsaWduID0gZ3JpZC5nZXRDb2x1bW5BbGlnbm1lbnQoYyk7XG4gICAgICAgIH1cbiAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNDb2x1bW5Ib3ZlcmVkID0gdGhpcy5pc1Jvd0hvdmVyZWQoYywgcik7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzUm93SG92ZXJlZCA9IHRoaXMuaXNDb2x1bW5Ib3ZlcmVkKGMsIHIpO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5ib3VuZHMgPSB0aGlzLl9nZXRCb3VuZHNPZkNlbGwoYywgcik7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzQ2VsbFNlbGVjdGVkID0gaXNDZWxsU2VsZWN0ZWQ7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzUm93U2VsZWN0ZWQgPSBpc1Jvd1NlbGVjdGVkO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5pc0NvbHVtblNlbGVjdGVkID0gaXNDb2x1bW5TZWxlY3RlZDtcbiAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNJbkN1cnJlbnRTZWxlY3Rpb25SZWN0YW5nbGUgPSBncmlkLmlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlKGMsIHIpO1xuXG4gICAgICAgIHZhciBtb3VzZURvd25TdGF0ZSA9IGdyaWQubW91c2VEb3duU3RhdGU7XG4gICAgICAgIGlmIChtb3VzZURvd25TdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gbW91c2VEb3duU3RhdGUuZ3JpZENlbGw7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5tb3VzZURvd24gPSBwb2ludC54ID09PSBjICYmIHBvaW50LnkgPT09IHI7XG4gICAgICAgIH1cblxuICAgICAgICBjZWxsUHJvcGVydGllcy54ID0gYztcbiAgICAgICAgY2VsbFByb3BlcnRpZXMueSA9IHI7XG5cbiAgICAgICAgYmVoYXZpb3IuY2VsbFByb3BlcnRpZXNQcmVQYWludE5vdGlmaWNhdGlvbihjZWxsUHJvcGVydGllcyk7XG5cbiAgICAgICAgdmFyIGNlbGwgPSBiZWhhdmlvci5nZXRDZWxsUmVuZGVyZXIoY2VsbFByb3BlcnRpZXMsIGMsIHIpO1xuICAgICAgICB2YXIgb3ZlcnJpZGVzID0gYmVoYXZpb3IuZ2V0Q2VsbFByb3BlcnRpZXMoYywgcik7XG5cbiAgICAgICAgLy9kZWNsYXJhdGl2ZSBjZWxsIHByb3BlcnRpZXNcbiAgICAgICAgXyhjZWxsUHJvcGVydGllcykuZXh0ZW5kT3duKG92ZXJyaWRlcyk7XG5cbiAgICAgICAgLy9hbGxvdyB0aGUgcmVuZGVyZXIgdG8gaWRlbnRpZnkgaXRzZWxmIGlmIGl0J3MgYSBidXR0b25cbiAgICAgICAgY2VsbFByb3BlcnRpZXMuYnV0dG9uQ2VsbHMgPSB0aGlzLmJ1dHRvbkNlbGxzO1xuXG4gICAgICAgIGNlbGwucGFpbnQoZ2MsIGNlbGxQcm9wZXJ0aWVzKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzW2NdID0gTWF0aC5tYXgoY2VsbFByb3BlcnRpZXMubWluV2lkdGggfHwgMCwgdGhpcy5yZW5kZXJlZENvbHVtbk1pbldpZHRoc1tjXSk7XG4gICAgICAgIGNvbHVtblByb3BlcnRpZXMucHJlZmVycmVkV2lkdGggPSB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzW2NdO1xuICAgIH0sXG5cbiAgICBpc1ZpZXdhYmxlQnV0dG9uOiBmdW5jdGlvbihjLCByKSB7XG4gICAgICAgIHZhciBrZXkgPSBjICsgJywnICsgcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnV0dG9uQ2VsbHNba2V5XSA9PT0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZ2V0Um93TnVtYmVyc1dpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbEVkZ2VzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICBpZiAoY29sRWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sRWRnZXNbMF07XG4gICAgfSxcblxuICAgIHN0YXJ0QW5pbWF0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYW5pbWF0ZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBhbmltYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmFuaW1hdGUoKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIH0sXG5cbiAgICBhbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0Q2FudmFzKCkuY2FudmFzQ1RYO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyRm9jdXNDZWxsKGN0eCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzO1xuICAgIH0sXG5cbiAgICBzZXRCb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcykge1xuICAgICAgICByZXR1cm4gKHRoaXMuYm91bmRzID0gYm91bmRzKTtcbiAgICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBzZXROdW1iZXJDb2x1bW5XaWR0aChnYywgYmVoYXZpb3IsIG1heFJvdykge1xuICAgIHZhciBjb2x1bW5Qcm9wZXJ0aWVzID0gYmVoYXZpb3IuZ2V0Q29sdW1uUHJvcGVydGllcygtMSksXG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gY29sdW1uUHJvcGVydGllcy5yb3dIZWFkZXIsXG4gICAgICAgIGljb24gPSBiZWhhdmlvci5nZXRJbWFnZSgnY2hlY2tlZCcpO1xuXG4gICAgZ2MuZm9udCA9IGNlbGxQcm9wZXJ0aWVzLmZvbnQ7XG5cbiAgICBjb2x1bW5Qcm9wZXJ0aWVzLnByZWZlcnJlZFdpZHRoID0gaWNvbi53aWR0aCArIDcgKyBjZWxsUHJvcGVydGllcy5nZXRUZXh0V2lkdGgoZ2MsIG1heFJvdyArIDEpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmFuZ2VTZWxlY3Rpb25Nb2RlbCA9IHJlcXVpcmUoJ3NwYXJzZS1ib29sZWFuLWFycmF5Jyk7XG5cbi8qKlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgV2UgcmVwcmVzZW50IHNlbGVjdGlvbnMgYXMgYSBsaXN0IG9mIHJlY3RhbmdsZXMgYmVjYXVzZSBsYXJnZSBhcmVhcyBjYW4gYmUgcmVwcmVzZW50ZWQgYW5kIHRlc3RlZCBhZ2FpbnN0IHF1aWNrbHkgd2l0aCBhIG1pbmltYWwgYW1vdW50IG9mIG1lbW9yeSB1c2FnZS4gQWxzbyB3ZSBuZWVkIHRvIG1haW50YWluIHRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcyBmbGF0dGVuZWQgY291bnRlciBwYXJ0cyBzbyB3ZSBjYW4gdGVzdCBmb3Igc2luZ2xlIGRpbWVuc2lvbiBjb250YWlucy4gVGhpcyBpcyBob3cgd2Uga25vdyB0byBoaWdobGlnaHQgdGhlIGZpeGVkIHJlZ2lvbnMgb24gdGhlIGVkZ2VzIG9mIHRoZSBncmlkLlxuICovXG5cbmZ1bmN0aW9uIFNlbGVjdGlvbk1vZGVsKCkge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc2VsZWN0aW9uc1xuICAgICAqIEB0eXBlIHtSZWN0YW5nbGVbXX1cbiAgICAgKiBAc3VtbWFyeSBUaGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMuXG4gICAgICogQGRlc2MgQ3JlYXRlZCBhcyBhbiBlbXB0eSBhcnJheSB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRoaXMuc2VsZWN0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgZmxhdHRlbmVkWFxuICAgICAqIEB0eXBlIHtSZWN0YW5nbGVbXX1cbiAgICAgKiBAc3VtbWFyeSBUaGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMgZmxhdHRlbmVkIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbiAobm8gd2lkdGgpLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYW4gZW1wdHkgYXJyYXkgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLmZsYXR0ZW5lZFggPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGZsYXR0ZW5lZFlcbiAgICAgKiBAdHlwZSB7UmVjdGFuZ2xlW119XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzIGZsYXR0ZW5lZCBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uIChubyBoZWlnaHQpLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYW4gZW1wdHkgYXJyYXkgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLmZsYXR0ZW5lZFkgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHJvd1NlbGVjdGlvbk1vZGVsXG4gICAgICogQHR5cGUge1JhbmdlU2VsZWN0aW9uTW9kZWx9XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwgPSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCgpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgY29sdW1uU2VsZWN0aW9uTW9kZWxcbiAgICAgKiBAdHlwZSB7UmFuZ2VTZWxlY3Rpb25Nb2RlbH1cbiAgICAgKiBAc3VtbWFyeSBUaGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMuXG4gICAgICogQGRlc2MgQ3JlYXRlZCBhcyBhIG5ldyBSYW5nZVNlbGVjdGlvbk1vZGVsIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbCA9IG5ldyBSYW5nZVNlbGVjdGlvbk1vZGVsKCk7XG5cbiAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCcnKTtcbn1cblxuU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFsbFJvd3NTZWxlY3RlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0dGVyIGZvciB0aGUgW2Zpbi1oeXBlcmdyaWRdKG1vZHVsZS0uX2Zpbi1oeXBlcmdyaWQuaHRtbClcbiAgICAgKiAjIyMjIHJldHVybnM6IGZpbi1oeXBlcmdyaWRcbiAgICAgKi9cbiAgICBnZXRHcmlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRMYXN0U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbHMgPSB0aGlzLnNlbGVjdGlvbnM7XG4gICAgICAgIHZhciBzZWwgPSBzZWxzW3NlbHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBzZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRMYXN0U2VsZWN0aW9uVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RTZWxlY3Rpb25UeXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdHlwZVxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRMYXN0U2VsZWN0aW9uVHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UeXBlID0gdHlwZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZWxlY3QgdGhlIHJlZ2lvbiBkZXNjcmliZWQgYnkgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG94IC0gb3JpZ2luIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV5IC0gZXh0ZW50IHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIHNlbGVjdDogZnVuY3Rpb24ob3gsIG95LCBleCwgZXkpIHtcbiAgICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZ2V0R3JpZCgpLm5ld1JlY3RhbmdsZShveCwgb3ksIGV4LCBleSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5wdXNoKG5ld1NlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuZmxhdHRlbmVkWC5wdXNoKG5ld1NlbGVjdGlvbi5mbGF0dGVuWEF0KDApKTtcbiAgICAgICAgdGhpcy5mbGF0dGVuZWRZLnB1c2gobmV3U2VsZWN0aW9uLmZsYXR0ZW5ZQXQoMCkpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdjZWxsJyk7XG4gICAgICAgIHRoaXMuZ2V0R3JpZCgpLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveCAtIG9yaWdpbiB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3kgLSBvcmlnaW4geSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleSAtIGV4dGVudCB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICB0b2dnbGVTZWxlY3Q6IGZ1bmN0aW9uKG94LCBveSwgZXgsIGV5KSB7XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkLCBpbmRleDtcblxuICAgICAgICBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0aW9ucy5maW5kKGZ1bmN0aW9uKHNlbGVjdGlvbiwgaWR4KSB7XG4gICAgICAgICAgICBpbmRleCA9IGlkeDtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLm9yaWdpbi54ID09PSBveCAmJiBzZWxlY3Rpb24ub3JpZ2luLnkgPT09IG95ICYmXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmV4dGVudC54ID09PSBleCAmJiBzZWxlY3Rpb24uZXh0ZW50LnkgPT09IGV5XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5mbGF0dGVuZWRYLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5lZFkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0R3JpZCgpLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG94LCBveSwgZXgsIGV5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVtb3ZlIHRoZSBsYXN0IHNlbGVjdGlvbiB0aGF0IHdhcyBjcmVhdGVkLlxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYWxsUm93c1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5sZW5ndGggPSBNYXRoLm1heCgwLCB0aGlzLnNlbGVjdGlvbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuZmxhdHRlbmVkWC5sZW5ndGggPSBNYXRoLm1heCgwLCB0aGlzLmZsYXR0ZW5lZFgubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuZmxhdHRlbmVkWS5sZW5ndGggPSBNYXRoLm1heCgwLCB0aGlzLmZsYXR0ZW5lZFkubGVuZ3RoIC0gMSk7XG4gICAgICAgIC8vdGhpcy5nZXRHcmlkKCkuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY29sdW1uJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdyb3cnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyUm93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5jbGVhcigpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdyb3cnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZXJlIGFyZSBhY3RpdmUgc2VsZWN0aW9uKHMpLlxuICAgICAqL1xuICAgIGhhc1NlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25zLmxlbmd0aCAhPT0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1Jvd1NlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucm93U2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzQ29sdW1uU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBTZWxlY3Rpb24gY292ZXJzIGEgc3BlY2lmaWMgY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWRJblJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDZWxsU2VsZWN0ZWQodGhpcy5mbGF0dGVuZWRYLCAwLCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIFNlbGVjdGlvbiBjb3ZlcnMgYSBzcGVjaWZpYyByb3cuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluQ29sdW1uOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NlbGxTZWxlY3RlZCh0aGlzLmZsYXR0ZW5lZFksIHgsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2VsZWN0aW9uIHF1ZXJ5IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY2VsbCBpcyBzZWxlY3RlZCAocGFydCBvZiBhbiBhY3RpdmUgc2VsZWN0aW9uKS5cbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZVtdfSBzZWxlY3Rpb25zIC0gU2VsZWN0aW9uIHJlY3RhbmdsZXMgdG8gc2VhcmNoIHRocm91Z2guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNDb2x1bW5TZWxlY3RlZCh4KSB8fFxuICAgICAgICAgICAgdGhpcy5pc1Jvd1NlbGVjdGVkKHkpIHx8XG4gICAgICAgICAgICB0aGlzLl9pc0NlbGxTZWxlY3RlZCh0aGlzLnNlbGVjdGlvbnMsIHgsIHkpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2VsbFNlbGVjdGVkKHRoaXMuc2VsZWN0aW9ucywgeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0NlbGxTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0aW9ucywgeCwgeSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAhIXNlbGVjdGlvbnMuZmluZChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnJlY3RhbmdsZUNvbnRhaW5zKHNlbGVjdGlvbiwgeCwgeSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQGRlc2MgZW1wdHkgb3V0IGFsbCBvdXIgc3RhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5hbGxSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZmxhdHRlbmVkWC5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFkubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5jbGVhcigpO1xuICAgICAgICB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICAgIC8vdGhpcy5nZXRHcmlkKCkuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG94IC0gb3JpZ2luIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV5IC0gZXh0ZW50IHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUmVjdGFuZ2xlU2VsZWN0ZWQ6IGZ1bmN0aW9uKG94LCBveSwgZXgsIGV5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc2VsZWN0aW9ucy5maW5kKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ub3JpZ2luLnggPT09IG94ICYmIHNlbGVjdGlvbi5vcmlnaW4ueSA9PT0gb3kgJiZcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZXh0ZW50LnggPT09IGV4ICYmIHNlbGVjdGlvbi5leHRlbnQueSA9PT0gZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpc0NvbHVtblNlbGVjdGVkOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQoeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufCp9XG4gICAgICovXG4gICAgaXNSb3dTZWxlY3RlZDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxSb3dzU2VsZWN0ZWQgfHwgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHgxXG4gICAgICogQHBhcmFtIHgyXG4gICAgICovXG4gICAgc2VsZWN0Q29sdW1uOiBmdW5jdGlvbih4MSwgeDIpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5zZWxlY3QoeDEsIHgyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY29sdW1uJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZWxlY3RBbGxSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmFsbFJvd3NTZWxlY3RlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBhcmVBbGxSb3dzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxSb3dzU2VsZWN0ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geTFcbiAgICAgKiBAcGFyYW0geTJcbiAgICAgKi9cbiAgICBzZWxlY3RSb3c6IGZ1bmN0aW9uKHkxLCB5Mikge1xuICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLnNlbGVjdCh5MSwgeTIpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdyb3cnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4MVxuICAgICAqIEBwYXJhbSB4MlxuICAgICAqL1xuICAgIGRlc2VsZWN0Q29sdW1uOiBmdW5jdGlvbih4MSwgeDIpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdCh4MSwgeDIpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdjb2x1bW4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5MVxuICAgICAqIEBwYXJhbSB5MlxuICAgICAqL1xuICAgIGRlc2VsZWN0Um93OiBmdW5jdGlvbih5MSwgeTIpIHtcbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdCh5MSwgeTIpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdyb3cnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFyZUFsbFJvd3NTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpO1xuICAgICAgICAgICAgdmFyIGhlYWRlclJvd3MgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgICAgICB2YXIgcm93Q291bnQgPSBncmlkLmdldFJvd0NvdW50KCkgLSBoZWFkZXJSb3dzO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBpICsgaGVhZGVyUm93cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp8QXJyYXkuQXJyYXkubnVtYmVyfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgICBpc0NvbHVtbk9yUm93U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpIHx8ICF0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRGbGF0dGVuZWRZczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHNldCA9IHt9O1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSBzZWxlY3Rpb24ub3JpZ2luLnk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHNlbGVjdGlvbi5leHRlbnQueSArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHNpemU7IHIrKykge1xuICAgICAgICAgICAgICAgIHZhciB0aSA9IHIgKyB0b3A7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXRbdGldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRpKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0W3RpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LnNvcnQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggLSB5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKi9cbiAgICBzZWxlY3RSb3dzRnJvbUNlbGxzOiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgICAgdmFyIHNtID0gdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgdGhpcy5hbGxSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgc20uY2xlYXIoKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSBzZWxlY3Rpb24ub3JpZ2luLnksXG4gICAgICAgICAgICAgICAgc2l6ZSA9IHNlbGVjdGlvbi5leHRlbnQueTtcbiAgICAgICAgICAgIHNtLnNlbGVjdCh0b3AgKyBvZmZzZXQsIHRvcCArIHNpemUgKyBvZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKi9cbiAgICBzZWxlY3RDb2x1bW5zRnJvbUNlbGxzOiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgICAgdmFyIHNtID0gdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgc20uY2xlYXIoKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gc2VsZWN0aW9uLm9yaWdpbi54O1xuICAgICAgICAgICAgdmFyIHNpemUgPSBzZWxlY3Rpb24uZXh0ZW50Lng7XG4gICAgICAgICAgICBzbS5zZWxlY3QobGVmdCArIG9mZnNldCwgbGVmdCArIHNpemUgKyBvZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgbGFzdCA9IHRoaXMuc2VsZWN0aW9uc1t0aGlzLnNlbGVjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBsYXN0ICYmIHRoaXMucmVjdGFuZ2xlQ29udGFpbnMobGFzdCwgeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gcmVjdFxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICByZWN0YW5nbGVDb250YWluczogZnVuY3Rpb24ocmVjdCwgeCwgeSkgeyAvL1RPRE86IGV4cGxvcmUgd2h5IHRoaXMgd29ya3MgYW5kIGNvbnRhaW5zIG9uIHJlY3RhbmdsdWxhciBkb2VzIG5vdFxuICAgICAgICB2YXIgbWluWCA9IHJlY3Qub3JpZ2luLng7XG4gICAgICAgIHZhciBtaW5ZID0gcmVjdC5vcmlnaW4ueTtcbiAgICAgICAgdmFyIG1heFggPSBtaW5YICsgcmVjdC5leHRlbnQueDtcbiAgICAgICAgdmFyIG1heFkgPSBtaW5ZICsgcmVjdC5leHRlbnQueTtcblxuICAgICAgICBpZiAocmVjdC5leHRlbnQueCA8IDApIHtcbiAgICAgICAgICAgIG1pblggPSBtYXhYO1xuICAgICAgICAgICAgbWF4WCA9IHJlY3Qub3JpZ2luLng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjdC5leHRlbnQueSA8IDApIHtcbiAgICAgICAgICAgIG1pblkgPSBtYXhZO1xuICAgICAgICAgICAgbWF4WSA9IHJlY3Qub3JpZ2luLnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID1cbiAgICAgICAgICAgIHggPj0gbWluWCAmJlxuICAgICAgICAgICAgeSA+PSBtaW5ZICYmXG4gICAgICAgICAgICB4IDw9IG1heFggJiZcbiAgICAgICAgICAgIHkgPD0gbWF4WTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0aW9uTW9kZWw7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnZXh0ZW5kLW1lJykuQmFzZTtcblxudmFyIENvbHVtbiA9IHJlcXVpcmUoJy4vQ29sdW1uJyk7XG52YXIgaW1hZ2VzID0gcmVxdWlyZSgnLi9pbWFnZXMnKTtcbnZhciBDZWxsUHJvdmlkZXIgPSByZXF1aXJlKCcuLi9DZWxsUHJvdmlkZXInKTtcblxudmFyIG5vRXhwb3J0UHJvcGVydGllcyA9IFtcbiAgICAnY29sdW1uSGVhZGVyJyxcbiAgICAnY29sdW1uSGVhZGVyQ29sdW1uU2VsZWN0aW9uJyxcbiAgICAnZmlsdGVyUHJvcGVydGllcycsXG4gICAgJ3Jvd0hlYWRlcicsXG4gICAgJ3Jvd0hlYWRlclJvd1NlbGVjdGlvbicsXG4gICAgJ3Jvd051bWJlcnNQcm9wZXJ0aWVzJyxcbiAgICAndHJlZUNvbHVtblByb3BlcnRpZXMnLFxuICAgICd0cmVlQ29sdW1uUHJvcGVydGllc0NvbHVtblNlbGVjdGlvbicsXG5dO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgY3JlYXRpbmcgYmVoYXZpb3JzLiAgYSBiZWhhdmlvciBjYW4gYmUgdGhvdWdodCBvZiBhcyBhIG1vZGVsKysuXG5pdCBjb250YWlucyBhbGwgY29kZS9kYXRhIHRoYXQncyBuZWNlc3NhcnkgZm9yIGVhc2lseSBpbXBsZW1lbnRpbmcgYSB2aXJ0dWFsIGRhdGEgc291cmNlIGFuZCBpdCdzIG1hbmlwdWxhdGlvbi9hbmFseXRpY3NcbiAqL1xudmFyIEJlaGF2aW9yID0gQmFzZS5leHRlbmQoJ0JlaGF2aW9yJywge1xuXG4gICAgLyoqXG4gICAgICogQGRlc2MgdGhpcyBpcyB0aGUgY2FsbGJhY2sgZm9yIHRoZSBwbHVnaW4gcGF0dGVybiBvZiBuZXN0ZWQgdGFnc1xuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQpIHsgLy9mb3JtZXJseSBpbnN0YWxsT25cbiAgICAgICAgZ3JpZC5zZXRCZWhhdmlvcih0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplRmVhdHVyZUNoYWluKGdyaWQpO1xuXG4gICAgICAgIHRoaXMuZ2V0RGF0YU1vZGVsKCk7XG4gICAgICAgIHRoaXMuY2VsbFByb3ZpZGVyID0gdGhpcy5jcmVhdGVDZWxsUHJvdmlkZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbkNvdW50ID0gMzA7XG4gICAgICAgIHRoaXMucmVuZGVyZWRSb3dDb3VudCA9IDYwO1xuICAgICAgICB0aGlzLmRhdGFVcGRhdGVzID0ge307IC8vZm9yIG92ZXJyaWRpbmcgd2l0aCBlZGl0IHZhbHVlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgY3JlYXRlIHRoZSBmZWF0dXJlIGNoYWluIC0gdGhpcyBpcyB0aGUgW2NoYWluIG9mIHJlc3BvbnNpYmlsaXR5XShodHRwOi8vYzIuY29tL2NnaS93aWtpP0NoYWluT2ZSZXNwb25zaWJpbGl0eVBhdHRlcm4pIHBhdHRlcm4uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZUZlYXR1cmVDaGFpbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbihGZWF0dXJlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0TmV4dEZlYXR1cmUobmV3IEZlYXR1cmVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmluaXRpYWxpemVPbihncmlkKTtcbiAgICB9LFxuXG4gICAgZmVhdHVyZXM6IFtdLCAvLyBpbiBjYXNlIGltcGxlbWVudGluZyBjbGFzcyBoYXMgbm8gZmVhdHVyZXMgVE9ETzogV2lsbCB0aGlzIGV2ZXIgaGFwcGVuP1xuXG4gICAgLyoqXG4gICAgICogbWVtZW50byBmb3IgdGhlIHVzZXIgY29uZmlndXJlZCB2aXN1YWwgcHJvcGVydGllcyBvZiB0aGUgdGFibGVcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0YWJsZVN0YXRlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0h5cGVyZ3JpZH1cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZ3JpZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGxpc3Qgb2YgZGVmYXVsdCBjZWxsIGVkaXRvciBuYW1lc1xuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZWRpdG9yVHlwZXM6IFsnY2hvaWNlJywgJ3RleHRmaWVsZCcsICdjb2xvcicsICdzbGlkZXInLCAnc3Bpbm5lcicsICdkYXRlJ10sXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyIGNoYWluIG9mIGNvbW1hbmRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmZWF0dXJlQ2hhaW46IG51bGwsXG5cbiAgICBkYXRhTW9kZWw6IG51bGwsXG4gICAgYmFzZU1vZGVsOiBudWxsLFxuXG4gICAgc2Nyb2xsUG9zaXRpb25YOiAwLFxuICAgIHNjcm9sbFBvc2l0aW9uWTogMCxcblxuICAgIGZlYXR1cmVNYXA6IHt9LFxuICAgIGFsbENvbHVtbnM6IFtdLFxuICAgIGNvbHVtbnM6IFtdLFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuY2VsbFByb3ZpZGVyID0gdGhpcy5jcmVhdGVDZWxsUHJvdmlkZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbkNvdW50ID0gMzA7XG4gICAgICAgIHRoaXMucmVuZGVyZWRSb3dDb3VudCA9IDYwO1xuICAgICAgICB0aGlzLmRhdGFVcGRhdGVzID0ge307IC8vZm9yIG92ZXJyaWRpbmcgd2l0aCBlZGl0IHZhbHVlcztcbiAgICAgICAgdGhpcy5jbGVhckNvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jbGVhclN0YXRlKCk7XG4gICAgICAgIHRoaXMuZ2V0RGF0YU1vZGVsKCkucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIGNsZWFyQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2x1bW5zWy0xXSA9IHRoaXMubmV3Q29sdW1uKC0xLCAnJyk7XG4gICAgICAgIHRoaXMuY29sdW1uc1stMl0gPSB0aGlzLm5ld0NvbHVtbigtMiwgJ1RyZWUnKTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zWy0xXSA9IHRoaXMuY29sdW1uc1stMV07XG4gICAgICAgIHRoaXMuYWxsQ29sdW1uc1stMl0gPSB0aGlzLmNvbHVtbnNbLTJdO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc1t4XTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uSWQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uKHgpLmxhYmVsO1xuICAgIH0sXG5cbiAgICBuZXdDb2x1bW46IGZ1bmN0aW9uKGluZGV4LCBsYWJlbCkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuY3JlYXRlQ29sdW1uUHJvcGVydGllcygpO1xuICAgICAgICB0aGlzLmdldFByaXZhdGVTdGF0ZSgpLmNvbHVtblByb3BlcnRpZXNbaW5kZXhdID0gcHJvcGVydGllcztcbiAgICAgICAgcmV0dXJuIG5ldyBDb2x1bW4odGhpcywgaW5kZXgsIGxhYmVsKTtcbiAgICB9LFxuXG4gICAgYWRkQ29sdW1uOiBmdW5jdGlvbihpbmRleCwgbGFiZWwpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubmV3Q29sdW1uKGluZGV4LCBsYWJlbCk7XG4gICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgfSxcblxuICAgIGNyZWF0ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2NvbmNyZXRlIGltcGxlbWVudGF0aW9uIGhlcmVcbiAgICB9LFxuXG4gICAgY3JlYXRlQ29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKHRhYmxlU3RhdGUpO1xuXG4gICAgICAgIHByb3BlcnRpZXMucm93TnVtYmVyc1Byb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnJvd0hlYWRlciA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcywge1xuICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJGb250O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckZvbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93SGVhZGVyQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJCYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3BlcnRpZXMuY29sdW1uSGVhZGVyID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckZvbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5jb2x1bW5IZWFkZXJDb2x1bW5TZWxlY3Rpb24gPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMuY29sdW1uSGVhZGVyLCB7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5yb3dIZWFkZXJSb3dTZWxlY3Rpb24gPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMucm93SGVhZGVyLCB7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFJvd1NlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRSb3dTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZFJvd1NlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRSb3dTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5maWx0ZXJQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckZvbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjZWxsQm9yZGVyU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQ2VsbEJvcmRlclN0eWxlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckNlbGxCb3JkZXJTdHlsZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjZWxsQm9yZGVyVGhpY2tuZXNzOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckNlbGxCb3JkZXJUaGlja25lc3M7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyQ2VsbEJvcmRlclRoaWNrbmVzcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy50cmVlQ29sdW1uUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcywge1xuICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uRm9udDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVDb2x1bW5Gb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnRyZWVDb2x1bW5Qcm9wZXJ0aWVzQ29sdW1uU2VsZWN0aW9uID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLnRyZWVDb2x1bW5Qcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgY29sID0gdGhpcy5nZXRDb2x1bW4oeCk7XG4gICAgICAgIGlmICghY29sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2RlZmF1bHRDb2x1bW5XaWR0aCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IGNvbC5nZXRXaWR0aCgpO1xuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIHNldENvbHVtbldpZHRoOiBmdW5jdGlvbih4LCB3aWR0aCkge1xuICAgICAgICB0aGlzLmdldENvbHVtbih4KS5zZXRXaWR0aCh3aWR0aCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIGdldERhdGFNb2RlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFNb2RlbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGRhdGFNb2RlbCA9IHRoaXMuZ2V0RGVmYXVsdERhdGFNb2RlbCgpO1xuICAgICAgICAgICAgdGhpcy5zZXREYXRhTW9kZWwoZGF0YU1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWw7XG4gICAgfSxcblxuICAgIGdldENlbGxSZW5kZXJlcjogZnVuY3Rpb24oY29uZmlnLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbih4KS5nZXRDZWxsUmVuZGVyZXIoY29uZmlnLCB5KTtcbiAgICB9LFxuXG4gICAgc2V0RGF0YU1vZGVsOiBmdW5jdGlvbihuZXdEYXRhTW9kZWwpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwgPSBuZXdEYXRhTW9kZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IGZ1bmN0aW9uIHRvIGVtcHR5IGFuIG9iamVjdCBvZiBpdHMgbWVtYmVyc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGVtcHR5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZXhwb3J0UHJvcHNdXG4gICAgICogKiBgdW5kZWZpbmVkYCAob21pdHRlZCkgLSBkZWxldGUgKmFsbCogcHJvcGVydGllc1xuICAgICAqICogKipmYWxzeSoqIC0gZGVsZXRlICpvbmx5KiB0aGUgZXhwb3J0IHByb3BlcnRpZXNcbiAgICAgKiAqICoqdHJ1dGh5KiogLSBkZWxldGUgYWxsIHByb3BlcnRpZXMgKmV4Y2VwdCogdGhlIGV4cG9ydCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgY2xlYXJPYmplY3RQcm9wZXJ0aWVzOiBmdW5jdGlvbihvYmosIGV4cG9ydFByb3BzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydFByb3BzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgIWV4cG9ydFByb3BzICYmIG5vRXhwb3J0UHJvcGVydGllcy5pbmRleE9mKGtleSkgPj0gMCB8fFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRQcm9wcyAmJiBub0V4cG9ydFByb3BlcnRpZXMuaW5kZXhPZihrZXkpIDwgMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0dGVyIGZvciBhIFtNZW1lbnRvXShodHRwOi8vYzIuY29tL2NnaS93aWtpP01lbWVudG9QYXR0ZXJuKSBPYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldFByaXZhdGVTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy50YWJsZVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnRhYmxlU3RhdGUgPSB0aGlzLmdldERlZmF1bHRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRhYmxlU3RhdGU7XG4gICAgfSxcblxuICAgIC8vdGhpcyBpcyBlZmZlY3RpdmVseSBhIGNsb25lLCB3aXRoIGNlcnRhaW4gdGhpbmdzIHJlbW92ZWQuLi4uXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRQcml2YXRlU3RhdGUoKSkpO1xuICAgICAgICB0aGlzLmNsZWFyT2JqZWN0UHJvcGVydGllcyhjb3B5LmNvbHVtblByb3BlcnRpZXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjbGVhciBhbGwgdGFibGUgc3RhdGVcbiAgICAgKi9cbiAgICBjbGVhclN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50YWJsZVN0YXRlID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge29iamVjdH0gTmV3bHkgY3JlYXRlZCBkZWZhdWx0IGVtcHR5IHRhYmxlc3RhdGUuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhYmxlUHJvcGVydGllcyA9IHRoaXMuZ2V0R3JpZCgpLl9nZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHZhciBzdGF0ZSA9IE9iamVjdC5jcmVhdGUodGFibGVQcm9wZXJ0aWVzKTtcblxuICAgICAgICBfKHN0YXRlKS5leHRlbmRPd24oe1xuICAgICAgICAgICAgcm93SGVpZ2h0czoge30sXG4gICAgICAgICAgICBjZWxsUHJvcGVydGllczoge30sXG4gICAgICAgICAgICBjb2x1bW5Qcm9wZXJ0aWVzOiBbXVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXN0b3JlIHRoaXMgdGFibGUgdG8gYSBwcmV2aW91cyBzdGF0ZS5cbiAgICAgKiBTZWUgdGhlIFttZW1lbnRvIHBhdHRlcm5dKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/TWVtZW50b1BhdHRlcm4pLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZW1lbnRvIC0gYW4gZW5jYXBzdWxhdGVkIHJlcHJlc2VudGF0aW9uIG9mIHRhYmxlIHN0YXRlXG4gICAgICovXG4gICAgc2V0U3RhdGU6IGZ1bmN0aW9uKG1lbWVudG8pIHtcblxuICAgICAgICAvL3dlIGRvbid0IHdhbnQgdG8gY2xvYmJlciB0aGUgY29sdW1uIHByb3BlcnRpZXMgY29tcGxldGVseVxuICAgICAgICBpZiAoIW1lbWVudG8uY29sdW1uSW5kZXhlcykge1xuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZ2V0RmllbGRzKCk7XG4gICAgICAgICAgICBtZW1lbnRvLmNvbHVtbkluZGV4ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWVtZW50by5jb2x1bW5JbmRleGVzW2ldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sUHJvcGVydGllcyA9IG1lbWVudG8uY29sdW1uUHJvcGVydGllcztcbiAgICAgICAgZGVsZXRlIG1lbWVudG8uY29sdW1uUHJvcGVydGllcztcbiAgICAgICAgdGhpcy50YWJsZVN0YXRlID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuc2V0Q29sdW1uT3JkZXIobWVtZW50by5jb2x1bW5JbmRleGVzKTtcbiAgICAgICAgXyhzdGF0ZSkuZXh0ZW5kT3duKG1lbWVudG8pO1xuICAgICAgICB0aGlzLnNldEFsbENvbHVtblByb3BlcnRpZXMoY29sUHJvcGVydGllcyk7XG4gICAgICAgIG1lbWVudG8uY29sdW1uUHJvcGVydGllcyA9IGNvbFByb3BlcnRpZXM7XG4gICAgICAgIC8vbWVtZW50by5jb2x1bW5Qcm9wZXJ0aWVzID0gY29sUHJvcGVydGllcztcblxuICAgICAgICAvLyB0aGlzLmdldERhdGFNb2RlbCgpLnNldFN0YXRlKG1lbWVudG8pO1xuICAgICAgICAvLyB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gICAgIHNlbGYuYXBwbHlTb3J0cygpO1xuICAgICAgICAvLyAgICAgc2VsZi5jaGFuZ2VkKCk7XG4gICAgICAgIC8vICAgICBzZWxmLnN0YXRlQ2hhbmdlZCgpO1xuICAgICAgICAvLyB9KTtcblxuICAgICAgICAvL2p1c3QgdG8gYmUgY2xvc2UvIGl0J3MgZWFzaWVyIG9uIHRoZSBleWVzXG4gICAgICAgIHRoaXMuc2V0Q29sdW1uV2lkdGgoLTEsIDI0LjE5MzM1OTM3NSk7XG4gICAgICAgIHRoaXMuZ2V0RGF0YU1vZGVsKCkuYXBwbHlTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBzZXRBbGxDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKS5jb2x1bW5Qcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgdGhpcy5jbGVhck9iamVjdFByb3BlcnRpZXMoY3VycmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgXyhjdXJyZW50KS5leHRlbmRPd24ocHJvcGVydGllc1tpXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0Q29sdW1uT3JkZXI6IGZ1bmN0aW9uKGluZGV4ZXMpIHtcbiAgICAgICAgaWYgKCFpbmRleGVzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbnMubGVuZ3RoID0gaW5kZXhlcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zW2ldID0gdGhpcy5hbGxDb2x1bW5zW2luZGV4ZXNbaV1dO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFwcGx5U29ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2lmIEkgaGF2ZSBzb3J0cywgYXBwbHkgdGhlbSBub3cvL1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZmV0Y2ggdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IGtleVxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgb2YgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBhIHByb3BlcnR5IG5hbWVcbiAgICAgKi9cbiAgICByZXNvbHZlUHJvcGVydHk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eShrZXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgQSBzcGVjaWZpYyBjZWxsIHdhcyBjbGlja2VkOyB5b3UndmUgYmVlbiBub3RpZmllZC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gcG9pbnQgb2YgY2VsbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIGFsbCBldmVudCBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGNlbGxDbGlja2VkOiBmdW5jdGlvbihjZWxsLCBldmVudCkge1xuICAgICAgICB0aGlzLmdldERhdGFNb2RlbCgpLmNlbGxDbGlja2VkKGNlbGwsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEEgc3BlY2lmaWMgY2VsbCB3YXMgbGUgZG91YmxlLWNsaWNrZWQ7IHlvdSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBwb2ludCBvZiBjZWxsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gYWxsIGV2ZW50IGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgY2VsbERvdWJsZUNsaWNrZWQ6IGZ1bmN0aW9uKGNlbGwsIGV2ZW50KSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGFkZCBuZXh0RmVhdHVyZSB0byBtZSBJZiBJIGRvbid0IGhhdmUgYSBuZXh0IG5vZGUsIG90aGVyd2lzZSBwYXNzIGl0IGFsb25nXG4gICAgICogQHBhcmFtIHtGZWF0dXJlfVxuICAgICAqL1xuICAgIHNldE5leHRGZWF0dXJlOiBmdW5jdGlvbihuZXh0RmVhdHVyZSkge1xuICAgICAgICB0aGlzLmZlYXR1cmVNYXBbbmV4dEZlYXR1cmUuYWxpYXNdID0gbmV4dEZlYXR1cmU7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uc2V0TmV4dChuZXh0RmVhdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbiA9IG5leHRGZWF0dXJlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGxvb2t1cEZlYXR1cmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlTWFwW2tleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXR0ZXIgZm9yIHRoZSBjZWxsIHByb3ZpZGVyXG4gICAgICogQHJldHVybiB7Q2VsbFByb3ZpZGVyfVxuICAgICAqL1xuICAgIGdldENlbGxQcm92aWRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxQcm92aWRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldHRlciBmb3IgdGhlIGh5cGVyZ3JpZFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2V0R3JpZDogZnVuY3Rpb24oZmluR3JpZCkge1xuICAgICAgICB0aGlzLmdyaWQgPSBmaW5HcmlkO1xuICAgICAgICB0aGlzLmdldERhdGFNb2RlbCgpLnNldEdyaWQoZmluR3JpZCk7XG4gICAgICAgIHRoaXMuY2xlYXJDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuczoge0h5cGVyZ3JpZH0gVGhlIGh5cGVyZ3JpZCB0byB3aGljaCB0aGlzIGJlaGF2aW9yIGlzIGF0dGFjaGVkLlxuICAgICAqIEBwYXJhbSB7dHlwZX0gdmFybmFtZSAtIGRlc2NyaXB0b25cbiAgICAgKi9cbiAgICBnZXRHcmlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBhbmQgc3Vic3RpdHV0ZSB5b3VyIG93biBjZWxsIHByb3ZpZGVyLlxuICAgICAqIEByZXR1cm4ge0NlbGxQcm92aWRlcn1cbiAgICAgKi9cbiAgICBjcmVhdGVDZWxsUHJvdmlkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IENlbGxQcm92aWRlcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgRmlyc3QgY2hlY2sgdG8gc2VlIGlmIHNvbWV0aGluZyB3YXMgb3ZlcnJpZGRlbi5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgYXQgYHgseWAgZm9yIHRoZSB0b3AgbGVmdCBzZWN0aW9uIG9mIHRoZSBoeXBlcmdyaWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldENvbHVtbih4KTtcbiAgICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHVtbi5nZXRWYWx1ZSh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgZGF0YSBhdCBwb2ludCB4LCB5IHdpdGggdmFsdWVcbiAgICAgKiBAcmV0dXJuIFRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gdXNlXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldENvbHVtbih4KTtcbiAgICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1uLnNldFZhbHVlKHksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YVZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldFZhbHVlKHgsIHkpO1xuICAgIH0sXG5cbiAgICBzZXREYXRhVmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2V0RGF0YU1vZGVsKCkuc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEZpcnN0IGNoZWNrcyB0byBzZWUgaWYgc29tZXRoaW5nIHdhcyBvdmVycmlkZGVuLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSBhdCB4LHkgZm9yIHRoZSB0b3AgbGVmdCBzZWN0aW9uIG9mIHRoZSBoeXBlcmdyaWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGdldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLmdldENvbHVtbih4KTtcbiAgICAgICAgcmV0dXJuIGNvbC5nZXRDZWxsUHJvcGVydGllcyh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgZGF0YSBhdCBwb2ludCB4LCB5IHdpdGggdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0geSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHVzZVxuICAgICAqL1xuICAgIHNldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgY29sID0gdGhpcy5nZXRDb2x1bW4oeCk7XG4gICAgICAgIGlmIChjb2wpIHtcbiAgICAgICAgICAgIGNvbC5zZXRDZWxsUHJvcGVydGllcyh5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgaHlwZXJncmlkLlxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0Um93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGhlaWdodCBpbiBwaXhlbHMgb2YgdGhlIGZpeGVkIHJvd3MgYXJlYSAgb2YgdGhlIGh5cGVyZ3JpZC5cbiAgICAgKi9cbiAgICBnZXRGaXhlZFJvd3NIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmdldEZpeGVkUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsICsgdGhpcy5nZXRSb3dIZWlnaHQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGVpZ2h0IGluIHBpeGVscyBvZiBhIHNwZWNpZmljIHJvdyBpbiB0aGUgaHlwZXJncmlkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dOdW0gLSByb3cgaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRSb3dIZWlnaHQ6IGZ1bmN0aW9uKHJvd051bSkge1xuICAgICAgICB2YXIgdGFibGVTdGF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgICAgIGlmICh0YWJsZVN0YXRlLnJvd0hlaWdodHMpIHtcbiAgICAgICAgICAgIHZhciBvdmVycmlkZSA9IHRhYmxlU3RhdGUucm93SGVpZ2h0c1tyb3dOdW1dO1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRSb3dIZWlnaHQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSB2YWx1ZSBpcyBsYXppbHkgaW5pdGlhbGl6ZWQgYW5kIGNvbWVzIGZyb20gdGhlIHByb3BlcnRpZXMgbWVjaGFuaXNtIGZvciAnYGRlZmF1bHRSb3dIZWlnaHRgJywgd2hpY2ggc2hvdWxkIGJlIH4yMHB4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3cgaGVpZ2h0IGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0Um93SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlZmF1bHRSb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFJvd0hlaWdodCA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdkZWZhdWx0Um93SGVpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFJvd0hlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgcGl4ZWwgaGVpZ2h0IG9mIGEgc3BlY2lmaWMgcm93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd051bSAtIHRoZSByb3cgaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gcGl4ZWwgaGVpZ2h0XG4gICAgICovXG4gICAgc2V0Um93SGVpZ2h0OiBmdW5jdGlvbihyb3dOdW0sIGhlaWdodCkge1xuICAgICAgICB2YXIgdGFibGVTdGF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgICAgIHRhYmxlU3RhdGUucm93SGVpZ2h0c1tyb3dOdW1dID0gTWF0aC5tYXgoNSwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoaXMgd2lsbCBhbGxvdyAnZmxvYXRpbmcnIGZpeGVkIHJvd3MuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWF4aW11bSBoZWlnaHQgb2YgdGhlIGZpeGVkIHJvd3MgYXJlYSBpbiB0aGUgaHlwZXJncmlkLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93c01heEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpeGVkUm93c0hlaWdodCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGZpeGVkIGNvbHVtbiBhcmVhIGluIHRoZSBoeXBlcmdyaWQuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5zV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgaWYgKHRoaXMuZ2V0R3JpZCgpLmlzU2hvd1Jvd051bWJlcnMoKSkge1xuICAgICAgICAgICAgdG90YWwgPSB0aGlzLmdldENvbHVtbldpZHRoKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsID0gdG90YWwgKyB0aGlzLmdldENvbHVtbldpZHRoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoaXMgZXhpc3RzIHRvIHN1cHBvcnQgXCJmbG9hdGluZ1wiIGNvbHVtbnMuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdG90YWwgd2lkdGggb2YgdGhlIGZpeGVkIGNvbHVtbnMgYXJlYS5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbnNNYXhXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0Rml4ZWRDb2x1bW5zV2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdmVydGljYWwgZGltZW5zaW9uIGFuZCBub3RpZnkgbGlzdGVuZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIG5ldyB5IHZhbHVlXG4gICAgICovXG4gICAgX3NldFNjcm9sbFBvc2l0aW9uWTogZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFBvc2l0aW9uWSh5KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiBob3Jpem9udGFsIGRpbWVuc2lvbiBhbmQgbm90aWZ5IGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBuZXcgeCB2YWx1ZVxuICAgICAqL1xuICAgIF9zZXRTY3JvbGxQb3NpdGlvblg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxQb3NpdGlvblgoeCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBudW1iZXIgb2YgY29sdW1ucyBqdXN0IHJlbmRlcmVkLCBpbmNsdWRpbmcgcGFydGlhbGx5IHJlbmRlcmVkIGNvbHVtbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gaG93IG1hbnkgY29sdW1ucyB3ZXJlIGp1c3QgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBzZXRSZW5kZXJlZENvbHVtbkNvdW50OiBmdW5jdGlvbihjb3VudCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVkQ29sdW1uQ291bnQgPSBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgbnVtYmVyIG9mIHJvd3MganVzdCByZW5kZXJlZCwgaW5jbHVkaW5nIHBhcnRpYWxseSByZW5kZXJlZCByb3dzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIGhvdyBtYW55IHJvd3Mgd2VyZSBqdXN0IHJlbmRlcmVkXG4gICAgICovXG4gICAgc2V0UmVuZGVyZWRSb3dDb3VudDogZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZFJvd0NvdW50ID0gY291bnQ7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBmaXhlZCByb3cgYXJlYSBoYXMgYmVlbiBjbGlja2VkLCBtYXNzYWdlIHRoZSBkZXRhaWxzIGFuZCBjYWxsIHRoZSByZWFsIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIF9maXhlZFJvd0NsaWNrZWQ6IGZ1bmN0aW9uKGdyaWQsIG1vdXNlKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy50cmFuc2xhdGVDb2x1bW5JbmRleCh0aGlzLmdldFNjcm9sbFBvc2l0aW9uWCgpICsgbW91c2UuZ3JpZENlbGwueCAtIHRoaXMuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpKTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZWRQb2ludCA9IHRoaXMuZ3JpZC5uZXdQb2ludCh4LCBtb3VzZS5ncmlkQ2VsbC55KTtcbiAgICAgICAgbW91c2UuZ3JpZENlbGwgPSB0cmFuc2xhdGVkUG9pbnQ7XG4gICAgICAgIHRoaXMuZml4ZWRSb3dDbGlja2VkKGdyaWQsIG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBmaXhlZCBjb2x1bW4gYXJlYSBoYXMgYmVlbiBjbGlja2VkLCBtYXNzYWdlIHRoZSBkZXRhaWxzIGFuZCBjYWxsIHRoZSByZWFsIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIF9maXhlZENvbHVtbkNsaWNrZWQ6IGZ1bmN0aW9uKGdyaWQsIG1vdXNlKSB7XG4gICAgICAgIHZhciB0cmFuc2xhdGVkUG9pbnQgPSB0aGlzLmdyaWQubmV3UG9pbnQobW91c2UuZ3JpZENlbGwueCwgdGhpcy5nZXRTY3JvbGxQb3NpdGlvblkoKSArIG1vdXNlLmdyaWRDZWxsLnkgLSB0aGlzLmdldEZpeGVkUm93Q291bnQoKSk7XG4gICAgICAgIG1vdXNlLmdyaWRDZWxsID0gdHJhbnNsYXRlZFBvaW50O1xuICAgICAgICB0aGlzLmZpeGVkQ29sdW1uQ2xpY2tlZChncmlkLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIG1vdmVTaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIHgsIHkpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIHNldHRpbmcgdGhlIGN1cnNvciB1cCB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2V0Q3Vyc29yOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGdyaWQudXBkYXRlQ3Vyc29yKCk7XG4gICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLnNldEN1cnNvcihncmlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIG1vdmUgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyB0YXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25UYXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVUYXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIHRhcCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbkNvbnRleHRNZW51OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgcHJvY2VlZCA9IGdyaWQuZmlyZVN5bnRoZXRpY0NvbnRleHRNZW51RXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAocHJvY2VlZCAmJiB0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlQ29udGV4dE1lbnUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIHdoZWVsIG1vdmVkIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uV2hlZWxNb3ZlZDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVXaGVlbE1vdmVkKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSB1cCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbk1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgZHJhZyB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbk1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIGtleSBkb3duIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBrZXkgdXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25LZXlVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVLZXlVcChncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgZG91YmxlIGNsaWNrIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIGhvbGQgcHVsc2UgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Ib2xkUHVsc2U6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlSG9sZFB1bHNlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBkb3VibGUgY2xpY2sgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgdG9nZ2xlQ29sdW1uUGlja2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi50b2dnbGVDb2x1bW5QaWNrZXIodGhpcy5nZXRHcmlkKCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSBkb3duIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIGV4aXQgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VFeGl0OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlRXhpdChncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyByZXBsYWNlZCBieSB0aGUgZ3JpZCBvbiBpbml0aWFsaXphdGlvbiBhbmQgc2VydmVzIGFzIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIGNoYW5nZWQ6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyByZXBsYWNlZCBieSB0aGUgZ3JpZCBvbiBpbml0aWFsaXphdGlvbiBhbmQgc2VydmVzIGFzIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIHNoYXBlQ2hhbmdlZDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDYW4gcmUtb3JkZXIgY29sdW1ucy5cbiAgICAgKi9cbiAgICBpc0NvbHVtblJlb3JkZXJhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwcm9wZXJ0aWVzIGZvciBhIHNwZWNpZmljIGNvbHVtbi4gVGhlc2UgYXJlIHVzZWQgaWYgbm8gY2VsbCBwcm9wZXJ0aWVzIGFyZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHtpbmRleH0gY29sdW1uSW5kZXggLSB0aGUgY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbCA9IHRoaXMuY29sdW1uc1tjb2x1bW5JbmRleF07XG4gICAgICAgIGlmICghY29sKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzTnVsbDogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGNvbC5nZXRQcm9wZXJ0aWVzKCk7IC8vVE9ETzogcmV0dXJucyBgbnVsbGAgb24gSHlwZXJncmlkLnJlc2V0KCk7XG4gICAgICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc051bGw6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfSxcbiAgICBzZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgcHJvcGVydGllcykge1xuICAgICAgICB2YXIgY29sdW1uUHJvcGVydGllcyA9IHRoaXMuZ2V0Q29sdW1uUHJvcGVydGllcyhjb2x1bW5JbmRleCk7XG4gICAgICAgIF8oY29sdW1uUHJvcGVydGllcykuZXh0ZW5kT3duKHByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ3NbXX0gTGFiZWxzIHRvIHVzZSBmb3IgdGhlIGNvbHVtbiBwaWNrZXIuXG4gICAgICovXG4gICAgZ2V0Q29sdW1uRGVzY3JpcHRvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2Fzc3VtZXMgdGhlcmUgaXMgb25lIHJvdy4uLi5cbiAgICAgICAgdGhpcy5pbnN1cmVDb2x1bW5JbmRleGVzQXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgY29sdW1uQ291bnQgPSB0YWJsZVN0YXRlLmNvbHVtbkluZGV4ZXMubGVuZ3RoO1xuICAgICAgICB2YXIgbGFiZWxzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkID0gdGFibGVTdGF0ZS5jb2x1bW5JbmRleGVzW2ldO1xuICAgICAgICAgICAgbGFiZWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5nZXRIZWFkZXIoaWQpLFxuICAgICAgICAgICAgICAgIGZpZWxkOiB0aGlzLmdldEZpZWxkKGlkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGZpZWxkIGF0IGBjb2xJbmRleGAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gdGhlIGNvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldEZpZWxkOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICBpZiAoY29sSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RyZWUnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLmdldENvbHVtbihjb2xJbmRleCk7XG4gICAgICAgIHJldHVybiBjb2wuZ2V0RmllbGQoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb2x1bW4gaGVhZGluZyBhdCBgY29sSW5kZXgnLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleCAtIHRoZSBjb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRIZWFkZXI6IGZ1bmN0aW9uKGNvbEluZGV4KSB7XG4gICAgICAgIGlmIChjb2xJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnVHJlZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbCA9IHRoaXMuZ2V0Q29sdW1uKGNvbEluZGV4KTtcbiAgICAgICAgcmV0dXJuIGNvbC5nZXRIZWFkZXIoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGlzIGNhbGxlZCBieSB0aGUgY29sdW1uIGVkaXRvciBwb3N0IGNsb3Npbmc7IHJlYnVpbGQgdGhlIGNvbHVtbiBvcmRlciBpbmRleGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCAtIGxpc3Qgb2YgY29sdW1uIG9iamVjdHMgZnJvbSB0aGUgY29sdW1uIGVkaXRvclxuICAgICAqL1xuICAgIHNldENvbHVtbkRlc2NyaXB0b3JzOiBmdW5jdGlvbihsaXN0cykge1xuICAgICAgICAvL2Fzc3VtZXMgdGhlcmUgaXMgb25lIHJvdy4uLi5cbiAgICAgICAgdmFyIHZpc2libGUgPSBsaXN0cy52aXNpYmxlO1xuICAgICAgICB2YXIgdGFibGVTdGF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG5cbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gdmlzaWJsZS5sZW5ndGg7XG4gICAgICAgIHZhciBpbmRleGVzID0gW107XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKHZpc2libGVbaV0uaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlU3RhdGUuY29sdW1uSW5kZXhlcyA9IGluZGV4ZXM7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7c3RyaW5nW119IEFsbCB0aGUgY3VycmVudGx5IGhpZGRlbiBjb2x1bW4gaGVhZGVyIGxhYmVscy5cbiAgICAgKi9cbiAgICBnZXRIaWRkZW5Db2x1bW5EZXNjcmlwdG9yczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIGluZGV4ZXMgPSB0YWJsZVN0YXRlLmNvbHVtbkluZGV4ZXM7XG4gICAgICAgIHZhciBsYWJlbHMgPSBbXTtcbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbmRleGVzLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0SGVhZGVyKGkpLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogdGhpcy5nZXRGaWVsZChpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoaWRlIGNvbHVtbnMgdGhhdCBhcmUgc3BlY2lmaWVkIGJ5IHRoZWlyIGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheU9mSW5kZXhlcyAtIGFuIGFycmF5IG9mIGNvbHVtbiBpbmRleGVzIHRvIGhpZGVcbiAgICAgKi9cbiAgICBoaWRlQ29sdW1uczogZnVuY3Rpb24oYXJyYXlPZkluZGV4ZXMpIHtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgb3JkZXIgPSB0YWJsZVN0YXRlLmNvbHVtbkluZGV4ZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZkluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlYWNoID0gYXJyYXlPZkluZGV4ZXNbaV07XG4gICAgICAgICAgICBpZiAob3JkZXIuaW5kZXhPZihlYWNoKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvcmRlci5zcGxpY2Uob3JkZXIuaW5kZXhPZihlYWNoKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge2ludGVnZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGFibGVTdGF0ZS5maXhlZENvbHVtbkNvdW50IHx8IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mRml4ZWRDb2x1bW5zIC0gdGhlIGludGVnZXIgY291bnQgb2YgaG93IG1hbnkgY29sdW1ucyB0byBiZSBmaXhlZFxuICAgICAqL1xuICAgIHNldEZpeGVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKG51bWJlck9mRml4ZWRDb2x1bW5zKSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdGFibGVTdGF0ZS5maXhlZENvbHVtbkNvdW50ID0gbnVtYmVyT2ZGaXhlZENvbHVtbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy50YWJsZVN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXNlcnNTaXplID0gdGhpcy50YWJsZVN0YXRlLmZpeGVkUm93Q291bnQgfHwgMDtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmdldEdyaWQoKS5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgdG90YWwgPSB1c2Vyc1NpemUgKyBoZWFkZXJzO1xuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIG51bWJlciBvZiByb3dzIHRoYXQgYXJlIGZpeGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mRml4ZWRSb3dzIC0gdGhlIGNvdW50IG9mIHJvd3MgdG8gYmUgc2V0IGZpeGVkXG4gICAgICovXG4gICAgc2V0Rml4ZWRSb3dDb3VudDogZnVuY3Rpb24obnVtYmVyT2ZGaXhlZFJvd3MpIHtcbiAgICAgICAgdGhpcy50YWJsZVN0YXRlLmZpeGVkUm93Q291bnQgPSBudW1iZXJPZkZpeGVkUm93cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldEhlYWRlclJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdldEdyaWQoKTtcbiAgICAgICAgdmFyIGhlYWRlciA9IGdyaWQuaXNTaG93SGVhZGVyUm93KCkgPyAxIDogMDtcbiAgICAgICAgdmFyIGZpbHRlciA9IGdyaWQuaXNTaG93RmlsdGVyUm93KCkgPyAxIDogMDtcbiAgICAgICAgdmFyIHRvdGFscyA9IHRoaXMuZ2V0VG9wVG90YWxzKCkubGVuZ3RoO1xuICAgICAgICB2YXIgY291bnQgPSBoZWFkZXIgKyBmaWx0ZXIgKyB0b3RhbHM7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgbnVtYmVyIG9mIHJvd3MgdGhhdCBhcmUgZml4ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZGaXhlZFJvd3MgLSB0aGUgY291bnQgb2Ygcm93cyB0byBiZSBzZXQgZml4ZWRcbiAgICAgKi9cbiAgICBzZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24obnVtYmVyT2ZIZWFkZXJSb3dzKSB7XG4gICAgICAgIHRoaXMudGFibGVTdGF0ZS5oZWFkZXJSb3dDb3VudCA9IG51bWJlck9mSGVhZGVyUm93cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldEhlYWRlckNvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdldEdyaWQoKTtcbiAgICAgICAgdmFyIGNvdW50ID0gZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ2hlYWRlckNvbHVtbkNvdW50Jyk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MuXG4gICAgICovXG4gICAgc2V0SGVhZGVyQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKG51bWJlck9mSGVhZGVyQ29sdW1ucykge1xuICAgICAgICB0aGlzLnRhYmxlU3RhdGUuaGVhZGVyQ29sdW1uQ291bnQgPSBudW1iZXJPZkhlYWRlckNvbHVtbnM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgYnVpbGQgYW5kIG9wZW4gdGhlIGVkaXRvciB3aXRoaW4gdGhlIGNvbnRhaW5lciBkaXYgYXJndW1lbnRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHByZXZlbnRzIGVkaXRvciBmcm9tIG9wZW5pbmdcbiAgICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSBkaXYgLSB0aGUgY29udGFpbmluZyBkaXYgZWxlbWVudFxuICAgICAqL1xuICAgIG9wZW5FZGl0b3I6IGZ1bmN0aW9uKGRpdikge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgdmFyIGhpZGRlbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zpbi1oeXBlcmdyaWQtZG5kLWxpc3QnKTtcbiAgICAgICAgdmFyIHZpc2libGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaW4taHlwZXJncmlkLWRuZC1saXN0Jyk7XG5cbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGhpZGRlbik7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh2aXNpYmxlKTtcblxuICAgICAgICB0aGlzLmJlQ29sdW1uU3R5bGUoaGlkZGVuLnN0eWxlKTtcbiAgICAgICAgaGlkZGVuLnRpdGxlID0gJ2hpZGRlbiBjb2x1bW5zJztcbiAgICAgICAgaGlkZGVuLmxpc3QgPSB0aGlzLmdldEhpZGRlbkNvbHVtbkRlc2NyaXB0b3JzKCk7XG5cbiAgICAgICAgdGhpcy5iZUNvbHVtblN0eWxlKHZpc2libGUuc3R5bGUpO1xuICAgICAgICB2aXNpYmxlLnN0eWxlLmxlZnQgPSAnNTAlJztcbiAgICAgICAgdmlzaWJsZS50aXRsZSA9ICd2aXNpYmxlIGNvbHVtbnMnO1xuICAgICAgICB2aXNpYmxlLmxpc3QgPSB0aGlzLmdldENvbHVtbkRlc2NyaXB0b3JzKCk7XG5cbiAgICAgICAgZGl2Lmxpc3RzID0ge1xuICAgICAgICAgICAgaGlkZGVuOiBoaWRkZW4ubGlzdCxcbiAgICAgICAgICAgIHZpc2libGU6IHZpc2libGUubGlzdFxuICAgICAgICB9O1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGUgZWRpdG9yIGlzIHJlcXVlc3RpbmcgY2xvc2U7IGRlYWwgd2l0aCB0aGUgZWRpdHNcbiAgICAgKiBAcmV0dXJuIGB0cnVlYFxuICAgICAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IGRpdiAtIHRoZSBjb250YWluaW5nIGRpdiBlbGVtZW50XG4gICAgICovXG4gICAgY2xvc2VFZGl0b3I6IGZ1bmN0aW9uKGRpdikge1xuICAgICAgICB2YXIgbGlzdHMgPSBkaXYubGlzdHM7XG4gICAgICAgIHRoaXMuc2V0Q29sdW1uRGVzY3JpcHRvcnMobGlzdHMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGEgZG5kIGNvbHVtbiBoYXMganVzdCBiZWVuIGRyb3BwZWQsIHdlJ3ZlIGJlZW4gbm90aWZpZWRcbiAgICAgKi9cbiAgICBlbmREcmFnQ29sdW1uTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGJpbmQgY29sdW1uIGVkaXRvciBhcHByb3ByaWF0ZSBjc3MgdmFsdWVzIHRvIGFyZyBzdHlsZVxuICAgICAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGUgLSB0aGUgc3R5bGUgb2JqZWN0IHRvIGVuaGFuY2VcbiAgICAgKi9cbiAgICBiZUNvbHVtblN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICBzdHlsZS50b3AgPSAnNSUnO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHN0eWxlLndpZHRoID0gJzUwJSc7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgc3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVsbH0gdGhlIGN1cnNvciBhdCBhIHNwZWNpZmljIHgseSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ2V0Q3Vyc29yQXQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0b3RhbCBudW1iZXIgb2YgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSBjb2x1bW4gYWxpZ25tZW50IGF0IGNvbHVtbiBgeGAsIHdoaWNoIGlzIG9uZSBvZiBgJ2xlZnQnYCwgYCdjZW50ZXInYCAsIG9yIGAncmlnaHQnYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBjb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5BbGlnbm1lbnQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgcXVpZXRseSBzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB0aGUgaG9yaXpvbnRhbCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBwb3NpdGlvbiBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICBzZXRTY3JvbGxQb3NpdGlvblg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvblggPSB4O1xuICAgIH0sXG5cbiAgICBnZXRTY3JvbGxQb3NpdGlvblg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxQb3NpdGlvblg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBxdWlldGx5IHNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIHRoZSBob3Jpem9udGFsIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHBvc2l0aW9uIGluIHBpeGVsc1xuICAgICAqL1xuICAgIHNldFNjcm9sbFBvc2l0aW9uWTogZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uWSA9IHk7XG4gICAgfSxcblxuICAgIGdldFNjcm9sbFBvc2l0aW9uWTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFBvc2l0aW9uWTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge2NlbGxFZGl0b3J9IENlbGwgZWRpdG9yIGZvciBjb29yZGluYXRlIGB4LHlgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uKHgpLmdldENlbGxFZGl0b3JBdCh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGZpeGVkIHJvdyBoYXMgYmVlbiBjbGlja2VkLCB5b3UndmUgYmVlbiBub3RpZmllZFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIHRvZ2dsZVNvcnQ6IGZ1bmN0aW9uKHgsIGtleXMpIHtcbiAgICAgICAgdGhpcy5nZXRDb2x1bW4oeCkudG9nZ2xlU29ydChrZXlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB3ZSBzaG91bGQgaGlnaGxpZ2h0IG9uIGhvdmVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0NvbHVtbkhvdmVyZWQgLSB0aGUgY29sdW1uIGlzIGhvdmVyZWQgb3Igbm90XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1Jvd0hvdmVyZWQgLSB0aGUgcm93IGlzIGhvdmVyZWQgb3Igbm90XG4gICAgICovXG4gICAgaGlnaGxpZ2h0Q2VsbE9uSG92ZXI6IGZ1bmN0aW9uKGlzQ29sdW1uSG92ZXJlZCwgaXNSb3dIb3ZlcmVkKSB7XG4gICAgICAgIHJldHVybiBpc0NvbHVtbkhvdmVyZWQgJiYgaXNSb3dIb3ZlcmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gYW4gaW1hZ2UgYWxpYXNcbiAgICAgKi9cbiAgICBnZXRJbWFnZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBpbWFnZXNba2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgaW1hZ2UgZm9yIGEgc3BlY2lmaWMgYWxpYXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gYW4gaW1hZ2UgYWxpYXNcbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltYWdlIC0gdGhlIGltYWdlIHRvIGNhY2hlXG4gICAgICovXG4gICAgc2V0SW1hZ2U6IGZ1bmN0aW9uKGtleSwgaW1hZ2UpIHtcbiAgICAgICAgaW1hZ2VzW2tleV0gPSBpbWFnZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgYSBob29rIGFuZCBpcyBjYWxsZWQganVzdCBiZWZvcmUgdGhlIHBhaW50aW5nIG9mIGEgY2VsbCBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXIuUG9pbnR9IGNlbGxcbiAgICAgKi9cbiAgICBjZWxsUHJvcGVydGllc1ByZVBhaW50Tm90aWZpY2F0aW9uOiBmdW5jdGlvbihjZWxsUHJvcGVydGllcykge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5nZXRSb3coY2VsbFByb3BlcnRpZXMueSk7XG4gICAgICAgIHZhciBjb2x1bW5JZCA9IHRoaXMuZ2V0SGVhZGVyKGNlbGxQcm9wZXJ0aWVzLngpO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5yb3cgPSByb3c7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmNvbHVtbklkID0gY29sdW1uSWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIGZpeGVkIHJvdyBjZWxsIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH0gY2VsbFxuICAgICAqL1xuICAgIGNlbGxGaXhlZFJvd1ByZVBhaW50Tm90aWZpY2F0aW9uOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgYSBob29rIGFuZCBpcyBjYWxsZWQganVzdCBiZWZvcmUgdGhlIHBhaW50aW5nIG9mIGEgZml4ZWQgY29sdW1uIGNlbGwgb2NjdXJzXG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbEZpeGVkQ29sdW1uUHJlUGFpbnROb3RpZmljYXRpb246IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyBhIGhvb2sgYW5kIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFpbnRpbmcgb2YgYSB0b3AgbGVmdCBjZWxsIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH0gY2VsbFxuICAgICAqL1xuICAgIGNlbGxUb3BMZWZ0UHJlUGFpbnROb3RpZmljYXRpb246IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBlbmhhbmNlIHRoZSBkb3VibGUgY2xpY2sgZXZlbnQganVzdCBiZWZvcmUgaXQncyBicm9hZGNhc3QgdG8gbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gZXZlbnQgdG8gZW5oYW5jZVxuICAgICAqL1xuICAgIGVuaGFuY2VEb3VibGVDbGlja0V2ZW50OiBmdW5jdGlvbihldmVudCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc3dhcCBzcmMgYW5kIHRhciBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyYyAtIGNvbHVtbiBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXIgLSBjb2x1bW4gaW5kZXhcbiAgICAgKi9cbiAgICBzd2FwQ29sdW1uczogZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnM7XG4gICAgICAgIHZhciB0bXAgPSBjb2x1bW5zW3NvdXJjZV07XG4gICAgICAgIGNvbHVtbnNbc291cmNlXSA9IGNvbHVtbnNbdGFyZ2V0XTtcbiAgICAgICAgY29sdW1uc1t0YXJnZXRdID0gdG1wO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uRWRnZTogZnVuY3Rpb24oYywgcmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0Q29sdW1uRWRnZShjLCByZW5kZXJlcik7XG4gICAgfSxcblxuICAgIHNldFRvdGFsc1ZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmdldEdyaWQoKS5zZXRUb3RhbHNWYWx1ZU5vdGlmaWNhdGlvbih4LCB5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBvYmplY3QgYXQgeSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSByb3cgaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0Um93KHkpO1xuICAgIH0sXG5cbiAgICBjb252ZXJ0Vmlld1BvaW50VG9EYXRhUG9pbnQ6IGZ1bmN0aW9uKHZpZXdQb2ludCkge1xuICAgICAgICB2YXIgbmV3WCA9IHRoaXMuZ2V0Q29sdW1uKHZpZXdQb2ludC54KTtcbiAgICAgICAgdmFyIG5ld1BvaW50ID0gdGhpcy5nZXRHcmlkKCkubmV3UG9pbnQobmV3WCwgdmlld1BvaW50LnkpO1xuICAgICAgICByZXR1cm4gbmV3UG9pbnQ7XG4gICAgfSxcblxuICAgIHNldEdyb3VwczogZnVuY3Rpb24oYXJyYXlPZkNvbHVtbkluZGV4ZXMpIHtcbiAgICAgICAgdGhpcy5nZXREYXRhTW9kZWwoKS5zZXRHcm91cHMoYXJyYXlPZkNvbHVtbkluZGV4ZXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIHNldEFnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKG1hcE9mS2V5c1RvRnVuY3Rpb25zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5nZXREYXRhTW9kZWwoKS5zZXRBZ2dyZWdhdGVzKG1hcE9mS2V5c1RvRnVuY3Rpb25zKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmNoYW5nZWQoKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9LFxuXG4gICAgaGFzSGllcmFyY2h5Q29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBnZXRSb3dDb250ZXh0RnVuY3Rpb246IGZ1bmN0aW9uKHNlbGVjdGVkUm93cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uTWF0cml4RnVuY3Rpb246IGZ1bmN0aW9uKHNlbGVjdGVkUm93cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0RmllbGROYW1lOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZHMoKVtpbmRleF07XG4gICAgfSxcblxuICAgIGdldENvbHVtbkluZGV4OiBmdW5jdGlvbihmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRzKCkuaW5kZXhPZihmaWVsZE5hbWUpO1xuICAgIH0sXG5cbiAgICBnZXRDb21wdXRlZFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhTW9kZWwoKS5nZXRDb21wdXRlZFJvdyh5KTtcbiAgICB9LFxuXG4gICAgYXV0b3NpemVBbGxDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jaGVja0NvbHVtbkF1dG9zaXppbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBjaGVja0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIGZvcmNlID0gZm9yY2UgPT09IHRydWU7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1uc1stMV0uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnNbLTJdLmNoZWNrQ29sdW1uQXV0b3NpemluZyhmb3JjZSk7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgY29sdW1uLmNoZWNrQ29sdW1uQXV0b3NpemluZyhmb3JjZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhdXRvU2l6ZVJvd051bWJlckNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1uc1stMV0uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgIH0sXG5cbiAgICBzZXRHbG9iYWxGaWx0ZXI6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB0aGlzLmdldERhdGFNb2RlbCgpLnNldEdsb2JhbEZpbHRlcihzdHJpbmcpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0U2VsZWN0aW9uTW9kZWwoKS5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0ZWRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0U2VsZWN0aW9uTW9kZWwoKS5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWhhdmlvcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xuXG5mdW5jdGlvbiBDb2x1bW4oYmVoYXZpb3IsIGluZGV4LCBsYWJlbCkge1xuICAgIHRoaXMuYmVoYXZpb3IgPSBiZWhhdmlvcjtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IGJlaGF2aW9yLmdldERhdGFNb2RlbCgpO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG59XG5cbkNvbHVtbi5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbHVtbi5wcm90b3R5cGUuY29uc3RydWN0b3IsXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0VmFsdWUodGhpcy5pbmRleCwgeSk7XG4gICAgfSxcblxuICAgIHNldFZhbHVlOiBmdW5jdGlvbih5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuc2V0VmFsdWUodGhpcy5pbmRleCwgeSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgb3ZlcnJpZGUgPSBwcm9wZXJ0aWVzLndpZHRoO1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLnJlc29sdmVQcm9wZXJ0eSgnZGVmYXVsdENvbHVtbldpZHRoJyk7XG4gICAgfSxcblxuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICB0aGlzLmdldFByb3BlcnRpZXMoKS53aWR0aCA9IE1hdGgubWF4KDUsIHdpZHRoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q2VsbFJlbmRlcmVyOiBmdW5jdGlvbihjb25maWcsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldENlbGxSZW5kZXJlcihjb25maWcsIHRoaXMuaW5kZXgsIHkpO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRQcml2YXRlU3RhdGUoKS5jZWxsUHJvcGVydGllc1t0aGlzLmluZGV4ICsgJywnICsgeV07XG4gICAgfSxcblxuICAgIHNldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmdldFByaXZhdGVTdGF0ZSgpLmNlbGxQcm9wZXJ0aWVzW3RoaXMuaW5kZXggKyAnLCcgKyB5XSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBjaGVja0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHZhciBhLCBiLCBkO1xuICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgYSA9IHByb3BlcnRpZXMud2lkdGg7XG4gICAgICAgICAgICBiID0gcHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCB8fCBwcm9wZXJ0aWVzLndpZHRoO1xuICAgICAgICAgICAgZCA9IHByb3BlcnRpZXMuY29sdW1uQXV0b3NpemVkICYmICFmb3JjZTtcbiAgICAgICAgICAgIGlmIChhICE9PSBiIHx8ICFkKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy53aWR0aCA9ICFkID8gYiA6IE1hdGgubWF4KGEsIGIpO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuY29sdW1uQXV0b3NpemVkID0gIWlzTmFOKHByb3BlcnRpZXMud2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRQcml2YXRlU3RhdGUoKS5jb2x1bW5Qcm9wZXJ0aWVzW3RoaXMuaW5kZXhdO1xuICAgIH0sXG5cbiAgICBzZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5iZWhhdmlvci5nZXRQcml2YXRlU3RhdGUoKS5jb2x1bW5Qcm9wZXJ0aWVzW3RoaXMuaW5kZXhdO1xuICAgICAgICB0aGlzLmNsZWFyT2JqZWN0UHJvcGVydGllcyhjdXJyZW50LCBmYWxzZSk7XG4gICAgICAgIF8oY3VycmVudCkuZXh0ZW5kT3duKHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICB0b2dnbGVTb3J0OiBmdW5jdGlvbihrZXlzKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnRvZ2dsZVNvcnQodGhpcy5pbmRleCwga2V5cyk7XG4gICAgfSxcblxuICAgIGdldENlbGxFZGl0b3JBdDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRDZWxsRWRpdG9yQXQodGhpcy5pbmRleCwgeSk7XG4gICAgfSxcblxuICAgIGdldEhlYWRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsO1xuICAgIH0sXG5cbiAgICBnZXRGaWVsZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRGaWVsZHMoKVt0aGlzLmluZGV4XTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gRGF0YU1vZGVsRGVjb3JhdG9yKGdyaWQsIGNvbXBvbmVudCkge1xuICAgIHRoaXMuc2V0Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgdGhpcy5zZXRHcmlkKGdyaWQpO1xufVxuXG5EYXRhTW9kZWxEZWNvcmF0b3IucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBEYXRhTW9kZWxEZWNvcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgY29tcG9uZW50OiBudWxsLFxuICAgIGdyaWQ6IG51bGwsXG5cbiAgICBnZXRHcmlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZDtcbiAgICB9LFxuXG4gICAgc2V0R3JpZDogZnVuY3Rpb24obmV3R3JpZCkge1xuICAgICAgICB0aGlzLmdyaWQgPSBuZXdHcmlkO1xuICAgICAgICB0aGlzLmdldENvbXBvbmVudCgpLnNldEdyaWQobmV3R3JpZCk7XG4gICAgfSxcblxuICAgIGdldEJlaGF2aW9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldEJlaGF2aW9yKCk7XG4gICAgfSxcblxuICAgIGNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBnZXRQcml2YXRlU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgfSxcblxuICAgIGFwcGx5U3RhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgfSxcblxuICAgIHNldENvbXBvbmVudDogZnVuY3Rpb24obmV3Q29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gbmV3Q29tcG9uZW50O1xuICAgIH0sXG5cbiAgICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQ7XG4gICAgfSxcblxuICAgIHNldEdsb2JhbEZpbHRlcjogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLnNldEdsb2JhbEZpbHRlcihzdHJpbmcpO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5nZXRWYWx1ZSh4LCB5KTtcbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KCkuc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmdldENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuZ2V0Um93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q2VsbFJlbmRlcmVyOiBmdW5jdGlvbihjb25maWcsIHgsIHksIHVudHJhbnNsYXRlZFgsIHVudHJhbnNsYXRlZFkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuZ2V0Q2VsbFJlbmRlcmVyKGNvbmZpZywgeCwgeSwgdW50cmFuc2xhdGVkWCwgdW50cmFuc2xhdGVkWSk7XG4gICAgfSxcblxuICAgIGdldFJvd0hlaWdodDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5nZXRSb3dIZWlnaHQoeSk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkVkZ2U6IGZ1bmN0aW9uKHgsIHJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmdldENvbHVtbkVkZ2UoeCwgcmVuZGVyZXIpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5nZXRDb2x1bW5XaWR0aCh4KTtcbiAgICB9LFxuXG4gICAgc2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uKHgsIHdpZHRoKSB7XG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KCkuc2V0Q29sdW1uV2lkdGgoeCwgd2lkdGgpO1xuICAgIH0sXG5cbiAgICB0b2dnbGVTb3J0OiBmdW5jdGlvbih4LCBrZXlzKSB7XG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KCkudG9nZ2xlU29ydCh4LCBrZXlzKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuZ2V0Q29sdW1uUHJvcGVydGllcyhjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIHNldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbHVtbkluZGV4LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KCkuc2V0Q29sdW1uUHJvcGVydGllcyhjb2x1bW5JbmRleCwgcHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5nZXRIZWFkZXJzKCk7XG4gICAgfSxcblxuICAgIGdldEZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmdldEZpZWxkcygpO1xuICAgIH0sXG5cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICB0aGlzLmdldENvbXBvbmVudCgpLnNldEZpZWxkcyhmaWVsZHMpO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5nZXRDZWxsUHJvcGVydGllcyh4LCB5KTtcbiAgICB9LFxuXG4gICAgc2V0Q2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KCkuc2V0Q2VsbFByb3BlcnRpZXMoeCwgeSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuZ2V0Um93KHkpO1xuICAgIH0sXG5cbiAgICBzZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKG5lc3RlZEFycmF5KSB7XG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KCkuc2V0VG9wVG90YWxzKG5lc3RlZEFycmF5KTtcbiAgICB9LFxuXG4gICAgZ2V0VG9wVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuZ2V0VG9wVG90YWxzKCk7XG4gICAgfSxcblxuICAgIHNldERhdGE6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuc2V0RGF0YSh5KTtcbiAgICB9LFxuXG4gICAgaGFzSGllcmFyY2h5Q29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuaGFzSGllcmFyY2h5Q29sdW1uKCk7XG4gICAgfSxcblxuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlckxhYmVscykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5zZXRIZWFkZXJzKGhlYWRlckxhYmVscyk7XG4gICAgfSxcblxuICAgIGNlbGxDbGlja2VkOiBmdW5jdGlvbihjZWxsLCBldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5jZWxsQ2xpY2tlZChjZWxsLCBldmVudCk7XG4gICAgfSxcblxuICAgIGdldEF2YWlsYWJsZUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmdldEF2YWlsYWJsZUdyb3VwcygpO1xuICAgIH0sXG5cbiAgICBnZXRHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5nZXRHcm91cHMoKTtcbiAgICB9LFxuXG4gICAgc2V0R3JvdXBzOiBmdW5jdGlvbihncm91cHMpIHtcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQoKS5zZXRHcm91cHMoZ3JvdXBzKTtcbiAgICB9LFxuXG4gICAgZ2V0SGlkZGVuQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmdldEhpZGRlbkNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5nZXRWaXNpYmxlQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICBzZXRBZ2dyZWdhdGVzOiBmdW5jdGlvbihhZ2dyZWdhdGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLnNldEFnZ3JlZ2F0ZXMoYWdncmVnYXRlcyk7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQoKS5yZXNldCgpO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuZ2V0Q2VsbEVkaXRvckF0KHgsIHkpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU1vZGVsRGVjb3JhdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGlzdERyYWdvbiA9IHJlcXVpcmUoJ2xpc3QtZHJhZ29uJyk7XG5cbnZhciBCZWhhdmlvciA9IHJlcXVpcmUoJy4vQmVoYXZpb3InKTtcbnZhciBEYXRhTW9kZWxEZWNvcmF0b3IgPSByZXF1aXJlKCcuL0RhdGFNb2RlbERlY29yYXRvcicpO1xudmFyIERhdGFNb2RlbEpTT04gPSByZXF1aXJlKCcuLi9kYXRhTW9kZWxzL0pTT04nKTtcbnZhciBmZWF0dXJlcyA9IHJlcXVpcmUoJy4uL2ZlYXR1cmVzL2luZGV4Jyk7XG52YXIgYWRkU3R5bGVzaGVldCA9IHJlcXVpcmUoJy4uL3N0eWxlc2hlZXRzJyk7XG52YXIgYWdncmVnYXRpb25zID0gcmVxdWlyZSgnaHlwZXItYW5hbHl0aWNzJykudXRpbC5hZ2dyZWdhdGlvbnM7XG4vL3ZhciBhZ2dyZWdhdGlvbnMgPSByZXF1aXJlKCcuLi9sb2NhbF9ub2RlX21vZHVsZXMvbmV3YW5hbHl0aWNzJykudXRpbC5hZ2dyZWdhdGlvbnM7XG4vL3ZhciBhZ2dyZWdhdGlvbnMgPSByZXF1aXJlKCcuLi9sb2NhbF9ub2RlX21vZHVsZXMvZmluYW5hbHl0aWNzJykuYWdncmVnYXRpb25zO1xuXG4vKipcbiAqIEBuYW1lIGJlaGF2aW9ycy5KU09OXG4gKiBAZGVzYyA+IFNhbWUgcGFyYW1ldGVycyBhcyB7QGxpbmsgYmVoYXZpb3JzLkpTT04jaW5pdGlhbGl6ZXxpbml0aWFsaXplfSwgd2hpY2ggaXMgY2FsbGVkIGJ5IHRoaXMgY29uc3RydWN0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEpTT04gPSBCZWhhdmlvci5leHRlbmQoJ2JlaGF2aW9ycy5KU09OJywge1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ29uc3RydWN0b3IgbG9naWMsIGNhbGxlZCBfYWZ0ZXJfe0BsaW5rIEJlaGF2aW9yI2luaXRpYWxpemV8QmVoYXZpb3IuaW5pdGlhbGl6ZSgpfS5cbiAgICAgKiBAZGVzYyBUaGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCB1cG9uIGluc3RhbnRpYXRpb24gb2YgdGhpcyBjbGFzcyBvciBvZiBhbnkgY2xhc3MgdGhhdCBleHRlbmRzIGZyb20gdGhpcyBjbGFzcy5cbiAgICAgKiA+IEFsbCBgaW5pdGlhbGl6ZSgpYCBtZXRob2RzIGluIHRoZSBpbmhlcml0YW5jZSBjaGFpbiBhcmUgY2FsbGVkLCBpbiB0dXJuLCBlYWNoIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciwgYmVnaW5uaW5nIHdpdGggdGhhdCBvZiB0aGUgbW9zdCBcInNlbmlvclwiIGNsYXNzIHRocm91Z2ggdGhhdCBvZiB0aGUgY2xhc3Mgb2YgdGhlIG5ldyBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkIC0gdGhlIGh5cGVyZ3JpZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGRhdGFSb3dzIC0gYXJyYXkgb2YgdW5pZm9ybSBkYXRhIG9iamVjdHNcbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgZGF0YVJvd3MpIHtcbiAgICAgICAgdGhpcy5zZXREYXRhKGRhdGFSb3dzKTtcbiAgICB9LFxuXG4gICAgZmVhdHVyZXM6IFtcbiAgICAgICAgZmVhdHVyZXMuQ2VsbFNlbGVjdGlvbixcbiAgICAgICAgZmVhdHVyZXMuS2V5UGFnaW5nLFxuICAgICAgICBmZWF0dXJlcy5PdmVybGF5LFxuICAgICAgICBmZWF0dXJlcy5Db2x1bW5SZXNpemluZyxcbiAgICAgICAgZmVhdHVyZXMuUm93UmVzaXppbmcsXG4gICAgICAgIGZlYXR1cmVzLkZpbHRlcnMsXG4gICAgICAgIGZlYXR1cmVzLlJvd1NlbGVjdGlvbixcbiAgICAgICAgZmVhdHVyZXMuQ29sdW1uU2VsZWN0aW9uLFxuICAgICAgICBmZWF0dXJlcy5Db2x1bW5Nb3ZpbmcsXG4gICAgICAgIGZlYXR1cmVzLkNvbHVtblNvcnRpbmcsXG4gICAgICAgIGZlYXR1cmVzLkNlbGxFZGl0aW5nLFxuICAgICAgICBmZWF0dXJlcy5DZWxsQ2xpY2ssXG4gICAgICAgIGZlYXR1cmVzLk9uSG92ZXJcbiAgICBdLFxuXG4gICAgYWdncmVnYXRpb25zOiBhZ2dyZWdhdGlvbnMsXG5cbiAgICBjcmVhdGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGFNb2RlbCA9IHRoaXMuZ2V0RGF0YU1vZGVsKCk7XG4gICAgICAgIHZhciBjb2x1bW5Db3VudCA9IGRhdGFNb2RlbC5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgaGVhZGVycyA9IGRhdGFNb2RlbC5nZXRIZWFkZXJzKCk7XG4gICAgICAgIHZhciBmaWVsZHMgPSBkYXRhTW9kZWwuZ2V0RmllbGRzKCk7XG4gICAgICAgIHRoaXMuY2xlYXJDb2x1bW5zKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IGhlYWRlcnNbaV07XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5hZGRDb2x1bW4oaSwgaGVhZGVyKTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gY29sdW1uLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0RGF0YU1vZGVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3IERhdGFNb2RlbEpTT04oKTtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgRGF0YU1vZGVsRGVjb3JhdG9yKHRoaXMuZ2V0R3JpZCgpLCBtb2RlbCk7XG4gICAgICAgIHdyYXBwZXIuc2V0Q29tcG9uZW50KG1vZGVsKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBoZWFkZXIgbGFiZWxzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGhlYWRlckxhYmVscyAtIFRoZSBoZWFkZXIgbGFiZWxzLlxuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlckxhYmVscykge1xuICAgICAgICB0aGlzLmdldERhdGFNb2RlbCgpLnNldEhlYWRlcnMoaGVhZGVyTGFiZWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgaGVhZGVyIGxhYmVscy5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0SGVhZGVycygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCB0aGUgZmllbGRzIGFycmF5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgLSBUaGUgZmllbGQgbmFtZXMuXG4gICAgICovXG4gICAgc2V0RmllbGRzOiBmdW5jdGlvbihmaWVsZE5hbWVzKSB7XG4gICAgICAgIC8vd2VyZSBkZWZpbmluZyB0aGUgY29sdW1ucyBiYXNlZCBvbiBmaWVsZCBuYW1lcy4uLi5cbiAgICAgICAgLy93ZSBtdXN0IHJlYnVpbGQgdGhlIGNvbHVtbiBkZWZpbml0aW9uc1xuICAgICAgICB0aGlzLmdldERhdGFNb2RlbCgpLnNldEZpZWxkcyhmaWVsZE5hbWVzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBmaWVsZCBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0RmllbGRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBkYXRhIGZpZWxkLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IG9iamVjdHMgLSBBbiBhcnJheSBvZiB1bmlmb3JtIG9iamVjdHMsIGVhY2ggYmVpbmcgYSByb3cgaW4gdGhlIGdyaWQuXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oZGF0YVJvd3MpIHtcbiAgICAgICAgdGhpcy5nZXREYXRhTW9kZWwoKS5zZXREYXRhKGRhdGFSb3dzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZ2V0R3JpZCgpLmlzQ29sdW1uQXV0b3NpemluZygpKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXV0b3NpemVBbGxDb2x1bW5zKCk7XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgc2VsZi5jaGFuZ2VkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYWxsQ29sdW1uc1stMV0uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIGRhdGEgZmllbGQuXG4gICAgICovXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldERhdGEoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q2VsbEVkaXRvckF0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIGlmIChncmlkLmlzRmlsdGVyUm93KHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JpZC5jZWxsRWRpdG9ycy50ZXh0ZmllbGQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIHRvdGFscyBmaWVsZC5cbiAgICAgKiBAcGFyYW0ge2FycmF5fSBuZXN0ZWRBcnJheSAtIGFycmF5MkQgb2YgdG90YWxzIGRhdGFcbiAgICAgKi9cbiAgICBzZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKG5lc3RlZEFycmF5KSB7XG4gICAgICAgIHRoaXMuZ2V0RGF0YU1vZGVsKCkuc2V0VG9wVG90YWxzKG5lc3RlZEFycmF5KTtcbiAgICB9LFxuXG4gICAgZ2V0VG9wVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0VG9wVG90YWxzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgdGhlIGZpZWxkcyBhbmQgaGVhZGVycyBmcm9tIHRoZSBzdXBwbGllZCBjb2x1bW4gZGVmaW5pdGlvbnMuXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIG15SnNvbkJlaGF2aW9yLnNldENvbHVtbnMoW1xuICAgICAqICAgICB7IHRpdGxlOiAnU3RvY2sgTmFtZScsIGZpZWxkOiAnc2hvcnRfZGVzY3JpcHRpb24nIH0sXG4gICAgICogICAgIHsgdGl0bGU6ICdTdGF0dXMnLCBmaWVsZDogJ3RyYWRpbmdfcGhhc2UnIH0sXG4gICAgICogICAgIHsgdGl0bGU6ICdSZWZlcmVuY2UgUHJpY2UnLCBmaWVsZDogJ3JlZmVyZW5jZV9wcmljZScgfVxuICAgICAqIF0pO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbHVtbkRlZmluaXRpb25zIC0gYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGZpZWxkcyAndGl0bGUnLCBhbmQgJ2ZpZWxkJ1xuICAgICAqL1xuICAgIHNldENvbHVtbnM6IGZ1bmN0aW9uKGNvbHVtbkRlZmluaXRpb25zKSB7XG4gICAgICAgIHRoaXMuZ2V0RGF0YU1vZGVsKCkuc2V0Q29sdW1ucyhjb2x1bW5EZWZpbml0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gRW5oYW5jZSB0aGUgZG91YmxlLWNsaWNrIGV2ZW50IGp1c3QgYmVmb3JlIGl0J3MgYnJvYWRjYXN0IHRvIGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBldmVudFxuICAgICAqL1xuICAgIGVuaGFuY2VEb3VibGVDbGlja0V2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5yb3cgPSB0aGlzLmdldFJvdyhldmVudC5ncmlkQ2VsbC55KTtcbiAgICB9LFxuXG4gICAgc2V0RGF0YVByb3ZpZGVyOiBmdW5jdGlvbihkYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5nZXREYXRhTW9kZWwoKS5zZXREYXRhUHJvdmlkZXIoZGF0YVByb3ZpZGVyKTtcbiAgICB9LFxuXG4gICAgaGFzSGllcmFyY2h5Q29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuaGFzSGllcmFyY2h5Q29sdW1uKCk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkFsaWdubWVudDogZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoeCA9PT0gMCAmJiB0aGlzLmhhc0hpZXJhcmNoeUNvbHVtbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFJvd1NlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oc2VsZWN0ZWRSb3dzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldFJvd1NlbGVjdGlvbk1hdHJpeChzZWxlY3RlZFJvd3MpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5TZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKHNlbGVjdGVkQ29sdW1ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhTW9kZWwoKS5nZXRDb2x1bW5TZWxlY3Rpb25NYXRyaXgoc2VsZWN0ZWRDb2x1bW5zKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uTWF0cml4OiBmdW5jdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldFNlbGVjdGlvbk1hdHJpeChzZWxlY3Rpb25zKTtcbiAgICB9LFxuXG4gICAgZ2V0Um93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkUm93cyA9IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldFJvd1NlbGVjdGlvbihzZWxlY3RlZFJvd3MpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRDb2x1bW5zID0gdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0Q29sdW1uU2VsZWN0aW9uKHNlbGVjdGVkQ29sdW1ucyk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldFNlbGVjdGlvbihzZWxlY3Rpb25zKTtcbiAgICB9LFxuXG4gICAgb3BlbkVkaXRvcjogZnVuY3Rpb24oZGl2KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0NvbHVtblJlb3JkZXJhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFN0eWxlc2hlZXQoJ2RuZCcsIG51bGwpO1xuXG4gICAgICAgIHZhciBncm91cHMgPSB7IG1vZGVsczogdGhpcy5nZXRHcm91cHMoKSwgdGl0bGU6ICdHcm91cHMnIH0sXG4gICAgICAgICAgICBhdmFpbGFibGVHcm91cHMgPSB7IG1vZGVsczogdGhpcy5nZXRBdmFpbGFibGVHcm91cHMoKSwgdGl0bGU6ICdBdmFpbGFibGUgR3JvdXBzJyB9LFxuICAgICAgICAgICAgaGlkZGVuQ29sdW1ucyA9IHsgbW9kZWxzOiB0aGlzLmdldEhpZGRlbkNvbHVtbnMoKSwgdGl0bGU6ICdIaWRkZW4gQ2NvbHVtbnMnIH0sXG4gICAgICAgICAgICB2aXNpYmxlQ29sdW1ucyA9IHsgbW9kZWxzOiB0aGlzLmdldFZpc2libGVDb2x1bW5zKCksIHRpdGxlOiAnVmlzaWJsZSBDb2x1bW5zJ30sXG4gICAgICAgICAgICBncm91cExpc3RzID0gbmV3IExpc3REcmFnb24oW2dyb3VwcywgYXZhaWxhYmxlR3JvdXBzXSksXG4gICAgICAgICAgICBjb2x1bW5MaXN0cyA9IG5ldyBMaXN0RHJhZ29uKFtoaWRkZW5Db2x1bW5zLCB2aXNpYmxlQ29sdW1uc10pLFxuICAgICAgICAgICAgbGlzdFNldHMgPSBbZ3JvdXBMaXN0cywgY29sdW1uTGlzdHNdO1xuXG4gICAgICAgIGxpc3RTZXRzLmZvckVhY2goZnVuY3Rpb24obGlzdFNldCkge1xuICAgICAgICAgICAgbGlzdFNldC5tb2RlbExpc3RzLmZvckVhY2goZnVuY3Rpb24obGlzdCkge1xuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChsaXN0LmNvbnRhaW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9hdHRhY2ggZm9yIGxhdGVyIHJldHJpZXZhbFxuICAgICAgICBkaXYubGlzdHMgPSB7XG4gICAgICAgICAgICBncm91cDogZ3JvdXBzLm1vZGVscyxcbiAgICAgICAgICAgIGF2YWlsYWJsZUdyb3VwczogYXZhaWxhYmxlR3JvdXBzLm1vZGVscyxcbiAgICAgICAgICAgIGhpZGRlbjogaGlkZGVuQ29sdW1ucy5tb2RlbHMsXG4gICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmxlQ29sdW1ucy5tb2RlbHNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldEdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldEdyb3VwcygpO1xuICAgIH0sXG4gICAgZ2V0QXZhaWxhYmxlR3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0QXZhaWxhYmxlR3JvdXBzKCk7XG4gICAgfSxcbiAgICBnZXRIaWRkZW5Db2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0SGlkZGVuQ29sdW1ucygpO1xuICAgIH0sXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhTW9kZWwoKS5nZXRWaXNpYmxlQ29sdW1ucygpO1xuICAgIH0sXG4gICAgc2V0Q29sdW1uRGVzY3JpcHRvcnM6IGZ1bmN0aW9uKGxpc3RzKSB7XG4gICAgICAgIC8vYXNzdW1lcyB0aGVyZSBpcyBvbmUgcm93Li4uLlxuICAgICAgICB2YXIgdHJlZSA9IHRoaXMuY29sdW1uc1swXTtcbiAgICAgICAgdGhpcy5jb2x1bW5zLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh0cmVlICYmIHRyZWUubGFiZWwgPT09ICdUcmVlJykge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2godHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0cy52aXNpYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaChsaXN0cy52aXNpYmxlW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cEJ5cyA9IGxpc3RzLmdyb3VwLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2V0RGF0YU1vZGVsKCkuc2V0R3JvdXBzKGdyb3VwQnlzKTtcblxuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0ZWRSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IC10aGlzLmdldEdyaWQoKS5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0R3JpZCgpLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBzZWxlY3Rpb25zLm1hcChmdW5jdGlvbihlYWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZWFjaCArIG9mZnNldDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGVkQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5nZXRTZWxlY3Rpb25Nb2RlbCgpLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0aW9ucygpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJlaGF2aW9yID0gcmVxdWlyZSgnLi9CZWhhdmlvcicpO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge30sXG4gICAgbjAwcCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE51bGwgPSBCZWhhdmlvci5leHRlbmQoJ051bGwnLCB7XG5cbiAgICAvL2luaXRhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgY29tcG9uZW50KSB7fSxcblxuICAgIHNldFNjcm9sbFBvc2l0aW9uWTogbm9vcCxcbiAgICBzZXRTY3JvbGxQb3NpdGlvblg6IG5vb3AsXG4gICAgZ2V0Q29sdW1uQ291bnQ6IG4wMHAsXG4gICAgZ2V0Rml4ZWRDb2x1bW5Db3VudDogbjAwcCxcbiAgICBnZXRGaXhlZENvbHVtbnNXaWR0aDogbjAwcCxcbiAgICBnZXRGaXhlZENvbHVtbnNNYXhXaWR0aDogbjAwcCxcbiAgICBzZXRSZW5kZXJlZFdpZHRoOiBuMDBwLFxuICAgIGdldFJvd0NvdW50OiBuMDBwLFxuICAgIGdldEZpeGVkUm93Q291bnQ6IG4wMHAsXG4gICAgZ2V0Rml4ZWRSb3dzSGVpZ2h0OiBuMDBwLFxuICAgIGdldEZpeGVkUm93c01heEhlaWdodDogbjAwcCxcbiAgICBzZXRSZW5kZXJlZEhlaWdodDogbjAwcCxcbiAgICBnZXRDZWxsUHJvdmlkZXI6IG5vb3AsXG4gICAgY2xpY2s6IG5vb3AsXG4gICAgZG91YmxlQ2xpY2s6IG5vb3Bcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bGw7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxudmFyIGltYWdlcyA9IHJlcXVpcmUoJy4uLy4uL2ltYWdlcycpOyAvLyB0aGlzIGluZGV4LmpzIGlzIGdlbmVyYXRlZCBieSBndWxwIGFuZCBpZ25vcmVkIGJ5IGdpdFxuXG5fKGltYWdlcykuZWFjaChmdW5jdGlvbihpbWFnZSwga2V5KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcbiAgICBlbGVtZW50LnNyYyA9ICdkYXRhOicgKyBpbWFnZS50eXBlICsgJztiYXNlNjQsJyArIGltYWdlLmRhdGE7XG4gICAgaW1hZ2VzW2tleV0gPSBlbGVtZW50O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW1hZ2VzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBCZWhhdmlvcjogcmVxdWlyZSgnLi9CZWhhdmlvcicpLCAvLyBhYnN0cmFjdCBiYXNlIGNsYXNzXG4gICAgSlNPTjogcmVxdWlyZSgnLi9KU09OJyksXG4gICAgTnVsbDogcmVxdWlyZSgnLi9OdWxsJylcbn07IiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG11c3RhY2hlID0gcmVxdWlyZSgnbXVzdGFjaGUnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnZXh0ZW5kLW1lJykuQmFzZTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENlbGxFZGl0b3IgPSBCYXNlLmV4dGVuZCgnQ2VsbEVkaXRvcicsIHtcblxuICAgIGFsaWFzOiAnYmFzZScsXG5cbiAgICAvKipcbiAgICAgKiBhbSBJIGN1cnJlbnRseSBlZGl0aW5nIChpLmUuLCBiZXR3ZWVuIGNhbGxzIHRvIGBiZWdpbkVkaXRBdGAgYW5kIGVpdGhlciBgc3RvcEVkaXRpbmdgIG9yIGBjYW5jZWxFZGl0aW5nYClcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGlzRWRpdGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgcG9pbnQgdGhhdCBJIGFtIGVkaXRpbmcgYXQgcmlnaHQgbm93XG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlZGl0b3JQb2ludDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGlmIHRydWUsIGNoZWNrIHRoYXQgdGhlIGVkaXRvciBpcyBpbiB0aGUgcmlnaHQgbG9jYXRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNoZWNrRWRpdG9yUG9zaXRpb25GbGFnOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIG15IG1haW4gaW5wdXQgY29udHJvbFxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbnB1dDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIG15IGluc3RhbmNlIG9mIGh5cGVyZ3JpZFxuICAgICAqIEB0eXBlIHtIeXBlcmdyaWR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdyaWQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgdmFsdWUgYmVmb3JlIGVkaXRpbmdcbiAgICAgKiBAdHlwZSB7dHlwZX1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5pdGlhbFZhbHVlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBiZWhhdmlvciAobW9kZWwpXG4gICAgICogQHJldHVybnMge0JlaGF2aW9yfSBUaGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKi9cbiAgICBnZXRCZWhhdmlvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0QmVoYXZpb3IoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBmdW5jdGlvbiBpcyBhIGNhbGxiYWNrIGZyb20gdGhlIGZpbi1oeXBlcmdyaWQuICAgSXQgaXMgY2FsbGVkIGFmdGVyIGVhY2ggcGFpbnQgb2YgdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBncmlkUmVuZGVyZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoZWNrRWRpdG9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNjcm9sbCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLCB3ZSd2ZSBiZWVuIG5vdGlmaWVkXG4gICAgICovXG4gICAgc2Nyb2xsVmFsdWVDaGFuZ2VkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRDaGVja0VkaXRvclBvc2l0aW9uRmxhZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0dXJuIG9uIGNoZWNrRWRpdG9yUG9zaXRpb25GbGFnIGJvb2xlYW4gZmllbGRcbiAgICAgKi9cbiAgICBzZXRDaGVja0VkaXRvclBvc2l0aW9uRmxhZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tFZGl0b3JQb3NpdGlvbkZsYWcgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBiZWdpbiBlZGl0aW5nIGF0IGxvY2F0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSB0aGUgbG9jYXRpb24gdG8gc3RhcnQgZWRpdGluZyBhdFxuICAgICAqL1xuICAgIGJlZ2luRWRpdEF0OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB0aGlzLnNldEVkaXRvclBvaW50KHBvaW50KTtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICB2YXIgdmFsdWUgPSBtb2RlbC5nZXRWYWx1ZShwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheScpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbMV07IC8vaXQncyBhIG5lc3RlZCBvYmplY3RcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvY2VlZCA9IHRoaXMuZ3JpZC5maXJlUmVxdWVzdENlbGxFZGl0KHBvaW50LCB2YWx1ZSk7XG4gICAgICAgIGlmICghcHJvY2VlZCkge1xuICAgICAgICAgICAgLy93ZSB3ZXJlIGNhbmNlbGxlZFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2V0RWRpdG9yVmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0Q2hlY2tFZGl0b3JQb3NpdGlvbkZsYWcoKTtcbiAgICAgICAgdGhpcy5jaGVja0VkaXRvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBwdXQgdmFsdWUgaW50byBvdXIgZWRpdG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIC0gd2hhdGV2ZXIgdmFsdWUgd2Ugd2FudCB0byBlZGl0XG4gICAgICovXG4gICAgc2V0RWRpdG9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybnMgdGhlIHBvaW50IGF0IHdoaWNoIHdlIGFyZSBjdXJyZW50bHkgZWRpdGluZ1xuICAgICAqIEByZXR1cm5zIHtQb2ludH1cbiAgICAgKi9cbiAgICBnZXRFZGl0b3JQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvclBvaW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIGN1cnJlbnQgZWRpdG9yIGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSB0aGUgZGF0YSBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCBlZGl0b3JcbiAgICAgKi9cbiAgICBzZXRFZGl0b3JQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdGhpcy5lZGl0b3JQb2ludCA9IHBvaW50O1xuICAgICAgICB0aGlzLm1vZGVsUG9pbnQgPSB0aGlzLmdldEdyaWQoKS5jb252ZXJ0Vmlld1BvaW50VG9EYXRhUG9pbnQocG9pbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkaXNwbGF5IHRoZSBlZGl0b3JcbiAgICAgKi9cbiAgICBzaG93RWRpdG9yOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGlkZSB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgaGlkZUVkaXRvcjogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHN0b3AgZWRpdGluZ1xuICAgICAqL1xuICAgIHN0b3BFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9jZWVkID0gdGhpcy5nZXRHcmlkKCkuZmlyZVN5bnRoZXRpY0VkaXRvckRhdGFDaGFuZ2VFdmVudCh0aGlzLCB0aGlzLmluaXRpYWxWYWx1ZSwgdGhpcy5nZXRFZGl0b3JWYWx1ZSwgdGhpcyk7XG4gICAgICAgIGlmICghcHJvY2VlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2F2ZUVkaXRvclZhbHVlKCk7XG4gICAgICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZUVkaXRvcigpO1xuICAgIH0sXG5cbiAgICBjYW5jZWxFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZUVkaXRvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzYXZlIHRoZSBuZXcgdmFsdWUgaW50byB0aGUgYmVoYXZpb3IobW9kZWwpXG4gICAgICovXG4gICAgc2F2ZUVkaXRvclZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5nZXRFZGl0b3JQb2ludCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldEVkaXRvclZhbHVlKCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5pbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy9kYXRhIGRpZG4ndCBjaGFuZ2UgZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250aW51ZWQgPSB0aGlzLmdldEdyaWQoKS5maXJlQmVmb3JlQ2VsbEVkaXQocG9pbnQsIHRoaXMuaW5pdGlhbFZhbHVlLCB2YWx1ZSwgdGhpcyk7XG4gICAgICAgIGlmICghY29udGludWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLnNldFZhbHVlKHBvaW50LngsIHBvaW50LnksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5nZXRHcmlkKCkuZmlyZUFmdGVyQ2VsbEVkaXQocG9pbnQsIHRoaXMuaW5pdGlhbFZhbHVlLCB2YWx1ZSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgY3VycmVudCBlZGl0b3IncyB2YWx1ZVxuICAgICAqL1xuICAgIGdldEVkaXRvclZhbHVlOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmVxdWVzdCBmb2N1cyBmb3IgbXkgaW5wdXQgY29udHJvbFxuICAgICAqL1xuICAgIHRha2VGb2N1czogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIG1vdmUgdGhlIGVkaXRvciB0byB0aGUgY3VycmVudCBlZGl0b3IgcG9pbnRcbiAgICAgKi9cbiAgICBfbW92ZUVkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIHZhciBlZGl0b3JQb2ludCA9IHRoaXMuZ2V0RWRpdG9yUG9pbnQoKTtcbiAgICAgICAgdmFyIGNlbGxCb3VuZHMgPSBncmlkLl9nZXRCb3VuZHNPZkNlbGwoZWRpdG9yUG9pbnQueCwgZWRpdG9yUG9pbnQueSk7XG5cbiAgICAgICAgLy9oYWNrIHRvIGFjY29tb2RhdGUgYm9vdHN0cmFwIG1hcmdpbiBpc3N1ZXMuLi5cbiAgICAgICAgdmFyIHhPZmZzZXQgPSBncmlkLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gZ3JpZC5kaXZDYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgY2VsbEJvdW5kcy54ID0gY2VsbEJvdW5kcy54IC0geE9mZnNldDtcblxuICAgICAgICB0aGlzLnNldEJvdW5kcyhjZWxsQm91bmRzKTtcbiAgICB9LFxuXG4gICAgbW92ZUVkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX21vdmVFZGl0b3IoKTtcbiAgICAgICAgdGhpcy50YWtlRm9jdXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBib3VuZHMgb2YgbXkgaW5wdXQgY29udHJvbFxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSB0aGUgYm91bmRzIHRvIG1vdmUgdG9cbiAgICAgKi9cbiAgICBzZXRCb3VuZHM6IGZ1bmN0aW9uKHJlY3RhbmdsZSkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjaGVjayB0aGF0IHRoZSBlZGl0b3IgaXMgaW4gdGhlIGNvcnJlY3QgbG9jYXRpb24sIGFuZCBpcyBzaG93aW5nL2hpZGRlbiBhcHByb3ByaWF0ZWx5XG4gICAgICovXG4gICAgY2hlY2tFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tFZGl0b3JQb3NpdGlvbkZsYWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tFZGl0b3JQb3NpdGlvbkZsYWcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVkaXRvclBvaW50ID0gdGhpcy5nZXRFZGl0b3JQb2ludCgpO1xuICAgICAgICBpZiAodGhpcy5ncmlkLmlzRGF0YVZpc2libGUoZWRpdG9yUG9pbnQueCwgZWRpdG9yUG9pbnQueSkpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUVkaXRvcigpO1xuICAgICAgICAgICAgdGhpcy5zaG93RWRpdG9yKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVFZGl0b3IoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRHcmlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZDtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKlxuXG4gICAgICAgICAqL1xuICAgIH0sXG5cbiAgICBnZXRIVE1MOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IHRoaXMudGVtcGxhdGUudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIHN0cmluZy5zaGlmdCgpO1xuICAgICAgICBzdHJpbmcuc2hpZnQoKTtcbiAgICAgICAgc3RyaW5nLmxlbmd0aCA9IHN0cmluZy5sZW5ndGggLSAyO1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcuam9pbignXFxuJykudHJpbSgpO1xuICAgICAgICByZXR1cm4gbXVzdGFjaGUucmVuZGVyKHN0cmluZywgdGhpcyk7XG4gICAgfSxcblxuICAgIGdldElucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5nZXREZWZhdWx0SW5wdXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dDtcbiAgICB9LFxuXG4gICAgZ2V0RGVmYXVsdElucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGhpcy5nZXRIVE1MKCk7XG4gICAgICAgIHZhciBpbnB1dCA9IGRpdi5maXJzdENoaWxkO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVJbnB1dChpbnB1dCk7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9LFxuXG4gICAgdXBkYXRlVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvbGRHdXkgPSB0aGlzLmdldElucHV0KCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBvbGRHdXkucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIG5ld0d1eSA9IHRoaXMuZ2V0RGVmYXVsdElucHV0KCk7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBuZXdHdXk7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobmV3R3V5LCBvbGRHdXkpO1xuICAgIH0sXG5cbiAgICBpbml0aWFsaXplSW5wdXQ6IGZ1bmN0aW9uKGlucHV0KSB7fSxcblxuICAgIHNob3dEcm9wZG93bjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB2YXIgZXZlbnQ7XG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG4gICAgICAgIGV2ZW50LmluaXRNb3VzZUV2ZW50KCdtb3VzZWRvd24nLCB0cnVlLCB0cnVlLCB3aW5kb3cpO1xuICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbEVkaXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNpbXBsZSA9IHJlcXVpcmUoJy4vU2ltcGxlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDaG9pY2UgPSBTaW1wbGUuZXh0ZW5kKCdDaG9pY2UnLCB7XG5cbiAgICAvKipcbiAgICAgKiBteSBsb29rdXAgYWxpYXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBDaG9pY2UucHJvdG90eXBlXG4gICAgICovXG4gICAgYWxpYXM6ICdjaG9pY2UnLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGxpc3Qgb2YgaXRlbXMgdG8gcGljayBmcm9tXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBtZW1iZXJPZiBDaG9pY2UucHJvdG90eXBlXG4gICAgICovXG4gICAgaXRlbXM6IFsnYScsICdiJywgJ2MnXSxcblxuICAgIHRlbXBsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgICAgICA8c2VsZWN0IGlkPVwiZWRpdG9yXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7I2l0ZW1zfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJ7ey59fVwiPnt7Ln19PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIHt7L2l0ZW1zfX1cbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICovXG4gICAgfSxcblxuICAgIC8vbm8gZXZlbnRzIGFyZSBmaXJlZCB3aGlsZSB0aGUgZHJvcGRvd24gaXMgb3BlblxuICAgIC8vc2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvbTR0bmR0dTQvNi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDaG9pY2UucHJvdG90eXBlXG4gICAgICovXG4gICAgc2hvd0VkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5pbnB1dC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnNob3dEcm9wZG93bihzZWxmLmlucHV0KTtcbiAgICAgICAgfSwgNTApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2hvaWNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBpdGVtc1xuICAgICAqL1xuICAgIHNldEl0ZW1zOiBmdW5jdGlvbihpdGVtcykge1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMudXBkYXRlVmlldygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2hvaWNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqL1xuICAgIGluaXRpYWxpemVJbnB1dDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBTaW1wbGUucHJvdG90eXBlLmluaXRpYWxpemVJbnB1dChpbnB1dCk7XG4gICAgICAgIGlucHV0Lm9uY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaG9pY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTaW1wbGUgPSByZXF1aXJlKCcuL1NpbXBsZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sb3IgPSBTaW1wbGUuZXh0ZW5kKCdDb2xvcicsIHtcblxuICAgIC8qKlxuICAgICAqIG15IGxvb2t1cCBhbGlhc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIENvbG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFsaWFzOiAnY29sb3InLFxuXG4gICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKlxuICAgICAgICAgICAgPGlucHV0IGlkPVwiZWRpdG9yXCIgdHlwZT1cImNvbG9yXCI+XG4gICAgICAgICovXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNpbXBsZSA9IHJlcXVpcmUoJy4vU2ltcGxlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRlID0gU2ltcGxlLmV4dGVuZCgnRGF0ZScsIHtcblxuICAgIC8qKlxuICAgICAqIG15IGxvb2t1cCBhbGlhc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIERhdGUucHJvdG90eXBlXG4gICAgICovXG4gICAgYWxpYXM6ICdkYXRlJyxcblxuICAgIHRlbXBsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cImVkaXRvclwiIHR5cGU9XCJkYXRlXCI+XG4gICAgICAgICovXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvci5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU2ltcGxlID0gQ2VsbEVkaXRvci5leHRlbmQoJ1NpbXBsZScsIHtcblxuICAgIC8qKlxuICAgICAqIG15IGxvb2t1cCBhbGlhc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIFNpbXBsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhbGlhczogJ3NpbXBsZScsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVkaXRvclBvaW50ID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNpbXBsZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyAgdGhlIGZ1bmN0aW9uIHRvIG92ZXJyaWRlIGZvciBpbml0aWFsaXphdGlvblxuICAgICAqL1xuICAgIGluaXRpYWxpemVJbnB1dDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlICYmIChlLmtleUNvZGUgPT09IDEzIHx8IGUua2V5Q29kZSA9PT0gMjcgfHwgZS5rZXlDb2RlID09PSA4KSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXJTdG9wRWRpdGluZygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbmNlbEVkaXRpbmcoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0R3JpZCgpLnJlcGFpbnQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmdldEdyaWQoKS50YWtlRm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZ2V0R3JpZCgpLmZpcmVTeW50aGV0aWNFZGl0b3JLZXlVcEV2ZW50KHNlbGYsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHNlbGYuZ2V0R3JpZCgpLmZpcmVTeW50aGV0aWNFZGl0b3JLZXlEb3duRXZlbnQoc2VsZiwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdrZXlwcmVzcycsIGUua2V5Q29kZSk7XG4gICAgICAgICAgICBzZWxmLmdldEdyaWQoKS5maXJlU3ludGhldGljRWRpdG9yS2V5UHJlc3NFdmVudChzZWxmLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgICBzZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgICBzZWxmLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICBpbnB1dC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGlucHV0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGlucHV0LnN0eWxlLmJvcmRlciA9ICdzb2xpZCAycHggYmxhY2snO1xuICAgICAgICBpbnB1dC5zdHlsZS5vdXRsaW5lID0gMDtcbiAgICAgICAgaW5wdXQuc3R5bGUucGFkZGluZyA9IDA7XG4gICAgICAgIGlucHV0LnN0eWxlLnpJbmRleCA9IDEwMDA7XG4gICAgICAgIGlucHV0LnN0eWxlLmZvbnRTaXplID0gJzhwdCc7XG4gICAgICAgIGlucHV0LnN0eWxlLmJveFNoYWRvdyA9ICd3aGl0ZSAwcHggMHB4IDFweCAxcHgnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBjdXJyZW50IGVkaXRvcidzIHZhbHVlXG4gICAgICovXG4gICAgZ2V0RWRpdG9yVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldElucHV0KCkudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNpbXBsZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzYXZlIHRoZSBuZXcgdmFsdWUgaW50byB0aGUgYmVoYXZpb3IobW9kZWwpXG4gICAgICovXG4gICAgc2V0RWRpdG9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2V0SW5wdXQoKS52YWx1ZSA9IHZhbHVlICsgJyc7XG4gICAgfSxcblxuICAgIGNsZWFyU3RvcEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldEVkaXRvclZhbHVlKCcnKTtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgIH0sXG5cbiAgICBjYW5jZWxFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0SW5wdXQoKS52YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZUVkaXRvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRpc3BsYXkgdGhlIGVkaXRvclxuICAgICAqL1xuICAgIHNob3dFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldElucHV0KCkuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhpZGUgdGhlIGVkaXRvclxuICAgICAqL1xuICAgIGhpZGVFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldElucHV0KCkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNpbXBsZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXF1ZXN0IGZvY3VzIGZvciBteSBpbnB1dCBjb250cm9sXG4gICAgICovXG4gICAgdGFrZUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RBbGwoKTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNpbXBsZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZWxlY3QgZXZlcnl0aGluZ1xuICAgICAqL1xuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNpbXBsZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBob3cgbXVjaCBzaG91bGQgSSBvZmZzZXQgbXkgYm91bmRzIGZyb20gMCwwXG4gICAgICovXG4gICAgb3JpZ2luT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNpbXBsZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIGJvdW5kcyBvZiBteSBpbnB1dCBjb250cm9sXG4gICAgICogQHBhcmFtIHtyZWN0YW5nbGV9IHJlY3RhbmdsZSAtIHRoZSBib3VuZHMgdG8gbW92ZSB0b1xuICAgICAqL1xuICAgIHNldEJvdW5kczogZnVuY3Rpb24oY2VsbEJvdW5kcykge1xuICAgICAgICB2YXIgb3JpZ2luT2Zmc2V0ID0gdGhpcy5vcmlnaW5PZmZzZXQoKTtcbiAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gJ3RyYW5zbGF0ZSgnXG4gICAgICAgICAgICArIChjZWxsQm91bmRzLnggLSAxICsgb3JpZ2luT2Zmc2V0WzBdKSArICdweCwnXG4gICAgICAgICAgICArIChjZWxsQm91bmRzLnkgLSAxICsgb3JpZ2luT2Zmc2V0WzFdKSArICdweCknO1xuXG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXQoKTtcblxuICAgICAgICBpbnB1dC5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG5cbiAgICAgICAgaW5wdXQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNsYXRpb247XG4gICAgICAgIGlucHV0LnN0eWxlLk1velRyYW5zZm9ybSA9IHRyYW5zbGF0aW9uO1xuICAgICAgICBpbnB1dC5zdHlsZS5tc1RyYW5zZm9ybSA9IHRyYW5zbGF0aW9uO1xuICAgICAgICBpbnB1dC5zdHlsZS5PVHJhbnNmb3JtID0gdHJhbnNsYXRpb247XG5cbiAgICAgICAgLy8gaW5wdXQuc3R5bGUubGVmdCA9IGNlbGxCb3VuZHMueCArIG9yaWdpbk9mZnNldFswXSArICdweCc7XG4gICAgICAgIC8vIGlucHV0LnN0eWxlLnRvcCA9IGNlbGxCb3VuZHMueSArIG9yaWdpbk9mZnNldFsxXSArICdweCc7XG5cbiAgICAgICAgaW5wdXQuc3R5bGUud2lkdGggPSAoY2VsbEJvdW5kcy53aWR0aCArIDIpICsgJ3B4JztcbiAgICAgICAgaW5wdXQuc3R5bGUuaGVpZ2h0ID0gKGNlbGxCb3VuZHMuaGVpZ2h0ICsgMikgKyAncHgnO1xuICAgICAgICAvL3ZhciB4T2Zmc2V0ID0gdGhpcy5ncmlkLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2ltcGxlID0gcmVxdWlyZSgnLi9TaW1wbGUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNsaWRlciA9IFNpbXBsZS5leHRlbmQoJ1NsaWRlcicsIHtcblxuICAgIC8qKlxuICAgICAqIG15IGxvb2t1cCBhbGlhc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIFNsaWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhbGlhczogJ3NsaWRlcicsXG5cbiAgICB0ZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XCJlZGl0b3JcIiB0eXBlPVwicmFuZ2VcIj5cbiAgICAgICAgKi9cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNsaWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNpbXBsZSA9IHJlcXVpcmUoJy4vU2ltcGxlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTcGlubmVyID0gU2ltcGxlLmV4dGVuZCgnU3Bpbm5lcicsIHtcblxuICAgIC8qKlxuICAgICAqIG15IGxvb2t1cCBhbGlhc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIFNwaW5uZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgYWxpYXM6ICdzcGlubmVyJyxcblxuICAgIHRlbXBsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cImVkaXRvclwiIHR5cGU9XCJudW1iZXJcIj5cbiAgICAgICAgKi9cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwaW5uZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTaW1wbGUgPSByZXF1aXJlKCcuL1NpbXBsZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVGV4dGZpZWxkID0gU2ltcGxlLmV4dGVuZCgnVGV4dGZpZWxkJywge1xuXG4gICAgLyoqXG4gICAgICogbXkgbG9va3VwIGFsaWFzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgVGV4dGZpZWxkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFsaWFzOiAndGV4dGZpZWxkJyxcblxuICAgIHRlbXBsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cImVkaXRvclwiPlxuICAgICAgICAqL1xuICAgIH0sXG5cbiAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKDAsIHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0ZmllbGQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIENlbGxFZGl0b3I6IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpLCAvLyBhYnN0cmFjdCBiYXNlIGNsYXNzXG4gICAgVGV4dGZpZWxkOiByZXF1aXJlKCcuL1RleHRmaWVsZCcpLFxuICAgIENob2ljZTogcmVxdWlyZSgnLi9DaG9pY2UnKSxcbiAgICAvL0NvbWJvOiByZXF1aXJlKCcuL0NvbWJvJyksXG4gICAgQ29sb3I6IHJlcXVpcmUoJy4vQ29sb3InKSxcbiAgICBEYXRlOiByZXF1aXJlKCcuL0RhdGUnKSxcbiAgICBTbGlkZXI6IHJlcXVpcmUoJy4vU2xpZGVyJyksXG4gICAgU3Bpbm5lcjogcmVxdWlyZSgnLi9TcGlubmVyJylcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2V4dGVuZC1tZScpLkJhc2U7XG5cbnZhciBBID0gJ0EnLmNoYXJDb2RlQXQoMCk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhTW9kZWwgPSBCYXNlLmV4dGVuZCgnRGF0YU1vZGVsJywge1xuXG4gICAgbmV4dDogbnVsbCxcblxuICAgIGdyaWQ6IG51bGwsXG5cbiAgICBzZXRHcmlkOiBmdW5jdGlvbihuZXdHcmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ld0dyaWQ7XG4gICAgfSxcblxuICAgIGdldEdyaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkO1xuICAgIH0sXG5cbiAgICBnZXRCZWhhdmlvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5nZXRCZWhhdmlvcigpO1xuICAgIH0sXG5cbiAgICBjaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgZ2V0UHJpdmF0ZVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBhcHBseVN0YXRlOiBmdW5jdGlvbigpIHtcblxuICAgIH0sXG5cbiAgICBhbHBoYUZvcjogZnVuY3Rpb24oaSkge1xuICAgICAgICAvLyBOYW1lIHRoZSBjb2x1bW4gaGVhZGVycyBpbiBBLCAuLiwgQUEsIEFCLCBBQywgLi4sIEFaIGZvcm1hdFxuICAgICAgICAvLyBxdW90aWVudC9yZW1haW5kZXJcbiAgICAgICAgLy92YXIgcXVvID0gTWF0aC5mbG9vcihjb2wvMjcpO1xuICAgICAgICB2YXIgcXVvID0gTWF0aC5mbG9vcihpIC8gMjYpO1xuICAgICAgICB2YXIgcmVtID0gaSAlIDI2O1xuICAgICAgICB2YXIgY29kZSA9ICcnO1xuICAgICAgICBpZiAocXVvID4gMCkge1xuICAgICAgICAgICAgY29kZSArPSB0aGlzLmFscGhhKHF1byAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGUgKz0gdGhpcy5hbHBoYShyZW0pO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9LFxuXG4gICAgYWxwaGE6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQSArIGkpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU1vZGVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5hbHl0aWNzID0gcmVxdWlyZSgnaHlwZXItYW5hbHl0aWNzJyk7XG4vL3ZhciBhbmFseXRpY3MgPSByZXF1aXJlKCcuLi9sb2NhbF9ub2RlX21vZHVsZXMvbmV3YW5hbHl0aWNzJyk7XG4vL3ZhciBhbmFseXRpY3MgPSByZXF1aXJlKCcuLi9sb2NhbF9ub2RlX21vZHVsZXMvZmluYW5hbHl0aWNzJyk7XG52YXIgRGF0YU1vZGVsID0gcmVxdWlyZSgnLi9EYXRhTW9kZWwnKTtcblxudmFyIFVQV0FSRFNfQkxBQ0tfQVJST1cgPSAnXFx1MmIwNicsXG4gICAgRE9XTldBUkRTX0JMQUNLX0FSUk9XID0gJ1xcdTJiMDcnO1xuXG52YXIgbnVsbERhdGFTb3VyY2UgPSB7XG4gICAgaXNOdWxsT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBnZXRHcmFuZFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGhhc0FnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBoYXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBnZXRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBuYW1lIGRhdGFNb2RlbHMuSlNPTlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBKU09OID0gRGF0YU1vZGVsLmV4dGVuZCgnZGF0YU1vZGVscy5KU09OJywge1xuXG4gICAgLy9udWxsIG9iamVjdCBwYXR0ZXJuIGZvciB0aGUgc291cmNlIG9iamVjdFxuICAgIHNvdXJjZTogbnVsbERhdGFTb3VyY2UsXG5cbiAgICBwcmVnbG9iYWxmaWx0ZXI6IG51bGxEYXRhU291cmNlLFxuICAgIHByZWZpbHRlcjogbnVsbERhdGFTb3VyY2UsXG5cbiAgICBwcmVzb3J0ZXI6IG51bGxEYXRhU291cmNlLFxuICAgIGFuYWx5dGljczogbnVsbERhdGFTb3VyY2UsXG4gICAgcG9zdGZpbHRlcjogbnVsbERhdGFTb3VyY2UsXG4gICAgcG9zdHNvcnRlcjogbnVsbERhdGFTb3VyY2UsXG5cbiAgICB0b3BUb3RhbHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNBZ2dyZWdhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5hbHl0aWNzLmhhc0FnZ3JlZ2F0ZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmFseXRpY3MuaGFzR3JvdXBzKCk7XG4gICAgfSxcblxuICAgIGdldERhdGFTb3VyY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmFseXRpY3M7IC8vdGhpcy5oYXNBZ2dyZWdhdGVzKCkgPyB0aGlzLmFuYWx5dGljcyA6IHRoaXMucHJlc29ydGVyO1xuICAgIH0sXG5cbiAgICBnZXRGaWx0ZXJTb3VyY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVmaWx0ZXI7IC8vdGhpcy5oYXNBZ2dyZWdhdGVzKCkgPyB0aGlzLnBvc3RmaWx0ZXIgOiB0aGlzLnByZWZpbHRlcjtcbiAgICB9LFxuXG4gICAgZ2V0U29ydGluZ1NvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXNvcnRlcjsgLy90aGlzLmhhc0FnZ3JlZ2F0ZXMoKSA/IHRoaXMucG9zdHNvcnRlciA6IHRoaXMucHJlc29ydGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgaGFzSGllcmFyY2h5Q29sdW1uID0gdGhpcy5oYXNIaWVyYXJjaHlDb2x1bW4oKTtcbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdldEdyaWQoKTtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmIChoYXNIaWVyYXJjaHlDb2x1bW4gJiYgeCA9PT0gLTIpIHtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5IDwgaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRIZWFkZXJSb3dWYWx1ZSh4LCB5KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzSGllcmFyY2h5Q29sdW1uKSB7XG4gICAgICAgICAgICB5ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB0aGlzLmdldERhdGFTb3VyY2UoKS5nZXRWYWx1ZSh4LCB5IC0gaGVhZGVyUm93Q291bnQpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldEhlYWRlclJvd1ZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEhlYWRlcnMoKVtNYXRoLm1heCh4LCAwKV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdldEdyaWQoKTtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gZ3JpZC5nZXRCZWhhdmlvcigpO1xuICAgICAgICB2YXIgaXNGaWx0ZXJSb3cgPSBncmlkLmlzU2hvd0ZpbHRlclJvdygpO1xuICAgICAgICB2YXIgaXNIZWFkZXJSb3cgPSBncmlkLmlzU2hvd0hlYWRlclJvdygpO1xuICAgICAgICB2YXIgaXNCb3RoID0gaXNGaWx0ZXJSb3cgJiYgaXNIZWFkZXJSb3c7XG4gICAgICAgIHZhciB0b3BUb3RhbHNPZmZzZXQgPSAoaXNGaWx0ZXJSb3cgPyAxIDogMCkgKyAoaXNIZWFkZXJSb3cgPyAxIDogMCk7XG4gICAgICAgIGlmICh5ID49IHRvcFRvdGFsc09mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9wVG90YWxzKClbeSAtIHRvcFRvdGFsc09mZnNldF1beF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuZ2V0RmlsdGVyKHgpO1xuICAgICAgICB2YXIgaW1hZ2UgPSBmaWx0ZXIubGVuZ3RoID09PSAwID8gJ2ZpbHRlci1vZmYnIDogJ2ZpbHRlci1vbic7XG4gICAgICAgIHZhciBoZWFkZXIsIHNvcnRTdHJpbmc7XG4gICAgICAgIGlmIChpc0JvdGgpIHtcbiAgICAgICAgICAgIGlmICh5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyID0gdGhpcy5nZXRIZWFkZXJzKClbeF07XG4gICAgICAgICAgICAgICAgc29ydFN0cmluZyA9IHRoaXMuZ2V0U29ydEltYWdlRm9yQ29sdW1uKHgsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChzb3J0U3RyaW5nKSB7IGhlYWRlciA9IHNvcnRTdHJpbmcgKyBoZWFkZXI7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW251bGwsIGhlYWRlciwgbnVsbF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbnVsbCwgZmlsdGVyLCBiZWhhdmlvci5nZXRJbWFnZShpbWFnZSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzRmlsdGVyUm93KSB7XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIGZpbHRlciwgYmVoYXZpb3IuZ2V0SW1hZ2UoaW1hZ2UpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRlciA9IHRoaXMuZ2V0SGVhZGVycygpW3hdO1xuICAgICAgICAgICAgc29ydFN0cmluZyA9IHRoaXMuZ2V0U29ydEltYWdlRm9yQ29sdW1uKHgsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHNvcnRTdHJpbmcpIHsgaGVhZGVyID0gc29ydFN0cmluZyArIGhlYWRlcjsgfVxuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBoZWFkZXIsIG51bGxdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHZhciBoYXNIaWVyYXJjaHlDb2x1bW4gPSB0aGlzLmhhc0hpZXJhcmNoeUNvbHVtbigpO1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIGlmIChoYXNIaWVyYXJjaHlDb2x1bW4pIHtcbiAgICAgICAgICAgIGlmICh4ID09PSAtMikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh5IDwgaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVyUm93VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0hpZXJhcmNoeUNvbHVtbikge1xuICAgICAgICAgICAgeSArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nZXREYXRhU291cmNlKCkuc2V0VmFsdWUoeCwgeSAtIGhlYWRlclJvd0NvdW50LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHNldEhlYWRlclJvd1ZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldEhlYWRlcih4LCB5KTsgLy8geSBpcyByZWFsbHkgdGhlIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdldEdyaWQoKTtcbiAgICAgICAgdmFyIGlzRmlsdGVyUm93ID0gZ3JpZC5pc1Nob3dGaWx0ZXJSb3coKTtcbiAgICAgICAgdmFyIGlzSGVhZGVyUm93ID0gZ3JpZC5pc1Nob3dIZWFkZXJSb3coKTtcbiAgICAgICAgdmFyIGlzQm90aCA9IGlzRmlsdGVyUm93ICYmIGlzSGVhZGVyUm93O1xuICAgICAgICB2YXIgdG9wVG90YWxzT2Zmc2V0ID0gKGlzRmlsdGVyUm93ID8gMSA6IDApICsgKGlzSGVhZGVyUm93ID8gMSA6IDApO1xuICAgICAgICBpZiAoeSA+PSB0b3BUb3RhbHNPZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9wVG90YWxzKClbeSAtIHRvcFRvdGFsc09mZnNldF1beF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBjYW4ndCBjaGFuZ2UgdGhlIHJvdyBudW1iZXJzXG4gICAgICAgIH0gZWxzZSBpZiAoaXNCb3RoKSB7XG4gICAgICAgICAgICBpZiAoeSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRIZWFkZXIoeCwgdmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZpbHRlcih4LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGaWx0ZXJSb3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RmlsdGVyKHgsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRIZWFkZXIoeCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICAvL2FjY2VzcyBkaXJlY3RseSBiZWNhdXNlIHdlIHdhbnQgaXQgb3JkZXJlZFxuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRCZWhhdmlvcigpLmFsbENvbHVtbnNbY29sSW5kZXhdO1xuICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldEZpbHRlcjogZnVuY3Rpb24oY29sSW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbHVtblByb3BlcnRpZXMgPSB0aGlzLmdldENvbHVtblByb3BlcnRpZXMoY29sSW5kZXgpO1xuICAgICAgICBpZiAoIWNvbHVtblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1uUHJvcGVydGllcy5maWx0ZXIgfHwgJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgc2V0RmlsdGVyOiBmdW5jdGlvbihjb2xJbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbHVtblByb3BlcnRpZXMgPSB0aGlzLmdldENvbHVtblByb3BlcnRpZXMoY29sSW5kZXgpO1xuICAgICAgICBjb2x1bW5Qcm9wZXJ0aWVzLmZpbHRlciA9IHZhbHVlO1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuYWx5dGljcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpO1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmdldERhdGFTb3VyY2UoKS5nZXRSb3dDb3VudCgpO1xuICAgICAgICBjb3VudCArPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuYWx5dGljcy5nZXRIZWFkZXJzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVyc1xuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5nZXREYXRhU291cmNlKCkuc2V0SGVhZGVycyhoZWFkZXJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZHNcbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICB0aGlzLmdldERhdGFTb3VyY2UoKS5zZXRGaWVsZHMoZmllbGRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YVNvdXJjZSgpLmdldEZpZWxkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGRhdGFSb3dzXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oZGF0YVJvd3MpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBuZXcgYW5hbHl0aWNzLkpTRGF0YVNvdXJjZShkYXRhUm93cyk7XG4gICAgICAgIHRoaXMucHJlZ2xvYmFsZmlsdGVyID0gbmV3IGFuYWx5dGljcy5EYXRhU291cmNlR2xvYmFsRmlsdGVyKHRoaXMuc291cmNlKTtcbiAgICAgICAgdGhpcy5wcmVmaWx0ZXIgPSBuZXcgYW5hbHl0aWNzLkRhdGFTb3VyY2VGaWx0ZXIodGhpcy5wcmVnbG9iYWxmaWx0ZXIpO1xuICAgICAgICB0aGlzLnByZXNvcnRlciA9IG5ldyBhbmFseXRpY3MuRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSh0aGlzLnByZWZpbHRlcik7XG4gICAgICAgIHRoaXMuYW5hbHl0aWNzID0gbmV3IGFuYWx5dGljcy5EYXRhU291cmNlQWdncmVnYXRvcih0aGlzLnByZXNvcnRlcik7XG5cbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuXG4gICAgICAgIC8vdGhpcy5wb3N0ZmlsdGVyID0gbmV3IGFuYWx5dGljcy5EYXRhU291cmNlRmlsdGVyKHRoaXMuYW5hbHl0aWNzKTtcbiAgICAgICAgLy90aGlzLnBvc3Rzb3J0ZXIgPSBuZXcgYW5hbHl0aWNzLkRhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUodGhpcy5wb3N0ZmlsdGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQWdncmVnYXRlcygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3BUb3RhbHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YVNvdXJjZSgpLmdldEdyYW5kVG90YWxzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIG5lc3RlZEFycmF5XG4gICAgICovXG4gICAgc2V0VG9wVG90YWxzOiBmdW5jdGlvbihuZXN0ZWRBcnJheSkge1xuICAgICAgICB0aGlzLnRvcFRvdGFscyA9IG5lc3RlZEFycmF5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBncm91cHNcbiAgICAgKi9cbiAgICBzZXRHcm91cHM6IGZ1bmN0aW9uKGdyb3Vwcykge1xuICAgICAgICB0aGlzLmFuYWx5dGljcy5zZXRHcm91cEJ5cyhncm91cHMpO1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgICAgIHRoaXMuZ2V0R3JpZCgpLmZpcmVTeW50aGV0aWNHcm91cHNDaGFuZ2VkRXZlbnQodGhpcy5nZXRHcm91cHMoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5nZXRIZWFkZXJzKCkuc2xpY2UoMCk7XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpLnNsaWNlKDApO1xuICAgICAgICB2YXIgZ3JvdXBCeXMgPSB0aGlzLmFuYWx5dGljcy5ncm91cEJ5cztcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQnlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBoZWFkZXJzW2dyb3VwQnlzW2ldXTtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogZ3JvdXBCeXNbaV0sXG4gICAgICAgICAgICAgICAgbGFiZWw6IGZpZWxkLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEF2YWlsYWJsZUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5zb3VyY2UuZ2V0SGVhZGVycygpLnNsaWNlKDApO1xuICAgICAgICB2YXIgZ3JvdXBCeXMgPSB0aGlzLmFuYWx5dGljcy5ncm91cEJ5cztcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChncm91cEJ5cy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGhlYWRlcnNbaV07XG4gICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0QmVoYXZpb3IoKS5jb2x1bW5zO1xuICAgICAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcihmdW5jdGlvbihlYWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZWFjaC5sYWJlbCAhPT0gJ1RyZWUnO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRIaWRkZW5Db2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZpc2libGUgPSB0aGlzLmdldEJlaGF2aW9yKCkuY29sdW1ucztcbiAgICAgICAgdmFyIGFsbCA9IHRoaXMuZ2V0QmVoYXZpb3IoKS5hbGxDb2x1bW5zO1xuICAgICAgICB2YXIgaGlkZGVuID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmlzaWJsZS5pbmRleE9mKGFsbFtpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuLnB1c2goYWxsW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoaWRkZW4uc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5sYWJlbCA8IGIubGFiZWw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGlkZGVuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBhZ2dyZWdhdGlvbnNcbiAgICAgKi9cbiAgICBzZXRBZ2dyZWdhdGVzOiBmdW5jdGlvbihhZ2dyZWdhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5xdWlldGx5U2V0QWdncmVnYXRlcyhhZ2dyZWdhdGlvbnMpO1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0aW9uc1xuICAgICAqL1xuICAgIHF1aWV0bHlTZXRBZ2dyZWdhdGVzOiBmdW5jdGlvbihhZ2dyZWdhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hbmFseXRpY3Muc2V0QWdncmVnYXRlcyhhZ2dyZWdhdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSAmJiB0aGlzLmhhc0dyb3VwcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5QW5hbHl0aWNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5hcHBseUZpbHRlcnMoKTtcbiAgICAgICAgdGhpcy5hcHBseVNvcnRzKCk7XG4gICAgICAgIHRoaXMuYXBwbHlHcm91cEJ5c0FuZEFnZ3JlZ2F0aW9ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5R3JvdXBCeXNBbmRBZ2dyZWdhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5hbmFseXRpY3MuYWdncmVnYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucXVpZXRseVNldEFnZ3JlZ2F0ZXMoe30pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5hbHl0aWNzLmFwcGx5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wcmVnbG9iYWxmaWx0ZXIuYXBwbHkoKTtcbiAgICAgICAgdmFyIGNvbENvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgZmlsdGVyU291cmNlID0gdGhpcy5nZXRGaWx0ZXJTb3VyY2UoKTtcbiAgICAgICAgdmFyIGdyb3VwT2Zmc2V0ID0gdGhpcy5oYXNBZ2dyZWdhdGVzKCkgPyAxIDogMDtcbiAgICAgICAgZmlsdGVyU291cmNlLmNsZWFyQWxsKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZpbHRlclRleHQgPSB0aGlzLmdldEZpbHRlcihpKTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJTb3VyY2UuYWRkKGkgLSBncm91cE9mZnNldCwgdGV4dE1hdGNoRmlsdGVyKGZpbHRlclRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXJTb3VyY2UuYXBwbHlBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXhcbiAgICAgKiBAcGFyYW0ga2V5c1xuICAgICAqL1xuICAgIHRvZ2dsZVNvcnQ6IGZ1bmN0aW9uKGNvbEluZGV4LCBrZXlzKSB7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50U29ydFN0YXRlKGNvbEluZGV4LCBrZXlzKTtcbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGtleXNcbiAgICAgKi9cbiAgICBpbmNyZW1lbnRTb3J0U3RhdGU6IGZ1bmN0aW9uKGNvbEluZGV4LCBrZXlzKSB7XG4gICAgICAgIGNvbEluZGV4Kys7IC8vaGFjayB0byBnZXQgYXJvdW5kIDAgaW5kZXhcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIGhhc0NUUkwgPSBrZXlzLmluZGV4T2YoJ0NUUkwnKSA+IC0xO1xuICAgICAgICBzdGF0ZS5zb3J0cyA9IHN0YXRlLnNvcnRzIHx8IFtdO1xuICAgICAgICB2YXIgYWxyZWFkeSA9IHN0YXRlLnNvcnRzLmluZGV4T2YoY29sSW5kZXgpO1xuICAgICAgICBpZiAoYWxyZWFkeSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGFscmVhZHkgPSBzdGF0ZS5zb3J0cy5pbmRleE9mKC0xICogY29sSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbHJlYWR5ID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zb3J0c1thbHJlYWR5XSA+IDApIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zb3J0c1thbHJlYWR5XSA9IC0xICogc3RhdGUuc29ydHNbYWxyZWFkeV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLnNvcnRzLnNwbGljZShhbHJlYWR5LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChoYXNDVFJMIHx8IHN0YXRlLnNvcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3RhdGUuc29ydHMudW5zaGlmdChjb2xJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5zb3J0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgc3RhdGUuc29ydHMudW5zaGlmdChjb2xJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnNvcnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIHN0YXRlLnNvcnRzLmxlbmd0aCA9IDM7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhcHBseVNvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNvcnRpbmdTb3VyY2UgPSB0aGlzLmdldFNvcnRpbmdTb3VyY2UoKTtcbiAgICAgICAgdmFyIHNvcnRzID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKS5zb3J0cztcbiAgICAgICAgdmFyIGdyb3VwT2Zmc2V0ID0gdGhpcy5oYXNBZ2dyZWdhdGVzKCkgPyAxIDogMDtcbiAgICAgICAgaWYgKCFzb3J0cyB8fCBzb3J0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHNvcnRpbmdTb3VyY2UuY2xlYXJTb3J0cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xJbmRleCA9IE1hdGguYWJzKHNvcnRzW2ldKSAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzb3J0c1tpXSA8IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgc29ydGluZ1NvdXJjZS5zb3J0T24oY29sSW5kZXggLSBncm91cE9mZnNldCwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc29ydGluZ1NvdXJjZS5hcHBseVNvcnRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogQHBhcmFtIHJldHVybkFzU3RyaW5nXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U29ydEltYWdlRm9yQ29sdW1uOiBmdW5jdGlvbihpbmRleCwgcmV0dXJuQXNTdHJpbmcpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgdmFyIHVwID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNvcnRzID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKS5zb3J0cztcbiAgICAgICAgaWYgKCFzb3J0cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gc29ydHMuaW5kZXhPZihpbmRleCk7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gc29ydHMuaW5kZXhPZigtMSAqIGluZGV4KTtcbiAgICAgICAgICAgIHVwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuayA9IHNvcnRzLmxlbmd0aCAtIHBvc2l0aW9uO1xuXG4gICAgICAgIGlmIChyZXR1cm5Bc1N0cmluZykge1xuICAgICAgICAgICAgdmFyIGFycm93ID0gdXAgPyBVUFdBUkRTX0JMQUNLX0FSUk9XIDogRE9XTldBUkRTX0JMQUNLX0FSUk9XO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmsgKyBhcnJvdyArICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lID0gcmFuayArICh1cCA/ICctdXAnIDogJy1kb3duJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0SW1hZ2UobmFtZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGNlbGxcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBjZWxsQ2xpY2tlZDogZnVuY3Rpb24oY2VsbCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5ncmlkQ2VsbC54ICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIHRoaXMgd2Fzbid0IGEgY2xpY2sgb24gdGhlIGhpZXJhcmNoeSBjb2x1bW5cbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciB5ID0gZXZlbnQuZ3JpZENlbGwueSAtIGhlYWRlclJvd0NvdW50ICsgMTtcbiAgICAgICAgdGhpcy5hbmFseXRpY3MuY2xpY2soeSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdldEdyaWQoKTtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICBpZiAoeSA8IGhlYWRlclJvd0NvdW50ICYmICF0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSkge1xuICAgICAgICAgICAgdmFyIHRvcFRvdGFscyA9IHRoaXMuZ2V0VG9wVG90YWxzKCk7XG4gICAgICAgICAgICByZXR1cm4gdG9wVG90YWxzW3kgLSAoaGVhZGVyUm93Q291bnQgLSB0b3BUb3RhbHMubGVuZ3RoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YVNvdXJjZSgpLmdldFJvdyh5IC0gaGVhZGVyUm93Q291bnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBidWlsZFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgY29sQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXS5jb25jYXQodGhpcy5nZXRGaWVsZHMoKSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQWdncmVnYXRlcygpKSB7XG4gICAgICAgICAgICByZXN1bHQudHJlZSA9IHRoaXMuZ2V0VmFsdWUoLTIsIHkpO1xuICAgICAgICAgICAgZmllbGRzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbZmllbGRzW2ldXSA9IHRoaXMuZ2V0VmFsdWUoaSwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0Q29tcHV0ZWRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIHJjZiA9IHRoaXMuZ2V0Um93Q29udGV4dEZ1bmN0aW9uKFt5XSk7XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpO1xuICAgICAgICB2YXIgcm93ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgICByb3dbZmllbGRdID0gcmNmKGZpZWxkKVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE5hbWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlQnlGaWVsZDogZnVuY3Rpb24oZmllbGROYW1lLCB5KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0RmllbGRzKCkuaW5kZXhPZihmaWVsZE5hbWUpO1xuICAgICAgICBpZiAodGhpcy5oYXNBZ2dyZWdhdGVzKCkpIHtcbiAgICAgICAgICAgIHkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhU291cmNlKCkuZ2V0VmFsdWUoaW5kZXgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3Jpbmd9IHN0cmluZ1xuICAgICAqL1xuICAgIHNldEdsb2JhbEZpbHRlcjogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIGlmICghc3RyaW5nIHx8IHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlZ2xvYmFsZmlsdGVyLmNsZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZWdsb2JhbGZpbHRlci5zZXQodGV4dE1hdGNoRmlsdGVyKHN0cmluZykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1bnRyYW5zbGF0ZWRYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVudHJhbnNsYXRlZFlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldENlbGxSZW5kZXJlcjogZnVuY3Rpb24oY29uZmlnLCB4LCB5LCB1bnRyYW5zbGF0ZWRYLCB1bnRyYW5zbGF0ZWRZKSB7XG4gICAgICAgIHZhciByZW5kZXJlcjtcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdGhpcy5nZXRHcmlkKCkuZ2V0Q2VsbFByb3ZpZGVyKCk7XG5cbiAgICAgICAgY29uZmlnLnggPSB4O1xuICAgICAgICBjb25maWcueSA9IHk7XG4gICAgICAgIGNvbmZpZy51bnRyYW5zbGF0ZWRYID0gdW50cmFuc2xhdGVkWDtcbiAgICAgICAgY29uZmlnLnVudHJhbnNsYXRlZFkgPSB1bnRyYW5zbGF0ZWRZO1xuXG4gICAgICAgIHJlbmRlcmVyID0gcHJvdmlkZXIuZ2V0Q2VsbChjb25maWcpO1xuICAgICAgICByZW5kZXJlci5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldERhdGEoW10pO1xuICAgIH1cblxufSk7XG5cbmZ1bmN0aW9uIHZhbHVlT3JGdW5jdGlvbkV4ZWN1dGUodmFsdWVPckZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZU9yRnVuY3Rpb24gPT09ICdmdW5jdGlvbicgPyB2YWx1ZU9yRnVuY3Rpb24oKSA6IHZhbHVlT3JGdW5jdGlvbjtcbn1cblxuZnVuY3Rpb24gdGV4dE1hdGNoRmlsdGVyKHN0cmluZykge1xuICAgIHJldHVybiBmdW5jdGlvbihlYWNoKSB7XG4gICAgICAgIGVhY2ggPSB2YWx1ZU9yRnVuY3Rpb25FeGVjdXRlKGVhY2gpO1xuICAgICAgICByZXR1cm4gKGVhY2ggKyAnJykudG9Mb3dlckNhc2UoKS5zZWFyY2goc3RyaW5nLnRvTG93ZXJDYXNlKCkpID4gLTE7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEh5cGVyZ3JpZCA9IHJlcXVpcmUoJy4vSHlwZXJncmlkJyk7XG5cbkh5cGVyZ3JpZC5iZWhhdmlvcnMgPSByZXF1aXJlKCcuL2JlaGF2aW9ycy9pbmRleCcpO1xuSHlwZXJncmlkLmNlbGxFZGl0b3JzID0gcmVxdWlyZSgnLi9jZWxsRWRpdG9ycy9pbmRleCcpO1xuSHlwZXJncmlkLmZlYXR1cmVzID0gcmVxdWlyZSgnLi9mZWF0dXJlcy9pbmRleCcpO1xuXG53aW5kb3cuZmluID0ge1xuICAgIEh5cGVyZ3JpZDogSHlwZXJncmlkXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ2VsbENsaWNrID0gRmVhdHVyZS5leHRlbmQoJ0NlbGxDbGljaycsIHtcblxuICAgIGFsaWFzOiAnQ2VsbENsaWNrJyxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsQ2xpY2sucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVUYXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSBncmlkLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IGJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBoZWFkZXJDb2x1bW5Db3VudCA9IGJlaGF2aW9yLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgICAgIGlmICgoZ3JpZENlbGwueSA+PSBoZWFkZXJSb3dDb3VudCkgJiZcbiAgICAgICAgICAgIChncmlkQ2VsbC54ID49IGhlYWRlckNvbHVtbkNvdW50KSkge1xuICAgICAgICAgICAgZ3JpZC5jZWxsQ2xpY2tlZChldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlVGFwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxDbGljaztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENlbGxFZGl0aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NlbGxFZGl0aW5nJywge1xuXG4gICAgYWxpYXM6ICdDZWxsRWRpdGluZycsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gZ3JpZC5nZXRCZWhhdmlvcigpO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBiZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgaGVhZGVyQ29sdW1uQ291bnQgPSBiZWhhdmlvci5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgaWYgKGdyaWRDZWxsLnggPj0gaGVhZGVyQ29sdW1uQ291bnQgJiYgZ3JpZENlbGwueSA+PSBoZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgZ3JpZC5fYWN0aXZhdGVFZGl0b3IoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVIb2xkUHVsc2U6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IGdyaWQuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gYmVoYXZpb3IuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIGhlYWRlckNvbHVtbkNvdW50ID0gYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIGlmIChncmlkQ2VsbC54ID49IGhlYWRlckNvbHVtbkNvdW50ICYmIGdyaWRDZWxsLnkgPj0gaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgIGdyaWQuX2FjdGl2YXRlRWRpdG9yKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVIb2xkUHVsc2UoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsRWRpdGluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENlbGxTZWxlY3Rpb24gPSBGZWF0dXJlLmV4dGVuZCgnQ2VsbFNlbGVjdGlvbicsIHtcblxuICAgIGFsaWFzOiAnQ2VsbFNlbGVjdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXIuUG9pbnR9XG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgY3VycmVudERyYWc6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgY2VsbCBjb29yZGluYXRlcyBvZiB0aGUgd2hlcmUgdGhlIG1vdXNlIHBvaW50ZXIgaXMgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb25cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxhc3REcmFnQ2VsbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBwcmV2aW91cyB0aW1lIGFuIGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiTGFzdEF1dG86IDAsXG5cbiAgICAvKipcbiAgICAgKiBhIG1pbGxpc2Vjb25kIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgdGltZSB0aGUgY3VycmVudCBhdXRvc2Nyb2xsIHN0YXJ0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkF1dG9TdGFydDogMCxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzUmlnaHRDbGljayA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2s7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IGdyaWQuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdmFyIHZpZXdDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgZHggPSBjZWxsLng7XG4gICAgICAgIHZhciBkeSA9IGNlbGwueTtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gYmVoYXZpb3IuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIGhlYWRlckNvbHVtbkNvdW50ID0gYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gYmVoYXZpb3IuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGlzT3V0c2lkZSA9IHZpZXdDZWxsLnggPj0gY29sdW1uQ291bnQ7XG5cbiAgICAgICAgdmFyIGlzSGVhZGVyID0gZHkgPCBoZWFkZXJSb3dDb3VudCB8fCBkeCA8IGhlYWRlckNvbHVtbkNvdW50O1xuXG4gICAgICAgIGlmICghZ3JpZC5pc0NlbGxTZWxlY3Rpb24oKSB8fCBpc1JpZ2h0Q2xpY2sgfHwgaXNIZWFkZXIgfHwgaXNPdXRzaWRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnggPCBudW1GaXhlZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBkeCA9IHZpZXdDZWxsLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC55IDwgbnVtRml4ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgZHkgPSB2aWV3Q2VsbC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZENlbGwgPSBncmlkLm5ld1BvaW50KGR4LCBkeSk7XG5cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHZhciBrZXlzID0gcHJpbUV2ZW50LmRldGFpbC5rZXlzO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbihncmlkLCBkQ2VsbCwga2V5cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcblxuICAgICAgICBpZiAoIWdyaWQuaXNDZWxsU2VsZWN0aW9uKCkgfHwgaXNSaWdodENsaWNrIHx8ICF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgICAgIHZhciB2aWV3Q2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgICAgIHZhciBkeCA9IGNlbGwueDtcbiAgICAgICAgICAgIHZhciBkeSA9IGNlbGwueTtcblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnggPCBudW1GaXhlZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBkeCA9IHZpZXdDZWxsLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC55IDwgbnVtRml4ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgZHkgPSB2aWV3Q2VsbC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZENlbGwgPSBncmlkLm5ld1BvaW50KGR4LCBkeSk7XG5cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYWcgPSBwcmltRXZlbnQuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBkQ2VsbDtcblxuICAgICAgICAgICAgdGhpcy5jaGVja0RyYWdTY3JvbGwoZ3JpZCwgdGhpcy5jdXJyZW50RHJhZyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgZENlbGwsIHByaW1FdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGNvbW1hbmQgPSAnaGFuZGxlJyArIGV2ZW50LmRldGFpbC5jaGFyO1xuICAgICAgICBpZiAodGhpc1tjb21tYW5kXSkge1xuICAgICAgICAgICAgdGhpc1tjb21tYW5kXS5jYWxsKHRoaXMsIGdyaWQsIGV2ZW50LmRldGFpbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIGEgbW91c2VkcmFnIHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCBncmlkQ2VsbCwga2V5cykge1xuXG4gICAgICAgIHZhciBiZWhhdmlvciA9IGdyaWQuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gYmVoYXZpb3IuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIGhlYWRlckNvbHVtbkNvdW50ID0gYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHggPSBncmlkQ2VsbC54O1xuICAgICAgICB2YXIgeSA9IGdyaWRDZWxsLnk7XG4gICAgICAgIHggPSBNYXRoLm1heChoZWFkZXJDb2x1bW5Db3VudCwgeCk7XG4gICAgICAgIHkgPSBNYXRoLm1heChoZWFkZXJSb3dDb3VudCwgeSk7XG5cbiAgICAgICAgdmFyIHByZXZpb3VzRHJhZ0V4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpO1xuICAgICAgICB2YXIgbW91c2VEb3duID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcblxuICAgICAgICAvL3ZhciBzY3JvbGxpbmdOb3cgPSBncmlkLmlzU2Nyb2xsaW5nTm93KCk7XG5cbiAgICAgICAgdmFyIG5ld1ggPSB4IC0gbW91c2VEb3duLng7XG4gICAgICAgIHZhciBuZXdZID0geSAtIG1vdXNlRG93bi55O1xuXG4gICAgICAgIGlmIChwcmV2aW91c0RyYWdFeHRlbnQueCA9PT0gbmV3WCAmJiBwcmV2aW91c0RyYWdFeHRlbnQueSA9PT0gbmV3WSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcblxuICAgICAgICBncmlkLnNlbGVjdChtb3VzZURvd24ueCwgbW91c2VEb3duLnksIG5ld1gsIG5ld1kpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgY2hlY2tzIHdoaWxlIHdlcmUgZHJhZ2dpbmcgaWYgd2UgZ28gb3V0c2lkZSB0aGUgdmlzaWJsZSBib3VuZHMsIGlmIHNvLCBraWNrIG9mZiB0aGUgZXh0ZXJuYWwgYXV0b3Njcm9sbCBjaGVjayBmdW5jdGlvbiAoYWJvdmUpXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGNoZWNrRHJhZ1Njcm9sbDogZnVuY3Rpb24oZ3JpZCwgbW91c2UpIHtcbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IGIuY29udGFpbnMobW91c2UpO1xuICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3coZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxEcmFnKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gbWFrZXMgc3VyZSB0aGF0IHdoaWxlIHdlIGFyZSBkcmFnZ2luZyBvdXRzaWRlIG9mIHRoZSBncmlkIHZpc2libGUgYm91bmRzLCB3ZSBzcmNyb2xsIGFjY29yZGluZ2x5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBzY3JvbGxEcmFnOiBmdW5jdGlvbihncmlkKSB7XG5cbiAgICAgICAgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmFnU3RhcnRlZEluSGVhZGVyQXJlYSA9IGdyaWQuaXNNb3VzZURvd25JbkhlYWRlckFyZWEoKTtcbiAgICAgICAgdmFyIGxhc3REcmFnQ2VsbCA9IHRoaXMubGFzdERyYWdDZWxsO1xuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpO1xuICAgICAgICB2YXIgeE9mZnNldCA9IDA7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gMDtcblxuICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICB2YXIgZHJhZ0VuZEluRml4ZWRBcmVhWCA9IGxhc3REcmFnQ2VsbC54IDwgbnVtRml4ZWRDb2x1bW5zO1xuICAgICAgICB2YXIgZHJhZ0VuZEluRml4ZWRBcmVhWSA9IGxhc3REcmFnQ2VsbC55IDwgbnVtRml4ZWRSb3dzO1xuXG4gICAgICAgIGlmICghZHJhZ1N0YXJ0ZWRJbkhlYWRlckFyZWEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnggPCBiLm9yaWdpbi54KSB7XG4gICAgICAgICAgICAgICAgeE9mZnNldCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueSA8IGIub3JpZ2luLnkpIHtcbiAgICAgICAgICAgICAgICB5T2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueCA+IGIub3JpZ2luLnggKyBiLmV4dGVudC54KSB7XG4gICAgICAgICAgICB4T2Zmc2V0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy55ID4gYi5vcmlnaW4ueSArIGIuZXh0ZW50LnkpIHtcbiAgICAgICAgICAgIHlPZmZzZXQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyYWdDZWxsT2Zmc2V0WCA9IHhPZmZzZXQ7XG4gICAgICAgIHZhciBkcmFnQ2VsbE9mZnNldFkgPSB5T2Zmc2V0O1xuXG4gICAgICAgIGlmIChkcmFnRW5kSW5GaXhlZEFyZWFYKSB7XG4gICAgICAgICAgICBkcmFnQ2VsbE9mZnNldFggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYWdFbmRJbkZpeGVkQXJlYVkpIHtcbiAgICAgICAgICAgIGRyYWdDZWxsT2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGxhc3REcmFnQ2VsbC5wbHVzWFkoZHJhZ0NlbGxPZmZzZXRYLCBkcmFnQ2VsbE9mZnNldFkpO1xuICAgICAgICBncmlkLnNjcm9sbEJ5KHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgbGFzdERyYWdDZWxsLCBbXSk7IC8vIHVwZGF0ZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuc2Nyb2xsRHJhZy5iaW5kKHRoaXMsIGdyaWQpLCAyNSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGV4dGVuZCBhIHNlbGVjdGlvbiBvciBjcmVhdGUgb25lIGlmIHRoZXJlIGlzbnQgeWV0XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JpZENlbGwgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgZXh0ZW5kU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCBncmlkQ2VsbCwga2V5cykge1xuICAgICAgICB2YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpICE9PSAtMTtcbiAgICAgICAgdmFyIGhhc1NISUZUID0ga2V5cy5pbmRleE9mKCdTSElGVCcpICE9PSAtMTtcbiAgICAgICAgLy8gdmFyIHNjcm9sbFRvcCA9IGdyaWQuZ2V0VlNjcm9sbFZhbHVlKCk7XG4gICAgICAgIC8vIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICAvLyB2YXIgbnVtRml4ZWRDb2x1bW5zID0gMDsvL2dyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICAvLyB2YXIgbnVtRml4ZWRSb3dzID0gMDsvL2dyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBtb3VzZVBvaW50ID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcbiAgICAgICAgdmFyIHggPSBncmlkQ2VsbC54OyAvLyAtIG51bUZpeGVkQ29sdW1ucyArIHNjcm9sbExlZnQ7XG4gICAgICAgIHZhciB5ID0gZ3JpZENlbGwueTsgLy8gLSBudW1GaXhlZFJvd3MgKyBzY3JvbGxUb3A7XG5cbiAgICAgICAgLy93ZXJlIG91dHNpZGUgb2YgdGhlIGdyaWQgZG8gbm90aGluZ1xuICAgICAgICBpZiAoeCA8IDAgfHwgeSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vd2UgaGF2ZSByZXBlYXRlZCBhIGNsaWNrIGluIHRoZSBzYW1lIHNwb3QgZGVzbGVjdCB0aGUgdmFsdWUgZnJvbSBsYXN0IHRpbWVcbiAgICAgICAgaWYgKHggPT09IG1vdXNlUG9pbnQueCAmJiB5ID09PSBtb3VzZVBvaW50LnkpIHtcbiAgICAgICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBncmlkLnBvcE1vdXNlRG93bigpO1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhc0NUUkwgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3QobW91c2VQb2ludC54LCBtb3VzZVBvaW50LnksIHggLSBtb3VzZVBvaW50LnggKyAxLCB5IC0gbW91c2VQb2ludC55ICsgMSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCh4IC0gbW91c2VQb2ludC54ICsgMSwgeSAtIG1vdXNlUG9pbnQueSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3QoeCwgeSwgMCwgMCk7XG4gICAgICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KHgsIHkpKTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgfVxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlRE9XTlNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDAsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDAsIC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIC0xLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAxLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlRE9XTjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgLy9rZWVwIHRoZSBicm93c2VyIHZpZXdwb3J0IGZyb20gYXV0byBzY3JvbGxpbmcgb24ga2V5IGV2ZW50XG4gICAgICAgIGV2ZW50LnByaW1pdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uKCk7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAwLCBjb3VudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICAvL2tlZXAgdGhlIGJyb3dzZXIgdmlld3BvcnQgZnJvbSBhdXRvIHNjcm9sbGluZyBvbiBrZXkgZXZlbnRcbiAgICAgICAgZXZlbnQucHJpbWl0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmdldEF1dG9TY3JvbGxBY2NlbGVyYXRpb24oKTtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIDAsIC1jb3VudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIC0xLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIDEsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJZiB3ZSBhcmUgaG9sZGluZyBkb3duIHRoZSBzYW1lIG5hdmlnYXRpb24ga2V5LCBhY2NlbGVyYXRlIHRoZSBpbmNyZW1lbnQgd2Ugc2Nyb2xsXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgIHZhciBlbGFwc2VkID0gdGhpcy5nZXRBdXRvU2Nyb2xsRHVyYXRpb24oKSAvIDIwMDA7XG4gICAgICAgIGNvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkKSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBzdGFydCB0aW1lIHRvIHJpZ2h0IG5vdyB3aGVuIHdlIGluaXRpYXRlIGFuIGF1dG8gc2Nyb2xsXG4gICAgICovXG4gICAgc2V0QXV0b1Njcm9sbFN0YXJ0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JBdXRvU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGF1dG9zY3JvbGwgc3RhcnQgdGltZSBpZiB3ZSBoYXZlbid0IGF1dG9zY3JvbGxlZCB3aXRoaW4gdGhlIGxhc3QgNTAwbXMgb3RoZXJ3aXNlIHVwZGF0ZSB0aGUgY3VycmVudCBhdXRvc2Nyb2xsIHRpbWVcbiAgICAgKi9cbiAgICBwaW5nQXV0b1Njcm9sbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF1dG9TY3JvbGxTdGFydFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNiTGFzdEF1dG8gPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgaG93IGxvbmcgd2UgaGF2ZSBiZWVuIGF1dG8gc2Nyb2xsaW5nXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbER1cmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zYkF1dG9TdGFydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXVnbWVudCB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIGV4dGVudCBieSAob2Zmc2V0WCxvZmZzZXRZKSBhbmQgc2Nyb2xsIGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2hpZnRTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFgsIG9mZnNldFkpIHtcblxuICAgICAgICB2YXIgbWF4Q29sdW1ucyA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIHZhciBtYXhSb3dzID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1ucygpIC0gMTtcbiAgICAgICAgdmFyIG1heFZpZXdhYmxlUm93cyA9IGdyaWQuZ2V0VmlzaWJsZVJvd3MoKSAtIDE7XG5cbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICBtYXhDb2x1bW5zID0gTWF0aC5taW4obWF4Q29sdW1ucywgbWF4Vmlld2FibGVDb2x1bW5zKTtcbiAgICAgICAgICAgIG1heFJvd3MgPSBNYXRoLm1pbihtYXhSb3dzLCBtYXhWaWV3YWJsZVJvd3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHZhciBleHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKTtcblxuICAgICAgICB2YXIgbmV3WCA9IGV4dGVudC54ICsgb2Zmc2V0WDtcbiAgICAgICAgdmFyIG5ld1kgPSBleHRlbnQueSArIG9mZnNldFk7XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWluKG1heENvbHVtbnMgLSBvcmlnaW4ueCwgTWF0aC5tYXgoLW9yaWdpbi54LCBuZXdYKSk7XG4gICAgICAgIG5ld1kgPSBNYXRoLm1pbihtYXhSb3dzIC0gb3JpZ2luLnksIE1hdGgubWF4KC1vcmlnaW4ueSwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgbmV3WCwgbmV3WSk7XG5cbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQobmV3WCwgbmV3WSkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsQ29sSXNWaXNpYmxlKG5ld1ggKyBvcmlnaW4ueCwgb2Zmc2V0WCkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbFJvd0lzVmlzaWJsZShuZXdZICsgb3JpZ2luLnksIG9mZnNldFkpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXBsYWNlIHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gd2l0aCBhIHNpbmdsZSBjZWxsIHNlbGVjdGlvbiB0aGF0IGlzIG1vdmVkIChvZmZzZXRYLG9mZnNldFkpIGZyb20gdGhlIHByZXZpb3VzIHNlbGVjdGlvbiBleHRlbnQuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuXG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcbiAgICAgICAgdmFyIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxO1xuXG4gICAgICAgIHZhciBtYXhWaWV3YWJsZUNvbHVtbnMgPSBncmlkLmdldFZpc2libGVDb2x1bW5zQ291bnQoKSAtIDE7XG4gICAgICAgIHZhciBtYXhWaWV3YWJsZVJvd3MgPSBncmlkLmdldFZpc2libGVSb3dzQ291bnQoKSAtIDE7XG5cbiAgICAgICAgdmFyIG1pblJvd3MgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBtaW5Db2xzID0gZ3JpZC5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuXG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IE1hdGgubWluKG1heENvbHVtbnMsIG1heFZpZXdhYmxlQ29sdW1ucyk7XG4gICAgICAgICAgICBtYXhSb3dzID0gTWF0aC5taW4obWF4Um93cywgbWF4Vmlld2FibGVSb3dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSk7XG5cbiAgICAgICAgdmFyIG5ld1ggPSBtb3VzZUNvcm5lci54ICsgb2Zmc2V0WDtcbiAgICAgICAgdmFyIG5ld1kgPSBtb3VzZUNvcm5lci55ICsgb2Zmc2V0WTtcblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucywgTWF0aC5tYXgobWluQ29scywgbmV3WCkpO1xuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cywgTWF0aC5tYXgobWluUm93cywgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0KG5ld1gsIG5ld1ksIDAsIDApO1xuICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KG5ld1gsIG5ld1kpKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsQ29sSXNWaXNpYmxlKG5ld1gsIG9mZnNldFgpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSwgb2Zmc2V0WSkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsU2VsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sdW1uQXV0b3NpemluZyA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5BdXRvc2l6aW5nJywge1xuXG4gICAgYWxpYXM6ICdDb2x1bW5BdXRvc2l6aW5nJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQG1lbWJlck9mIENvbHVtbkF1dG9zaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgLy92YXIgaGVhZGVyQ29sQ291bnQgPSBncmlkLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICBpZiAoZ3JpZENlbGwueSA8PSBoZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgZ3JpZC5hdXRvc2l6ZUNvbHVtbihncmlkQ2VsbC54KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbkF1dG9zaXppbmc7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qIGdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZlYXR1cmUgaXMgcmVzcG9uc2libGUgZm9yIGNvbHVtbiBkcmFnIGFuZCBkcm9wIHJlb3JkZXJpbmcuXG4vLyBUaGlzIG9iamVjdCBpcyBhIG1lc3MgYW5kIGRlc3BlcmF0ZWx5IG5lZWRzIGEgY29tcGxldGUgcmV3cml0ZS4uLi4uXG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbnZhciBjb2x1bW5BbmltYXRpb25UaW1lID0gMTUwO1xudmFyIGRyYWdnZXI7XG52YXIgZHJhZ2dlckNUWDtcbnZhciBmbG9hdENvbHVtbjtcbnZhciBmbG9hdENvbHVtbkNUWDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENvbHVtbk1vdmluZyA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5Nb3ZpbmcnLCB7XG5cbiAgICBhbGlhczogJ0NvbHVtbk1vdmluZycsXG5cbiAgICAvKipcbiAgICAgKiBxdWV1ZSB1cCB0aGUgYW5pbWF0aW9ucyB0aGF0IG5lZWQgdG8gcGxheSBzbyB0aGV5IGFyZSBkb25lIHN5bmNocm9ub3VzbHlcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZmxvYXRlckFuaW1hdGlvblF1ZXVlOiBbXSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgY3VycmVudGx5IGF1dG8gc2Nyb2xsaW5nIHJpZ2h0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBhbSBJIGN1cnJlbnRseSBhdXRvIHNjcm9sbGluZyBsZWZ0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGlzIHRoZSBkcmFnIG1lY2hhbmlzbSBjdXJyZW50bHkgZW5hYmxlZCAoXCJhcm1lZFwiKVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdBcm1lZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBhbSBJIGRyYWdnaW5nIHJpZ2h0IG5vd1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdnaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBjb2x1bW4gaW5kZXggb2YgdGhlIGN1cnJlbnRseSBkcmFnZ2VkIGNvbHVtblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0NvbDogLTEsXG5cbiAgICAvKipcbiAgICAgKiBhbiBvZmZzZXQgdG8gcG9zaXRpb24gdGhlIGRyYWdnZWQgaXRlbSBmcm9tIHRoZSBjdXJzb3JcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdPZmZzZXQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnaXZlIG1lIGFuIG9wcG9ydHVuaXR5IHRvIGluaXRpYWxpemUgc3R1ZmYgb24gdGhlIGdyaWRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGluaXRpYWxpemVPbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLmlzRmxvYXRpbmdOb3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQW5pbWF0aW9uU3VwcG9ydChncmlkKTtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmluaXRpYWxpemVPbihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBpbml0aWFsaXplIGFuaW1hdGlvbiBzdXBwb3J0IG9uIHRoZSBncmlkXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplQW5pbWF0aW9uU3VwcG9ydDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAoIWRyYWdnZXIpIHtcbiAgICAgICAgICAgIGRyYWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGRyYWdnZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcwcHgnKTtcbiAgICAgICAgICAgIGRyYWdnZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMHB4Jyk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHJhZ2dlcik7XG4gICAgICAgICAgICBkcmFnZ2VyQ1RYID0gZHJhZ2dlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmxvYXRDb2x1bW4pIHtcbiAgICAgICAgICAgIGZsb2F0Q29sdW1uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBmbG9hdENvbHVtbi5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzBweCcpO1xuICAgICAgICAgICAgZmxvYXRDb2x1bW4uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMHB4Jyk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZmxvYXRDb2x1bW4pO1xuICAgICAgICAgICAgZmxvYXRDb2x1bW5DVFggPSBmbG9hdENvbHVtbi5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZ2V0Q2FuRHJhZ0N1cnNvck5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJy13ZWJraXQtZ3JhYic7XG4gICAgfSxcblxuICAgIGdldERyYWdnaW5nQ3Vyc29yTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC1ncmFiYmluZyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcblxuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdmFyIHg7XG4gICAgICAgIC8vdmFyIHk7XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5hYnMoZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmRyYWdzdGFydC54IC0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLngpO1xuXG4gICAgICAgIGlmIChkaXN0YW5jZSA8IDEwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0hlYWRlclJvdyhncmlkLCBldmVudCkgJiYgdGhpcy5kcmFnQXJtZWQgJiYgIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kcmFnQ29sID0gZ3JpZENlbGwueDtcbiAgICAgICAgICAgIHRoaXMuZHJhZ09mZnNldCA9IGV2ZW50Lm1vdXNlUG9pbnQueDtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoQ2hhaW4oKTtcbiAgICAgICAgICAgIHggPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueCAtIHRoaXMuZHJhZ09mZnNldDtcbiAgICAgICAgICAgIC8veSA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS55O1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVEcmFnQ29sdW1uKGdyaWQsIHgsIHRoaXMuZHJhZ0NvbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB4ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnggLSB0aGlzLmRyYWdPZmZzZXQ7XG4gICAgICAgICAgICAvL3kgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NvbHVtbihncmlkLCB4KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChncmlkLmdldEJlaGF2aW9yKCkuaXNDb2x1bW5SZW9yZGVyYWJsZSgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0hlYWRlclJvdyhncmlkLCBldmVudCkgJiYgZXZlbnQuZ3JpZENlbGwueCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmdldERyYWdnaW5nQ3Vyc29yTmFtZSgpO1xuICAgICAgICAgICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgLy92YXIgY29sID0gZXZlbnQuZ3JpZENlbGwueDtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIC8vZGVsYXkgaGVyZSB0byBnaXZlIG90aGVyIGV2ZW50cyBhIGNoYW5jZSB0byBiZSBkcm9wcGVkXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVuZERyYWdDb2x1bW4oZ3JpZCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoQ2hhaW4oKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnQ29sID0gLTE7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnQXJtZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcblxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nICYmIGV2ZW50Lm1vdXNlUG9pbnQueSA8IDUgJiYgZXZlbnQudmlld1BvaW50LnkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gdGhpcy5nZXRDYW5EcmFnQ3Vyc29yTmFtZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0hlYWRlclJvdyhncmlkLCBldmVudCkgJiYgdGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmdldERyYWdnaW5nQ3Vyc29yTmFtZSgpOyAvL21vdmUnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgaXMgdGhlIG1haW4gZXZlbnQgaGFuZGxlciB0aGF0IG1hbmFnZXMgdGhlIGRyYWdnaW5nIG9mIHRoZSBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZHJhZ2dlZFRvVGhlUmlnaHQgLSBhcmUgd2UgbW92aW5nIHRvIHRoZSByaWdodFxuICAgICAqL1xuICAgIGZsb2F0Q29sdW1uVG86IGZ1bmN0aW9uKGdyaWQsIGRyYWdnZWRUb1RoZVJpZ2h0KSB7XG4gICAgICAgIHRoaXMuZmxvYXRpbmdOb3cgPSB0cnVlO1xuXG4gICAgICAgIHZhciByZW5kZXJlciA9IGdyaWQuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgdmFyIGNvbEVkZ2VzID0gcmVuZGVyZXIuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgLy92YXIgYmVoYXZpb3IgPSBncmlkLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIGZsb2F0ZXJJbmRleCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlci5jb2x1bW5JbmRleDtcbiAgICAgICAgdmFyIGRyYWdnZXJJbmRleCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleDtcbiAgICAgICAgdmFyIGhkcGlyYXRpbyA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5oZHBpcmF0aW87XG5cbiAgICAgICAgdmFyIGRyYWdnZXJTdGFydFg7XG4gICAgICAgIHZhciBmbG9hdGVyU3RhcnRYO1xuICAgICAgICB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgZHJhZ2dlcldpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aChkcmFnZ2VySW5kZXgpO1xuICAgICAgICB2YXIgZmxvYXRlcldpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aChmbG9hdGVySW5kZXgpO1xuXG4gICAgICAgIHZhciBtYXggPSBncmlkLmdldFZpc2libGVDb2x1bW5zQ291bnQoKTtcblxuICAgICAgICB2YXIgZG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBmb2Zmc2V0ID0gMDtcblxuICAgICAgICBpZiAoZHJhZ2dlckluZGV4ID49IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIGRvZmZzZXQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbG9hdGVySW5kZXggPj0gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgZm9mZnNldCA9IHNjcm9sbExlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhZ2dlZFRvVGhlUmlnaHQpIHtcbiAgICAgICAgICAgIGRyYWdnZXJTdGFydFggPSBjb2xFZGdlc1tNYXRoLm1pbihtYXgsIGRyYWdnZXJJbmRleCAtIGRvZmZzZXQpXTtcbiAgICAgICAgICAgIGZsb2F0ZXJTdGFydFggPSBjb2xFZGdlc1tNYXRoLm1pbihtYXgsIGZsb2F0ZXJJbmRleCAtIGZvZmZzZXQpXTtcblxuICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLnN0YXJ0WCA9IChkcmFnZ2VyU3RhcnRYICsgZmxvYXRlcldpZHRoKSAqIGhkcGlyYXRpbztcbiAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlci5zdGFydFggPSBkcmFnZ2VyU3RhcnRYICogaGRwaXJhdGlvO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbG9hdGVyU3RhcnRYID0gY29sRWRnZXNbTWF0aC5taW4obWF4LCBmbG9hdGVySW5kZXggLSBmb2Zmc2V0KV07XG4gICAgICAgICAgICBkcmFnZ2VyU3RhcnRYID0gZmxvYXRlclN0YXJ0WCArIGRyYWdnZXJXaWR0aDtcblxuICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLnN0YXJ0WCA9IGZsb2F0ZXJTdGFydFggKiBoZHBpcmF0aW87XG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIuc3RhcnRYID0gZHJhZ2dlclN0YXJ0WCAqIGhkcGlyYXRpbztcbiAgICAgICAgfVxuICAgICAgICBncmlkLnN3YXBDb2x1bW5zKGRyYWdnZXJJbmRleCwgZmxvYXRlckluZGV4KTtcbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4ID0gZmxvYXRlckluZGV4O1xuICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIuY29sdW1uSW5kZXggPSBkcmFnZ2VySW5kZXg7XG5cblxuICAgICAgICB0aGlzLmZsb2F0ZXJBbmltYXRpb25RdWV1ZS51bnNoaWZ0KHRoaXMuZG9Db2x1bW5Nb3ZlQW5pbWF0aW9uKGdyaWQsIGZsb2F0ZXJTdGFydFgsIGRyYWdnZXJTdGFydFgpKTtcblxuICAgICAgICB0aGlzLmRvRmxvYXRlckFuaW1hdGlvbihncmlkKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBtYW5pZmVzdCB0aGUgY29sdW1uIGRyYWcgYW5kIGRyb3AgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmxvYXRlclN0YXJ0WCAtIHRoZSB4IHN0YXJ0IGNvb3JkaW5hdGUgb2YgdGhlIGNvbHVtbiB1bmRlcm5lYXRoIHRoYXQgZmxvYXRzIGJlaGluZCB0aGUgZHJhZ2dlZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHJhZ2dlclN0YXJ0WCAtIHRoZSB4IHN0YXJ0IGNvb3JkaW5hdGUgb2YgdGhlIGRyYWdnZWQgY29sdW1uXG4gICAgICovXG4gICAgZG9Db2x1bW5Nb3ZlQW5pbWF0aW9uOiBmdW5jdGlvbihncmlkLCBmbG9hdGVyU3RhcnRYLCBkcmFnZ2VyU3RhcnRYKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGQgPSBmbG9hdENvbHVtbjtcbiAgICAgICAgICAgIGQuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgZmxvYXRlclN0YXJ0WCArICdweCwgJyArIDAgKyAncHgpJyk7XG5cbiAgICAgICAgICAgIC8vZC5zdHlsZS53ZWJraXQtd2Via2l0LVRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIGZsb2F0ZXJTdGFydFggKyAncHgsICcgKyAwICsgJ3B4KSc7XG4gICAgICAgICAgICAvL2Quc3R5bGUud2Via2l0LXdlYmtpdC1UcmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyBmbG9hdGVyU3RhcnRYICsgJ3B4LCAnICsgMCArICdweCknO1xuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNpdGlvbicsIChzZWxmLmlzV2Via2l0ID8gJy13ZWJraXQtJyA6ICcnKSArICd0cmFuc2Zvcm0gJyArIGNvbHVtbkFuaW1hdGlvblRpbWUgKyAnbXMgZWFzZScpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGRyYWdnZXJTdGFydFggKyAncHgsICcgKyAtMiArICdweCknKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICAvL25lZWQgdG8gY2hhbmdlIHRoaXMgdG8ga2V5IGZyYW1lc1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmRvRmxvYXRlckFuaW1hdGlvbihncmlkKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pc0Zsb2F0aW5nTm93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBjb2x1bW5BbmltYXRpb25UaW1lICsgNTApO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBtYW5pZmVzdCB0aGUgZmxvYXRlciBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGRvRmxvYXRlckFuaW1hdGlvbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAodGhpcy5mbG9hdGVyQW5pbWF0aW9uUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZsb2F0aW5nTm93ID0gZmFsc2U7XG4gICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5mbG9hdGVyQW5pbWF0aW9uUXVldWUucG9wKCk7XG4gICAgICAgIGFuaW1hdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjcmVhdGUgdGhlIGZsb2F0IGNvbHVtbiBhdCBjb2x1bW5JbmRleCB1bmRlcm5lYXRoIHRoZSBkcmFnZ2VkIGNvbHVtblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCB3aWxsIGJlIGZsb2F0aW5nXG4gICAgICovXG4gICAgY3JlYXRlRmxvYXRDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGNvbHVtbkluZGV4KSB7XG5cbiAgICAgICAgdmFyIGZpeGVkQ29sdW1uQ291bnQgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIGlmIChjb2x1bW5JbmRleCA8IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZ3JpZC5nZXRSZW5kZXJlcigpO1xuICAgICAgICB2YXIgY29sdW1uRWRnZXMgPSByZW5kZXJlci5nZXRDb2x1bW5FZGdlcygpO1xuXG4gICAgICAgIHZhciBjb2x1bW5XaWR0aCA9IGdyaWQuZ2V0Q29sdW1uV2lkdGgoY29sdW1uSW5kZXgpO1xuICAgICAgICB2YXIgY29sSGVpZ2h0ID0gZ3JpZC5kaXYuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgZCA9IGZsb2F0Q29sdW1uO1xuICAgICAgICB2YXIgc3R5bGUgPSBkLnN0eWxlO1xuICAgICAgICB2YXIgbG9jYXRpb24gPSBncmlkLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBzdHlsZS50b3AgPSAobG9jYXRpb24udG9wIC0gMikgKyAncHgnO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gbG9jYXRpb24ubGVmdCArICdweCc7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcblxuICAgICAgICB2YXIgaGRwaVJhdGlvID0gZ3JpZC5nZXRIaURQSShmbG9hdENvbHVtbkNUWCk7XG5cbiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgTWF0aC5yb3VuZChjb2x1bW5XaWR0aCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIE1hdGgucm91bmQoY29sSGVpZ2h0ICogaGRwaVJhdGlvKSArICdweCcpO1xuICAgICAgICBzdHlsZS5ib3hTaGFkb3cgPSAnMCAxMHB4IDIwcHggcmdiYSgwLDAsMCwwLjE5KSwgMCA2cHggNnB4IHJnYmEoMCwwLDAsMC4yMyknO1xuICAgICAgICBzdHlsZS53aWR0aCA9IGNvbHVtbldpZHRoICsgJ3B4JzsgLy9NYXRoLnJvdW5kKGNvbHVtbldpZHRoIC8gaGRwaVJhdGlvKSArICdweCc7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGNvbEhlaWdodCArICdweCc7IC8vTWF0aC5yb3VuZChjb2xIZWlnaHQgLyBoZHBpUmF0aW8pICsgJ3B4JztcbiAgICAgICAgc3R5bGUuYm9yZGVyVG9wID0gJzFweCBzb2xpZCAnICsgcmVuZGVyZXIucmVzb2x2ZVByb3BlcnR5KCdsaW5lQ29sb3InKTtcbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcmVuZGVyZXIucmVzb2x2ZVByb3BlcnR5KCdiYWNrZ3JvdW5kQ29sb3InKTtcblxuICAgICAgICB2YXIgc3RhcnRYID0gY29sdW1uRWRnZXNbY29sdW1uSW5kZXggLSBzY3JvbGxMZWZ0XTtcbiAgICAgICAgc3RhcnRYID0gc3RhcnRYICogaGRwaVJhdGlvO1xuXG4gICAgICAgIGZsb2F0Q29sdW1uQ1RYLnNjYWxlKGhkcGlSYXRpbywgaGRwaVJhdGlvKTtcblxuICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIgPSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleDogY29sdW1uSW5kZXgsXG4gICAgICAgICAgICBjdHg6IGZsb2F0Q29sdW1uQ1RYLFxuICAgICAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbEhlaWdodCxcbiAgICAgICAgICAgIGhkcGlyYXRpbzogaGRwaVJhdGlvXG4gICAgICAgIH07XG5cbiAgICAgICAgc3R5bGUuekluZGV4ID0gJzQnO1xuICAgICAgICB0aGlzLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBzdGFydFggKyAncHgsICcgKyAtMiArICdweCknKTtcbiAgICAgICAgc3R5bGUuY3Vyc29yID0gdGhpcy5nZXREcmFnZ2luZ0N1cnNvck5hbWUoKTtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gZm9yIHNldHRpbmcgY3Jvc3MgYnJvd3NlciBjc3MgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBkZXNjcmlwdG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGFzc2lnblxuICAgICAqL1xuICAgIHNldENyb3NzQnJvd3NlclByb3BlcnR5OiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHVQcm9wZXJ0eSA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zdWJzdHIoMSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnd2Via2l0JyArIHVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ01veicgKyB1UHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsICdtcycgKyB1UHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsICdPJyArIHVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBmdW5jdGlvbiBmb3Igc2V0dGluZyBwcm9wZXJ0aWVzIG9uIEhUTUxFbGVtZW50c1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBkZXNjcmlwdG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGFzc2lnblxuICAgICAqL1xuICAgIHNldFByb3A6IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBpZiAocHJvcGVydHkgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjcmVhdGUgdGhlIGRyYWdnZWQgY29sdW1uIGF0IGNvbHVtbkluZGV4IGFib3ZlIHRoZSBmbG9hdGVkIGNvbHVtblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGNvbHVtbiB0aGF0IHdpbGwgYmUgZmxvYXRpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVEcmFnQ29sdW1uOiBmdW5jdGlvbihncmlkLCB4LCBjb2x1bW5JbmRleCkge1xuXG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICBpZiAoY29sdW1uSW5kZXggPCBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW5kZXJlciA9IGdyaWQuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgdmFyIGNvbHVtbkVkZ2VzID0gcmVuZGVyZXIuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgdmFyIGhkcGlSYXRpbyA9IGdyaWQuZ2V0SGlEUEkoZHJhZ2dlckNUWCk7XG4gICAgICAgIHZhciBjb2x1bW5XaWR0aCA9IGdyaWQuZ2V0Q29sdW1uV2lkdGgoY29sdW1uSW5kZXgpO1xuICAgICAgICB2YXIgY29sSGVpZ2h0ID0gZ3JpZC5kaXYuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgZCA9IGRyYWdnZXI7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGdyaWQuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgc3R5bGUgPSBkLnN0eWxlO1xuXG4gICAgICAgIHN0eWxlLnRvcCA9IGxvY2F0aW9uLnRvcCArICdweCc7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBsb2NhdGlvbi5sZWZ0ICsgJ3B4JztcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMC44NTtcbiAgICAgICAgc3R5bGUuYm94U2hhZG93ID0gJzAgMTlweCAzOHB4IHJnYmEoMCwwLDAsMC4zMCksIDAgMTVweCAxMnB4IHJnYmEoMCwwLDAsMC4yMiknO1xuICAgICAgICAvL3N0eWxlLnpJbmRleCA9IDEwMDtcbiAgICAgICAgc3R5bGUuYm9yZGVyVG9wID0gJzFweCBzb2xpZCAnICsgcmVuZGVyZXIucmVzb2x2ZVByb3BlcnR5KCdsaW5lQ29sb3InKTtcbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZ3JpZC5yZW5kZXJlci5yZXNvbHZlUHJvcGVydHkoJ2JhY2tncm91bmRDb2xvcicpO1xuXG4gICAgICAgIGQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIE1hdGgucm91bmQoY29sdW1uV2lkdGggKiBoZHBpUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgIGQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBNYXRoLnJvdW5kKGNvbEhlaWdodCAqIGhkcGlSYXRpbykgKyAncHgnKTtcblxuICAgICAgICBzdHlsZS53aWR0aCA9IGNvbHVtbldpZHRoICsgJ3B4JzsgLy9NYXRoLnJvdW5kKGNvbHVtbldpZHRoIC8gaGRwaVJhdGlvKSArICdweCc7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGNvbEhlaWdodCArICdweCc7IC8vTWF0aC5yb3VuZChjb2xIZWlnaHQgLyBoZHBpUmF0aW8pICsgJ3B4JztcblxuICAgICAgICB2YXIgc3RhcnRYID0gY29sdW1uRWRnZXNbY29sdW1uSW5kZXggLSBzY3JvbGxMZWZ0XTtcbiAgICAgICAgc3RhcnRYID0gc3RhcnRYICogaGRwaVJhdGlvO1xuXG4gICAgICAgIGRyYWdnZXJDVFguc2NhbGUoaGRwaVJhdGlvLCBoZHBpUmF0aW8pO1xuXG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlciA9IHtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgIGN0eDogZHJhZ2dlckNUWCxcbiAgICAgICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb2xIZWlnaHQsXG4gICAgICAgICAgICBoZHBpcmF0aW86IGhkcGlSYXRpb1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHggKyAncHgsIC01cHgpJyk7XG4gICAgICAgIHN0eWxlLnpJbmRleCA9ICc1JztcbiAgICAgICAgc3R5bGUuY3Vyc29yID0gdGhpcy5nZXREcmFnZ2luZ0N1cnNvck5hbWUoKTtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgdGhlIG1haW4gZHJhZ2dpbmcgbG9naWNcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHN0YXJ0IHBvc2l0aW9uXG4gICAgICovXG4gICAgZHJhZ0NvbHVtbjogZnVuY3Rpb24oZ3JpZCwgeCkge1xuXG4gICAgICAgIC8vVE9ETzogdGhpcyBmdW5jdGlvbiBpcyBvdmVybHkgY29tcGxleCwgcmVmYWN0b3IgdGhpcyBpbiB0byBzb21ldGhpbmcgbW9yZSByZWFzb25hYmxlXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgLy92YXIgcmVuZGVyZXIgPSBncmlkLmdldFJlbmRlcmVyKCk7XG4gICAgICAgIC8vdmFyIGNvbHVtbkVkZ2VzID0gcmVuZGVyZXIuZ2V0Q29sdW1uRWRnZXMoKTtcblxuICAgICAgICB2YXIgYXV0b1Njcm9sbGluZ05vdyA9IHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCB8fCB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdDtcblxuICAgICAgICB2YXIgaGRwaVJhdGlvID0gZ3JpZC5nZXRIaURQSShkcmFnZ2VyQ1RYKTtcblxuICAgICAgICB2YXIgZHJhZ0NvbHVtbkluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuICAgICAgICB2YXIgY29sdW1uV2lkdGggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIud2lkdGg7XG5cbiAgICAgICAgdmFyIG1pblggPSAwOyAvL2dyaWQuZ2V0Rml4ZWRDb2x1bW5zV2lkdGgoKTtcbiAgICAgICAgdmFyIG1heFggPSBncmlkLnJlbmRlcmVyLmdldEZpbmFsVmlzYWJsZUNvbHVtbkJvdW5kcnkoKSAtIGNvbHVtbldpZHRoO1xuICAgICAgICB4ID0gTWF0aC5taW4oeCwgbWF4WCArIDE1KTtcbiAgICAgICAgeCA9IE1hdGgubWF4KG1pblggLSAxNSwgeCk7XG5cbiAgICAgICAgLy9hbSBJIGF0IG15IGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciBhdE1pbiA9IHggPCBtaW5YICYmIGRyYWdDb2x1bW5JbmRleCAhPT0gMDtcblxuICAgICAgICAvL2FtIEkgYXQgbXkgdXBwZXIgYm91bmRcbiAgICAgICAgdmFyIGF0TWF4ID0geCA+IG1heFg7XG5cbiAgICAgICAgdmFyIGQgPSBkcmFnZ2VyO1xuXG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zaXRpb24nLCAoc2VsZi5pc1dlYmtpdCA/ICctd2Via2l0LScgOiAnJykgKyAndHJhbnNmb3JtICcgKyAwICsgJ21zIGVhc2UsIGJveC1zaGFkb3cgJyArIGNvbHVtbkFuaW1hdGlvblRpbWUgKyAnbXMgZWFzZScpO1xuXG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHggKyAncHgsICcgKyAtMTAgKyAncHgpJyk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgb3ZlckNvbCA9IGdyaWQucmVuZGVyZXIuZ2V0Q29sdW1uRnJvbVBpeGVsWCh4ICsgKGQud2lkdGggLyAyIC8gaGRwaVJhdGlvKSk7XG5cbiAgICAgICAgaWYgKGF0TWluKSB7XG4gICAgICAgICAgICBvdmVyQ29sID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdE1heCkge1xuICAgICAgICAgICAgb3ZlckNvbCA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG9BRmxvYXQgPSBkcmFnQ29sdW1uSW5kZXggPiBvdmVyQ29sO1xuICAgICAgICBkb0FGbG9hdCA9IGRvQUZsb2F0IHx8IChvdmVyQ29sIC0gZHJhZ0NvbHVtbkluZGV4ID49IDEpO1xuXG4gICAgICAgIGlmIChkb0FGbG9hdCAmJiAhYXRNYXggJiYgIWF1dG9TY3JvbGxpbmdOb3cpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2VkVG9UaGVSaWdodCA9IGRyYWdDb2x1bW5JbmRleCA8IG92ZXJDb2w7XG4gICAgICAgICAgICAvLyBpZiAoZHJhZ2dlZFRvVGhlUmlnaHQpIHtcbiAgICAgICAgICAgIC8vICAgICBvdmVyQ29sID0gb3ZlckNvbCAtIDE7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Zsb2F0aW5nTm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmlzRmxvYXRpbmdOb3cgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGbG9hdENvbHVtbihncmlkLCBvdmVyQ29sKTtcbiAgICAgICAgICAgIHRoaXMuZmxvYXRDb2x1bW5UbyhncmlkLCBkcmFnZ2VkVG9UaGVSaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICh4IDwgbWluWCAtIDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0F1dG9TY3JvbGxUb0xlZnQoZ3JpZCwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA+IG1pblggLSAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2xldHMgY2hlY2sgZm9yIGF1dG9zY3JvbGwgdG8gcmlnaHQgaWYgd2VyZSB1cCBhZ2FpbnN0IGl0XG4gICAgICAgICAgICBpZiAoYXRNYXggfHwgeCA+IG1heFggKyAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tBdXRvU2Nyb2xsVG9SaWdodChncmlkLCB4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA8IG1heFggKyAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGF1dG9zY3JvbGwgdG8gdGhlIHJpZ2h0IGlmIG5lY2Vzc2FyeVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgc3RhcnQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBjaGVja0F1dG9TY3JvbGxUb1JpZ2h0OiBmdW5jdGlvbihncmlkLCB4KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nUmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nUmlnaHQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jaGVja0F1dG9TY3JvbGxUb1JpZ2h0KGdyaWQsIHgpO1xuICAgIH0sXG5cbiAgICBfY2hlY2tBdXRvU2Nyb2xsVG9SaWdodDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAoIXRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgaWYgKCFncmlkLmRyYWdnaW5nIHx8IHNjcm9sbExlZnQgPiAoZ3JpZC5zYkhTY3JvbGxDb25maWcucmFuZ2VTdG9wIC0gMikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHJhZ2dlZEluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuICAgICAgICBncmlkLnNjcm9sbEJ5KDEsIDApO1xuICAgICAgICB2YXIgbmV3SW5kZXggPSBkcmFnZ2VkSW5kZXggKyAxO1xuICAgICAgICBjb25zb2xlLmxvZyhuZXdJbmRleCwgZHJhZ2dlZEluZGV4KTtcbiAgICAgICAgZ3JpZC5zd2FwQ29sdW1ucyhuZXdJbmRleCwgZHJhZ2dlZEluZGV4KTtcbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4ID0gbmV3SW5kZXg7XG5cbiAgICAgICAgc2V0VGltZW91dCh0aGlzLl9jaGVja0F1dG9TY3JvbGxUb1JpZ2h0LmJpbmQodGhpcywgZ3JpZCwgeCksIDI1MCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGF1dG9zY3JvbGwgdG8gdGhlIGxlZnQgaWYgbmVjZXNzYXJ5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBzdGFydCBwb3NpdGlvblxuICAgICAqL1xuICAgIGNoZWNrQXV0b1Njcm9sbFRvTGVmdDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NoZWNrQXV0b1Njcm9sbFRvTGVmdChncmlkLCB4KTtcbiAgICB9LFxuXG4gICAgX2NoZWNrQXV0b1Njcm9sbFRvTGVmdDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAoIXRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIGlmICghZ3JpZC5kcmFnZ2luZyB8fCBzY3JvbGxMZWZ0IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcmFnZ2VkSW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIGdyaWQuc3dhcENvbHVtbnMoZHJhZ2dlZEluZGV4ICsgc2Nyb2xsTGVmdCwgZHJhZ2dlZEluZGV4ICsgc2Nyb2xsTGVmdCAtIDEpO1xuICAgICAgICBncmlkLnNjcm9sbEJ5KC0xLCAwKTtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLl9jaGVja0F1dG9TY3JvbGxUb0xlZnQuYmluZCh0aGlzLCBncmlkLCB4KSwgMjUwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgYSBjb2x1bW4gZHJhZyBoYXMgY29tcGxldGVkLCB1cGRhdGUgZGF0YSBhbmQgY2xlYW51cFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZW5kRHJhZ0NvbHVtbjogZnVuY3Rpb24oZ3JpZCkge1xuXG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICB2YXIgY29sdW1uSW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG5cbiAgICAgICAgaWYgKGNvbHVtbkluZGV4IDwgZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVuZGVyZXIgPSBncmlkLmdldFJlbmRlcmVyKCk7XG4gICAgICAgIHZhciBjb2x1bW5FZGdlcyA9IHJlbmRlcmVyLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXJ0WCA9IGNvbHVtbkVkZ2VzW2NvbHVtbkluZGV4IC0gc2Nyb2xsTGVmdF07XG4gICAgICAgIHZhciBkID0gZHJhZ2dlcjtcblxuICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2l0aW9uJywgKHNlbGYuaXNXZWJraXQgPyAnLXdlYmtpdC0nIDogJycpICsgJ3RyYW5zZm9ybSAnICsgY29sdW1uQW5pbWF0aW9uVGltZSArICdtcyBlYXNlLCBib3gtc2hhZG93ICcgKyBjb2x1bW5BbmltYXRpb25UaW1lICsgJ21zIGVhc2UnKTtcbiAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgc3RhcnRYICsgJ3B4LCAnICsgLTEgKyAncHgpJyk7XG4gICAgICAgIGQuc3R5bGUuYm94U2hhZG93ID0gJzBweCAwcHggMHB4ICM4ODg4ODgnO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIgPSBudWxsO1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIGdyaWQuZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGNvbHVtbkFuaW1hdGlvblRpbWUgKyA1MCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0hlYWRlclJvdzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgaXNGaXhlZCA9IGdyaWRDZWxsLnkgPT09IDA7XG4gICAgICAgIHJldHVybiBpc0ZpeGVkO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uTW92aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sdW1uUmVzaXppbmcgPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uUmVzaXppbmcnLCB7XG5cbiAgICBhbGlhczogJ0NvbHVtblJlc2l6aW5nJyxcblxuICAgIC8qKlxuICAgICAqIHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHdhbGwgd2VyZSBjdXJyZW50bHkgZHJhZ2dpbmdcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0yXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdJbmRleDogLTIsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIHdoZXJlIHRoZSBkcmFnIHdhcyBpbml0aWF0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdTdGFydDogLTEsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgc3RhcnRpbmcgd2lkdGgvaGVpZ2h0IG9mIHRoZSByb3cvY29sdW1uIHdlIGFyZSBkcmFnZ2luZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0luZGV4U3RhcnRpbmdTaXplOiAtMSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXQgdGhlIG1vdXNlIHgseSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gdGhlIG1vdXNlIGV2ZW50IHRvIHF1ZXJ5XG4gICAgICovXG4gICAgZ2V0TW91c2VWYWx1ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IHRoZSBncmlkIGNlbGwgeCx5IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH0gZ3JpZENlbGxcbiAgICAgKi9cbiAgICBnZXRHcmlkQ2VsbFZhbHVlOiBmdW5jdGlvbihncmlkQ2VsbCkge1xuICAgICAgICByZXR1cm4gZ3JpZENlbGwueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgZ3JpZHMgeCx5IHNjcm9sbCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBnZXRTY3JvbGxWYWx1ZTogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSByb3cvY29sdW1uIG9mIGludGVyZXN0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSByb3cvY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0QXJlYVNpemU6IGZ1bmN0aW9uKGdyaWQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldENvbHVtbldpZHRoKGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSByb3cvY29sdW1uIGF0IGluZGV4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSByb3cvY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdGhlIHdpZHRoL2hlaWdodCB0byBzZXQgdG9cbiAgICAgKi9cbiAgICBzZXRBcmVhU2l6ZTogZnVuY3Rpb24oZ3JpZCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGdyaWQuc2V0Q29sdW1uV2lkdGgoaW5kZXgsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgcmVjZW50bHkgcmVuZGVyZWQgYXJlYSdzIHdpZHRoL2hlaWdodFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgcm93L2NvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldFByZXZpb3VzQWJzb2x1dGVTaXplOiBmdW5jdGlvbihncmlkLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRSZW5kZXJlZFdpZHRoKGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybnMgdGhlIGluZGV4IG9mIHdoaWNoIGRpdmlkZXIgSSdtIG92ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvdmVyQXJlYURpdmlkZXI6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBncmlkLm92ZXJDb2x1bW5EaXZpZGVyKGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGFtIEkgb3ZlciB0aGUgY29sdW1uL3JvdyBhcmVhXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRmlyc3RGaXhlZE90aGVyQXJlYTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGaXJzdEZpeGVkUm93KGdyaWQsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgY3Vyc29yIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldEN1cnNvck5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ2NvbC1yZXNpemUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnSW5kZXggPiAtMikge1xuICAgICAgICAgICAgLy92YXIgZml4ZWRBcmVhQ291bnQgPSB0aGlzLmdldEZpeGVkQXJlYUNvdW50KGdyaWQpO1xuICAgICAgICAgICAgLy92YXIgb2Zmc2V0ID0gdGhpcy5nZXRGaXhlZEFyZWFTaXplKGdyaWQsIGZpeGVkQXJlYUNvdW50ICsgYXJlYUluZGV4KTtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IHRoaXMuZ2V0TW91c2VWYWx1ZShldmVudCk7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsVmFsdWUgPSB0aGlzLmdldFNjcm9sbFZhbHVlKGdyaWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ0luZGV4IDwgdGhpcy5nZXRGaXhlZEFyZWFDb3VudChncmlkKSkge1xuICAgICAgICAgICAgICAgIHNjcm9sbFZhbHVlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMuZ2V0UHJldmlvdXNBYnNvbHV0ZVNpemUoZ3JpZCwgdGhpcy5kcmFnSW5kZXggLSBzY3JvbGxWYWx1ZSk7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBtb3VzZSAtIHByZXZpb3VzO1xuICAgICAgICAgICAgdGhpcy5zZXRBcmVhU2l6ZShncmlkLCB0aGlzLmRyYWdJbmRleCwgZGlzdGFuY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldCB0aGUgd2lkdGgvaGVpZ2h0IG9mIGEgc3BlY2lmaWMgcm93L2NvbHVtblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZWFJbmRleCAtIHRoZSByb3cvY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0U2l6ZTogZnVuY3Rpb24oZ3JpZCwgYXJlYUluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFyZWFTaXplKGdyaWQsIGFyZWFJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGZpeGVkIGFyZWEgcm93cy9jb2x1bW5zIGNvdW50XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGdldE90aGVyRml4ZWRBcmVhQ291bnQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc0VuYWJsZWQgPSB0aGlzLmlzRW5hYmxlZChncmlkKTtcbiAgICAgICAgdmFyIG92ZXJBcmVhID0gdGhpcy5vdmVyQXJlYURpdmlkZXIoZ3JpZCwgZXZlbnQpO1xuICAgICAgICBpZiAoaXNFbmFibGVkICYmIG92ZXJBcmVhID4gLTEgJiYgdGhpcy5pc0ZpcnN0Rml4ZWRPdGhlckFyZWEoZ3JpZCwgZXZlbnQpKSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsVmFsdWUgPSB0aGlzLmdldFNjcm9sbFZhbHVlKGdyaWQpO1xuICAgICAgICAgICAgaWYgKG92ZXJBcmVhIDwgdGhpcy5nZXRGaXhlZEFyZWFDb3VudChncmlkKSkge1xuICAgICAgICAgICAgICAgIHNjcm9sbFZhbHVlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhZ0luZGV4ID0gb3ZlckFyZWEgLSAxICsgc2Nyb2xsVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRyYWdTdGFydCA9IHRoaXMuZ2V0TW91c2VWYWx1ZShldmVudCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdJbmRleFN0YXJ0aW5nU2l6ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmRldGFjaENoYWluKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNFbmFibGVkID0gdGhpcy5pc0VuYWJsZWQoZ3JpZCk7XG4gICAgICAgIGlmIChpc0VuYWJsZWQgJiYgdGhpcy5kcmFnSW5kZXggPiAtMikge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kcmFnSW5kZXggPSAtMjtcblxuICAgICAgICAgICAgZXZlbnQucHJpbWl0aXZlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAvL2RlbGF5IGhlcmUgdG8gZ2l2ZSBvdGhlciBldmVudHMgYSBjaGFuY2UgdG8gYmUgZHJvcHBlZFxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZ3JpZC5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllcygpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmF0dGFjaENoYWluKCk7XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0luZGV4ID4gLTIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tGb3JBcmVhUmVzaXplQ3Vyc29yQ2hhbmdlKGdyaWQsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGZpbGwgdGhpcyBpblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBjaGVja0ZvckFyZWFSZXNpemVDdXJzb3JDaGFuZ2U6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc0VuYWJsZWQgPSB0aGlzLmlzRW5hYmxlZChncmlkKTtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCAmJiB0aGlzLm92ZXJBcmVhRGl2aWRlcihncmlkLCBldmVudCkgPiAtMSAmJiB0aGlzLmlzRmlyc3RGaXhlZE90aGVyQXJlYShncmlkLCBldmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gdGhpcy5nZXRDdXJzb3JOYW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Rml4ZWRBcmVhQ291bnQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCkgKyAoZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkgPyAxIDogMCkgKyAoZ3JpZC5oYXNIaWVyYXJjaHlDb2x1bW4oKSA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqIEBkZWZhdWx0IC0yXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhhbmRsZURvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNFbmFibGVkID0gdGhpcy5pc0VuYWJsZWQoZ3JpZCk7XG4gICAgICAgIHZhciBoYXNDdXJzb3IgPSB0aGlzLm92ZXJBcmVhRGl2aWRlcihncmlkLCBldmVudCkgPiAtMTsgLy90aGlzLmN1cnNvciAhPT0gbnVsbDtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAvL3ZhciBoZWFkZXJDb2xDb3VudCA9IGdyaWQuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIGlmIChpc0VuYWJsZWQgJiYgaGFzQ3Vyc29yICYmIChncmlkQ2VsbC55IDw9IGhlYWRlclJvd0NvdW50KSkge1xuICAgICAgICAgICAgZ3JpZC5hdXRvc2l6ZUNvbHVtbihncmlkQ2VsbC54IC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uUmVzaXppbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDb2x1bW5TZWxlY3Rpb24gPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uU2VsZWN0aW9uJywge1xuXG4gICAgYWxpYXM6ICdDb2x1bW5TZWxlY3Rpb24nLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnJlbnREcmFnOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNlbGwgY29vcmRpbmF0ZXMgb2YgdGhlIHdoZXJlIHRoZSBtb3VzZSBwb2ludGVyIGlzIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgbGFzdERyYWdDZWxsOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHRpbWUgYW4gYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkxhc3RBdXRvOiAwLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHRpbWUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkF1dG9TdGFydDogMCxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIGlmICgoIWdyaWQuaXNDb2x1bW5TZWxlY3Rpb24oKSB8fCBldmVudC5tb3VzZVBvaW50LnkgPCA1KSAmJiB0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzUmlnaHRDbGljayA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2s7XG4gICAgICAgIHZhciBjZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciB2aWV3Q2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGR4ID0gY2VsbC54O1xuICAgICAgICB2YXIgZHkgPSBjZWxsLnk7XG5cbiAgICAgICAgdmFyIGlzSGVhZGVyID0gZ3JpZC5pc1Nob3dIZWFkZXJSb3coKSAmJiBkeSA9PT0gMCAmJiBkeCAhPT0gLTE7XG5cbiAgICAgICAgaWYgKGlzUmlnaHRDbGljayB8fCAhaXNIZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuXG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIC8vY2hlY2sgYm90aCB4IGFuZCB5IHZhbHVlcyBpbmRlcGVuZGVudGx5XG4gICAgICAgICAgICBpZiAodmlld0NlbGwueCA8IG51bUZpeGVkQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIGR4ID0gdmlld0NlbGwueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRDZWxsID0gZ3JpZC5uZXdQb2ludChkeCwgMCk7XG5cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHZhciBrZXlzID0gcHJpbUV2ZW50LmRldGFpbC5rZXlzO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbihncmlkLCBkQ2VsbCwga2V5cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcblxuICAgICAgICBpZiAoKCFncmlkLmlzQ29sdW1uU2VsZWN0aW9uKCkgfHwgdGhpcy5pc0NvbHVtbkRyYWdnaW5nKGdyaWQpKSAmJiB0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzUmlnaHRDbGljayA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2s7XG5cbiAgICAgICAgaWYgKGlzUmlnaHRDbGljayB8fCAhdGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG5cbiAgICAgICAgICAgIHZhciBjZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgICAgICB2YXIgdmlld0NlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgICAgICB2YXIgZHggPSBjZWxsLng7XG4gICAgICAgICAgICB2YXIgZHkgPSBjZWxsLnk7XG5cbiAgICAgICAgICAgIC8vaWYgd2UgYXJlIGluIHRoZSBmaXhlZCBhcmVhIGRvIG5vdCBhcHBseSB0aGUgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy9jaGVjayBib3RoIHggYW5kIHkgdmFsdWVzIGluZGVwZW5kZW50bHlcbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC54IDwgbnVtRml4ZWRDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgZHggPSB2aWV3Q2VsbC54O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZENlbGwgPSBncmlkLm5ld1BvaW50KGR4LCBkeSk7XG5cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYWcgPSBwcmltRXZlbnQuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBkQ2VsbDtcblxuICAgICAgICAgICAgdGhpcy5jaGVja0RyYWdTY3JvbGwoZ3JpZCwgdGhpcy5jdXJyZW50RHJhZyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgZENlbGwsIHByaW1FdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChncmlkLmdldExhc3RTZWxlY3Rpb25UeXBlKCkgIT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21tYW5kID0gJ2hhbmRsZScgKyBldmVudC5kZXRhaWwuY2hhcjtcbiAgICAgICAgaWYgKHRoaXNbY29tbWFuZF0pIHtcbiAgICAgICAgICAgIHRoaXNbY29tbWFuZF0uY2FsbCh0aGlzLCBncmlkLCBldmVudC5kZXRhaWwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIGEgbW91c2VkcmFnIHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIGdyaWRDZWxsLCBrZXlzKSB7XG5cbiAgICAgICAgLy92YXIgYmVoYXZpb3IgPSBncmlkLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIHZhciB4ID0gZ3JpZENlbGwueDtcbiAgICAgICAgLy8gICAgICAgICAgICB2YXIgcHJldmlvdXNEcmFnRXh0ZW50ID0gZ3JpZC5nZXREcmFnRXh0ZW50KCk7XG4gICAgICAgIHZhciBtb3VzZURvd24gPSBncmlkLmdldE1vdXNlRG93bigpO1xuXG4gICAgICAgIHZhciBuZXdYID0geCAtIG1vdXNlRG93bi54O1xuICAgICAgICAvL3ZhciBuZXdZID0geSAtIG1vdXNlRG93bi55O1xuXG4gICAgICAgIC8vIGlmIChwcmV2aW91c0RyYWdFeHRlbnQueCA9PT0gbmV3WCAmJiBwcmV2aW91c0RyYWdFeHRlbnQueSA9PT0gbmV3WSkge1xuICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb24oKTtcblxuICAgICAgICBncmlkLnNlbGVjdENvbHVtbihtb3VzZURvd24ueCwgeCk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KG5ld1gsIDApKTtcblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGNoZWNrcyB3aGlsZSB3ZXJlIGRyYWdnaW5nIGlmIHdlIGdvIG91dHNpZGUgdGhlIHZpc2libGUgYm91bmRzLCBpZiBzbywga2ljayBvZmYgdGhlIGV4dGVybmFsIGF1dG9zY3JvbGwgY2hlY2sgZnVuY3Rpb24gKGFib3ZlKVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBjaGVja0RyYWdTY3JvbGw6IGZ1bmN0aW9uKGdyaWQsIG1vdXNlKSB7XG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCk7XG4gICAgICAgIHZhciBpbnNpZGUgPSBiLmNvbnRhaW5zKG1vdXNlKTtcbiAgICAgICAgaWYgKGluc2lkZSkge1xuICAgICAgICAgICAgaWYgKGdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRHJhZyhncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gbWFrZXMgc3VyZSB0aGF0IHdoaWxlIHdlIGFyZSBkcmFnZ2luZyBvdXRzaWRlIG9mIHRoZSBncmlkIHZpc2libGUgYm91bmRzLCB3ZSBzcmNyb2xsIGFjY29yZGluZ2x5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBzY3JvbGxEcmFnOiBmdW5jdGlvbihncmlkKSB7XG5cbiAgICAgICAgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0RHJhZ0NlbGwgPSB0aGlzLmxhc3REcmFnQ2VsbDtcbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKTtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgeU9mZnNldCA9IDA7XG5cbiAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtRml4ZWRSb3dzID0gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgdmFyIGRyYWdFbmRJbkZpeGVkQXJlYVggPSBsYXN0RHJhZ0NlbGwueCA8IG51bUZpeGVkQ29sdW1ucztcbiAgICAgICAgdmFyIGRyYWdFbmRJbkZpeGVkQXJlYVkgPSBsYXN0RHJhZ0NlbGwueSA8IG51bUZpeGVkUm93cztcblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy54IDwgYi5vcmlnaW4ueCkge1xuICAgICAgICAgICAgeE9mZnNldCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueCA+IGIub3JpZ2luLnggKyBiLmV4dGVudC54KSB7XG4gICAgICAgICAgICB4T2Zmc2V0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmFnQ2VsbE9mZnNldFggPSB4T2Zmc2V0O1xuICAgICAgICB2YXIgZHJhZ0NlbGxPZmZzZXRZID0geU9mZnNldDtcblxuICAgICAgICBpZiAoZHJhZ0VuZEluRml4ZWRBcmVhWCkge1xuICAgICAgICAgICAgZHJhZ0NlbGxPZmZzZXRYID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmFnRW5kSW5GaXhlZEFyZWFZKSB7XG4gICAgICAgICAgICBkcmFnQ2VsbE9mZnNldFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBsYXN0RHJhZ0NlbGwucGx1c1hZKGRyYWdDZWxsT2Zmc2V0WCwgZHJhZ0NlbGxPZmZzZXRZKTtcbiAgICAgICAgZ3JpZC5zY3JvbGxCeSh4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIGxhc3REcmFnQ2VsbCwgW10pOyAvLyB1cGRhdGUgdGhlIHNlbGVjdGlvblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnNjcm9sbERyYWcuYmluZCh0aGlzLCBncmlkKSwgMjUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGV4dGVuZCBhIHNlbGVjdGlvbiBvciBjcmVhdGUgb25lIGlmIHRoZXJlIGlzbnQgeWV0XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JpZENlbGwgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgZXh0ZW5kU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCBncmlkQ2VsbCwga2V5cykge1xuICAgICAgICBncmlkLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIC8vdmFyIGhhc0NUUkwgPSBrZXlzLmluZGV4T2YoJ0NUUkwnKSAhPT0gLTE7XG4gICAgICAgIHZhciBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSAhPT0gLTE7XG5cbiAgICAgICAgLy8gdmFyIHNjcm9sbFRvcCA9IGdyaWQuZ2V0VlNjcm9sbFZhbHVlKCk7XG4gICAgICAgIC8vIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICAvLyB2YXIgbnVtRml4ZWRDb2x1bW5zID0gMDsvL2dyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICAvLyB2YXIgbnVtRml4ZWRSb3dzID0gMDsvL2dyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBtb3VzZVBvaW50ID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcbiAgICAgICAgdmFyIHggPSBncmlkQ2VsbC54OyAvLyAtIG51bUZpeGVkQ29sdW1ucyArIHNjcm9sbExlZnQ7XG4gICAgICAgIHZhciB5ID0gZ3JpZENlbGwueTsgLy8gLSBudW1GaXhlZFJvd3MgKyBzY3JvbGxUb3A7XG5cbiAgICAgICAgLy93ZXJlIG91dHNpZGUgb2YgdGhlIGdyaWQgZG8gbm90aGluZ1xuICAgICAgICBpZiAoeCA8IDAgfHwgeSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vd2UgaGF2ZSByZXBlYXRlZCBhIGNsaWNrIGluIHRoZSBzYW1lIHNwb3QgZGVzbGVjdCB0aGUgdmFsdWUgZnJvbSBsYXN0IHRpbWVcbiAgICAgICAgLy8gaWYgKG1vdXNlUG9pbnQgJiYgeCA9PT0gbW91c2VQb2ludC54ICYmIHkgPT09IG1vdXNlUG9pbnQueSkge1xuICAgICAgICAvLyAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgLy8gICAgIGdyaWQucG9wTW91c2VEb3duKCk7XG4gICAgICAgIC8vICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmICghaGFzQ1RSTCAmJiAhaGFzU0hJRlQpIHtcbiAgICAgICAgLy8gICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBncmlkLnNlbGVjdENvbHVtbih4LCBtb3VzZVBvaW50LngpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoeCAtIG1vdXNlUG9pbnQueCwgMCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZC50b2dnbGVTZWxlY3RDb2x1bW4oeCwga2V5cyk7XG4gICAgICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KHgsIHkpKTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgfVxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUFNISUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURPV046IGZ1bmN0aW9uKGdyaWQpIHtcblxuICAgICAgICAvLyB2YXIgbW91c2VDb3JuZXIgPSBncmlkLmdldE1vdXNlRG93bigpLnBsdXMoZ3JpZC5nZXREcmFnRXh0ZW50KCkpO1xuICAgICAgICAvLyB2YXIgbWF4Um93cyA9IGdyaWQuZ2V0Um93Q291bnQoKSAtIDE7XG5cbiAgICAgICAgLy8gdmFyIG5ld1ggPSBtb3VzZUNvcm5lci54O1xuICAgICAgICAvLyB2YXIgbmV3WSA9IGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKSArIGdyaWQuZ2V0VlNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgLy8gbmV3WSA9IE1hdGgubWluKG1heFJvd3MsIG5ld1kpO1xuXG4gICAgICAgIC8vIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIC8vIGdyaWQuc2VsZWN0KG5ld1gsIG5ld1ksIDAsIDApO1xuICAgICAgICAvLyBncmlkLnNldE1vdXNlRG93bihuZXcgZ3JpZC5yZWN0YW5ndWxhci5Qb2ludChuZXdYLCBuZXdZKSk7XG4gICAgICAgIC8vIGdyaWQuc2V0RHJhZ0V4dGVudChuZXcgZ3JpZC5yZWN0YW5ndWxhci5Qb2ludCgwLCAwKSk7XG5cbiAgICAgICAgLy8gZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVA6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVMRUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIElmIHdlIGFyZSBob2xkaW5nIGRvd24gdGhlIHNhbWUgbmF2aWdhdGlvbiBrZXksIGFjY2VsZXJhdGUgdGhlIGluY3JlbWVudCB3ZSBzY3JvbGxcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICBnZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMTtcbiAgICAgICAgdmFyIGVsYXBzZWQgPSB0aGlzLmdldEF1dG9TY3JvbGxEdXJhdGlvbigpIC8gMjAwMDtcbiAgICAgICAgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQpKTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgc3RhcnQgdGltZSB0byByaWdodCBub3cgd2hlbiB3ZSBpbml0aWF0ZSBhbiBhdXRvIHNjcm9sbFxuICAgICAqL1xuICAgIHNldEF1dG9TY3JvbGxTdGFydFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNiQXV0b1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGF1dG9zY3JvbGwgc3RhcnQgdGltZSBpZiB3ZSBoYXZlbid0IGF1dG9zY3JvbGxlZCB3aXRoaW4gdGhlIGxhc3QgNTAwbXMgb3RoZXJ3aXNlIHVwZGF0ZSB0aGUgY3VycmVudCBhdXRvc2Nyb2xsIHRpbWVcbiAgICAgKi9cbiAgICBwaW5nQXV0b1Njcm9sbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF1dG9TY3JvbGxTdGFydFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNiTGFzdEF1dG8gPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGFuc3dlciBob3cgbG9uZyB3ZSBoYXZlIGJlZW4gYXV0byBzY3JvbGxpbmdcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICBnZXRBdXRvU2Nyb2xsRHVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnNiQXV0b1N0YXJ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEF1Z21lbnQgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiBleHRlbnQgYnkgKG9mZnNldFgsb2Zmc2V0WSkgYW5kIHNjcm9sbCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNoaWZ0U2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRYKSB7XG5cbiAgICAgICAgdmFyIG1heENvbHVtbnMgPSBncmlkLmdldENvbHVtbkNvdW50KCkgLSAxO1xuXG4gICAgICAgIHZhciBtYXhWaWV3YWJsZUNvbHVtbnMgPSBncmlkLmdldFZpc2libGVDb2x1bW5zKCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IE1hdGgubWluKG1heENvbHVtbnMsIG1heFZpZXdhYmxlQ29sdW1ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JpZ2luID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcbiAgICAgICAgdmFyIGV4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpO1xuXG4gICAgICAgIHZhciBuZXdYID0gZXh0ZW50LnggKyBvZmZzZXRYO1xuICAgICAgICAvL3ZhciBuZXdZID0gZ3JpZC5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIG5ld1ggPSBNYXRoLm1pbihtYXhDb2x1bW5zIC0gb3JpZ2luLngsIE1hdGgubWF4KC1vcmlnaW4ueCwgbmV3WCkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0Q29sdW1uKG9yaWdpbi54LCBvcmlnaW4ueCArIG5ld1gpO1xuXG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KG5ld1gsIDApKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbENvbElzVmlzaWJsZShuZXdYICsgb3JpZ2luLngsIG9mZnNldFgpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcGxhY2UgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiB3aXRoIGEgc2luZ2xlIGNlbGwgc2VsZWN0aW9uIHRoYXQgaXMgbW92ZWQgKG9mZnNldFgsb2Zmc2V0WSkgZnJvbSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIGV4dGVudC5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRYKSB7XG5cbiAgICAgICAgdmFyIG1heENvbHVtbnMgPSBncmlkLmdldENvbHVtbkNvdW50KCkgLSAxO1xuXG4gICAgICAgIHZhciBtYXhWaWV3YWJsZUNvbHVtbnMgPSBncmlkLmdldFZpc2libGVDb2x1bW5zQ291bnQoKSAtIDE7XG5cbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICBtYXhDb2x1bW5zID0gTWF0aC5taW4obWF4Q29sdW1ucywgbWF4Vmlld2FibGVDb2x1bW5zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSk7XG5cbiAgICAgICAgdmFyIG5ld1ggPSBtb3VzZUNvcm5lci54ICsgb2Zmc2V0WDtcbiAgICAgICAgLy92YXIgbmV3WSA9IGdyaWQuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucywgTWF0aC5tYXgoMCwgbmV3WCkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0Q29sdW1uKG5ld1gpO1xuICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KG5ld1gsIDApKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsQ29sSXNWaXNpYmxlKG5ld1gsIG9mZnNldFgpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcblxuICAgIH0sXG5cbiAgICBpc0NvbHVtbkRyYWdnaW5nOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHZhciBkcmFnZ2VyID0gZ3JpZC5sb29rdXBGZWF0dXJlKCdDb2x1bW5Nb3ZpbmcnKTtcbiAgICAgICAgaWYgKCFkcmFnZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzQWN0aXZhdGVkID0gZHJhZ2dlci5kcmFnZ2luZyAmJiAhdGhpcy5kcmFnZ2luZztcbiAgICAgICAgcmV0dXJuIGlzQWN0aXZhdGVkO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uU2VsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sdW1uU29ydGluZyA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5Tb3J0aW5nJywge1xuXG4gICAgYWxpYXM6ICdDb2x1bW5Tb3J0aW5nJyxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Tb3J0aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICBpZiAoZ3JpZC5pc1Nob3dIZWFkZXJSb3coKSAmJiBncmlkQ2VsbC55ID09PSAwICYmIGdyaWRDZWxsLnggIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5rZXlzO1xuICAgICAgICAgICAgZ3JpZC50b2dnbGVTb3J0KGdyaWRDZWxsLngsIGtleXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU29ydGluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIHkgPSBldmVudC5ncmlkQ2VsbC55O1xuICAgICAgICBpZiAodGhpcy5pc0ZpeGVkUm93KGdyaWQsIGV2ZW50KSAmJiB5IDwgMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblNvcnRpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnZXh0ZW5kLW1lJykuQmFzZTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjIGluc3RhbmNlcyBvZiBmZWF0dXJlcyBhcmUgY29ubmVjdGVkIHRvIG9uZSBhbm90aGVyIHRvIG1ha2UgYSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eSBmb3IgaGFuZGxpbmcgYWxsIHRoZSBpbnB1dCB0byB0aGUgaHlwZXJncmlkLlxuICovXG52YXIgRmVhdHVyZSA9IEJhc2UuZXh0ZW5kKCdGZWF0dXJlJywge1xuXG4gICAgLyoqXG4gICAgICogdGhlIG5leHQgZmVhdHVyZSB0byBiZSBnaXZlbiBhIGNoYW5jZSB0byBoYW5kbGUgaW5jb21pbmcgZXZlbnRzXG4gICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIG5leHQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBhIHRlbXBvcmFyeSBob2xkaW5nIGZpZWxkIGZvciBteSBuZXh0IGZlYXR1cmUgd2hlbiBJJ20gaW4gYSBkaXNjb25uZWN0ZWQgc3RhdGVcbiAgICAgKiBAdHlwZSB7RmVhdHVyZX1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICovXG4gICAgZGV0YWNoZWQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgY3Vyc29yIEkgd2FudCB0byBiZSBkaXNwbGF5ZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJzb3I6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgY2VsbCBsb2NhdGlvbiB3aGVyZSB0aGUgY3Vyc29yIGlzIGN1cnJlbnRseVxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICovXG4gICAgY3VycmVudEhvdmVyQ2VsbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCBteSBuZXh0IGZpZWxkLCBvciBpZiBpdCdzIHBvcHVsYXRlZCBkZWxlZ2F0ZSB0byB0aGUgZmVhdHVyZSBpbiBteSBuZXh0IGZpZWxkXG4gICAgICogQHBhcmFtIHtGZWF0dXJlfSBuZXh0RmVhdHVyZSAtIHRoaXMgaXMgaG93IHdlIGJ1aWxkIHRoZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqL1xuICAgIHNldE5leHQ6IGZ1bmN0aW9uKG5leHRGZWF0dXJlKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5zZXROZXh0KG5leHRGZWF0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG5leHRGZWF0dXJlO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hlZCA9IG5leHRGZWF0dXJlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRpc2Nvbm5lY3QgbXkgY2hpbGRcbiAgICAgKi9cbiAgICBkZXRhY2hDaGFpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJlYXR0YWNoIG15IGNoaWxkIGZyb20gdGhlIGRldGFjaGVkIHJlZmVyZW5jZVxuICAgICAqL1xuICAgIGF0dGFjaENoYWluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gdGhpcy5kZXRhY2hlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIG1vdXNlIG1vdmUgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VFeGl0OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VFeGl0KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRW50ZXI6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZUVudGVyKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVdoZWVsTW92ZWQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVXaGVlbE1vdmVkKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlSG9sZFB1bHNlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlSG9sZFB1bHNlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVRhcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZVRhcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlQ29udGV4dE1lbnU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVDb250ZXh0TWVudShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgdG9nZ2xlIHRoZSBjb2x1bW4gcGlja2VyXG4gICAgICovXG5cbiAgICB0b2dnbGVDb2x1bW5QaWNrZXI6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LnRvZ2dsZUNvbHVtblBpY2tlcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRvZ2dsZSB0aGUgY29sdW1uIHBpY2tlclxuICAgICAqL1xuXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQubW92ZVNpbmdsZVNlbGVjdChncmlkLCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRml4ZWRSb3c6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGlzRml4ZWQgPSBncmlkQ2VsbC55IDwgZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgICAgIHJldHVybiBpc0ZpeGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRmlyc3RGaXhlZFJvdzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgaXNGaXhlZCA9IGdyaWRDZWxsLnkgPCAxO1xuICAgICAgICByZXR1cm4gaXNGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpeGVkQ29sdW1uOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBpc0ZpeGVkID0gZ3JpZENlbGwueCA8IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICByZXR1cm4gaXNGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpcnN0Rml4ZWRDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGVkZ2UgPSBncmlkLmlzU2hvd1Jvd051bWJlcnMoKSA/IDAgOiAxO1xuICAgICAgICB2YXIgaXNGaXhlZCA9IGdyaWRDZWxsLnggPCBlZGdlO1xuICAgICAgICByZXR1cm4gaXNGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc1RvcExlZnQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc1RvcExlZnQgPSB0aGlzLmlzRml4ZWRSb3coZ3JpZCwgZXZlbnQpICYmIHRoaXMuaXNGaXhlZENvbHVtbihncmlkLCBldmVudCk7XG4gICAgICAgIHJldHVybiBpc1RvcExlZnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgc2V0Q3Vyc29yOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICBncmlkLmJlQ3Vyc29yKHRoaXMuY3Vyc29yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGluaXRpYWxpemVPbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGZWF0dXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRmlsdGVycyA9IEZlYXR1cmUuZXh0ZW5kKCdGaWx0ZXJzJywge1xuXG4gICAgYWxpYXM6ICdGaWx0ZXJzJyxcblxuICAgIGhhbmRsZVRhcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIGlmIChncmlkLmlzRmlsdGVyUm93KGdyaWRDZWxsLnkpICYmIGdyaWRDZWxsLnggIT09IC0xKSB7XG4gICAgICAgICAgICBncmlkLmZpbHRlckNsaWNrZWQoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZVRhcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbnZhciBjb21tYW5kcyA9IHtcbiAgICBQQUdFRE9XTjogZnVuY3Rpb24oZ3JpZCkgeyBncmlkLnBhZ2VEb3duKCk7IH0sXG4gICAgUEFHRVVQOiBmdW5jdGlvbihncmlkKSB7IGdyaWQucGFnZVVwKCk7IH0sXG4gICAgUEFHRUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHsgZ3JpZC5wYWdlTGVmdCgpOyB9LFxuICAgIFBBR0VSSUdIVDogZnVuY3Rpb24oZ3JpZCkgeyBncmlkLnBhZ2VSaWdodCgpOyB9XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgS2V5UGFnaW5nID0gRmVhdHVyZS5leHRlbmQoJ0tleVBhZ2luZycsIHtcblxuICAgIGFsaWFzOiAnS2V5UGFnaW5nJyxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBtZW1iZXJPZiBLZXlQYWdpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IGV2ZW50LmRldGFpbC5jaGFyO1xuICAgICAgICB2YXIgZnVuYyA9IGNvbW1hbmRzW2RldGFpbF07XG4gICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICBmdW5jKGdyaWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWdpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBPbkhvdmVyID0gRmVhdHVyZS5leHRlbmQoJ09uSG92ZXInLCB7XG5cbiAgICBhbGlhczogJ09uSG92ZXInLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgSGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBtZW1iZXJPZiBPbkhvdmVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRIb3ZlckNlbGwgPSBncmlkLmdldEhvdmVyQ2VsbCgpO1xuICAgICAgICBpZiAoIWV2ZW50LmdyaWRDZWxsLmVxdWFscyhjdXJyZW50SG92ZXJDZWxsKSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRIb3ZlckNlbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRXhpdChncmlkLCBjdXJyZW50SG92ZXJDZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VFbnRlcihncmlkLCBldmVudCk7XG4gICAgICAgICAgICBncmlkLnNldEhvdmVyQ2VsbChldmVudC5ncmlkQ2VsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9uSG92ZXI7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qIGdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG52YXIgQU5JTUFUSU9OX1RJTUUgPSAyMDA7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBPdmVybGF5ID0gRmVhdHVyZS5leHRlbmQoJ092ZXJsYXknLCB7XG5cbiAgICBhbGlhczogJ092ZXJsYXknLFxuXG4gICAgLyoqXG4gICAgICogaXMgdGhlIGVkaXRvciBvcGVuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIE92ZXJsYXkucHJvdG90eXBlXG4gICAgICovXG4gICAgb3BlbkVkaXRvcjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgT3ZlcmxheS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUtleVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIga2V5ID0gZXZlbnQuZGV0YWlsLmNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGtleXMgPSBncmlkLnJlc29sdmVQcm9wZXJ0eSgnZWRpdG9yQWN0aXZhdGlvbktleXMnKTtcbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQ29sdW1uUGlja2VyKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBPdmVybGF5LnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRvZ2dsZSB0aGUgY29sdW1uIHBpY2tlciBvbi9vZmZcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHRvZ2dsZUNvbHVtblBpY2tlcjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAodGhpcy5pc0NvbHVtblBpY2tlck9wZW4oZ3JpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb2x1bW5QaWNrZXIoZ3JpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5Db2x1bW5QaWNrZXIoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE92ZXJsYXkucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJucyB0cnVlIGlmIHRoZSBjb2x1bW4gcGlja2VyIGlzIG9wZW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGlzQ29sdW1uUGlja2VyT3BlbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5LnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE92ZXJsYXkucHJvdG90eXBlXG4gICAgICogQGRlc2Mgb3BlbiB0aGUgY29sdW1uIHBpY2tlclxuICAgICAqICMjIyMgcmV0dXJuczogdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgb3BlbkNvbHVtblBpY2tlcjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAodGhpcy5pc0NvbHVtblBpY2tlck9wZW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BlbkVkaXRvciA9IHRydWU7XG4gICAgICAgIGlmIChncmlkLmdldEJlaGF2aW9yKCkub3BlbkVkaXRvcih0aGlzLm92ZXJsYXkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ2JhY2tncm91bmRDb2xvcicpO1xuXG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS50b3AgPSAnMCUnO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUucmlnaHQgPSAnMCUnO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUuYm90dG9tID0gJzAlJztcbiAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlLmxlZnQgPSAnMCUnO1xuXG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS5tYXJnaW5Ub3AgPSAnMTVweCc7XG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS5tYXJnaW5SaWdodCA9ICczNXB4JztcbiAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlLm1hcmdpbkJvdHRvbSA9ICczNXB4JztcbiAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlLm1hcmdpbkxlZnQgPSAnMTVweCc7XG5cbiAgICAgICAgc2VsZi5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnJztcblxuXG4gICAgICAgIGlmICghdGhpcy5fY2xvc2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHNlbGYuZ2V0Q2hhckZvcihncmlkLCBlLmtleUNvZGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBncmlkLnJlc29sdmVQcm9wZXJ0eSgnZWRpdG9yQWN0aXZhdGlvbktleXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGtleSkgPiAtMSB8fCBlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZUNvbHVtblBpY2tlcihncmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9ncmlkLnNldEZvY3VzYWJsZShmYWxzZSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYub3ZlcmxheS5zdHlsZS5vcGFjaXR5ID0gMC45NTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBzZWxmLl9jbG9zZXIsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLm92ZXJsYXkuZm9jdXMoKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE92ZXJsYXkucHJvdG90eXBlXG4gICAgICogQGRlc2MgY2xvc2UgdGhlIGNvbHVtbiBwaWNrZXJcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGNsb3NlQ29sdW1uUGlja2VyOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIC8vZ3JpZC5zZXRGb2N1c2FibGUodHJ1ZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQ29sdW1uUGlja2VyT3BlbigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3BlbkVkaXRvcikge1xuICAgICAgICAgICAgdGhpcy5vcGVuRWRpdG9yID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQuZ2V0QmVoYXZpb3IoKS5jbG9zZUVkaXRvcih0aGlzLm92ZXJsYXkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2Nsb3NlciwgZmFsc2UpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLm92ZXJsYXkuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLm92ZXJsYXkuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBzZWxmLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGdyaWQudGFrZUZvY3VzKCk7XG4gICAgICAgIH0sIEFOSU1BVElPTl9USU1FKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE92ZXJsYXkucHJvdG90eXBlXG4gICAgICogQGRlc2MgaW5pdGlhbGl6ZSBteXNlbGYgaW50byB0aGUgZ3JpZFxuICAgICAqICMjIyMgcmV0dXJuczogdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZU9uOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZU92ZXJsYXlTdXJmYWNlKGdyaWQpO1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBPdmVybGF5LnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGluaXRpYWxpemUgdGhlIG92ZXJsYXkgc3VyZmFjZSBpbnRvIHRoZSBncmlkXG4gICAgICogIyMjIyByZXR1cm5zOiB0eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplT3ZlcmxheVN1cmZhY2U6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMub3ZlcmxheS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUuYm94U2hhZG93ID0gJzAgMTlweCAzOHB4IHJnYmEoMCwwLDAsMC4zMCksIDAgMTVweCAxMnB4IHJnYmEoMCwwLDAsMC4yMiknO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlLnRyYW5zaXRpb24gPSAnb3BhY2l0eSAnICsgQU5JTUFUSU9OX1RJTUUgKyAnbXMgZWFzZS1pbic7XG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlLnpJbmRleCA9IDEwO1xuICAgICAgICBncmlkLmRpdi5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXkpO1xuICAgICAgICAvL2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5vdmVybGF5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE92ZXJsYXkucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IGEgaHVtYW4gcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGtleSBwcmVzc2VkIGZyb20gaXQncyBpbnRlZ2VyIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlZ2VyIC0gdGhlIGludGVnZXIgd2Ugd2FudCB0aGUgY2hhciBmb3JcbiAgICAgKi9cbiAgICBnZXRDaGFyRm9yOiBmdW5jdGlvbihncmlkLCBpbnRlZ2VyKSB7XG4gICAgICAgIHZhciBjaGFyTWFwID0gZ3JpZC5nZXRDYW52YXMoKS5nZXRDaGFyTWFwKCk7XG4gICAgICAgIHJldHVybiBjaGFyTWFwW2ludGVnZXJdWzBdO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gT3ZlcmxheTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbHVtblJlc2l6aW5nID0gcmVxdWlyZSgnLi9Db2x1bW5SZXNpemluZycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUm93UmVzaXppbmcgPSBDb2x1bW5SZXNpemluZy5leHRlbmQoJ1Jvd1Jlc2l6aW5nJywge1xuXG4gICAgYWxpYXM6ICdSb3dSZXNpemluZycsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgaW5kZXggb2YgdGhlIHJvdy9jb2x1bW4gd2UgYXJlIGRyYWdnaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnQXJlYTogLTEsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIHdoZXJlIHRoZSBkcmFnIHdhcyBpbml0aWF0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdTdGFydDogLTEsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgc3RhcnRpbmcgd2lkdGgvaGVpZ2h0IG9mIHRoZSByb3cvY29sdW1uIHdlIGFyZSBkcmFnZ2luZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0FyZWFTdGFydGluZ1NpemU6IC0xLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldCB0aGUgbW91c2UgeCx5IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSB0aGUgbW91c2UgZXZlbnQgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBnZXRNb3VzZVZhbHVlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXQgdGhlIGdyaWQgY2VsbCB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtQb2ludH0gZ3JpZENlbGxcbiAgICAgKi9cbiAgICBnZXRHcmlkQ2VsbFZhbHVlOiBmdW5jdGlvbihncmlkQ2VsbCkge1xuICAgICAgICByZXR1cm4gZ3JpZENlbGwueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgZ3JpZHMgeCx5IHNjcm9sbCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBnZXRTY3JvbGxWYWx1ZTogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSByb3cvY29sdW1uIG9mIGludGVyZXN0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSByb3cvY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0QXJlYVNpemU6IGZ1bmN0aW9uKGdyaWQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldFJvd0hlaWdodChpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiBhdCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgcm93L2NvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHRoZSB3aWR0aC9oZWlnaHQgdG8gc2V0IHRvXG4gICAgICovXG4gICAgc2V0QXJlYVNpemU6IGZ1bmN0aW9uKGdyaWQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBncmlkLnNldFJvd0hlaWdodChpbmRleCwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJucyB0aGUgaW5kZXggb2Ygd2hpY2ggZGl2aWRlciBJJ20gb3ZlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG92ZXJBcmVhRGl2aWRlcjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQub3ZlclJvd0RpdmlkZXIoZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW0gSSBvdmVyIHRoZSBjb2x1bW4vcm93IGFyZWFcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaXNGaXJzdEZpeGVkT3RoZXJBcmVhOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZpcnN0Rml4ZWRDb2x1bW4oZ3JpZCwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBjdXJzb3IgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q3Vyc29yTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAncm93LXJlc2l6ZSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIHJlY2VudGx5IHJlbmRlcmVkIGFyZWEncyB3aWR0aC9oZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRQcmV2aW91c0Fic29sdXRlU2l6ZTogZnVuY3Rpb24oZ3JpZCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0UmVuZGVyZWRIZWlnaHQoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBmaXhlZCBhcmVhIHJvd3MvY29sdW1ucyBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBnZXRPdGhlckZpeGVkQXJlYUNvdW50OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Rml4ZWRBcmVhQ291bnQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpICsgZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkLmlzUm93UmVzaXplYWJsZSgpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUm93UmVzaXppbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSb3dTZWxlY3Rpb24gPSBGZWF0dXJlLmV4dGVuZCgnUm93U2VsZWN0aW9uJywge1xuXG4gICAgYWxpYXM6ICdSb3dTZWxlY3Rpb24nLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50RHJhZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjZWxsIGNvb3JkaW5hdGVzIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxhc3REcmFnQ2VsbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBwcmV2aW91cyB0aW1lIGFuIGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JMYXN0QXV0bzogMCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JBdXRvU3RhcnQ6IDAsXG5cbiAgICBkcmFnQXJtZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnQXJtZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0FybWVkID0gZmFsc2U7XG4gICAgICAgICAgICAvL2dsb2JhbCByb3cgc2VsZWN0aW9uXG4gICAgICAgICAgICBpZiAoZXZlbnQuZ3JpZENlbGwueCA9PT0gLTEgJiYgZXZlbnQuZ3JpZENlbGwueSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGdyaWQudG9nZ2xlU2VsZWN0QWxsUm93cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcblxuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcbiAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdmFyIHZpZXdDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgZHggPSBjZWxsLng7XG4gICAgICAgIHZhciBkeSA9IGNlbGwueTtcblxuXG4gICAgICAgIHZhciBpc0hlYWRlciA9IGdyaWQuaXNTaG93Um93TnVtYmVycygpICYmIGR4IDwgMDtcblxuICAgICAgICBpZiAoIWdyaWQuaXNSb3dTZWxlY3Rpb24oKSB8fCBpc1JpZ2h0Q2xpY2sgfHwgIWlzSGVhZGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnkgPCBudW1GaXhlZFJvd3MpIHtcbiAgICAgICAgICAgICAgICBkeSA9IHZpZXdDZWxsLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkQ2VsbCA9IGdyaWQubmV3UG9pbnQoMCwgZHkpO1xuXG4gICAgICAgICAgICB2YXIgcHJpbUV2ZW50ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICB2YXIga2V5cyA9IHByaW1FdmVudC5kZXRhaWwua2V5cztcbiAgICAgICAgICAgIHRoaXMuZHJhZ0FybWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kU2VsZWN0aW9uKGdyaWQsIGRDZWxsLCBrZXlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcblxuICAgICAgICBpZiAoIXRoaXMuZHJhZ0FybWVkIHx8ICFncmlkLmlzUm93U2VsZWN0aW9uKCkgfHwgaXNSaWdodENsaWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgICAgIHZhciB2aWV3Q2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgICAgIC8vdmFyIGR4ID0gY2VsbC54O1xuICAgICAgICAgICAgdmFyIGR5ID0gY2VsbC55O1xuXG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIC8vY2hlY2sgYm90aCB4IGFuZCB5IHZhbHVlcyBpbmRlcGVuZGVudGx5XG4gICAgICAgICAgICBpZiAodmlld0NlbGwueSA8IG51bUZpeGVkUm93cykge1xuICAgICAgICAgICAgICAgIGR5ID0gdmlld0NlbGwueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRDZWxsID0gZ3JpZC5uZXdQb2ludCgwLCBkeSk7XG5cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYWcgPSBwcmltRXZlbnQuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBkQ2VsbDtcblxuICAgICAgICAgICAgdGhpcy5jaGVja0RyYWdTY3JvbGwoZ3JpZCwgdGhpcy5jdXJyZW50RHJhZyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgZENlbGwsIHByaW1FdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChncmlkLmdldExhc3RTZWxlY3Rpb25UeXBlKCkgIT09ICdyb3cnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21tYW5kID0gJ2hhbmRsZScgKyBldmVudC5kZXRhaWwuY2hhcjtcbiAgICAgICAgaWYgKHRoaXNbY29tbWFuZF0pIHtcbiAgICAgICAgICAgIHRoaXNbY29tbWFuZF0uY2FsbCh0aGlzLCBncmlkLCBldmVudC5kZXRhaWwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIGEgbW91c2VkcmFnIHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIGdyaWRDZWxsLCBrZXlzKSB7XG5cbiAgICAgICAgLy92YXIgYmVoYXZpb3IgPSBncmlkLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIHZhciB5ID0gZ3JpZENlbGwueTtcbiAgICAgICAgLy8gICAgICAgICAgICB2YXIgcHJldmlvdXNEcmFnRXh0ZW50ID0gZ3JpZC5nZXREcmFnRXh0ZW50KCk7XG4gICAgICAgIHZhciBtb3VzZURvd24gPSBncmlkLmdldE1vdXNlRG93bigpO1xuXG4gICAgICAgIHZhciBuZXdZID0geSAtIG1vdXNlRG93bi55O1xuICAgICAgICAvL3ZhciBuZXdZID0geSAtIG1vdXNlRG93bi55O1xuXG4gICAgICAgIC8vIGlmIChwcmV2aW91c0RyYWdFeHRlbnQueCA9PT0gbmV3WCAmJiBwcmV2aW91c0RyYWdFeHRlbnQueSA9PT0gbmV3WSkge1xuICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb24oKTtcblxuICAgICAgICBncmlkLnNlbGVjdFJvdyhtb3VzZURvd24ueSwgeSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIG5ld1kpKTtcblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGNoZWNrcyB3aGlsZSB3ZXJlIGRyYWdnaW5nIGlmIHdlIGdvIG91dHNpZGUgdGhlIHZpc2libGUgYm91bmRzLCBpZiBzbywga2ljayBvZmYgdGhlIGV4dGVybmFsIGF1dG9zY3JvbGwgY2hlY2sgZnVuY3Rpb24gKGFib3ZlKVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBjaGVja0RyYWdTY3JvbGw6IGZ1bmN0aW9uKGdyaWQsIG1vdXNlKSB7XG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCk7XG4gICAgICAgIHZhciBpbnNpZGUgPSBiLmNvbnRhaW5zKG1vdXNlKTtcbiAgICAgICAgaWYgKGluc2lkZSkge1xuICAgICAgICAgICAgaWYgKGdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRHJhZyhncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gbWFrZXMgc3VyZSB0aGF0IHdoaWxlIHdlIGFyZSBkcmFnZ2luZyBvdXRzaWRlIG9mIHRoZSBncmlkIHZpc2libGUgYm91bmRzLCB3ZSBzcmNyb2xsIGFjY29yZGluZ2x5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBzY3JvbGxEcmFnOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdERyYWdDZWxsID0gdGhpcy5sYXN0RHJhZ0NlbGw7XG4gICAgICAgIHZhciBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCk7XG4gICAgICAgIHZhciB4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHlPZmZzZXQgPSAwO1xuXG4gICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBkcmFnRW5kSW5GaXhlZEFyZWFYID0gbGFzdERyYWdDZWxsLnggPCBudW1GaXhlZENvbHVtbnM7XG4gICAgICAgIHZhciBkcmFnRW5kSW5GaXhlZEFyZWFZID0gbGFzdERyYWdDZWxsLnkgPCBudW1GaXhlZFJvd3M7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueSA8IGIub3JpZ2luLnkpIHtcbiAgICAgICAgICAgIHlPZmZzZXQgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnkgPiBiLm9yaWdpbi55ICsgYi5leHRlbnQueSkge1xuICAgICAgICAgICAgeU9mZnNldCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJhZ0NlbGxPZmZzZXRYID0geE9mZnNldDtcbiAgICAgICAgdmFyIGRyYWdDZWxsT2Zmc2V0WSA9IHlPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGRyYWdFbmRJbkZpeGVkQXJlYVgpIHtcbiAgICAgICAgICAgIGRyYWdDZWxsT2Zmc2V0WCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhZ0VuZEluRml4ZWRBcmVhWSkge1xuICAgICAgICAgICAgZHJhZ0NlbGxPZmZzZXRZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdERyYWdDZWxsID0gbGFzdERyYWdDZWxsLnBsdXNYWShkcmFnQ2VsbE9mZnNldFgsIGRyYWdDZWxsT2Zmc2V0WSk7XG4gICAgICAgIGdyaWQuc2Nyb2xsQnkoeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCBsYXN0RHJhZ0NlbGwsIFtdKTsgLy8gdXBkYXRlIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zY3JvbGxEcmFnLmJpbmQodGhpcywgZ3JpZCksIDI1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBleHRlbmQgYSBzZWxlY3Rpb24gb3IgY3JlYXRlIG9uZSBpZiB0aGVyZSBpc250IHlldFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyaWRDZWxsIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGV4dGVuZFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgZ3JpZENlbGwsIGtleXMpIHtcbiAgICAgICAgZ3JpZC5zdG9wRWRpdGluZygpO1xuICAgICAgICAvL3ZhciBoYXNDVFJMID0ga2V5cy5pbmRleE9mKCdDVFJMJykgIT09IC0xO1xuICAgICAgICB2YXIgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgIT09IC0xO1xuXG4gICAgICAgIHZhciBtb3VzZVBvaW50ID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcbiAgICAgICAgdmFyIHggPSBncmlkQ2VsbC54OyAvLyAtIG51bUZpeGVkQ29sdW1ucyArIHNjcm9sbExlZnQ7XG4gICAgICAgIHZhciB5ID0gZ3JpZENlbGwueTsgLy8gLSBudW1GaXhlZFJvd3MgKyBzY3JvbGxUb3A7XG5cbiAgICAgICAgLy93ZXJlIG91dHNpZGUgb2YgdGhlIGdyaWQgZG8gbm90aGluZ1xuICAgICAgICBpZiAoeCA8IDAgfHwgeSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNTSElGVCkge1xuICAgICAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0Um93KHksIG1vdXNlUG9pbnQueSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCB5IC0gbW91c2VQb2ludC55KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmlkLnRvZ2dsZVNlbGVjdFJvdyh5LCBrZXlzKTtcbiAgICAgICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGhhbmRsZURPV05TSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVMRUZUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVFNISUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlRE9XTjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVA6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVMRUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFQ6IGZ1bmN0aW9uKGdyaWQpIHtcblxuICAgICAgICB2YXIgbW91c2VDb3JuZXIgPSBncmlkLmdldE1vdXNlRG93bigpLnBsdXMoZ3JpZC5nZXREcmFnRXh0ZW50KCkpO1xuICAgICAgICB2YXIgbWF4Q29sdW1ucyA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG5cbiAgICAgICAgdmFyIG5ld1ggPSBncmlkLmdldEhlYWRlckNvbHVtbkNvdW50KCkgKyBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICB2YXIgbmV3WSA9IG1vdXNlQ29ybmVyLnk7XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWluKG1heENvbHVtbnMsIG5ld1gpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0KG5ld1gsIG5ld1ksIDAsIDApO1xuICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KG5ld1gsIG5ld1kpKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIElmIHdlIGFyZSBob2xkaW5nIGRvd24gdGhlIHNhbWUgbmF2aWdhdGlvbiBrZXksIGFjY2VsZXJhdGUgdGhlIGluY3JlbWVudCB3ZSBzY3JvbGxcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICBnZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMTtcbiAgICAgICAgdmFyIGVsYXBzZWQgPSB0aGlzLmdldEF1dG9TY3JvbGxEdXJhdGlvbigpIC8gMjAwMDtcbiAgICAgICAgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQpKTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgc3RhcnQgdGltZSB0byByaWdodCBub3cgd2hlbiB3ZSBpbml0aWF0ZSBhbiBhdXRvIHNjcm9sbFxuICAgICAqL1xuICAgIHNldEF1dG9TY3JvbGxTdGFydFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNiQXV0b1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGF1dG9zY3JvbGwgc3RhcnQgdGltZSBpZiB3ZSBoYXZlbid0IGF1dG9zY3JvbGxlZCB3aXRoaW4gdGhlIGxhc3QgNTAwbXMgb3RoZXJ3aXNlIHVwZGF0ZSB0aGUgY3VycmVudCBhdXRvc2Nyb2xsIHRpbWVcbiAgICAgKi9cbiAgICBwaW5nQXV0b1Njcm9sbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF1dG9TY3JvbGxTdGFydFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNiTGFzdEF1dG8gPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGFuc3dlciBob3cgbG9uZyB3ZSBoYXZlIGJlZW4gYXV0byBzY3JvbGxpbmdcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICBnZXRBdXRvU2Nyb2xsRHVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnNiQXV0b1N0YXJ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEF1Z21lbnQgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiBleHRlbnQgYnkgKG9mZnNldFgsb2Zmc2V0WSkgYW5kIHNjcm9sbCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNoaWZ0U2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRZKSB7XG5cbiAgICAgICAgdmFyIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxO1xuXG4gICAgICAgIHZhciBtYXhWaWV3YWJsZVJvd3MgPSBncmlkLmdldFZpc2libGVSb3dzKCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgbWF4Um93cyA9IE1hdGgubWluKG1heFJvd3MsIG1heFZpZXdhYmxlUm93cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JpZ2luID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcbiAgICAgICAgdmFyIGV4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpO1xuXG4gICAgICAgIHZhciBuZXdZID0gZXh0ZW50LnkgKyBvZmZzZXRZO1xuICAgICAgICAvL3ZhciBuZXdZID0gZ3JpZC5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIG5ld1kgPSBNYXRoLm1pbihtYXhSb3dzIC0gb3JpZ2luLnksIE1hdGgubWF4KC1vcmlnaW4ueSwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0Um93KG9yaWdpbi55LCBvcmlnaW4ueSArIG5ld1kpO1xuXG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIG5ld1kpKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbFJvd0lzVmlzaWJsZShuZXdZICsgb3JpZ2luLnksIG9mZnNldFkpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXBsYWNlIHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gd2l0aCBhIHNpbmdsZSBjZWxsIHNlbGVjdGlvbiB0aGF0IGlzIG1vdmVkIChvZmZzZXRYLG9mZnNldFkpIGZyb20gdGhlIHByZXZpb3VzIHNlbGVjdGlvbiBleHRlbnQuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WSkge1xuXG4gICAgICAgIHZhciBtYXhSb3dzID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVSb3dzID0gZ3JpZC5nZXRWaXNpYmxlUm93c0NvdW50KCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgbWF4Um93cyA9IE1hdGgubWluKG1heFJvd3MsIG1heFZpZXdhYmxlUm93cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW91c2VDb3JuZXIgPSBncmlkLmdldE1vdXNlRG93bigpLnBsdXMoZ3JpZC5nZXREcmFnRXh0ZW50KCkpO1xuXG4gICAgICAgIHZhciBuZXdZID0gbW91c2VDb3JuZXIueSArIG9mZnNldFk7XG4gICAgICAgIC8vdmFyIG5ld1kgPSBncmlkLmdldFJvd0NvdW50KCk7XG5cbiAgICAgICAgbmV3WSA9IE1hdGgubWluKG1heFJvd3MsIE1hdGgubWF4KDAsIG5ld1kpKTtcblxuICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICBncmlkLnNlbGVjdFJvdyhuZXdZKTtcbiAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCgwLCBuZXdZKSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbFJvd0lzVmlzaWJsZShuZXdZLCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgfSxcblxuICAgIGlzU2luZ2xlUm93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3dTZWxlY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBUaHVtYndoZWVsU2Nyb2xsaW5nID0gRmVhdHVyZS5leHRlbmQoJ1RodW1id2hlZWxTY3JvbGxpbmcnLCB7XG5cbiAgICBhbGlhczogJ1RodW1id2hlZWxTY3JvbGxpbmcnLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFRodW1id2hlZWxTY3JvbGxpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVXaGVlbE1vdmVkOiBmdW5jdGlvbihncmlkLCBlKSB7XG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmltRXZlbnQgPSBlLnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICB2YXIgZGVsdGFZID0gcHJpbUV2ZW50LndoZWVsRGVsdGFZIHx8IC1wcmltRXZlbnQuZGVsdGFZO1xuICAgICAgICB2YXIgZGVsdGFYID0gcHJpbUV2ZW50LndoZWVsRGVsdGFYIHx8IC1wcmltRXZlbnQuZGVsdGFYO1xuICAgICAgICBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxCeSgwLCAtMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGFZIDwgLTApIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsQnkoMCwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGFYID4gMCkge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxCeSgtMSwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGFYIDwgLTApIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsQnkoMSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGh1bWJ3aGVlbFNjcm9sbGluZztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRmVhdHVyZTogcmVxdWlyZSgnLi9GZWF0dXJlJyksIC8vIGFic3RyYWN0IGJhc2UgY2xhc3NcbiAgICBDZWxsQ2xpY2s6IHJlcXVpcmUoJy4vQ2VsbENsaWNrJyksXG4gICAgQ2VsbEVkaXRpbmc6IHJlcXVpcmUoJy4vQ2VsbEVkaXRpbmcnKSxcbiAgICBDZWxsU2VsZWN0aW9uOiByZXF1aXJlKCcuL0NlbGxTZWxlY3Rpb24nKSxcbiAgICBDb2x1bW5BdXRvc2l6aW5nOiByZXF1aXJlKCcuL0NvbHVtbkF1dG9zaXppbmcnKSxcbiAgICBDb2x1bW5Nb3Zpbmc6IHJlcXVpcmUoJy4vQ29sdW1uTW92aW5nJyksXG4gICAgQ29sdW1uUmVzaXppbmc6IHJlcXVpcmUoJy4vQ29sdW1uUmVzaXppbmcnKSxcbiAgICBDb2x1bW5TZWxlY3Rpb246IHJlcXVpcmUoJy4vQ29sdW1uU2VsZWN0aW9uJyksXG4gICAgQ29sdW1uU29ydGluZzogcmVxdWlyZSgnLi9Db2x1bW5Tb3J0aW5nJyksXG4gICAgRmlsdGVyczogcmVxdWlyZSgnLi9GaWx0ZXJzJyksXG4gICAgS2V5UGFnaW5nOiByZXF1aXJlKCcuL0tleVBhZ2luZycpLFxuICAgIE9uSG92ZXI6IHJlcXVpcmUoJy4vT25Ib3ZlcicpLFxuICAgIE92ZXJsYXk6IHJlcXVpcmUoJy4vT3ZlcmxheScpLFxuICAgIFJvd1Jlc2l6aW5nOiByZXF1aXJlKCcuL1Jvd1Jlc2l6aW5nJyksXG4gICAgUm93U2VsZWN0aW9uOiByZXF1aXJlKCcuL1Jvd1NlbGVjdGlvbicpLFxuICAgIFRodW1id2hlZWxTY3JvbGxpbmc6IHJlcXVpcmUoJy4vVGh1bWJ3aGVlbFNjcm9sbGluZycpXG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNzc0luamVjdG9yID0gcmVxdWlyZSgnY3NzLWluamVjdG9yJyk7XG5cbnZhciBzdHlsZXNoZWV0cyA9IHtcbiAgICBncmlkOiBbXG4gICAgICAgICdkaXYjZ3JpZC1jb250YWluZXIgeycsXG4gICAgICAgICcgICAgcG9zaXRpb246IHJlbGF0aXZlOycsXG4gICAgICAgICcgICAgZGlzcGxheTogaW5saW5lLWJsb2NrOycsXG4gICAgICAgICcgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsnLFxuICAgICAgICAnICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7JyxcbiAgICAgICAgJyAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7JyxcbiAgICAgICAgJyAgICAtby11c2VyLXNlbGVjdDogbm9uZTsnLFxuICAgICAgICAnICAgIHVzZXItc2VsZWN0OiBub25lOycsXG4gICAgICAgICcgICAgb3ZlcmZsb3c6IGhpZGRlbjsgfScsXG4gICAgICAgICd2aXNpYmxlIHsgb3BhY2l0eTogMC43NTsgfScsXG4gICAgICAgICdoaWRkZW4geyBvcGFjaXR5OiAwLjA7IH0nLFxuICAgICAgICAnZWRpdG9yIHsnLFxuICAgICAgICAnICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTsnLFxuICAgICAgICAnICAgIGRpc3BsYXk6IG5vbmU7JyxcbiAgICAgICAgJyAgICBib3JkZXI6IHNvbGlkIDJweCBibGFjazsnLFxuICAgICAgICAnICAgIG91dGxpbmU6IDA7JyxcbiAgICAgICAgJyAgICBwYWRkaW5nOiAwOycsXG4gICAgICAgICcgICAgei1pbmRleDogMTAwMDsgfSdcbiAgICBdLFxuICAgIGRuZDogW1xuICAgICAgICAnZGl2LmRyYWdvbi1saXN0LCBsaS5kcmFnb24tcG9wIHsnLFxuICAgICAgICAnICAgIGZvbnQtZmFtaWx5OiBSb2JvdG8sIHNhbnMtc2VyaWY7JyxcbiAgICAgICAgJyAgICB0ZXh0LXRyYW5zZm9ybTogY2FwaXRhbGl6ZTsgfScsXG4gICAgICAgICdkaXYuZHJhZ29uLWxpc3QgeycsXG4gICAgICAgICcgICAgcG9zaXRpb246IGFic29sdXRlOycsXG4gICAgICAgICcgICAgdG9wOiA0JTsnLFxuICAgICAgICAnICAgIGxlZnQ6IDQlOycsXG4gICAgICAgICcgICAgaGVpZ2h0OiA5MiU7JyxcbiAgICAgICAgJyAgICB3aWR0aDogMjAlOyB9JyxcbiAgICAgICAgJ2Rpdi5kcmFnb24tbGlzdDpudGgtY2hpbGQoMikgeyBsZWZ0OiAyOCU7IH0nLFxuICAgICAgICAnZGl2LmRyYWdvbi1saXN0Om50aC1jaGlsZCgzKSB7IGxlZnQ6IDUyJTsgfScsXG4gICAgICAgICdkaXYuZHJhZ29uLWxpc3Q6bnRoLWNoaWxkKDQpIHsgbGVmdDogNzYlOyB9JyxcbiAgICAgICAgJ2Rpdi5kcmFnb24tbGlzdCA+IGRpdiwgZGl2LmRyYWdvbi1saXN0ID4gdWwgPiBsaSwgbGkuZHJhZ29uLXBvcCB7IGxpbmUtaGVpZ2h0OiA0NnB4OyB9JyxcbiAgICAgICAgJ2Rpdi5kcmFnb24tbGlzdCA+IHVsIHsgdG9wOiA0NnB4OyB9JyxcbiAgICAgICAgJ2Rpdi5kcmFnb24tbGlzdCA+IHVsID4gbGk6bm90KDpsYXN0LWNoaWxkKTo6YmVmb3JlLCBsaS5kcmFnb24tcG9wOjpiZWZvcmUgeycsXG4gICAgICAgICcgICAgY29udGVudDogXFwnXFxcXDJiMjRcXCc7JywgLy8gQkxBQ0sgTEFSR0UgQ0lSQ0xFXG4gICAgICAgICcgICAgY29sb3I6ICNiNmI2YjY7JyxcbiAgICAgICAgJyAgICBmb250LXNpemU6IDMwcHg7JyxcbiAgICAgICAgJyAgICBtYXJnaW46IDhweCAxNHB4IDhweCA4cHg7IH0nLFxuICAgICAgICAnbGkuZHJhZ29uLXBvcCB7IG9wYWNpdHk6Ljg7IH0nXG4gICAgXVxufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzaGVldChrZXksIHJlZmVyZW5jZUVsZW1lbnQpIHtcbiAgICBjc3NJbmplY3RvcihzdHlsZXNoZWV0c1trZXldLCBrZXksIHJlZmVyZW5jZUVsZW1lbnQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZFN0eWxlc2hlZXQ7XG4iXX0=
