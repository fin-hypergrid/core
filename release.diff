diff --git a/src/Base.js b/src/Base.js
index df829df..7b17e2f 100644
--- a/src/Base.js
+++ b/src/Base.js
@@ -1,3 +1,5 @@
+/* globals alert */
+
 'use strict';
 
 /**
@@ -13,13 +15,21 @@ var Base = require('extend-me').Base;
 Base.prototype.deprecated = require('./lib/deprecated');
 Base.prototype.HypergridError = require('./lib/error');
 
+Base.prototype.notify = function(message, onerror) {
+    switch (onerror) {
+        case 'warn': console.warn(message); break;
+        case 'alert': alert(message); break; // eslint-disable-line no-alert
+        default: throw new this.HypergridError(message);
+    }
+};
+
 /**
  * Convenience function for getting the value when that value can be defined as a function that needs to be called to get the actual (primitive) value.
  * @param value
  * @returns {*}
  */
 Base.prototype.unwrap = function(value) {
-    if (typeof value === 'function') {
+    if ((typeof value)[0] === 'f') {
         value = value();
     }
     return value;
@@ -43,4 +53,24 @@ Base.prototype.unwrap = function(value) {
 Base.prototype.mixIn = require('overrider').mixIn;
 
 
+/**
+ * @method
+ * @summary Instantiate an object with discrete + variable args.
+ * @desc The discrete args are passed first, followed by the variable args.
+ * @param {function} Constructor
+ * @param {Array} variableArgArray
+ * @param {...*} discreteArgs
+ * @returns {object} Object of type `Constructor` newly constructor using the arguments in `arrayOfArgs`.
+ */
+Base.prototype.createApply = function(Constructor, variableArgArray, discreteArgs) {
+    var discreteArgArray = Array.prototype.slice.call(arguments, 2),
+        args = [null] // null is context for `bind` call below
+            .concat(discreteArgArray) // discrete arguments
+            .concat(variableArgArray), // variable arguments
+        BoundConstructor = Constructor.bind.apply(Constructor, args);
+
+    return new BoundConstructor;
+};
+
+
 module.exports = Base;
diff --git a/src/Hypergrid.js b/src/Hypergrid.js
index ba4f09f..5e805c6 100644
--- a/src/Hypergrid.js
+++ b/src/Hypergrid.js
@@ -5,29 +5,26 @@
 require('./lib/polyfills'); // Installs misc. polyfills into global objects, as needed
 
 var FinBar = require('finbars');
-var Canvas = require('fincanvas');
 var Point = require('rectangular').Point;
 var Rectangle = require('rectangular').Rectangle;
 var _ = require('object-iterators'); // fyi: installs the Array.prototype.find polyfill, as needed
+var injectCSS = require('inject-stylesheet-template').bind(require('../css'));
 
 var Base = require('./Base');
 var defaults = require('./defaults');
-var Renderer = require('./lib/Renderer');
+var dynamicProperties = require('./lib/dynamicProperties');
+var Canvas = require('./lib/Canvas');
+var Renderer = require('./renderer');
 var SelectionModel = require('./lib/SelectionModel');
-var stylesheet = require('./lib/stylesheet');
 var Localization = require('./lib/Localization');
-//var behaviors = require('./behaviors');
+var behaviors = require('./behaviors');
 var CellRenderers = require('./cellRenderers');
 var CellEditors = require('./cellEditors');
-var BehaviorJSON = require('./behaviors/JSON');
 
-var themeInitialized = false,
-    gridTheme = Object.create(defaults),
-    globalProperties = Object.create(gridTheme);
+var EDGE_STYLES = ['top', 'bottom', 'left', 'right'],
+    RECT_STYLES = EDGE_STYLES.concat(['width', 'height', 'position']);
 
-var warned = {};
-
-/**s
+/**
  * @constructor
  * @param {string|Element} [container] - CSS selector or Element
  * @param {object} [options]
@@ -41,31 +38,37 @@ var warned = {};
  * * A function returning a schema array. Called at filter reset time with behavior as context.
  * * Omit to generate a basic schema from `this.behavior.columns`.
  * @param {Behavior} [options.Behavior=JSON] - A grid behavior (descendant of Behavior "class").
+ *
  * @param {pluginSpec|pluginSpec[]} [options.plugins]
- * @param {DataModels[]} [options.subgrids]
- * @param {string} [options.localization=Hypergrid.localization]
+ *
+ * @param {subgridSpec[]} [options.subgrids]
+ *
  * @param {string|Element} [options.container] - CSS selector or Element
+ *
+ * @param {string} [options.localization=Hypergrid.localization]
  * @param {string|string[]} [options.localization.locale=Hypergrid.localization.locale] - The default locale to use when an explicit `locale` is omitted from localizer constructor calls. Passed to Intl.NumberFomrat` and `Intl.DateFomrat`. See {@ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Locale identification and negotiation} for more information.
- * @param {string} [options.localization.numberOptions=Hypergrid.localization.numberOptions] - Options passed to `Intl.NumberFomrat` for creating the basic "number" localizer.
+ * @param {string} [options.localization.numberOptions=Hypergrid.localization.numberOptions] - Options passed to `Intl.NumberFormat` for creating the basic "number" localizer.
  * @param {string} [options.localization.dateOptions=Hypergrid.localization.dateOptions] - Options passed to `Intl.DateFomrat` for creating the basic "date" localizer.
+ *
  * @param {object} [options.schema]
- * @param {object} [options.margin] - optional canvas margins
- * @param {string} [options.margin.top=0]
- * @param {string} [options.margin.right=0]
- * @param {string} [options.margin.bottom=0]
- * @param {string} [options.margin.left=0]
- * @param {object} [options.boundingRect] - optional grid container argument
- * @param {string} [options.boundingRect.height=300]
- * @param {string} [options.boundingRect.width=300]
- * @param {string} [options.boundingRect.postion=relative]
+ *
+ * @param {object} [options.margin] - Optional canvas "margins" applied to containing div as .left, .top, .right, .bottom. (Default values actually derive from 'grid' stylesheet's `.hypergrid-container` rule.)
+ * @param {string} [options.margin.top='0px']
+ * @param {string} [options.margin.right='0px']
+ * @param {string} [options.margin.bottom='0px']
+ * @param {string} [options.margin.left='0px']
+ *
+ * @param {object} [options.boundingRect] - Optional grid container size & position. (Default values actually derive from 'grid' stylesheet's `.hypergrid-container > div:first-child` rule.)
+ * @param {string} [options.boundingRect.height='500px']
+ * @param {string} [options.boundingRect.width='auto']
+ * @param {string} [options.boundingRect.left='auto']
+ * @param {string} [options.boundingRect.top='auto']
+ * @param {string} [options.boundingRect.right='auto']
+ * @param {string} [options.boundingRect.bottom='auto']
+ * @param {string} [options.boundingRect.position='relative']
  */
 var Hypergrid = Base.extend('Hypergrid', {
     initialize: function(container, options) {
-        if (!themeInitialized) {
-            themeInitialized = true;
-            gridTheme = buildTheme(gridTheme);
-        }
-
         //Optional container argument
         if (!(typeof container === 'string') && !(container instanceof HTMLElement)) {
             options = container;
@@ -74,11 +77,19 @@ var Hypergrid = Base.extend('Hypergrid', {
 
         this.options = options = options || {};
 
+        this.clearState();
+
+        //Set up the container for a grid instance
+        this.setContainer(
+            container ||
+            options.container ||
+            findOrCreateContainer(options.boundingRect)
+        );
+
         // Install shared plug-ins (those with a `preinstall` method)
         Object.getPrototypeOf(this).installPlugins(options.plugins);
 
         this.lastEdgeSelection = [0, 0];
-        this.lnfProperties = Object.create(globalProperties);
         this.isWebkit = navigator.userAgent.toLowerCase().indexOf('webkit') > -1;
         this.selectionModel = new SelectionModel(this);
         this.renderOverridesCache = {};
@@ -88,26 +99,22 @@ var Hypergrid = Base.extend('Hypergrid', {
         this.numColumns = 0;
         this.clearMouseDown();
         this.setFormatter(options.localization);
+        this.listeners = {};
 
         /**
          * @name cellRenderers
          * @type {CellRenderer}
-         * @memberOf Hypergrid.prototype
+         * @memberOf Hypergrid#
          */
         this.cellRenderers = new CellRenderers();
 
         /**
          * @name cellEditors
          * @type {CellEditor}
-         * @memberOf Hypergrid.prototype
+         * @memberOf Hypergrid#
          */
         this.cellEditors = new CellEditors(this);
 
-        //Set up the container for a grid instance
-        container = container || options.container;
-        container = container || findOrCreateContainer(options.boundingRect);
-        this.setContainer(container);
-
         if (this.options.Behavior) {
             this.setBehavior(this.options); // also sets this.options.pipeline and this.options.data
         } else if (this.options.data) {
@@ -122,10 +129,10 @@ var Hypergrid = Base.extend('Hypergrid', {
          * For the dictionary of _shared_ plugins, see {@link Hypergrid.plugins|plugins} (a property of the constructor).
          * @example
          * var instancePlugins = myGrid.plugins;
-         * var instancePlugins = this.plugins // internal use
+         * var instancePlugins = this.plugins; // internal use
          * var myInstancePlugin = myGrid.plugins.myInstancePlugin;
          * @type {object}
-         * @memberOf Hypergrid.prototype
+         * @memberOf Hypergrid#
          */
         this.plugins = {};
 
@@ -163,27 +170,27 @@ var Hypergrid = Base.extend('Hypergrid', {
      *
      * A null object behavior serves as a place holder.
      * @type {object}
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     behavior: null,
 
     /**
      * Cached resulan}
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     isWebkit: true,
 
     /**
      * The pixel location of an initial mousedown click, either for editing a cell or for dragging a selection.
      * @type {Point}
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     mouseDown: [],
 
     /**
      * The extent from the mousedown point during a drag operation.
      * @type {Point}
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
 
     dragExtent: null,
@@ -191,59 +198,59 @@ var Hypergrid = Base.extend('Hypergrid', {
     /**
      * A float value between 0.0 - 1.0 of the vertical scroll position.
      * @type {number}
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     vScrollValue: 0,
 
     /**
      * A float value between 0.0 - 1.0 of the horizontal scroll position.
      * @type {number}
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     hScrollValue: 0,
 
     /**
      * @property {fin-hypergrid-selection-model} selectionModel - A [fin-hypergrid-selection-model](module-._selection-model.html) instance.
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     selectionModel: null,
 
     /**
      * @property {fin-hypergrid-cell-editor} cellEditor - The current instance of [fin-hypergrid-cell-editor](module-cell-editors_base.html).
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     cellEditor: null,
 
     /**
      * @property {fin-vampire-bar} sbHScroller - An instance of {@link https://github.com/openfin/finbars|FinBar}.
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     sbHScroller: null,
 
     /**
      * @property {fin-vampire-bar} sbVScroller - An instance of {@link https://github.com/openfin/finbars|FinBar}.
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     sbVScroller: null,
 
     /**
      * The previous value of sbVScrollVal.
      * @type {number}
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     sbPrevVScrollValue: null,
 
     /**
      * The previous value of sbHScrollValue.
      * @type {number}
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     sbPrevHScrollValue: null,
 
     /**
      * is the short term memory of what column I might be dragging around
      * @type {object}
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
 
     renderOverridesCache: {},
@@ -252,7 +259,7 @@ var Hypergrid = Base.extend('Hypergrid', {
      * The pixel location of the current hovered cell.
      * @todo Need to detect hovering over bottom totals.
      * @type {Point}
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     hoverCell: null,
 
@@ -261,20 +268,52 @@ var Hypergrid = Base.extend('Hypergrid', {
     lastEdgeSelection: null,
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     setAttribute: function(attribute, value) {
         this.div.setAttribute(attribute, value);
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @desc Clear out all state and data of a grid instance.
+     * @memberOf Hypergrid#
+     */
+    clearState: function() {
+        /**
+         * @name properties
+         * @type {object}
+         * @summary Object containing the properties of the grid.
+         * @desc Grid properties objects have the following structure:
+         * 1. User-configured properties are in the "own" layer.
+         * 2. Extends from (has as its prototype) the {@link module:dynamicProperties|dynamicProperties} object.
+         * 3. The dynamic properties object extends from the {@link module:defaults|defaults} object.
+         *
+         * Note: Any changes the application developer may wish to make to the {@link module:defaults|defaults} object should be made _before_ reaching this point (_i.e.,_ prior to any grid instantiations).
+         * @memberOf Hypergrid#
+         */
+        this.properties = Object.create(dynamicProperties, {
+            grid: { value: this },
+            var: { value: new Var() }
+        });
+    },
+
+    /**
+     * @desc Clear out all state settings, data (rows), and schema (columns) of a grid instance.
+     * @param {object} [options]
+     * @param {object} [options.subgrids] - Consumed by {@link Behavior#reset}.
+     * If omitted, previously established subgrids list is reused.
+     * @param {object} [options.pipeline] - Consumed by {@link dataModels.JSON#reset}.
+     * If omitted, previously established pipeline is reused.
+     * @param {object} [options.controllers] - Consumed by {@link dataModels.JSON#reset}.
+     * If omitted, previously established controllers list is reused.
+     * @memberOf Hypergrid#
      */
-    reset: function() {
+    reset: function(options) {
+        this.clearState();
+
+        this.removeAllEventListeners();
+
         this.lastEdgeSelection = [0, 0];
-        this.lnfProperties = Object.create(globalProperties);
-        this.selectionModel = new SelectionModel(this);
+        this.selectionModel.reset();
         this.renderOverridesCache = {};
         this.clearMouseDown();
         this.dragExtent = new Point(0, 0);
@@ -294,9 +333,15 @@ var Hypergrid = Base.extend('Hypergrid', {
         this.scrollingNow = false;
         this.lastEdgeSelection = [0, 0];
 
-        this.behavior.reset();
+        options = options || {};
+        this.behavior.reset({
+            subgrids: options.subgrids,
+            pipeline: options.pipeline,
+            controllers: options.controllers
+        });
+
         this.renderer.reset();
-        this.getCanvas().resize();
+        this.canvas.resize();
         this.behaviorChanged();
 
         this.refreshProperties();
@@ -331,10 +376,13 @@ var Hypergrid = Base.extend('Hypergrid', {
      * * Preinstalled plugins which are installed on the prototype. These are simple API plugins with a `preinstall` method called with the `installPlugins` calling context as the first argument. Preinstallations are automatically performed whenever a grid is instantiated (at the beginning of the constructor), by calling `installPlugins` with `Hypergrid.prototype` as the calling context.
      * * Regular plugins which are installed on the instance. These are simple API plugins with an `install` method, as well as all object API plugins (constructors), called with the `installPlugins` calling context as the first argument. These installations are automatically performed whenever a grid is instantiated (at the end of the constructor), called with the new grid instance as the calling context.
      *
+     * The "`installPlugins` calling context" means either the grid instance or its prototype, depending on how this method is called.
+     *
      * Plugins may have both `preinstall` _and_ `install` methods, in which case both will be called. However, note that in any case, `install` methods on object API plugins are ignored.
      *
-     * @this {Hypergrid|Hypergrid.prototype}
-     * @param {pluginSpec|pluginSpec[]} [plugins] - The plugins to install. This call is a no-op if omitted.
+     * @this {Hypergrid}
+     * @param {pluginSpec|pluginSpec[]} [plugins] - The plugins to install. If omitted, the call is a no-op.
+     * @memberOf Hypergrid#
      */
     installPlugins: function(plugins) {
         var shared = this === Hypergrid.prototype; // Do shared ("preinstalled") plugins (if any)
@@ -352,10 +400,13 @@ var Hypergrid = Base.extend('Hypergrid', {
                 return; // ignore falsy plugin spec
             }
 
-            // set first arg to constructor to `this` (the grid instance)
-            // set first arg to `install` method to `this` (the grid instance)
-            // set first arg to `preinstall` method to `this` (the Hypergrid prototype)
+            // set first arg of constructor to `this` (the grid instance)
+            // set first arg of `install` method to `this` (the grid instance)
+            // set first two args of `preinstall` method to `this` (the Hypergrid prototype) and the Behavior prototype
             args = [this];
+            if (shared) {
+                args.push(behaviors.Behavior.prototype);
+            }
 
             if (Array.isArray(plugin)) {
                 if (!plugin.length) {
@@ -393,8 +444,7 @@ var Hypergrid = Base.extend('Hypergrid', {
                 hash = this.plugins;
                 if (typeof plugin === 'function') {
                     // Install "object API" by instantiating
-                    args.unshift(null); // context for the `bind` call
-                    plugin = new (Function.prototype.bind.apply(plugin, args));
+                    plugin = this.createApply(plugin, args);
                 } else if (plugin.install) {
                     // Install "simple API" by calling its `install` method
                     plugin.install.apply(plugin, args);
@@ -422,6 +472,7 @@ var Hypergrid = Base.extend('Hypergrid', {
      * * `key` - name of the plugin to be uninstalled (_i.e.,_ key in `plugins`)
      * * `plugins` - the plugins hash (a.k.a. `grid.plugins`)
      * @param {string|stirng[]} [pluginNames] If provided, limit uninstall to the named plugin (string) or plugins (string[]).
+     * @memberOf Hypergrid#
      */
     uninstallPlugins: function(pluginNames) {
         if (!pluginNames) {
@@ -444,10 +495,6 @@ var Hypergrid = Base.extend('Hypergrid', {
         return this.deprecated('getProperties()', 'properties', '1.2.0');
     },
 
-    _getProperties: function() {
-        return this.lnfProperties;
-    },
-
     computeCellsBounds: function() {
         this.renderer.computeCellsBounds();
     },
@@ -459,7 +506,12 @@ var Hypergrid = Base.extend('Hypergrid', {
             options.numberOptions || Hypergrid.localization.numberOptions,
             options.dateOptions || Hypergrid.localization.dateOptions
         );
+
+        this.localization.header = {
+            format: headerFormatter.bind(this)
+        };
     },
+
     getFormatter: function(localizerName) {
         return this.localization.get(localizerName).format;
     },
@@ -470,15 +522,15 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     isRowResizeable: function() {
-        return this.properties.rowResize;
+        return this.deprecated('isRowResizeable()', 'properties.rowResize', 'v1.2.10');
     },
 
     isCheckboxOnlyRowSelections: function() {
-        return this.properties.checkboxOnlyRowSelections;
+        return this.deprecated('isCheckboxOnlyRowSelections()', 'properties.checkboxOnlyRowSelections', 'v1.2.10');
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {Point} The cell over which the cursor is hovering.
      */
     getHoverCell: function() {
@@ -487,94 +539,56 @@ var Hypergrid = Base.extend('Hypergrid', {
 
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Set the cell under the cursor.
-     * @param {Point} point
-     */
-    setHoverCell: function(point) {
-        var me = this.hoverCell;
-        var newPoint = new Point(point.x, point.y);
-        if (me && me.equals(newPoint)) {
-            return;
-        }
-        this.hoverCell = newPoint;
-        if (me) { this.fireSyntheticOnCellExitEvent(me); } //Exit first
-        this.fireSyntheticOnCellEnterEvent(newPoint);
-        this.repaint();
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Ammend properties for all hypergrids in this process.
-     * @param {object} properties - A simple properties hash.
+     * @param {CellEvent} cellEvent
      */
-    addGlobalProperties: function(properties) {
-        //we check for existence to avoid race condition in initialization
-        if (!globalProperties) {
-            var self = this;
-            setTimeout(function() {
-                self.addGlobalProperties(properties);
-            }, 10);
-        } else {
-            this._addGlobalProperties(properties);
+    setHoverCell: function(cellEvent) {
+        var hoverCell = this.hoverCell;
+        if (!hoverCell || !hoverCell.equals(cellEvent.gridCell)) {
+            this.hoverCell = cellEvent.gridCell;
+            if (hoverCell) {
+                this.fireSyntheticOnCellExitEvent(cellEvent);
+            }
+            this.fireSyntheticOnCellEnterEvent(cellEvent);
+            this.repaint();
         }
-
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @desc Amend properties for all hypergrids in this process.
-     * @param {object} properties - A simple properties hash.
-     * @private
+     * @memberOf Hypergrid#
+     * @desc Amend properties for this hypergrid only.
+     * @param {object} moreProperties - A simple properties hash.
      */
-    _addGlobalProperties: function(properties) {
-        _(properties).each(function(property, key) {
-            globalProperties[key] = property;
-        });
+    addProperties: function(properties) {
+        Object.assign(this.properties, properties);
+        this.refreshProperties();
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @todo deprecate this in favor of making properties dynamic instead (for those that need to be)
+     * @memberOf Hypergrid#
      * @desc Utility function to push out properties if we change them.
      * @param {object} properties - An object of various key value pairs.
      */
     refreshProperties: function() {
-        var state = this.properties;
-        this.selectionModel.multipleSelections = state.multipleSelections;
-
-        // this.canvas = this.shadowRoot.querySelector('fin-canvas');
-        //this.canvas = new Canvas(this.divCanvas, this.renderer); //TODO: Do we really need to be recreating it here?
-
         this.computeCellsBounds();
         this.checkScrollbarVisibility();
         this.behavior.defaultRowHeight = null;
-        if (this.isColumnAutosizing()) {
-            this.behavior.autosizeAllColumns();
-        }
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Amend properties for this hypergrid only.
-     * @param {object} moreProperties - A simple properties hash.
-     */
-    addProperties: function(moreProperties) {
-        var properties = this.properties;
-        addDeepProperties(properties, moreProperties);
-        this.refreshProperties();
+        this.behavior.autosizeAllColumns();
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {object} The state object for remembering our state.
      * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
      */
     getPrivateState: function() {
-        return this.deprecate('getPrivateState()', 'properties', '1.2.0');
+        return this.deprecated('getPrivateState()', 'properties', '1.2.0');
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Set the state object to return to the given user configuration.
      * @param {object} state - A memento object.
      * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
@@ -593,30 +607,30 @@ var Hypergrid = Base.extend('Hypergrid', {
         return this.behavior.getState();
     },
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {object} The initial mouse position on a mouse down event for cell editing or a drag operation.
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     getMouseDown: function() {
-        var last = this.mouseDown.length - 1;
-        if (last < 0) {
-            return null;
+        if (this.mouseDown.length) {
+            return this.mouseDown[this.mouseDown.length - 1];
         }
-        return this.mouseDown[last];
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Remove the last item from the mouse down stack.
      */
     popMouseDown: function() {
-        if (this.mouseDown.length !== 0) {
-            this.mouseDown.length = this.mouseDown.length - 1;
+        var result;
+        if (this.mouseDown.length) {
+            result = this.mouseDown.pop();
         }
+        return result;
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Empty out the mouse down stack.
      */
     clearMouseDown: function() {
@@ -627,14 +641,14 @@ var Hypergrid = Base.extend('Hypergrid', {
     /**
      * Set the mouse point that initiated a cell edit or drag operation.
      * @param {Point} point
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     setMouseDown: function(point) {
         this.mouseDown.push(point);
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {Point} The extent point of the current drag selection rectangle.
      */
     getDragExtent: function() {
@@ -642,7 +656,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Set the extent point of the current drag selection operation.
      * @param {Point} point
      */
@@ -651,7 +665,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc This function is a callback from the HypergridRenderer sub-component. It is called after each paint of the canvas.
      */
     gridRenderedNotification: function() {
@@ -662,14 +676,18 @@ var Hypergrid = Base.extend('Hypergrid', {
         this.fireSyntheticGridRenderedEvent();
     },
 
+    tickNotification: function() {
+        this.fireSyntheticTickEvent();
+    },
+
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc The grid has just been rendered, make sure the column widths are optimal.
      */
     checkColumnAutosizing: function() {
         var behavior = this.behavior;
         behavior.autoSizeRowNumberColumn();
-        if (this.isColumnAutosizing() && behavior.checkColumnAutosizing(false)) {
+        if (behavior.checkColumnAutosizing(false)) {
             setTimeout(function() {
                 behavior.grid.synchronizeScrollingBoundaries();
             });
@@ -677,7 +695,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Conditionally copy to clipboard.
      * @desc If we have focus, copy our current selection data to the system clipboard.
      * @param {event} event - The copy system event.
@@ -691,174 +709,38 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @returns {boolean} We have any selections.
-     */
-    hasSelections: function() {
-        if (!this.getSelectionModel) {
-            return; // were not fully initialized yet
-        }
-        return this.selectionModel.hasSelections();
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @returns {string} Tab separated value string from the selection and our data.
-     */
-    getSelectionAsTSV: function() {
-        var sm = this.selectionModel;
-        if (sm.hasSelections()) {
-            var selections = this.getSelectionMatrix();
-            selections = selections[selections.length - 1];
-            return this.getMatrixSelectionAsTSV(selections);
-        } else if (sm.hasRowSelections()) {
-            return this.getMatrixSelectionAsTSV(this.getRowSelectionMatrix());
-        } else if (sm.hasColumnSelections()) {
-            return this.getMatrixSelectionAsTSV(this.getColumnSelectionMatrix());
-        }
-    },
-
-    getMatrixSelectionAsTSV: function(selections) {
-        var result = '';
-
-        //only use the data from the last selection
-        if (selections.length) {
-            var width = selections.length,
-                height = selections[0].length,
-                area = width * height,
-                lastCol = width - 1,
-                //Whitespace will only be added on non-singular rows, selections
-                whiteSpaceDelimiterForRow = (height > 1 ? '\n' : '');
-
-            //disallow if selection is too big
-            if (area > 20000) {
-                alert('selection size is too big to copy to the paste buffer'); // eslint-disable-line no-alert
-                return '';
-            }
-
-            for (var h = 0; h < height; h++) {
-                for (var w = 0; w < width; w++) {
-                    result += selections[w][h] + (w < lastCol ? '\t' : whiteSpaceDelimiterForRow);
-                }
-            }
-        }
-
-        return result;
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {boolean} We have focus.
      */
     hasFocus: function() {
-        return this.getCanvas().hasFocus();
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Clear all the selections.
-     */
-    clearSelections: function() {
-        var dontClearRows = this.isCheckboxOnlyRowSelections();
-        this.selectionModel.clear(dontClearRows);
-        this.clearMouseDown();
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Clear the most recent selection.
-     */
-    clearMostRecentSelection: function() {
-        var dontClearRows = this.isCheckboxOnlyRowSelections();
-        this.selectionModel.clearMostRecentSelection(dontClearRows);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Clear the most recent column selection.
-     */
-    clearMostRecentColumnSelection: function() {
-        this.selectionModel.clearMostRecentColumnSelection();
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Clear the most recent row selection.
-     */
-    clearMostRecentRowSelection: function() {
-        //this.selectionModel.clearMostRecentRowSelection(); // commented off as per GRID-112
-    },
-
-    clearRowSelection: function() {
-        this.selectionModel.clearRowSelection();
-        this.behavior.dataModel.clearSelectedData();
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @summary Select given region.
-     * @param {number} ox - origin x
-     * @param {number} oy - origin y
-     * @param {number} ex - extent x
-     * @param {number} ex - extent y
-     */
-    select: function(ox, oy, ex, ey) {
-        if (ox < 0 || oy < 0) {
-            //we don't select negative area
-            //also this means there is no origin mouse down for a selection rect
-            return;
-        }
-        this.selectionModel.select(ox, oy, ex, ey);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @returns {boolean} Given point is selected.
-     * @param {number} x - The horizontal coordinate.
-     * @param {number} y - The vertical coordinate.
-     */
-    isSelected: function(x, y) {
-        return this.selectionModel.isSelected(x, y);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @returns {boolean} The given column is selected anywhere in the entire table.
-     * @param {number} y - The row index.
-     */
-    isCellSelectedInRow: function(y) {
-        return this.selectionModel.isCellSelectedInRow(y);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @returns {boolean} The given row is selected anywhere in the entire table.
-     * @param {number} x - The column index.
-     */
-    isCellSelectedInColumn: function(x) {
-        return this.selectionModel.isCellSelectedInColumn(x);
+        return this.canvas.hasFocus();
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Set the Behavior (model) object for this grid control.
      * @desc This can be done dynamically.
      * @param {object} options - _(See {@link behaviors.JSON#setData}.)_
-     * @param {Behavior} [options.behavior=BehaviorJSON] - The behavior (model) can be either a constructor or an instance.
+     * @param {Behavior} [options.behavior=behaviors.JSON] - The behavior (model) can be either a constructor or an instance.
      * @param {dataRowObject[]} [options.data] - _(See {@link behaviors.JSON#setData}.)_
      * @param {pipelineSchema} [options.pipeline] - New pipeline description.
      */
     setBehavior: function(options) {
-        var Behavior = options.Behavior || BehaviorJSON;
-        this.behavior = new Behavior(this, options);
-        this.initCanvas();
-        this.initScrollbars();
-        this.refreshProperties();
-        this.behavior.reindex();
+        if (!this.behavior) {
+            // If we get here it means:
+            // 1. Called from constructor because behavior included in options object.
+            // 2. Called from `setData` _and_ wasn't called explicitly since instantiation
+            var Behavior = options.Behavior || behaviors.JSON;
+            this.behavior = new Behavior(this, options);
+            this.initCanvas();
+            this.initScrollbars();
+            this.refreshProperties();
+            this.behavior.reindex();
+        }
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Set the underlying datasource.
      * @desc This can be done dynamically.
      * @param {function|object[]} dataRows - May be:
@@ -867,19 +749,21 @@ var Hypergrid = Base.extend('Hypergrid', {
      * @param {object} [options] - _(See {@link behaviors.JSON#setData}.)_
      */
     setData: function(dataRows, options) {
-        if (!this.behavior) {
-            // If we get hear it means:
-            // 1. `Behavior` option wasn't given to constructor.
-            // 2. `setBehavior` wasn't called explicitly.
-            // So we call it now to set the default behavior (by not specifying a `Behavior`) with the unused constructor `pipeline` option.
-            this.setBehavior({ pipeline: this.options.pipeline });
-        }
+        // Call `setBehavior` here just in case not previously set by constructor _or_ explicitly since instantiation
+        this.setBehavior({
+            pipeline: this.options.pipeline
+        });
         this.behavior.setData(dataRows, options);
+        this.setInfo(dataRows.length ? '' : this.properties.noDataMessage);
         this.behavior.changed();
     },
 
+    setInfo: function(messages) {
+        this.renderer.setInfo(messages);
+    },
+
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary _(See {@link Hypergrid.prototype#setData}.)_
      * @desc Binds the data and reshapes the grid (new column objects created)
      * @param {function|object[]} dataRows - May be:
@@ -888,16 +772,12 @@ var Hypergrid = Base.extend('Hypergrid', {
      * @param {object} [options]
      */
     updateData: function(dataRows, options){
-        if (!this.behavior){
-            this.setData(dataRows, options);
-        } else {
-            this.behavior.updateData(dataRows, options);
-            this.behavior.changed();
-        }
+        this.deprecated('updateData(dataRows, options)', 'setData(dataRows, options)', 'v1.2.10', arguments,
+            'To update data without changing column definitions, call setData _without a schema._');
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @param {object} [pipelines] - New pipeline description. _(See {@link dataModels.JSON#setPipeline}.)_
      * @param {object} [options] - _(See {@link dataModels.JSON#setPipeline}.)_
      */
@@ -906,7 +786,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc I've been notified that the behavior has changed.
      */
     behaviorChanged: function() {
@@ -922,7 +802,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc The dimensions of the grid data have changed. You've been notified.
      */
     behaviorShapeChanged: function() {
@@ -932,7 +812,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc The dimensions of the grid data have changed. You've been notified.
      */
     behaviorStateChanged: function() {
@@ -943,7 +823,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {Rectangle} My bounds.
      */
     getBounds: function() {
@@ -951,22 +831,19 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {string} The value of a lnf property.
      * @param {string} key - A look-and-feel key.
      */
     resolveProperty: function(key) {
         // todo: when we remove this method, also remove forwards from Behavior.js and Renderer.js
-        if (!warned.resolveProperty) {
-            warned.resolveProperty = true;
-            console.warn('resolveProperty(key) deprecated as of v1.2.0 in favor of grid.properties[key] and will be removed in a future version.');
-        }
+        this.deprecated('resolveProperty', '.resolveProperty(key) deprecated as of v1.2.0 in favor of .properties dereferenced by [key]. (Will be removed in a future version.)');
         return this.properties[key];
     },
 
     repaint: function() {
         var now = this.properties.repaintImmediately;
-        var canvas = this.getCanvas();
+        var canvas = this.canvas;
         if (canvas) {
             if (now === true) {
                 canvas.paintNow();
@@ -977,23 +854,23 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Paint immediately in this microtask.
      */
     paintNow: function() {
-        this.getCanvas().paintNow();
+        this.canvas.paintNow();
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {boolean} In HiDPI mode (has an attribute as such).
      */
     useHiDPI: function() {
-        return this.properties.useHiDPI !== false;
+        return this.deprecated('useHiDPI()', 'properties.useHiDPI', 'v1.2.10');
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Set the container for a grid instance
      * @private
      */
@@ -1004,7 +881,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Initialize container
      * @private
      */
@@ -1022,7 +899,7 @@ var Hypergrid = Base.extend('Hypergrid', {
             div.style.height = null; // revert to stylesheet value
         }
 
-        stylesheet.inject('grid');
+        injectCSS('grid');
 
         //prevent the default context menu for appearing
         div.oncontextmenu = function(event) {
@@ -1040,155 +917,26 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Initialize drawing surface.
      * @private
      */
     initCanvas: function() {
-        if (this.divCanvas) {
-            return;
-        }
+        if (!this.divCanvas) {
+            var divCanvas = document.createElement('div');
 
-        var self = this,
-            margin = this.options.margin || {},
-            divCanvas = this.divCanvas = document.createElement('div'),
-            style = divCanvas.style;
+            setStyles(divCanvas, this.options.margin, EDGE_STYLES);
 
-        style.position = 'absolute';
-        style.top = margin.top || 0;
-        style.right = margin.right || 0;
-        style.bottom = margin.bottom || 0;
-        style.left = margin.left || 0;
+            this.div.appendChild(divCanvas);
 
-        this.div.appendChild(divCanvas);
+            var canvas = new Canvas(divCanvas, this.renderer, this.options.canvas);
+            canvas.canvas.classList.add('hypergrid');
 
-        this.canvas = new Canvas(divCanvas, this.renderer);
-        this.canvas.canvas.classList.add('hypergrid');
-        this.canvas.canvas.style.backgroundColor = this.properties.lineColor;
-        this.canvas.resize();
+            this.divCanvas = divCanvas;
+            this.canvas = canvas;
 
-        function getMouseEvent(e) {
-            return Object.defineProperty(
-                self.getGridCellFromMousePoint(e.detail.mouse),
-                'primitiveEvent',
-                {
-                    value: e,
-                    enumerable: false,
-                    configurable: true,
-                    writable: true
-                }
-            );
+            this.delegateCanvasEvents();
         }
-
-        this.canvas.resizeNotification = function() {
-            self.resized();
-        };
-
-        this.addEventListener('fin-canvas-mousemove', function(e) {
-            if (self.properties.readOnly) {
-                return;
-            }
-            self.delegateMouseMove(getMouseEvent(e));
-        });
-
-        this.addEventListener('fin-canvas-mousedown', function(e) {
-            if (self.properties.readOnly) {
-                return;
-            }
-            if (!self.abortEditing()) {
-                event.stopPropagation();
-                return;
-            }
-            var mouseEvent = getMouseEvent(e);
-            mouseEvent.keys = e.detail.keys;
-            self.mouseDownState = mouseEvent;
-            self.delegateMouseDown(mouseEvent);
-            self.fireSyntheticMouseDownEvent(mouseEvent);
-            self.repaint();
-        });
-
-        this.addEventListener('fin-canvas-click', function(e) {
-            if (self.properties.readOnly) {
-                return;
-            }
-            var mouseEvent = getMouseEvent(e);
-            mouseEvent.keys = e.detail.keys; // todo: this was in fin-tap but wasn't here
-            self.fireSyntheticClickEvent(mouseEvent);
-            self.delegateClick(mouseEvent);
-        });
-
-        this.addEventListener('fin-canvas-mouseup', function(e) {
-            if (self.properties.readOnly) {
-                return;
-            }
-            self.dragging = false;
-            if (self.isScrollingNow()) {
-                self.setScrollingNow(false);
-            }
-            if (self.columnDragAutoScrolling) {
-                self.columnDragAutoScrolling = false;
-            }
-            var mouseEvent = getMouseEvent(e);
-            self.delegateMouseUp(mouseEvent);
-            if (self.mouseDownState) {
-                self.fireSyntheticButtonPressedEvent(self.mouseDownState);
-            }
-            self.mouseDownState = null;
-            self.fireSyntheticMouseUpEvent(mouseEvent);
-        });
-
-        this.addEventListener('fin-canvas-dblclick', function(e) {
-            if (self.properties.readOnly) {
-                return;
-            }
-            var mouseEvent = getMouseEvent(e);
-            self.fireSyntheticDoubleClickEvent(mouseEvent, e);
-            self.delegateDoubleClick(mouseEvent);
-        });
-
-        this.addEventListener('fin-canvas-drag', function(e) {
-            if (self.properties.readOnly) {
-                return;
-            }
-            self.dragging = true;
-            self.delegateMouseDrag(getMouseEvent(e));
-        });
-
-        this.addEventListener('fin-canvas-keydown', function(e) {
-            if (self.properties.readOnly) {
-                return;
-            }
-            self.fireSyntheticKeydownEvent(e);
-            self.delegateKeyDown(e);
-        });
-
-        this.addEventListener('fin-canvas-keyup', function(e) {
-            if (self.properties.readOnly) {
-                return;
-            }
-            self.fireSyntheticKeyupEvent(e);
-            self.delegateKeyUp(e);
-        });
-
-        this.addEventListener('fin-canvas-wheelmoved', function(e) {
-            self.delegateWheelMoved(getMouseEvent(e));
-        });
-
-        this.addEventListener('fin-canvas-mouseout', function(e) {
-            if (self.properties.readOnly) {
-                return;
-            }
-            self.delegateMouseExit(getMouseEvent(e));
-        });
-
-        this.addEventListener('fin-canvas-context-menu', function(e) {
-            self.delegateContextMenu(getMouseEvent(e));
-        });
-
-        //Register a listener for the copy event so we can copy our selected region to the pastebuffer if conditions are right.
-        document.body.addEventListener('copy', function(evt) {
-            self.checkClipboardCopy(evt);
-        });
     },
 
     convertViewPointToDataPoint: function(unscrolled) {
@@ -1200,33 +948,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @summary Add an event listener to me.
-     * @param {string} eventName - The type of event we are interested in.
-     * @param {function} callback - The event handler.
-     */
-    addEventListener: function(eventName, callback) {
-        var self = this;
-        var decorator = function(e) {
-            if (self.allowEventHandlers){
-                callback(e);
-            }
-        };
-        this.canvas.addEventListener(eventName, decorator);
-    },
-
-    allowEvents: function(allow){
-        if ((this.allowEventHandlers = !!allow)){
-            this.behavior.featureChain.attachChain();
-        } else {
-            this.behavior.featureChain.detachChain();
-        }
-
-        this.behavior.changed();
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Set for `scrollingNow` field.
      * @param {boolean} isItNow - The type of event we are interested in.
      */
@@ -1235,7 +957,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {boolean} The `scrollingNow` field.
      */
     isScrollingNow: function() {
@@ -1243,25 +965,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @returns {number} The index of the column divider under the mouse coordinates.
-     * @param {MouseEvent} mouseEvent - The event to interogate.
-     */
-    overColumnDivider: function(mouseEvent) {
-        return this.renderer.overColumnDivider(mouseEvent.primitiveEvent.detail.mouse.x);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @returns {number} The index of the row divider under the mouse coordinates.
-     * @param {MouseEvent} mouseEvent - The event to interogate.
-     */
-    overRowDivider: function(mouseEvent) {
-        return this.renderer.overRowDivider(mouseEvent.primitiveEvent.detail.mouse.y);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Switch the cursor for a grid instance.
      * @param {string} cursorName - A well know cursor name.
      * @see [cursor names](http://www.javascripter.net/faq/stylesc.htm)
@@ -1274,112 +978,11 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @desc Delegate the wheel moved event to the behavior.
-     * @param {Event} event - The pertinent event.
-     */
-    delegateWheelMoved: function(event) {
-        this.behavior.onWheelMoved(this, event);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Delegate MouseExit to the behavior (model).
-     * @param {Event} event - The pertinent event.
-     */
-    delegateMouseExit: function(event) {
-        this.behavior.handleMouseExit(this, event);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Delegate MouseExit to the behavior (model).
-     * @param {Event} event - The pertinent event.
-     */
-    delegateContextMenu: function(event) {
-        this.behavior.onContextMenu(this, event);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Delegate MouseMove to the behavior (model).
-     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
-     */
-    delegateMouseMove: function(mouseDetails) {
-        this.behavior.onMouseMove(this, mouseDetails);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Delegate mousedown to the behavior (model).
-     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
-     */
-    delegateMouseDown: function(mouseDetails) {
-        this.behavior.handleMouseDown(this, mouseDetails);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Delegate mouseup to the behavior (model).
-     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
-     */
-    delegateMouseUp: function(mouseDetails) {
-        this.behavior.onMouseUp(this, mouseDetails);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Delegate click to the behavior (model).
-     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
-     */
-    delegateClick: function(mouseDetails) {
-        this.behavior.onClick(this, mouseDetails);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Delegate mouseDrag to the behavior (model).
-     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
-     */
-    delegateMouseDrag: function(mouseDetails) {
-        this.behavior.onMouseDrag(this, mouseDetails);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc We've been doubleclicked on. Delegate through the behavior (model).
-     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
-     */
-    delegateDoubleClick: function(mouseDetails) {
-        this.behavior.onDoubleClick(this, mouseDetails);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @summary Generate a function name and call it on self.
-     * @desc This should also be delegated through Behavior keeping the default implementation here though.
-     * @param {event} event - The pertinent event.
-     */
-    delegateKeyDown: function(event) {
-        this.behavior.onKeyDown(this, event);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @summary Generate a function name and call it on self.
-     * @desc This should also be delegated through Behavior keeping the default implementation here though.
-     * @param {event} event - The pertinent event.
-     */
-    delegateKeyUp: function(event) {
-        this.behavior.onKeyUp(this, event);
-    },
-
-    /**
      * @summary Shut down the current cell editor and save the edited value.
      * @returns {boolean} One of:
      * * `false` - Editing BUT could not abort.
      * * `true` - Not editing OR was editing AND abort was successful.
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     stopEditing: function() {
         return !this.cellEditor || this.cellEditor.stopEditing();
@@ -1390,7 +993,7 @@ var Hypergrid = Base.extend('Hypergrid', {
      * @returns {boolean} One of:
      * * `false` - Editing BUT could not abort.
      * * `true` - Not editing OR was editing AND abort was successful.
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     cancelEditing: function() {
         return !this.cellEditor || this.cellEditor.cancelEditing();
@@ -1401,7 +1004,7 @@ var Hypergrid = Base.extend('Hypergrid', {
      * @returns {boolean} One of:
      * * `false` - Editing BUT could not abort.
      * * `true` - Not editing OR was editing AND abort was successful.
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     abortEditing: function() {
         return !this.cellEditor || (
@@ -1410,7 +1013,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {Rectangle} The pixel coordinates of just the center 'main" data area.
      */
     getDataBounds: function() {
@@ -1419,17 +1022,17 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {Canvas} Our fin-canvas instance.
      */
     getCanvas: function() {
-        return this.canvas;
+        return this.deprecated('getCanvas()', 'canvas', '1.2.2');
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Open the cell-editor for the cell at the given coordinates.
-     * @param {Point} editPoint - The grid cell coordinate mixed with the data row coordinate.
+     * @param {CellEvent} event - Coordinates of "edit point" (gridCell.x, dataCell.y).
      * @return {undefined|CellEditor} The cellEditor determined from the cell's render properties, which may be modified by logic added by overriding {@link DataModel#getCellEditorAt|getCellEditorAt}.
      */
     editAt: function(event) {
@@ -1442,23 +1045,18 @@ var Hypergrid = Base.extend('Hypergrid', {
         this.abortEditing(); // if another editor is open, close it first
 
         if (
-            event.isGridColumn &&
-            event.getCellProperty(event.isGridRow ? 'editable' : 'filterable')
+            event.isDataColumn &&
+            event.properties[event.isDataRow ? 'editable' : 'filterable'] &&
+            (cellEditor = this.getCellEditorAt(event))
         ) {
-            this.setMouseDown(event.gridCell);
-            this.setDragExtent(new Point(0, 0));
-
-            cellEditor = this.getCellEditorAt(event);
-            if (cellEditor) {
-                cellEditor.beginEditing();
-            }
+            cellEditor.beginEditing();
         }
 
         return cellEditor;
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @param {number} columnIndex - The column index in question.
      * @returns {boolean} The given column is fully visible.
      */
@@ -1467,7 +1065,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @param {number} r - The raw row index in question.
      * @returns {boolean} The given row is fully visible.
      */
@@ -1476,8 +1074,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @todo refac and move to CellEvent
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @param {number} c - The column index in question.
      * @param {number} rn - The grid row index in question.
      * @returns {boolean} The given cell is fully is visible.
@@ -1487,7 +1084,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Scroll in the `offsetX` direction if column index `colIndex` is not visible.
      * @param {number} colIndex - The column index in question.
      * @param {number} offsetX - The direction and magnitude to scroll if we need to.
@@ -1495,7 +1092,7 @@ var Hypergrid = Base.extend('Hypergrid', {
      */
     insureModelColIsVisible: function(colIndex, offsetX) {
         var maxCols = this.getColumnCount() - 1, // -1 excludes partially visible columns
-            indexToCheck = colIndex + (offsetX > 0),
+            indexToCheck = colIndex + Math.sign(offsetX),
             visible = !this.isColumnVisible(indexToCheck) || colIndex === maxCols;
 
         if (visible) {
@@ -1507,7 +1104,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Scroll in the `offsetY` direction if column index c is not visible.
      * @param {number} rowIndex - The column index in question.
      * @param {number} offsetX - The direction and magnitude to scroll if we need to.
@@ -1515,7 +1112,7 @@ var Hypergrid = Base.extend('Hypergrid', {
      */
     insureModelRowIsVisible: function(rowIndex, offsetY) {
         var maxRows = this.getRowCount() - 1, // -1 excludes partially visible rows
-            indexToCheck = rowIndex + (offsetY > 0),
+            indexToCheck = rowIndex + Math.sign(offsetY),
             visible = !this.isDataRowVisible(indexToCheck) || rowIndex === maxRows;
 
         if (visible) {
@@ -1527,7 +1124,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Scroll horizontal and vertically by the provided offsets.
      * @param {number} offsetX - Scroll in the x direction this much.
      * @param {number} offsetY - Scroll in the y direction this much.
@@ -1538,7 +1135,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Scroll vertically by the provided offset.
      * @param {number} offsetY - Scroll in the y direction this much.
      */
@@ -1552,7 +1149,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Scroll horizontally by the provided offset.
      * @param {number} offsetX - Scroll in the x direction this much.
      */
@@ -1600,12 +1197,12 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     selectCellAndScrollToMakeVisible: function(c, r) {
-        this.selectCell(c, r, true);
         this.scrollToMakeVisible(c, r);
+        this.selectCell(c, r, true);
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Answer which data cell is under a pixel value mouse point.
      * @param {mousePoint} mouse - The mouse point to interrogate.
      */
@@ -1617,7 +1214,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     /**
      * @param {Point} gridCell - The pixel location of the mouse in physical grid coordinates.
      * @returns {Rectangle} The pixel based bounds rectangle given a data cell point.
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     getBoundsOfCell: function(gridCell) {
         var b = this.renderer.getBoundsOfCell(gridCell.x, gridCell.y);
@@ -1627,7 +1224,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc This is called by the fin-canvas when a resize occurs.
      */
     resized: function() {
@@ -1635,7 +1232,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary A click event occurred.
      * @desc Determine the cell and delegate to the behavior (model).
      * @param {MouseEvent} event - The mouse event to interrogate.
@@ -1645,151 +1242,41 @@ var Hypergrid = Base.extend('Hypergrid', {
      * * `false` drill-down unchanged (was already in requested state)
      */
     cellClicked: function(event) {
-        var result = false;
-
-        //click occurred in background area
-        if (
-            event.gridCell.x <= this.getColumnCount() &&
-            event.gridCell.y <= this.getRowCount()
-        ) {
-            result = this.behavior.cellClicked(event);
+        var result = this.behavior.cellClicked(event);
 
-            if (result !== undefined) {
-                this.behavior.changed();
-            }
+        if (result !== undefined) {
+            this.behavior.changed();
         }
 
         return result;
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @param {number} c - grid column index.
-     * @param {string[]} keys
+     * To intercept link clicks, override this method (either on the prototype to apply to all grid instances or on an instance to apply to a specific grid instance).
+     * @memberOf Hypergrid#
      */
-    fireSyntheticColumnSortEvent: function(c, keys) {
-        var event = new CustomEvent('fin-column-sort', {
-            detail: {
-                column: c,
-                keys: keys
-            }
-        });
-        this.canvas.dispatchEvent(event);
-    },
-
-    fireSyntheticEditorKeyUpEvent: function(inputControl, keyEvent) {
-        var clickEvent = new CustomEvent('fin-editor-keyup', {
-            detail: {
-                input: inputControl,
-                keyEvent: keyEvent,
-                char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
-            }
-        });
-        this.canvas.dispatchEvent(clickEvent);
-    },
-
-    fireSyntheticEditorKeyDownEvent: function(inputControl, keyEvent) {
-        var clickEvent = new CustomEvent('fin-editor-keydown', {
-            detail: {
-                input: inputControl,
-                keyEvent: keyEvent,
-                char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
-            }
-        });
-        this.canvas.dispatchEvent(clickEvent);
-    },
-
-    fireSyntheticEditorKeyPressEvent: function(inputControl, keyEvent) {
-        var clickEvent = new CustomEvent('fin-editor-keypress', {
-            detail: {
-                input: inputControl,
-                keyEvent: keyEvent,
-                char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
-            }
-        });
-        this.canvas.dispatchEvent(clickEvent);
-    },
-
-    fireSyntheticEditorDataChangeEvent: function(inputControl, oldValue, newValue) {
-        var clickEvent = new CustomEvent('fin-editor-data-change', {
-            detail: {
-                input: inputControl,
-                oldValue: oldValue,
-                newValue: newValue
-            },
-            cancelable: true
-        });
-        return this.canvas.dispatchEvent(clickEvent);
+    windowOpen: function(url, name, features, replace) {
+        return window.open.apply(window, arguments);
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and fire a `fin-row-selection-changed` event.
+     * @param {number} [begin]
+     * @param {nubmer} [end]
+     * * @returns {Column[]} A copy of the all columns array by passing the params to `Array.prototype.slice`.
      */
-    fireSyntheticRowSelectionChangedEvent: function() {
-        var selectionEvent = new CustomEvent('fin-row-selection-changed', {
-            detail: {
-                rows: this.getSelectedRows(),
-                columns: this.getSelectedColumns(),
-                selections: this.selectionModel.getSelections(),
-            }
-        });
-        this.canvas.dispatchEvent(selectionEvent);
+    getColumns: function(begin, end) {
+        var columns = this.behavior.getColumns();
+        return columns.slice.apply(columns, arguments);
     },
 
-    fireSyntheticColumnSelectionChangedEvent: function() {
-        var selectionEvent = new CustomEvent('fin-column-selection-changed', {
-            detail: {
-                rows: this.getSelectedRows(),
-                columns: this.getSelectedColumns(),
-                selections: this.selectionModel.getSelections()
-            }
-        });
-        this.canvas.dispatchEvent(selectionEvent);
-    },
     /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and dispatch a `fin-selection-changed` event.
+     * @param {number} [begin]
+     * @param {nubmer} [end]
+     * * @returns {Column[]} A copy of the active columns array by passing the params to `Array.prototype.slice`.
      */
-    selectionChanged: function() {
-        var selectedRows = this.getSelectedRows();
-        var selectionEvent = new CustomEvent('fin-selection-changed', {
-            detail: {
-                rows: selectedRows,
-                columns: this.getSelectedColumns(),
-                selections: this.selectionModel.getSelections(),
-            }
-        });
-        this.canvas.dispatchEvent(selectionEvent);
-    },
-
-    getRowSelection: function(includeHiddenColumns) {
-        var column, rows, getColumn,
-            self = this,
-            selectedRowIndexes = this.selectionModel.getSelectedRows(),
-            numColumns = this.getColumnCount(),
-            result = {};
-
-        if (includeHiddenColumns) {
-            numColumns += this.getHiddenColumns().length;
-            getColumn = this.behavior.getColumn;
-        } else {
-            getColumn = this.behavior.getActiveColumn;
-        }
-        getColumn = getColumn.bind(this.behavior);
-
-        for (var c = 0; c < numColumns; c++) {
-            column = getColumn(c);
-            rows = result[column.name] = new Array(selectedRowIndexes.length);
-            selectedRowIndexes.forEach(getValue);
-        }
-
-        function getValue(selectedRowIndex, j) {
-            var dataRow = self.getRow(selectedRowIndex);
-            rows[j] = valOrFunc.call(dataRow, column);
-        }
-
-        return result;
+    getActiveColumns: function(begin, end) {
+        var columns = this.behavior.getActiveColumns();
+        return columns.slice.apply(columns, arguments);
     },
 
     getHiddenColumns: function(){
@@ -1797,331 +1284,12 @@ var Hypergrid = Base.extend('Hypergrid', {
         return this.behavior.getHiddenColumns();
     },
 
-    getRowSelectionMatrix: function() {
-        var self = this,
-            selectedRowIndexes = this.selectionModel.getSelectedRows(),
-            numCols = this.getColumnCount(),
-            result = new Array(numCols);
-
-        for (var c = 0; c < numCols; c++) {
-            var column = this.behavior.getActiveColumn(c);
-            result[c] = new Array(selectedRowIndexes.length);
-            selectedRowIndexes.forEach(getValue);
-        }
-
-        function getValue(selectedRowIndex, r) {
-            var dataRow = self.getRow(selectedRowIndex);
-            result[c][r] = valOrFunc.call(dataRow, column);
-        }
-
-        return result;
-    },
-
-    getColumnSelectionMatrix: function() {
-        var dataRow,
-            self = this,
-            headerRowCount = this.getHeaderRowCount(),
-            selectedColumnIndexes = this.getSelectedColumns(),
-            numRows = this.getRowCount(),
-            result = new Array(selectedColumnIndexes.length);
-
-        selectedColumnIndexes.forEach(function(selectedColumnIndex, c) {
-            var column = self.behavior.getActiveColumn(selectedColumnIndex),
-                values = result[c] = new Array(numRows);
-
-            for (var r = headerRowCount; r < numRows; r++) {
-                dataRow = self.getRow(r);
-                values[r] = valOrFunc.call(dataRow, column);
-            }
-        });
-
-        return result;
-    },
-
-    getColumnSelection: function() {
-        var dataRow,
-            self = this,
-            headerRowCount = this.getHeaderRowCount(),
-            selectedColumnIndexes = this.getSelectedColumns(),
-            result = {},
-            rowCount = this.getRowCount();
-
-        selectedColumnIndexes.forEach(function(selectedColumnIndex) {
-            var column = self.behavior.getActiveColumn(selectedColumnIndex),
-                values = result[column.name] = new Array(rowCount);
-
-            for (var r = headerRowCount; r < rowCount; r++) {
-                dataRow = self.getRow(r);
-                values[r] = valOrFunc.call(dataRow, column);
-            }
-        });
-
-        return result;
-    },
-
-    getSelection: function() {
-        var dataRow,
-            self = this,
-            selections = this.getSelections(),
-            rects = new Array(selections.length);
-
-        selections.forEach(getRect);
-
-        function getRect(selectionRect, i) {
-            var rect = normalizeRect(selectionRect),
-                colCount = rect.extent.x + 1,
-                rowCount = rect.extent.y + 1,
-                columns = {};
-
-            for (var c = 0, x = rect.origin.x; c < colCount; c++, x++) {
-                var column = self.behavior.getActiveColumn(x),
-                    values = columns[column.name] = new Array(rowCount);
-
-                for (var r = 0, y = rect.origin.y; r < rowCount; r++, y++) {
-                    dataRow = self.getRow(y);
-                    values[r] = valOrFunc.call(dataRow, column);
-                }
-            }
-
-            rects[i] = columns;
-        }
-
-        return rects;
-    },
-
-    getSelectionMatrix: function() {
-        var dataRow,
-            self = this,
-            selections = this.getSelections(),
-            rects = new Array(selections.length);
-
-        selections.forEach(getRect);
-
-        function getRect(selectionRect, i) {
-            var rect = normalizeRect(selectionRect),
-                colCount = rect.extent.x + 1,
-                rowCount = rect.extent.y + 1,
-                rows = [];
-
-            for (var c = 0, x = rect.origin.x; c < colCount; c++, x++) {
-                var values = rows[c] = new Array(rowCount),
-                    column = self.behavior.getActiveColumn(x);
-
-                for (var r = 0, y = rect.origin.y; r < rowCount; r++, y++) {
-                    dataRow = self.getRow(y);
-                    values[r] = valOrFunc.call(dataRow, column);
-                }
-            }
-
-            rects[i] = rows;
-        }
-
-        return rects;
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and fire a `fin-context-menu` event
-     * @param {keyEvent} event - The canvas event.
-     */
-    fireSyntheticContextMenuEvent: function(event) {
-        event.rows = this.getSelectedRows();
-        event.columns = this.getSelectedColumns();
-        event.selections = this.selectionModel.getSelections();
-        this.canvas.dispatchEvent(
-            new CustomEvent('fin-context-menu', { detail: event })
-        );
-    },
-
-    fireSyntheticMouseUpEvent: function(event) {
-        event.rows = this.getSelectedRows();
-        event.columns = this.getSelectedColumns();
-        event.selections = this.selectionModel.getSelections();
-        this.canvas.dispatchEvent(
-            new CustomEvent('fin-mouseup', { detail: event })
-        );
-    },
-
-    fireSyntheticMouseDownEvent: function(event) {
-        event.rows = this.getSelectedRows();
-        event.columns = this.getSelectedColumns();
-        event.selections = this.selectionModel.getSelections();
-        this.canvas.dispatchEvent(
-            new CustomEvent('fin-mousedown', { detail: event })
-        );
-    },
-
     isViewableButton: function(c, r) {
         return this.renderer.isViewableButton(c, r);
     },
 
-    fireSyntheticButtonPressedEvent: function(event) {
-        if (this.isViewableButton(event.dataCell.x, event.gridCell.y)) {
-            this.canvas.dispatchEvent(
-                new CustomEvent('fin-button-pressed', { detail: event })
-            );
-        }
-    },
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and fire a `fin-column-drag-start` event.
-     */
-    fireSyntheticOnColumnsChangedEvent: function() {
-        var detail = {
-            time: Date.now(),
-            grid: this
-        };
-        var cEvent = new CustomEvent('fin-column-changed-event', {
-            detail: detail
-        });
-        this.canvas.dispatchEvent(cEvent);
-    },
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and fire a `fin-keydown` event.
-     * @param {keyEvent} event - The canvas event.
-     */
-    fireSyntheticKeydownEvent: function(keyEvent) {
-        var clickEvent = new CustomEvent('fin-keydown', {
-            detail: keyEvent.detail
-        });
-        this.canvas.dispatchEvent(clickEvent);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and fire a `fin-keyup` event.
-     * @param {keyEvent} event - The canvas event.
-     */
-    fireSyntheticKeyupEvent: function(keyEvent) {
-        var clickEvent = new CustomEvent('fin-keyup', {
-            detail: keyEvent.detail
-        });
-        this.canvas.dispatchEvent(clickEvent);
-    },
-
-    fireSyntheticFilterAppliedEvent: function() {
-        var filterEvent = new CustomEvent('fin-filter-applied');
-        this.canvas.dispatchEvent(filterEvent);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and fire a `fin-cell-enter` event
-     * @param {Point} cell - The pixel location of the cell in which the click event occurred.
-     * @param {MouseEvent} event - The system mouse event.
-     */
-    fireSyntheticOnCellEnterEvent: function(cell) {
-        var detail = {
-            gridCell: cell,
-            time: Date.now(),
-            grid: this
-        };
-        var clickEvent = new CustomEvent('fin-cell-enter', {
-            detail: detail
-        });
-        this.canvas.dispatchEvent(clickEvent);
-    },
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and fire a `fin-cell-exit` event.
-     * @param {Point} cell - The pixel location of the cell in which the click event occured.
-     * @param {MouseEvent} event - The system mouse event.
-     */
-    fireSyntheticOnCellExitEvent: function(cell) {
-        var detail = {
-            gridCell: cell,
-            time: Date.now(),
-            grid: this
-        };
-        var clickEvent = new CustomEvent('fin-cell-exit', {
-            detail: detail
-        });
-        this.canvas.dispatchEvent(clickEvent);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and fire a `fin-cell-click` event.
-     * @param {Point} cell - The pixel location of the cell in which the click event occured.
-     * @param {MouseEvent} event - The system mouse event.
-     */
-    fireSyntheticClickEvent: function(mouseEvent) {
-        var cell = mouseEvent.gridCell;
-        var detail = {
-            gridCell: cell,
-            mousePoint: mouseEvent.mousePoint,
-            keys: mouseEvent.keys,
-            primitiveEvent: mouseEvent,
-            time: Date.now(),
-            grid: this
-        };
-        this.behavior.enhanceDoubleClickEvent(detail);
-        var clickEvent = new CustomEvent('fin-click', {
-            detail: detail
-        });
-        this.canvas.dispatchEvent(clickEvent);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and fire a `fin-double-click` event.
-     * @param {MouseEvent} event - The system mouse event.
-     */
-    fireSyntheticDoubleClickEvent: function(mouseEvent) {
-        if (!this.abortEditing()) { return; }
-        var cell = mouseEvent.gridCell;
-        var detail = {
-            gridCell: cell,
-            mousePoint: mouseEvent.mousePoint,
-            time: Date.now(),
-            grid: this
-        };
-        this.behavior.enhanceDoubleClickEvent(mouseEvent);
-        var clickEvent = new CustomEvent('fin-double-click', {
-            detail: detail
-        });
-        this.behavior.cellDoubleClicked(cell, mouseEvent);
-        this.canvas.dispatchEvent(clickEvent);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and fire a rendered event.
-     */
-    fireSyntheticGridRenderedEvent: function() {
-        var event = new CustomEvent('fin-grid-rendered', {
-            detail: {
-                source: this,
-                time: Date.now()
-            }
-        });
-        if (this.canvas) {
-            this.canvas.dispatchEvent(event);
-        }
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and fire a scroll event.
-     * @param {string} type - Should be either `fin-scroll-x` or `fin-scroll-y`.
-     * @param {number} oldValue - The old scroll value.
-     * @param {number} newValue - The new scroll value.
-     */
-    fireScrollEvent: function(type, oldValue, newValue) {
-        var event = new CustomEvent(type, {
-            detail: {
-                oldValue: oldValue,
-                value: newValue,
-                time: Date.now()
-            }
-        });
-        this.canvas.dispatchEvent(event);
-
-    },
-
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Set the vertical scroll value.
      * @param {number} newValue - The new scroll value.
      */
@@ -2141,7 +1309,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @return {number} The vertical scroll value.
      */
     getVScrollValue: function() {
@@ -2149,7 +1317,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Set the horizontal scroll value.
      * @param {number} newValue - The new scroll value.
      */
@@ -2170,7 +1338,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns The vertical scroll value.
      */
     getHScrollValue: function() {
@@ -2178,19 +1346,19 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Request input focus.
      */
     takeFocus: function() {
         var wasCellEditor = this.cellEditor;
         this.stopEditing();
         if (!wasCellEditor) {
-            this.getCanvas().takeFocus();
+            this.canvas.takeFocus();
         }
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Request focus for our cell editor.
      */
     editorTakeFocus: function() {
@@ -2200,7 +1368,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Initialize the scroll bars.
      */
     initScrollbars: function() {
@@ -2252,7 +1420,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Scroll values have changed, we've been notified.
      */
     setVScrollbarValues: function(max) {
@@ -2270,51 +1438,49 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     scrollValueChangedNotification: function() {
+        if (
+            this.hScrollValue !== this.sbPrevHScrollValue ||
+            this.vScrollValue !== this.sbPrevVScrollValue
+        ) {
+            this.sbPrevHScrollValue = this.hScrollValue;
+            this.sbPrevVScrollValue = this.vScrollValue;
 
-        if (this.hScrollValue === this.sbPrevHScrollValue && this.vScrollValue === this.sbPrevVScrollValue) {
-            return;
-        }
-
-        this.sbPrevHScrollValue = this.hScrollValue;
-        this.sbPrevVScrollValue = this.vScrollValue;
+            if (this.cellEditor) {
+                this.cellEditor.scrollValueChangedNotification();
+            }
 
-        if (this.cellEditor) {
-            this.cellEditor.scrollValueChangedNotification();
+            this.computeCellsBounds();
         }
-
-        this.computeCellsBounds();
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Get data value at given cell.
-     * @desc Delegates to the behavior.
      * @param {number} x - The horizontal coordinate.
      * @param {number} y - The vertical coordinate.
-     * @param {*} value
      */
     getValue: function(x, y) {
-        return this.behavior.getValue.apply(this.behavior, arguments);
+        return this.behavior.getValue.apply(this.behavior, arguments); // must use .apply (see this.behavior.getValue)
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @desc Set a data value into the behavior (model) at the given point
+     * @memberOf Hypergrid#
+     * @summary Set a data value of a given cell.
      * @param {number} x - The horizontal coordinate.
      * @param {number} y - The vertical coordinate.
+     * @param {*} value - New cell value.
      */
     setValue: function(x, y, value) {
-        this.behavior.setValue.apply(this.beahvior, arguments);
+        this.behavior.setValue.apply(this.behavior, arguments); // must use .apply (see this.behavior.setValue)
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @desc The data dimensions have changed, or our pixel boundries have changed.
+     * @memberOf Hypergrid#
+     * @desc The data dimensions have changed, or our pixel boundaries have changed.
      * Adjust the scrollbar properties as necessary.
      */
     synchronizeScrollingBoundaries: function() {
         var numFixedColumns = this.getFixedColumnCount();
-        var numFixedRows = this.getFixedRowCount();
 
         var numColumns = this.getColumnCount();
         var numRows = this.getRowCount();
@@ -2324,34 +1490,38 @@ var Hypergrid = Base.extend('Hypergrid', {
             return;
         }
 
-        // 15px padding at bottom and right side
-        var scrollableHeight = bounds.height - this.behavior.getFixedRowsMaxHeight() - 15;
-        var scrollableWidth = bounds.width - this.behavior.getFixedColumnsMaxWidth() - 15;
-
+        var scrollableWidth = bounds.width - this.behavior.getFixedColumnsMaxWidth();
         for (
             var columnsWidth = 0, lastPageColumnCount = 0;
-            lastPageColumnCount < numColumns && columnsWidth <= scrollableWidth;
+            lastPageColumnCount < numColumns && columnsWidth < scrollableWidth;
             lastPageColumnCount++
         ) {
             columnsWidth += this.getColumnWidth(numColumns - lastPageColumnCount - 1);
         }
+        if (columnsWidth > scrollableWidth) {
+            lastPageColumnCount--;
+        }
 
+        var scrollableHeight = this.renderer.getVisibleScrollHeight();
         for (
             var rowsHeight = 0, lastPageRowCount = 0;
-            lastPageRowCount < numRows && rowsHeight <= scrollableHeight;
+            lastPageRowCount < numRows && rowsHeight < scrollableHeight;
             lastPageRowCount++
         ) {
             rowsHeight += this.getRowHeight(numRows - lastPageRowCount - 1);
         }
+        if (rowsHeight > scrollableHeight) {
+            lastPageRowCount--;
+        }
 
         // inform scroll bars
         if (this.sbHScroller) {
-            var hMax = 1 + Math.max(0, numColumns - numFixedColumns - lastPageColumnCount);
+            var hMax = Math.max(0, numColumns - numFixedColumns - lastPageColumnCount);
             this.setHScrollbarValues(hMax);
             this.setHScrollValue(Math.min(this.getHScrollValue(), hMax));
         }
         if (this.sbVScroller) {
-            var vMax = Math.max(0, numRows - numFixedRows - lastPageRowCount);
+            var vMax = Math.max(0, numRows - this.properties.fixedRowCount - lastPageRowCount);
             this.setVScrollbarValues(vMax);
             this.setVScrollValue(Math.min(this.getVScrollValue(), vMax));
         }
@@ -2362,11 +1532,11 @@ var Hypergrid = Base.extend('Hypergrid', {
         this.resizeScrollbars();
     },
     synchronizeScrollingBoundries: function() {
-        this.deprecated('synchronizeScrollingBoundries', 'synchronizeScrollingBoundaries', '1.2.0');
+        this.deprecated('synchronizeScrollingBoundries()', 'synchronizeScrollingBoundaries()', '1.2.0');
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Note that "viewable rows" includes any partially viewable rows.
      * @returns {number} The number of viewable rows.
      */
@@ -2375,7 +1545,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Note that "viewable columns" includes any partially viewable columns.
      * @returns {number} The number of viewable columns.
      */
@@ -2384,7 +1554,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Initialize the renderer sub-component.
      */
     initRenderer: function() {
@@ -2392,7 +1562,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {number} The width of the given column.
      * @param {number} columnIndex - The untranslated column index.
      */
@@ -2401,7 +1571,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Set the width of the given column.
      * @param {number} columnIndex - The untranslated column index.
      * @param {number} columnWidth - The width in pixels.
@@ -2417,7 +1587,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {number} The total width of all the fixed columns.
      */
     getFixedColumnsWidth: function() {
@@ -2425,7 +1595,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {number} The height of the given row
      * @param {number} rowIndex - The untranslated fixed column index.
      */
@@ -2434,7 +1604,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Set the height of the given row.
      * @param {number} rowIndex - The row index.
      * @param {number} rowHeight - The width in pixels.
@@ -2446,7 +1616,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {number} The total fixed rows height
      */
     getFixedRowsHeight: function() {
@@ -2455,7 +1625,7 @@ var Hypergrid = Base.extend('Hypergrid', {
 
     /**
      * Number of _visible_ columns.
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {number} The number of columns.
      */
     getColumnCount: function() {
@@ -2463,8 +1633,8 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @returns {number} The number of fixed rows.
+     * @memberOf Hypergrid#
+     * @returns {number} The number of rows.
      */
     getRowCount: function() {
         return this.behavior.getRowCount();
@@ -2475,7 +1645,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {number} The number of fixed columns.
      */
     getFixedColumnCount: function() {
@@ -2483,7 +1653,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns The number of fixed rows.
      */
     getFixedRowCount: function() {
@@ -2491,17 +1661,17 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary The top left area has been clicked on
      * @desc Delegates to the behavior.
-     * @param {event} event - The event details.
+     * @param {event} mouse - The event details.
      */
     topLeftClicked: function(mouse) {
         this.behavior.topLeftClicked(this, mouse);
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary A fixed row has been clicked.
      * @desc Delegates to the behavior.
      * @param {event} event - The event details.
@@ -2511,7 +1681,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary A fixed column has been clicked.
      * @desc Delegates to the behavior.
      * @param {event} event - The event details.
@@ -2521,7 +1691,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc An edit event has occurred. Activate the editor at the given coordinates.
      * @param {number} event.gridCell.x - The horizontal coordinate.
      * @param {number} event.gridCell.y - The vertical coordinate.
@@ -2533,7 +1703,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Get the cell editor.
      * @desc Delegates to the behavior.
      * @returns The cell editor at the given coordinates.
@@ -2544,13 +1714,13 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @summary Toggle HiDPI support.
      * @desc HiDPI support is now *on* by default.
      * > There used to be a bug in Chrome that caused severe slow down on bit blit of large images, so this HiDPI needed to be optional.
      */
     toggleHiDPI: function() {
-        if (this.useHiDPI()) {
+        if (this.properties.useHiDPI) {
             this.removeAttribute('hidpi');
         } else {
             this.setAttribute('hidpi', null);
@@ -2559,27 +1729,26 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @returns {number} Te HiDPI ratio.
+     * @memberOf Hypergrid#
+     * @returns {number} The HiDPI ratio.
      */
     getHiDPI: function(ctx) {
-        if (window.devicePixelRatio && this.useHiDPI()) {
-            var devicePixelRatio = window.devicePixelRatio || 1;
-            var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
+        if (window.devicePixelRatio && this.properties.useHiDPI) {
+            var devicePixelRatio = window.devicePixelRatio || 1,
+                backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                 ctx.mozBackingStorePixelRatio ||
                 ctx.msBackingStorePixelRatio ||
                 ctx.oBackingStorePixelRatio ||
-                ctx.backingStorePixelRatio || 1;
-
-            var ratio = devicePixelRatio / backingStoreRatio;
-            return ratio;
+                ctx.backingStorePixelRatio || 1,
+                result = devicePixelRatio / backingStoreRatio;
         } else {
-            return 1;
+            result = 1;
         }
+        return result;
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {number} The width of the given (recently rendered) column.
      * @param {number} colIndex - The column index.
      */
@@ -2588,16 +1757,16 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {number} The height of the given (recently rendered) row.
-     * @param {number} rowIndex - Tthe row index.
+     * @param {number} rowIndex - The row index.
      */
     getRenderedHeight: function(rowIndex) {
         return this.renderer.getRenderedHeight(rowIndex);
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Update the cursor under the hover cell.
      */
     updateCursor: function() {
@@ -2615,7 +1784,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Repaint the given cell.
      * @param {x} x - The horizontal coordinate.
      * @param {y} y - The vertical coordinate.
@@ -2625,7 +1794,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {boolean} The user is currently dragging a column to reorder it.
      */
     isDraggingColumn: function() {
@@ -2633,7 +1802,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Scroll up one full page.
      * @returns {number}
      */
@@ -2644,7 +1813,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Scroll down one full page.
      * @returns {number}
      */
@@ -2655,7 +1824,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Not yet implemented.
      */
     pageLeft: function() {
@@ -2663,7 +1832,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Not yet implemented.
      */
     pageRight: function() {
@@ -2671,7 +1840,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {object[]} Objects with the values that were just rendered.
      */
     getRenderedData: function() {
@@ -2700,103 +1869,27 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
-     * @returns {object} An object that represents the currently selection row.
-     */
-    getSelectedRow: function() {
-        var sels = this.selectionModel.getSelections();
-        if (sels.length) {
-            var behavior = this.behavior,
-                colCount = this.getColumnCount(),
-                topRow = sels[0].origin.y,
-                row = {
-                    //hierarchy: behavior.getFixedColumnValue(0, topRow)
-                };
-
-            for (var c = 0; c < colCount; c++) {
-                row[behavior.getActiveColumn(c).header] = behavior.getValue(c, topRow);
-            }
-
-            return row;
-        }
-    },
-
-    fireRequestCellEdit: function(cell, value) {
-        var clickEvent = new CustomEvent('fin-request-cell-edit', {
-            cancelable: true,
-            detail: {
-                value: value,
-                gridCell: cell,
-                time: Date.now()
-            }
-        });
-        return this.canvas.dispatchEvent(clickEvent); //I wasn't cancelled
-    },
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Synthesize and fire a fin-before-cell-edit event.
-     * @param {Point} cell - The x,y coordinates.
-     * @param {Object} value - The current value.
-     * @returns {boolean} Proceed (don't cancel).
-     */
-    fireBeforeCellEdit: function(cell, oldValue, newValue, control) {
-        var clickEvent = new CustomEvent('fin-before-cell-edit', {
-            cancelable: true,
-            detail: {
-                oldValue: oldValue,
-                newValue: newValue,
-                gridCell: cell,
-                time: Date.now(),
-                input: control,
-                row: this.getRow(cell.y)
-            }
-        });
-        return this.canvas.dispatchEvent(clickEvent);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @returns {Renderer} sub-component
-     * @param {Point} cell - The x,y coordinates.
-     * @param {Object} oldValue - The old value.
-     * @param {Object} newValue - The new value.
+     * @summary Autosize a column for best fit.
+     * @param {Column|number} columnOrIndex - The column or active column index.
+     * @memberOf Hypergrid#
      */
-    fireAfterCellEdit: function(cell, oldValue, newValue, control) {
-        var clickEvent = new CustomEvent('fin-after-cell-edit', {
-            detail: {
-                newValue: newValue,
-                oldValue: oldValue,
-                gridCell: cell,
-                time: Date.now(),
-                input: control,
-                row: this.getRow(cell.y)
-            }
-        });
-        this.canvas.dispatchEvent(clickEvent);
-    },
-
-    /**
-     * @memberOf Hypergrid.prototype
-     * @desc Autosize the column at colIndex for best fit.
-     * @param {number} colIndex - The column index to modify at
-     */
-    autosizeColumn: function(activeColumnIndex) {
-        var column = this.behavior.getActiveColumn(activeColumnIndex);
+    autosizeColumn: function(columnOrIndex) {
+        var column = columnOrIndex >= -2 ? this.behavior.getActiveColumn(columnOrIndex) : columnOrIndex;
         column.checkColumnAutosizing(true);
         this.computeCellsBounds();
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Enable/disable if this component can receive the focus.
      * @param {boolean} - canReceiveFocus
      */
     setFocusable: function(canReceiveFocus) {
-        this.getCanvas().setFocusable(canReceiveFocus);
+        this.canvas.setFocusable(canReceiveFocus);
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {number} The number of columns that were just rendered
      */
     getVisibleColumnsCount: function() {
@@ -2804,7 +1897,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @returns {number} The number of rows that were just rendered
      */
     getVisibleRowsCount: function() {
@@ -2812,7 +1905,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Update the size of a grid instance.
      */
     updateSize: function() {
@@ -2821,7 +1914,7 @@ var Hypergrid = Base.extend('Hypergrid', {
 
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Stop the global repainting flag thread.
      */
     stopPaintThread: function() {
@@ -2829,7 +1922,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Stop the global resize check flag thread.
      */
     stopResizeThread: function() {
@@ -2837,7 +1930,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Restart the global resize check flag thread.
      */
     restartResizeThread: function() {
@@ -2845,7 +1938,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      * @desc Restart the global repainting check flag thread.
      */
     restartPaintThread: function() {
@@ -2872,10 +1965,6 @@ var Hypergrid = Base.extend('Hypergrid', {
         return mouseDown.x < 0 || mouseDown.y < headerRowCount;
     },
 
-    isHeaderWrapping: function() {
-        return this.properties.headerTextWrapping;
-    },
-
     _getBoundsOfCell: function(x, y) {
         return this.deprecated('_getBoundsOfCell()', 'getBoundsOfCell()', '1.2.0', arguments);
     },
@@ -2883,7 +1972,7 @@ var Hypergrid = Base.extend('Hypergrid', {
     /**
      * @param {index} x - Data x coordinate.
      * @return {Object} The properties for a specific column.
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     getColumnProperties: function(x) {
         return this.behavior.getColumnProperties(x);
@@ -2892,227 +1981,52 @@ var Hypergrid = Base.extend('Hypergrid', {
     /**
      * @param {index} x - Data x coordinate.
      * @return {Object} The properties for a specific column.
-     * @memberOf Hypergrid.prototype
+     * @memberOf Hypergrid#
      */
     setColumnProperties: function(x, properties) {
         this.behavior.setColumnProperties(x, properties);
     },
 
-    moveSingleSelect: function(x, y) {
-        this.behavior.moveSingleSelect(this, x, y);
-    },
-
-    selectCell: function(x, y, silent) {
-        var dontClearRows = this.isCheckboxOnlyRowSelections();
-        this.selectionModel.clear(dontClearRows);
-        this.selectionModel.select(x, y, 0, 0, silent);
-    },
-
-    toggleSelectColumn: function(x, keys) {
-        keys = keys || [];
-        var model = this.selectionModel;
-        var alreadySelected = model.isColumnSelected(x);
-        var hasCTRL = keys.indexOf('CTRL') > -1;
-        var hasSHIFT = keys.indexOf('SHIFT') > -1;
-        if (!hasCTRL && !hasSHIFT) {
-            model.clear();
-            if (!alreadySelected) {
-                model.selectColumn(x);
-            }
-        } else {
-            if (hasCTRL) {
-                if (alreadySelected) {
-                    model.deselectColumn(x);
-                } else {
-                    model.selectColumn(x);
-                }
-            }
-            if (hasSHIFT) {
-                model.clear();
-                model.selectColumn(this.lastEdgeSelection[0], x);
-            }
-        }
-        if (!alreadySelected && !hasSHIFT) {
-            this.lastEdgeSelection[0] = x;
-        }
-        this.repaint();
-        this.fireSyntheticColumnSelectionChangedEvent();
-    },
-
-    toggleSelectRow: function(y, keys) {
-        //we can select the totals rows if they exist, but not rows above that
-        keys = keys || [];
-
-        var sm = this.selectionModel;
-        var alreadySelected = sm.isRowSelected(y);
-        var hasSHIFT = keys.indexOf('SHIFT') >= 0;
-
-        if (alreadySelected) {
-            sm.deselectRow(y);
-        } else {
-            this.singleSelect();
-            sm.selectRow(y);
-        }
-
-        if (hasSHIFT) {
-            sm.clear();
-            sm.selectRow(this.lastEdgeSelection[1], y);
-        }
-
-        if (!alreadySelected && !hasSHIFT) {
-            this.lastEdgeSelection[1] = y;
-        }
-
-        this.repaint();
-    },
-
-    singleSelect: function() {
-        var isCheckboxOnlyRowSelections = this.isCheckboxOnlyRowSelections(),
-            isSingleRowSelectionMode = this.isSingleRowSelectionMode(),
-            hasCTRL = false,
-            result;
-
-        if (this.mouseDownState){
-            //triggered programmatically
-            hasCTRL = this.mouseDownState.primitiveEvent.detail.primitiveEvent.ctrlKey;
-        }
-
-        result = (
-            isCheckboxOnlyRowSelections && isSingleRowSelectionMode ||
-            !isCheckboxOnlyRowSelections && (!hasCTRL || isSingleRowSelectionMode)
-        );
-
-        if (result) {
-            this.selectionModel.clearRowSelection();
-        }
-
-        return result;
-    },
-
-    selectViewportCell: function(x, y) {
-        var headerRowCount = this.getHeaderRowCount(),
-            realX = this.renderer.visibleColumns[x].ColumnIndex, // todo refac
-            realY = this.renderer.visibleRows[y].rowIndex; // todo refac
-        this.clearSelections();
-        this.select(realX, realY + headerRowCount, 0, 0);
-        this.setMouseDown(this.newPoint(realX, realY + headerRowCount)); // todo refac
-        this.setDragExtent(this.newPoint(0, 0));
-        this.repaint();
-    },
-
-    selectToViewportCell: function(x, y) {
-        var selections = this.getSelections();
-        if (selections && selections.length) {
-            var headerRowCount = this.getHeaderRowCount(),
-                realX = this.renderer.visibleColumns[x].columnIndex, // todo refac
-                realY = this.renderer.visibleRows[y].rowIndex + headerRowCount, // todo refac
-                selection = selections[0],
-                origin = selection.origin;
-            this.setDragExtent(this.newPoint(realX - origin.x, realY - origin.y));
-            this.select(origin.x, origin.y, realX - origin.x, realY - origin.y);
-            this.repaint();
-        }
-    },
-
-    selectFinalCellOfCurrentRow: function() {
-        var x = this.getColumnCount() - 1,
-            y = this.getSelectedRows()[0],
-            headerRowCount = this.getHeaderRowCount();
-        this.clearSelections();
-        this.scrollBy(this.getColumnCount(), 0);
-        this.select(x, y + headerRowCount, 0, 0);
-        this.setMouseDown(this.newPoint(x, y + headerRowCount));
-        this.setDragExtent(this.newPoint(0, 0));
-        this.repaint();
-    },
-
-    selectToFinalCellOfCurrentRow: function() {
-        var selections = this.getSelections();
-        if (selections && selections.length) {
-            var selection = selections[0],
-                origin = selection.origin,
-                extent = selection.extent,
-                columnCount = this.getColumnCount();
-            this.scrollBy(columnCount, 0);
-
-            this.clearSelections();
-            this.select(origin.x, origin.y, columnCount - origin.x - 1, extent.y);
-
-            this.repaint();
-        }
-    },
-
-    selectFirstCellOfCurrentRow: function() {
-        var x = 0,
-            y = this.getSelectedRows()[0],
-            headerRowCount = this.getHeaderRowCount();
-        this.clearSelections();
-        this.setHScrollValue(0);
-        this.select(x, y + headerRowCount, 0, 0);
-        this.setMouseDown(this.newPoint(x, y + headerRowCount));
-        this.setDragExtent(this.newPoint(0, 0));
-        this.repaint();
-    },
-
-    selectToFirstCellOfCurrentRow: function() {
-        var selections = this.getSelections();
-        if (selections && selections.length) {
-            var selection = selections[0],
-                origin = selection.origin,
-                extent = selection.extent;
-            this.clearSelections();
-            this.select(origin.x, origin.y, -origin.x, extent.y);
-            this.setHScrollValue(0);
-            this.repaint();
-        }
-    },
-
-    selectFinalCell: function() {
-        this.selectCell(this.getColumnCount() - 1, this.getRowCount() - 1);
-        this.scrollBy(this.getColumnCount(), this.getRowCount());
-        this.repaint();
-    },
-
-    selectToFinalCell: function() {
-        var selections = this.getSelections();
-        if (selections && selections.length) {
-            var selection = selections[0],
-                origin = selection.origin,
-                columnCount = this.getColumnCount(),
-                rowCount = this.getRowCount();
-
-            this.clearSelections();
-            this.select(origin.x, origin.y, columnCount - origin.x - 1, rowCount - origin.y - 1);
-            this.scrollBy(columnCount, rowCount);
-            this.repaint();
-        }
+    /**
+     * Clears all cell properties of given column or of all columns.
+     * @param {number} [x] - Omit for all columns.
+     * @memberOf Behavior#
+     */
+    clearAllCellProperties: function(x) {
+        this.behavior.clearAllCellProperties(x);
+        this.renderer.resetAllCellPropertiesCaches();
     },
 
     isShowRowNumbers: function() {
-        return this.properties.showRowNumbers;
+        return this.deprecated('isShowRowNumbers()', 'properties.showRowNumbers', 'v1.2.10');
     },
     isEditable: function() {
-        return this.properties.editable === true;
+        return this.deprecated('isEditable()', 'properties.editable', 'v1.2.10');
     },
 
     /**
-     * @todo row refac: deprecate in favor of CellEvent.isGridRow
      * @param {integerRowIndex|sectionPoint} rn
      * @returns {boolean}
+     * @memberOf Hypergrid#
      */
-    isGridRow: function(rn) {
-        return rn >= 0 || rn.y >= 0;
+    isGridRow: function(y) {
+        return new this.beahvior.CellEvent(0, y).isDataRow;
     },
 
     isShowHeaderRow: function() {
-        return this.properties.showHeaderRow;
+        return this.deprecated('isShowHeaderRow()', 'properties.showHeaderRow', 'v1.2.10');
     },
+
+    /**
+     * @returns {number} The total number of rows of all subgrids preceding the data subgrid.
+     * @memberOf Hypergrid#
+     */
     getHeaderRowCount: function() {
         return this.behavior.getHeaderRowCount();
     },
 
     isShowFilterRow: function() {
-        return this.properties.showFilterRow;
+        return this.deprecated('isShowFilterRow()', 'properties.showFilterRow', 'v1.2.10');
     },
 
     hasHierarchyColumn: function() {
@@ -3132,26 +2046,8 @@ var Hypergrid = Base.extend('Hypergrid', {
         //     this.sbVScroller.classList.add('visible');
         // }
     },
-    isColumnOrRowSelected: function() {
-        return this.selectionModel.isColumnOrRowSelected();
-    },
-    selectColumn: function(x1, x2) {
-        this.selectionModel.selectColumn(x1, x2);
-    },
-    selectRow: function(y1, y2) {
-        var sm = this.selectionModel;
-
-        if (this.singleSelect()) {
-            y1 = y2;
-        } else {
-            // multiple row selection
-            y2 = y2 || y1;
-        }
-
-        sm.selectRow(Math.min(y1, y2), Math.max(y1, y2));
-    },
     isRowNumberAutosizing: function() {
-        return this.properties.rowNumberAutosizing;
+        return this.deprecated('isRowNumberAutosizing()', 'properties.rowNumberAutosizing', 'v1.2.10');
     },
     lookupFeature: function(key) {
         return this.behavior.lookupFeature(key);
@@ -3159,67 +2055,9 @@ var Hypergrid = Base.extend('Hypergrid', {
     getRow: function(y) {
         return this.behavior.getRow(y);
     },
-    isCellSelection: function() {
-        return this.properties.cellSelection === true;
-    },
-    isRowSelection: function() {
-        return this.properties.rowSelection === true;
-    },
-    isColumnSelection: function() {
-        return this.properties.columnSelection === true;
-    },
-    isColumnAutosizing: function() {
-        return this.properties.columnAutosizing === true;
-    },
-
-    selectRowsFromCells: function() {
-        if (!this.isCheckboxOnlyRowSelections()) {
-            var last,
-                hasCTRL = this.mouseDownState.primitiveEvent.detail.primitiveEvent.ctrlKey;
 
-            if (hasCTRL && !this.isSingleRowSelectionMode()) {
-                this.selectionModel.selectRowsFromCells(0, hasCTRL);
-            } else if ((last = this.selectionModel.getLastSelection())) {
-                this.selectRow(null, last.corner.y);
-            } else {
-                this.clearRowSelection();
-            }
-        }
-    },
-    selectColumnsFromCells: function() {
-        this.selectionModel.selectColumnsFromCells();
-    },
-    getSelectedRows: function() {
-        return this.behavior.getSelectedRows();
-    },
-    getSelectedColumns: function() {
-        return this.behavior.getSelectedColumns();
-    },
-    getSelections: function() {
-        return this.behavior.getSelections();
-    },
-    getLastSelectionType: function() {
-        return this.selectionModel.getLastSelectionType();
-    },
-    isInCurrentSelectionRectangle: function(x, y) {
-        return this.selectionModel.isInCurrentSelectionRectangle(x, y);
-    },
-    selectAllRows: function() {
-        this.selectionModel.selectAllRows();
-    },
-    areAllRowsSelected: function() {
-        return this.selectionModel.areAllRowsSelected();
-    },
-    toggleSelectAllRows: function() {
-        if (this.areAllRowsSelected()) {
-            this.selectionModel.clear();
-        } else {
-            this.selectAllRows();
-        }
-        this.repaint();
-    },
-    isSingleRowSelectionMode: function() {
-        return this.properties.singleRowSelectionMode;
+    isColumnAutosizing: function() {
+        return this.deprecated('isColumnAutosizing()', 'columnAutosizing', 'v1.2.2', arguments, 'Note however that as of v1.2.2 columnAutosizing grid property no longer has the global meaning it had previously and should no longer be referred to directly. Refer to each column\'s `columnAutosizing` property instead.');
     },
 
     newPoint: function(x, y) {
@@ -3230,295 +2068,125 @@ var Hypergrid = Base.extend('Hypergrid', {
     },
 
     /**
-     * @summary _Getter_
-     * @method
-     * @returns {sorterAPI} The grid's currently assigned sorter.
-     * @memberOf dataModels.JSON.prototype
+     * @summary Get the given data controller.
+     * @param {string} type
+     * @returns {null|undefined|*} The data controller or:
+     * * `null` means unknown data controller.
+     * * `undefined` means the data source handles this data controller but the data controller is undefined.
+     * @memberOf Hypergrid#
      */
-    get sorter() {
-        return this.behavior.sorter;
+    getController: function(type) {
+        return this.behavior.getController(type);
     },
 
     /**
-     * @summary _Setter:_ Assign a sorter to the grid.
-     * @method
-     * @param {sorterAPI|undefined|null} sorter - One of:
-     * * A sorter object, turning sorting *ON*.
-     * * If `undefined` or `null`, the {@link dataModels.JSON~nullSorter|nullSorter} is reassigned to the grid, turning sorting *OFF.*
-     * @memberOf Hypergrid.prototype
-     */
-    set sorter(sorter) {
-        this.behavior.sorter = sorter;
-        this.behaviorChanged();
-    },
-
-    /**
-     * @summary _Getter_
-     * @method
-     * @returns {dataSourceHelperAPI} The grid's currently assigned filter.
-     * @memberOf Hypergrid.prototype
-     */
-    get filter() {
-        return this.behavior.filter;
-    },
-
-    /**
-     * @summary _Setter:_ Set a grid instance's filter.
-     * @desc Requires a filter data source be installed in the transformation pipeline.
-     * @method
-     * @param {dataSourceHelperAPI|undefined|null} filter - One of:
-     * * A filter object, turning filter *ON*.
-     * * If `undefined` or `null`, the null filter is reassigned to the grid, turning filtering *OFF.*
-     * @memberOf Hypergrid.prototype
-     */
-    set filter(filter) {
-        this.behavior.filter = filter;
-        this.behaviorChanged();
-    },
-
-    /**
-     * @summary Sticky hash of dialog options objects.
-     * @desc Each key is a dialog name; the value is the options object for that dialog.
-     * The default dialog options object has the key `'undefined'`, which is undefined by default; it is set by calling `setDialogOptions` with no `dialogName` parameter.
-     * @private
-     */
-    dialogOptions: {},
-
-    /**
-     * @summary Set and/or return a specific dialog options object *or* a default dialog options object.
+     * @summary Set the given data controller(s).
+     * @desc The data model needs to be able to accept the specified data controller type(s). If it fails to accept the specified data controller(s), an error condition is raised.
      *
-     * @desc If `options` defined:
-     * * If `dialogName` defined: Save the specific dialog's options object.
-     * * If `dialogName` undefined: Save the default dialog options object.
+     * (To ignore the error, place the call in a `try...catch`. From there you could call {@link Base#notify|notify} to report it as a warning or an alert instead.)
      *
-     * If `options` is _not_ defined, no new dialog options object will be saved; but a previously saved preset will be returned (after mixing in the default preset if there is one).
-     *
-     * The default dialog options object is used in two ways:
-     * * when a dialog has no options object
-     * * as a mix-in base when a dialog does have an options object
-     *
-     * @param {string} [dialogName] If undefined, `options` defines the default dialog options object.
-     *
-     * @param {object} [options] If defined, preset the named dialog options object or the default dialog options object if name is undefined.
-     *
-     * @returns {object} One of:
-     * * When `options` undefined, first of:
-     *   * previous preset
-     *   * default preset
-     *   * empty object
-     * * When `options` defined, first of:
-     *   * mix-in: default preset members + `options` members
-     *   * `options` verbatim when default preset undefined
-     */
-    setDialogOptions: function(dialogName, options) {
-        if (typeof dialogName === 'object') {
-            options = dialogName;
-            dialogName = undefined;
-        }
-        var defaultOptions = this.dialogOptions.undefined;
-        options = options || dialogName && this.dialogOptions[dialogName];
-        if (options) {
-            this.dialogOptions[dialogName] = options;
-            if (defaultOptions) {
-                options = _({}).extend(defaultOptions, options); // make a mix-in
-            }
-        } else {
-            options = defaultOptions || {};
+     * Setting data controller(s) triggers a shape change.
+     * @param {string} typeOrHashOfTypes - One of:
+     * * **object** - Hash of multiple data controllers, by type.
+     * * **string** - Type of the single data controller given in `controller`.
+     * @param {dataControlInterface} [controller] - Only required when 'hash' is a string; omit when `hash` is an object.
+     * @returns {object} - Hash of all results, by type. Each member will be:
+     * * The given data controller for that type when defined.
+     * * A new "null" data controller, generated by the data model when the given data controller for that type was `undefined`.
+     * * `undefined` - The data controller was unknown to the data model.
+     * @memberOf Hypergrid#
+     */
+    setController: function(typeOrHashOfTypes, controller) {
+        var results = this.behavior.setController(typeOrHashOfTypes, controller),
+            rejections = Object.keys(results).filter(function(name) {
+                return !results[name];
+            }).toString();
+
+        if (rejections) {
+            throw 'Unexpected data controller(s): ' + rejections;
         }
-        return options;
+
+        return results;
     },
 
-    /**
-     * Options objects are remembered for subsequent use. Alternatively, they can be preset by calling {@link Hypergrid#setDialogOptions|setDialogOptions}.
-     * @param {string} dialogName
-     * @param {object} [options] - If omitted, use the options object previously given here (or to {@link Hypergrid#setDialogOptions|setDialogOptions}), if any. In any case, the resultant options object, if any, is mixed into the default options object, if there is one.
-     */
-    openDialog: function(dialogName, options) {
-        if (!this.abortEditing()) { return; }
-        options = this.setDialogOptions(dialogName, options);
-        options.terminate = function() { // when about-to-be-opened dialog is eventually closed
-            delete this.dialog;
-        }.bind(this);
-        this.dialog = this.behavior.openDialog(dialogName, options);
+    prop: function(type, columnIndex, keyOrHash, value) {
+        return this.behavior.prop.apply(this.behavior, arguments);
     },
 
-    // although you can have multiple dialogs open at the same time, the following enforces one at a time (for now)
-    toggleDialog: function(newDialogName, options) {
-        var dialog = this.dialog,
-            oldDialogName = dialog && dialog.$$CLASS_NAME;
-        if (!dialog || !this.dialog.close() && oldDialogName !== newDialogName) {
-            if (!dialog) {
-                // open new dialog now
-                this.openDialog(newDialogName, options);
-            } else {
-                // open new dialog when already-opened dialog finishes closing due to .closeDialog() above
-                dialog.terminate = this.openDialog.bind(this, newDialogName, options);
-            }
-        }
+    get charMap() {
+        return this.behavior.charMap;
     }
 });
 
+var VAR = '.var.';
+function hasVar(descriptor) {
+    return (
+        descriptor.get && descriptor.get.toString().indexOf(VAR) >= 0 ||
+        descriptor.set && descriptor.set.toString().indexOf(VAR) >= 0
+    );
+}
+/**
+ * Creates an instance variable backer for use by the getters and setters in {@link dynamicProperties}.
+ * @constructor
+ * @memberOf Hypergrid~
+ * @private
+ */
+function Var() {
+    Object.getOwnPropertyNames(dynamicProperties).forEach(function(name) {
+        if (hasVar(Object.getOwnPropertyDescriptor(dynamicProperties, name))) {
+            this[name] = defaults[name];
+        }
+    }, this);
+}
+
 function findOrCreateContainer(boundingRect) {
     var div = document.getElementById('hypergrid'),
         used = div && !div.firstElementChild;
 
     if (!used) {
         div = document.createElement('div');
-
-        if (boundingRect) {
-            ['width', 'height', 'position', 'top', 'bottom', 'left', 'right'].forEach(function(style) {
-                if (boundingRect[style]) {
-                    div.style[style] = boundingRect[style];
-                }
-            });
-        }
-
+        setStyles(div, boundingRect, RECT_STYLES);
         document.body.appendChild(div);
     }
 
     return div;
 }
 
-
-/**
- * @summary Update deep properties with new values.
- * @desc This function is a recursive property setter which updates a deep property in a destination object with the value of a congruent property in a source object.
- *
- * > Terminology: A deep property is a "terminal node" (primitive value) nested at some depth (i.e., depth > 1) inside a complex object (an object containing nested objects). A congruent property is a property in another object with the same name and at the same level of nesting.
- *
- * This function is simple and elegant. I recommend you study the code, which nonetheless implies all of the following:
- *
- * * If the deep property is _not_ found in `destination`, it will be created.
- * * If the deep property is found in `destination` _and_ is a primitive type, it will be modified (overwritten with the value from `source`).
- * * If the deep property is found in `destination` _but_ is not a primitive type (i.e., is a nested object), it will _also_ be overwritten with the (primitive) value from `source`.
- * * If the nested object the deep property inhabits in `source` is not found in `destination`, it will be created.
- * * If the nested object the deep property inhabits in `source` is found in `destination` but is not in fact an object (i.e., it is a primitive value), it will be overwritten with a reference to that object.
- * * If the primitive value is `undefined`, the destination property is deleted.
- * * `source` may contain multiple properties to update.
- *
- * That one rule is simply this: If both the source _and_ the destination properties are objects, then recurse; else overwrite the destination property with the source property.
- *
- * > Caveat: This is _not_ equivalent to a deep extend function. While both a deep extend and this function will recurse over a complex object, they are fundamentally different: A deep extend clones the nested objects as it finds them; this function merely updates them (or creates them where they don't exist).
- *
- * @param {object} destination - An object to update with new or modified property values
- * @param {object} source - A congruent object continaly (only) the new or modified property values.
- * @returns {object} Always returns `destination`.
- */
-function addDeepProperties(destination, source) {
-    _(source).each(function(property, key) {
-        if (typeof destination[key] === 'object' && typeof property === 'object') {
-            addDeepProperties(destination[key], property);
-        } else if (property === undefined) {
-            delete destination[key];
-        } else {
-            destination[key] = property;
-        }
-    });
-    return destination;
-}
-
-function normalizeRect(rect) {
-    var o = rect.origin,
-        c = rect.corner,
-
-        ox = Math.min(o.x, c.x),
-        oy = Math.min(o.y, c.y),
-
-        cx = Math.max(o.x, c.x),
-        cy = Math.max(o.y, c.y);
-
-    return new Rectangle(ox, oy, cx - ox, cy - oy);
-}
-
-function buildTheme(theme) {
-    clearObjectProperties(theme);
-    var pb = document.createElement('paper-button'); // styles were based on old polymer theme
-
-    pb.style.display = 'none';
-    pb.setAttribute('disabled', true);
-    document.body.appendChild(pb);
-    var p = window.getComputedStyle(pb);
-
-    var section = document.createElement('section');
-    section.style.display = 'none';
-    section.setAttribute('hero', true);
-    document.body.appendChild(section);
-
-    var h = window.getComputedStyle(document.querySelector('html'));
-    var hb = window.getComputedStyle(document.querySelector('html, body'));
-    var s = window.getComputedStyle(section);
-
-    theme.columnHeaderBackgroundColor = p.color;
-    theme.rowHeaderBackgroundColor = p.color;
-    theme.topLeftBackgroundColor = p.color;
-    theme.lineColor = p.backgroundColor;
-
-    theme.backgroundColor2 = hb.backgroundColor;
-
-    theme.color = h.color;
-    theme.fontFamily = h.fontFamily;
-    theme.backgroundColor = s.backgroundColor;
-
-    pb.setAttribute('disabled', false);
-    pb.setAttribute('secondary', true);
-    pb.setAttribute('raised', true);
-    p = window.getComputedStyle(pb);
-
-    theme.columnHeaderColor = p.color;
-    theme.rowHeaderColor = p.color;
-    theme.topLeftColor = p.color;
-
-
-    theme.backgroundSelectionColor = p.backgroundColor;
-    theme.foregroundSelectionColor = p.color;
-
-    pb.setAttribute('secondary', false);
-    pb.setAttribute('warning', true);
-
-    theme.columnHeaderForegroundSelectionColor = p.color;
-    theme.columnHeaderBackgroundSelectionColor = p.backgroundColor;
-    theme.rowHeaderForegroundSelectionColor = p.color;
-    theme.fixedColumnBackgroundSelectionColor = p.backgroundColor;
-
-    //check if there is actually a theme loaded if not, clear out all bogus values
-    //from my cache
-    if (theme.columnHeaderBackgroundSelectionColor === 'rgba(0, 0, 0, 0)' ||
-        theme.lineColor === 'transparent') {
-        clearObjectProperties(theme);
+function setStyles(el, style, keys) {
+    if (style) {
+        var elStyle = el.style;
+        keys.forEach(function(key) {
+            if (style[key] !== undefined) {
+                elStyle[key] = style[key];
+            }
+        });
     }
+}
 
-    document.body.removeChild(pb);
-    document.body.removeChild(section);
+function headerFormatter(value, config) {
+    var colIndex = config.dataCell.x,
+        sortString = this.behavior.dataModel.getSortImageForColumn(colIndex);
 
-    return theme;
-}
+    if (sortString) {
+        var groups = value.lastIndexOf(this.behavior.groupHeaderDelimiter) + 1;
 
-function clearObjectProperties(obj) {
-    for (var prop in obj) {
-        if (obj.hasOwnProperty(prop)) {
-            delete obj[prop];
+        // if grouped header, prepend group headers to sort direction indicator
+        if (groups) {
+            sortString = value.substr(0, groups) + sortString;
+            value = value.substr(groups);
         }
-    }
-}
 
-/**
- * @this {dataRowObject}
- * @param column
- * @returns {string}
- */
-function valOrFunc(column) {
-    var result, calculator;
-    if (this) {
-        result = this[column.name];
-        calculator = (typeof result)[0] === 'f' && result || column.calculator;
-        if (calculator) {
-            result = calculator.call(this, column.name);
-        }
+        // prepend sort direction indicator to column header
+        value = sortString + value;
     }
-    return result || result === 0 || result === false ? result : '';
+
+    return value;
 }
 
 /**
+ * @name plugins
+ * @memberOf Hypergrid
+ * @type {object}
  * @summary Hash of references to shared plug-ins.
  * @desc Dictionary of shared (pre-installed) plug-ins. Used internally, primarily to avoid reinstallations. See examples for how to reference (albeit there is normally no need to reference plugins directly).
  *
@@ -3535,22 +2203,31 @@ function valOrFunc(column) {
  * @example
  * var allSharedPlugins = Hypergrid.plugins;
  * var mySharedPlugin = Hypergrid.plugins.mySharedPlugin;
- * @type {object}
  */
 Hypergrid.plugins = {};
 
 /**
+ * @name localization
+ * @memberOf Hypergrid
+ * @type {object}
  * @summary Shared localization defaults for all grid instances.
  * @desc These property values are overridden by those supplied in the `Hypergrid` constructor's `options.localization`.
  * @property {string|string[]} [locale] - The default locale to use when an explicit `locale` is omitted from localizer constructor calls. Passed to Intl.NumberFormat` and `Intl.DateFormat`. See {@ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Locale identification and negotiation} for more information. Omitting will use the runtime's local language and region.
  * @property {object} [numberOptions] - Options passed to `Intl.NumberFormat` for creating the basic "number" localizer.
  * @property {object} [dateOptions] - Options passed to `Intl.DateFormat` for creating the basic "date" localizer.
- * @type {object}
  */
-
 Hypergrid.localization = {
     locale: 'en-US',
     numberOptions: { maximumFractionDigits: 0 }
 };
 
+
+Hypergrid.prototype.setController.onerror = 'warn';
+
+Hypergrid.prototype.mixIn(require('./lib/events'));
+Hypergrid.prototype.mixIn(require('./lib/selection'));
+
+Hypergrid.defaults = Hypergrid.properties = defaults;
+
+
 module.exports = Hypergrid;
diff --git a/src/Shared.js b/src/Shared.js
deleted file mode 100644
index 98b8600..0000000
--- a/src/Shared.js
+++ /dev/null
@@ -1,12 +0,0 @@
-/* eslint-env browser */
-
-'use strict';
-
-// Only 1 choice from each block below should be exposed (uncommented):
-
-module.exports = {
-
-	analytics: require('hyper-analytics'), // npm
-    // analytics: require('../../hyper-analytics'), // developer
-
-};
diff --git a/src/behaviors/Behavior.js b/src/behaviors/Behavior.js
index f9128c0..f036611 100644
--- a/src/behaviors/Behavior.js
+++ b/src/behaviors/Behavior.js
@@ -1,18 +1,10 @@
-/* eslint-env browser */
-
 'use strict';
 
-var _ = require('object-iterators');
 var Point = require('rectangular').Point;
 
 var Base = require('../Base');
 var Column = require('./Column');
 var cellEventFactory = require('./../lib/cellEventFactory');
-var HeaderSubgrid = require('../dataModels/HeaderSubgrid');
-var FilterSubgrid = require('../dataModels/FilterSubgrid');
-var SummarySubgrid = require('../dataModels/SummarySubgrid');
-var dialogs = require('../dialogs');
-
 var noExportProperties = [
     'columnHeader',
     'columnHeaderColumnSelection',
@@ -24,8 +16,6 @@ var noExportProperties = [
     'treeColumnPropertiesColumnSelection',
 ];
 
-var warned = {};
-
 /**
  * @constructor
  * @abstract
@@ -39,12 +29,12 @@ var Behavior = Base.extend('Behavior', {
      * @param {Hypergrid} grid
      * @param {object} [options] - _(See {@link behaviors.JSON#setData} for additional options.)_
      * @param {DataModels[]} [options.subgrids]
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      */
     initialize: function(grid, options) {
         /**
          * @type {Hypergrid}
-         * @memberOf Behavior.prototype
+         * @memberOf Behavior#
          */
         this.grid = grid;
 
@@ -57,7 +47,7 @@ var Behavior = Base.extend('Behavior', {
     /**
      * @desc create the feature chain - this is the [chain of responsibility](http://c2.com/cgi/wiki?ChainOfResponsibilityPattern) pattern.
      * @param {Hypergrid} grid
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      */
     initializeFeatureChain: function(grid) {
         var self = this;
@@ -66,7 +56,7 @@ var Behavior = Base.extend('Behavior', {
          * @summary Hash of feature class names.
          * @desc Built here but otherwise not in use.
          * @type {object}
-         * @memberOf Behavior.prototype
+         * @memberOf Behavior#
          */
         this.featureMap = {};
 
@@ -80,7 +70,7 @@ var Behavior = Base.extend('Behavior', {
                  * @summary Controller chain of command.
                  * @desc Each feature is linked to the next feature.
                  * @type {Feature}
-                 * @memberOf Behavior.prototype
+                 * @memberOf Behavior#
                  */
                 self.featureChain = newFeature;
             }
@@ -92,35 +82,45 @@ var Behavior = Base.extend('Behavior', {
 
     features: [], // override in implementing class unless no features
 
+    /**
+     * @param {object} [options]
+     * @param {object} [options.pipeline] - Consumed by {@link dataModels.JSON#reset}.
+     *
+     * If omitted, previously established pipeline is reused.
+     * @param {object} [options.controllers] - Consumed by {@link dataModels.JSON#reset}.
+     *
+     * If omitted, previously established controllers list is reused.
+     * @memberOf Behavior#
+     */
     reset: function(options) {
-        this.clearState();
-
         if (this.dataModel) {
-            this.dataModel.reset();
+            options = options || {};
+            this.dataModel.reset({
+                pipeline: options.pipeline,
+                controllers: options.controllers
+            });
         } else {
             /**
-             * @type {DataModel}
-             * @memberOf Behavior.prototype
+             * @type {dataModelAPI}
+             * @memberOf Behavior#
              */
             this.dataModel = this.getNewDataModel(options);
-        }
 
-        // recreate `CellEvent` class so it can set up its internal `grid`, `behavior`, and `dataModel` convenience properties
-        this.CellEvent = cellEventFactory(this.grid);
+            // recreate `CellEvent` class so it can set up its internal `grid`, `behavior`, and `dataModel` convenience properties
+            this.CellEvent = cellEventFactory(this.grid);
+        }
 
-        this.dataUpdates = {}; //for overriding with edit values;
         this.scrollPositionX = this.scrollPositionY = 0;
+
         this.clearColumns();
-        this.clearState();
         this.createColumns();
 
-        this.subgrids = options.subgrids || [
-            HeaderSubgrid,
-            FilterSubgrid,
-            [SummarySubgrid, { name: 'topTotals' }],
-            this.dataModel,
-            [SummarySubgrid, { name: 'bottomTotals' }]
-        ];
+        /**
+         * Ordered list of subgrids to render.
+         * @type {subgridSpec[]}
+         * @memberOf Hypergrid#
+         */
+        this.subgrids = options.subgrids || this.subgrids || this.defaultSubgridSpecs;
     },
 
     get renderedColumnCount() {
@@ -134,13 +134,13 @@ var Behavior = Base.extend('Behavior', {
     clearColumns: function() {
         /**
          * @type {Column[]}
-         * @memberOf Behavior.prototype
+         * @memberOf Behavior#
          */
         this.columns = [];
 
         /**
          * @type {Column[]}
-         * @memberOf Behavior.prototype
+         * @memberOf Behavior#
          */
         this.allColumns = [];
 
@@ -158,6 +158,7 @@ var Behavior = Base.extend('Behavior', {
      * The "grid index" given a "data index" (or column object)
      * @param {Column|number} columnOrIndex
      * @returns {undefined|number} The grid index of the column or undefined if column not in grid.
+     * @memberOf Hypergrid#
      */
     getActiveColumnIndex: function(columnOrIndex) {
         var index = columnOrIndex instanceof Column ? columnOrIndex.index : columnOrIndex;
@@ -197,6 +198,8 @@ var Behavior = Base.extend('Behavior', {
     },
 
     createColumns: function() {
+        this.clearColumns();
+        this.clearAllCellProperties();
         //concrete implementation here
     },
 
@@ -209,14 +212,17 @@ var Behavior = Base.extend('Behavior', {
         return width;
     },
 
-    setColumnWidth: function(x, width) {
-        this.getActiveColumn(x).setWidth(width);
+    /**
+     * @param {Column|number} columnOrIndex - The column or active column index.
+     * @param width
+     * @memberOf Hypergrid#
+     */
+    setColumnWidth: function(columnOrIndex, width) {
+        var column = columnOrIndex >= -2 ? this.getActiveColumn(columnOrIndex) : columnOrIndex;
+        column.setWidth(width);
         this.stateChanged();
     },
 
-    getCellRenderer: function(config, cellEvent) {
-        return cellEvent.column.getCellRenderer(config, cellEvent);
-    },
     getCellProvider: function(name) {
         return this.deprecated('getCellProvider()', 'grid.cellRenderers', '1.0.6', arguments);
     },
@@ -225,16 +231,15 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @deprecated
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      */
-    applyAnalytics: function() {
+    reindex: function() {
         this.dataModel.reindex();
         this.shapeChanged();
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc utility function to empty an object of its members
      * @param {object} obj - the object to empty
      * @param {boolean} [exportProps]
@@ -257,12 +262,12 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc getter for a [Memento](http://c2.com/cgi/wiki?MementoPattern) Object
      * @returns {object}
      */
     getPrivateState: function() {
-        return this.deprecate('getPrivateState()', 'grid.properties', '1.2.0');
+        return this.deprecated('getPrivateState()', 'grid.properties', '1.2.0');
     },
 
     //this is effectively a clone, with certain things removed....
@@ -272,35 +277,15 @@ var Behavior = Base.extend('Behavior', {
         return copy;
     },
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc clear all table state
      */
     clearState: function() {
-        /**
-         * memento for the user configured visual properties of the table
-         * @type {object}
-         * @memberOf Behavior.prototype
-         */
-        this.grid.properties = this.getDefaultState();
+       this.grid.clearState();
     },
 
     /**
-     * @memberOf Behavior.prototype
-     * @return {object} Newly created default empty tablestate.
-     */
-    getDefaultState: function() {
-        var tableProperties = this.grid._getProperties();
-        var state = Object.create(tableProperties);
-
-        _(state).extendOwn({
-            columnProperties: []
-        });
-
-        return state;
-    },
-
-    /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc Restore this table to a previous state.
      * See the [memento pattern](http://c2.com/cgi/wiki?MementoPattern).
      * @param {Object} memento - an encapsulated representation of table state
@@ -308,45 +293,32 @@ var Behavior = Base.extend('Behavior', {
     setState: function(memento) {
 
         if (memento.rowHeights) {
-            if (!warned.rowHeights) {
-                warned.rowHeights = true;
-                console.warn('rowHeights, the hash of row heights you provided to setState method, is no longer supported as of v1.2.0 and will be ignored. Instead use individual calls to setRowHeight(y, height, dataModel) for each row height you wish to set, where y is local zero-based row index within dataModel. The dataModel arg is optional and defaults to this.dataModel; specify to set row heights in other data models, such as header row, filter cell row, individual summary rows, etc.');
-            }
+            this.deprecated('rowHeights', 'rowHeights, the hash of row heights you provided to setState method, is no longer supported as of v1.2.0 and will be ignored. Instead use individual calls to setRowHeight(y, height, dataModel) for each row height you wish to set, where y is local zero-based row index within dataModel. The dataModel arg is optional and defaults to this.dataModel; specify to set row heights in other data models, such as header row, filter cell row, individual summary rows, etc.');
         }
 
-        //we don't want to clobber the column properties completely
-        if (!memento.columnIndexes) {
-            var length = this.dataModel.schema.length;
-            memento.columnIndexes = [];
-            for (var i = 0; i < length; i++) {
-                memento.columnIndexes[i] = i;
+        this.createColumns();
+
+        var state = this.grid.properties;
+        for (var key in memento) {
+            if (memento.hasOwnProperty(key)) {
+                state[key] = memento[key];
             }
         }
-        var colProperties = memento.columnProperties;
-        delete memento.columnProperties;
-        this.clearState();
-        var state = this.grid.properties;
-        this.createColumns();
-        this._setColumnOrder(memento.columnIndexes);
-        _(state).extendOwn(memento);
-        this.setAllColumnProperties(colProperties);
-        memento.columnProperties = colProperties;
 
-        //just to be close/ it's easier on the eyes
-        this.setColumnWidth(-1, 24.193359375);
+        this.setAllColumnProperties(memento.columnProperties);
+
         this.dataModel.reindex();
     },
 
-    setAllColumnProperties: function(properties) {
-        properties = properties || [];
-        for (var i = 0; i < properties.length; i++) {
-            var current = this.grid.properties.columnProperties[i];
-            this.clearObjectProperties(current, false);
-            _(current).extendOwn(properties[i]);
+    setAllColumnProperties: function(columnProperties) {
+        if (columnProperties) {
+            columnProperties.forEach(function(properties, i) {
+                this.getColumn(i).properties = properties;
+            }, this);
         }
     },
 
-    _setColumnOrder: function(columnIndexes) {
+    setColumnOrder: function(columnIndexes) {
         if (Array.isArray(columnIndexes)){
             this.columns.length = columnIndexes.length;
             columnIndexes.forEach(function(index, i) {
@@ -355,17 +327,18 @@ var Behavior = Base.extend('Behavior', {
         }
     },
 
+    _setColumnOrder: function(columnIndexes) {
+        this.deprecated('_setColumnOrder(columnIndexes)', 'setColumnOrder(columnIndexes)', '1.2.10', arguments);
+    },
+
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc Rebuild the column order indexes
      * @param {Array} columnIndexes - list of column indexes
      * @param {Boolean} [silent=false] - whether to trigger column changed event
      */
     setColumnIndexes: function(columnIndexes, silent) {
-        var tableState = this.grid.properties;
-        this._setColumnOrder(columnIndexes);
-        tableState.columnIndexes = columnIndexes;
-        this.changed();
+        this.grid.properties.columnIndexes = columnIndexes;
         if (!silent) {
             this.grid.fireSyntheticOnColumnsChangedEvent();
         }
@@ -394,7 +367,7 @@ var Behavior = Base.extend('Behavior', {
      *
      * _Promoted left one arg position when `isActiveColumnIndexes` omitted + one position when `referenceIndex` omitted._
      *
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      */
     showColumns: function(isActiveColumnIndexes, columnIndexes, referenceIndex, allowDuplicateColumns) {
         // Promote args when isActiveColumnIndexes omitted
@@ -457,7 +430,7 @@ var Behavior = Base.extend('Behavior', {
      * * **Array of column indexes** - Adds multiple consecutive columns at insertion point.
      *
      * _This required parameter is promoted left one arg position when `isActiveColumnIndexes` omitted._
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      */
     hideColumns: function(isActiveColumnIndexes, columnIndexes) {
         var args = Array.prototype.slice.call(arguments); // Convert to array so we can add an argument (element)
@@ -466,7 +439,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc fetch the value for a property key
      * @returns {*} The value of the given property.
      * @param {string} key - a property name
@@ -477,7 +450,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc A specific cell was clicked; you've been notified.
      * @param {Object} event - all event information
      * @return {boolean} Clicked in a drill-down column.
@@ -490,7 +463,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc A specific cell was le double-clicked; you've been notified.
      * @param {Point} cell - point of cell coordinates
      * @param {Object} event - all event information
@@ -506,7 +479,7 @@ var Behavior = Base.extend('Behavior', {
     /**
      * @param {CellEvent|number} xOrCellEvent - Grid column coordinate.
      * @param {number} [y] - Grid row coordinate. Omit if `xOrCellEvent` is a CellEvent.
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      */
     getValue: function(xOrCellEvent, y) {
         switch (arguments.length) {
@@ -517,13 +490,21 @@ var Behavior = Base.extend('Behavior', {
         }
     },
 
+    /**
+     * @summary Gets the number of rows in the data subgrid.
+     * @memberOf Behavior.prototype
+     */
+    getRowCount: function() {
+        return this.dataModel.getRowCount();
+    },
+
     getUnfilteredValue: function(x, y) {
         var column = this.getActiveColumn(x);
         return column && column.getUnfilteredValue(y);
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc update the data at point x, y with value
      * @return The data.
      * @param {CellEvent|number} xOrCellEvent - Grid column coordinate.
@@ -541,7 +522,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     getDataValue: function(x, y) {
-        return this.deprecated('getDataValue(x, y, value)', 'dataModel.getValue(x, y, value)', '1.1.0', arguments);
+        return this.deprecated('getDataValue(x, y)', 'dataModel.getValue(x, y)', '1.1.0', arguments);
     },
 
     setDataValue: function(x, y, value) {
@@ -554,7 +535,7 @@ var Behavior = Base.extend('Behavior', {
      * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
      * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
      * @returns {undefined|object} The "own" properties of the cell at x,y in the grid. If the cell does not own a properties object, returns `undefined`.
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      */
     getCellOwnProperties: function(xOrCellEvent, y) {
         switch (arguments.length) {
@@ -575,13 +556,12 @@ var Behavior = Base.extend('Behavior', {
      * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
      * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
      * @return {object} The properties of the cell at x,y in the grid.
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      */
     getCellProperties: function(xOrCellEvent, y) {
         switch (arguments.length) {
             case 1:
-                return xOrCellEvent.column // xOrCellEvent is cellEvent
-                    .getCellProperties(xOrCellEvent.dataCell.y, xOrCellEvent.visibleRow.subgrid);
+                return xOrCellEvent.properties; // xOrCellEvent is cellEvent
             case 2:
                 return this.getColumn(xOrCellEvent) // xOrCellEvent is x
                     .getCellProperties(y);
@@ -595,13 +575,12 @@ var Behavior = Base.extend('Behavior', {
      * @param {number} [y] - Grid row coordinate._ Omit when `xOrCellEvent` is a `CellEvent`._
      * @param {string} key - Name of property to get. _When `y` omitted, this param promoted to 2nd arg._
      * @return {object} The specified property for the cell at x,y in the grid.
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      */
     getCellProperty: function(xOrCellEvent, y, key) {
         switch (arguments.length) {
             case 2:
-                return xOrCellEvent.column // xOrCellEvent is cellEvent
-                    .getCellProperty(xOrCellEvent.dataCell.y, y, xOrCellEvent.visibleRow.subgrid); // y omitted so y here is actually key
+                return xOrCellEvent.properties[y]; // xOrCellEvent is cellEvent and y omitted so y here is actually key
             case 3:
                 return this.getColumn(xOrCellEvent) // xOrCellEvent is x
                     .getCellProperty(y, key);
@@ -609,7 +588,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc update the data at point x, y with value
      * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
      * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
@@ -626,7 +605,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc update the data at point x, y with value
      * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
      * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
@@ -645,32 +624,33 @@ var Behavior = Base.extend('Behavior', {
     /**
      * @summary Set a specific cell property.
      * @desc If there is no cell properties object, defers to column properties object.
-     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
+     *
+     * NOTE: For performance reasons, renderer's cell event objects cache their respective cell properties objects. This method accepts a `CellEvent` overload. Whenever possible, use the `CellEvent` from the renderer's cell event pool. Doing so will reset the cell properties object cache.
+     *
+     * If you use some other `CellEvent`, the renderer's `CellEvent` properties cache will not be automatically reset until the whole cell event pool is reset on the next call to {@link Renderer#computeCellBoundaries}. If necessary, you can "manually" reset it by calling {@link Renderer#resetCellPropertiesCache|resetCellPropertiesCache(yourCellEvent)} which searches the cell event pool for one with matching coordinates and resets the cache.
+     *
+     * The raw coordinates overload calls the `resetCellPropertiesCache(x, y)` overload for you.
+     * @param {CellEvent|number} xOrCellEvent - `CellEvent` or data x coordinate.
      * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
      * @param {string} key - Name of property to get. _When `y` omitted, this param promoted to 2nd arg._
      * @param value
-     * @memberOf Behavior.prototype
+     * @parsam {dataModelAPI} [dataModel=this.subgrids.lookup.data] - For use only when `xOrCellEvent` is _not_ a `CellEvent`: Provide a subgrid.
+     * @memberOf Behavior#
      */
-    setCellProperty: function(xOrCellEvent, y, key, value) {
+    setCellProperty: function(xOrCellEvent, y, key, value, dataModel) {
+        var cellOwnProperties;
         switch (arguments.length) {
             case 3:
-                return xOrCellEvent.column // xOrCellEvent is cellEvent
-                    .setCellProperty(xOrCellEvent.dataCell.y, y, key, xOrCellEvent.visibleRow.subgrid); // y omitted so y here is actually key and key is actually value
+                // xOrCellEvent is cellEvent, y is key, key is value
+                cellOwnProperties = xOrCellEvent.setCellProperty(y, key);
+                break;
             case 4:
-                return this.getColumn(xOrCellEvent) // xOrCellEvent is x
-                    .setCellProperty(y, key, value);
+            case 5:
+                cellOwnProperties = this.getColumn(xOrCellEvent) // xOrCellEvent is x
+                    .setCellProperty(y, key, value, dataModel);
+                this.grid.renderer.resetCellPropertiesCache(xOrCellEvent, y, dataModel);
         }
-    },
-
-    /**
-     * @summary Gets the number of rows in the hypergrid.
-     * @dsc Defined as the sum of all rows from all subgrids.
-     * @memberOf Behavior.prototype
-     */
-    getRowCount: function() {
-        return this.subgrids.reduce(function(sum, subgrid) {
-            return sum + subgrid.getRowCount();
-        }, 0);
+        return cellOwnProperties;
     },
 
     getUnfilteredRowCount: function() {
@@ -678,22 +658,34 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
-     * @return {number} The height in pixels of the fixed rows area  of the hypergrid.
+     * @summary The total height of the "fixed rows."
+     * @desc The total height of all (non-scrollable) rows preceding the (scrollable) data subgrid.
+     * @memberOf Behavior#
+     * @return {number} The height in pixels of the fixed rows area of the hypergrid, the total height of:
+     * 1. All rows of all subgrids preceding the data subgrid.
+     * 2. The first `fixedRowCount` rows of the data subgrid.
      */
     getFixedRowsHeight: function() {
-        var count = this.getFixedRowCount();
-        var total = 0;
-        for (var i = 0; i < count; i++) {
-            total += this.getRowHeight(i);
+        var dataModel, isData, r, R,
+            subgrids = this.subgrids,
+            height = 0;
+
+        for (var i = 0; i < subgrids.length && !isData; ++i) {
+            dataModel = subgrids[i];
+            isData = dataModel.isData;
+            R = isData ? this.grid.properties.fixedRowCount : dataModel.getRowCount();
+            for (r = 0; r < R; ++r) {
+                height += this.getRowHeight(r, dataModel);
+            }
         }
-        return total;
+
+        return height;
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @param {number} rowIndex - Data row coordinate local to datsModel.
-     * @param {DataModel} [dataModel=this.dataModel]
+     * @param {dataModelAPI} [dataModel=this.dataModel]
      */
     getRowHeight: function(rowIndex, dataModel) {
         var rowData = (dataModel || this.dataModel).getRow(rowIndex);
@@ -701,56 +693,44 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc The value is lazily initialized and comes from the properties mechanism for '`defaultRowHeight`', which should be ~20px.
      * @returns {number} The row height in pixels.
      */
     getDefaultRowHeight: function() {
-        return this.deprecated('getDefaultRowHeight', 'grid.properties.defaultRowHeight', '1.2.0');
+        return this.deprecated('getDefaultRowHeight()', 'grid.properties.defaultRowHeight', '1.2.0');
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc set the pixel height of a specific row
      * @param {number} rowIndex - Data row coordinate local to datsModel.
      * @param {number} height - pixel height
-     * @param {DataModel} [dataModel=this.dataModel]
+     * @param {dataModelAPI} [dataModel=this.dataModel]
      */
     setRowHeight: function(rowIndex, height, dataModel) {
         var rowData = (dataModel || this.dataModel).getRow(rowIndex);
         if (rowData) {
-            rowData.__ROW_HEIGHT = Math.max(5, height);
+            rowData.__ROW_HEIGHT = Math.max(5, Math.ceil(height));
             this.stateChanged();
         }
     },
 
     /**
-     * @memberOf Behavior.prototype
-     * @desc This will allow 'floating' fixed rows.
-     * @return {number} The maximum height of the fixed rows area in the hypergrid.
-     */
-    getFixedRowsMaxHeight: function() {
-        return this.getFixedRowsHeight();
-    },
-
-    /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @return {number} The width of the fixed column area in the hypergrid.
      */
     getFixedColumnsWidth: function() {
         var count = this.getFixedColumnCount();
         var total = 0;
-        if (this.grid.isShowRowNumbers()) {
-            total = this.getColumnWidth(-1);
-        }
-        for (var i = 0; i < count; i++) {
+        for (var i = this.grid.properties.showRowNumbers ? -1 : 0; i < count; i++) {
             total += this.getColumnWidth(i);
         }
         return total;
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc This exists to support "floating" columns.
      * @return {number} The total width of the fixed columns area.
      */
@@ -759,7 +739,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc Set the scroll position in vertical dimension and notify listeners.
      * @param {number} y - the new y value
      */
@@ -769,7 +749,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc Set the scroll position in horizontal dimension and notify listeners.
      * @param {number} x - the new x value
      */
@@ -779,7 +759,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc The fixed row area has been clicked, massage the details and call the real function.
      * @param {Hypergrid} grid
      * @param {Object} mouse - event details
@@ -792,7 +772,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc The fixed column area has been clicked, massage the details and call the real function.
      * @param {Hypergrid} grid
      * @param {Object} mouse - event details
@@ -803,15 +783,8 @@ var Behavior = Base.extend('Behavior', {
         this.fixedColumnClicked(grid, mouse);
     },
 
-    moveSingleSelect: function(grid, x, y) {
-        if (this.featureChain) {
-            this.featureChain.moveSingleSelect(grid, x, y);
-            this.setCursor(grid);
-        }
-    },
-
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc delegate setting the cursor up the feature chain of responsibility
      * @param {Hypergrid} grid
      */
@@ -821,7 +794,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc delegate handling mouse move to the feature chain of responsibility
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
@@ -834,7 +807,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc delegate handling tap to the feature chain of responsibility
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
@@ -847,21 +820,20 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc delegate handling tap to the feature chain of responsibility
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
      */
     onContextMenu: function(grid, event) {
-        var proceed = grid.fireSyntheticContextMenuEvent(event);
-        if (proceed && this.featureChain) {
+        if (this.featureChain) {
             this.featureChain.handleContextMenu(grid, event);
             this.setCursor(grid);
         }
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc delegate handling wheel moved to the feature chain of responsibility
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
@@ -874,7 +846,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc delegate handling mouse up to the feature chain of responsibility
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
@@ -887,7 +859,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc delegate handling mouse drag to the feature chain of responsibility
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
@@ -900,7 +872,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc delegate handling key down to the feature chain of responsibility
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
@@ -913,7 +885,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc delegate handling key up to the feature chain of responsibility
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
@@ -926,7 +898,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc delegate handling double click to the feature chain of responsibility
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
@@ -937,19 +909,8 @@ var Behavior = Base.extend('Behavior', {
             this.setCursor(grid);
         }
     },
-
     /**
-     * @memberOf Behavior.prototype
-     * @desc delegate handling double click to the feature chain of responsibility
-     * @param {Hypergrid} grid
-     * @param {string[]} [options] - Forwarded to dialog constructor.
-     */
-    openDialog: function(dialogName, options) {
-        return new dialogs[dialogName](this.grid, options);
-    },
-
-    /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc delegate handling mouse down to the feature chain of responsibility
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
@@ -962,7 +923,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc delegate handling mouse exit to the feature chain of responsibility
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
@@ -975,25 +936,25 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc I've been notified that the behavior has changed.
      */
     changed: function() { this.grid.behaviorChanged(); },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc The dimensions of the grid data have changed. You've been notified.
      */
     shapeChanged: function() { this.grid.behaviorShapeChanged(); },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc The dimensions of the grid data have changed. You've been notified.
      */
     stateChanged: function() { this.grid.behaviorStateChanged(); },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @return {boolean} Can re-order columns.
      */
     isColumnReorderable: function() {
@@ -1003,7 +964,7 @@ var Behavior = Base.extend('Behavior', {
     /**
      * @param {index} x - Data x coordinate.
      * @return {Object} The properties for a specific column.
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      */
     getColumnProperties: function(x) {
         var column = this.getColumn(x);
@@ -1013,14 +974,14 @@ var Behavior = Base.extend('Behavior', {
     /**
      * @param {index} x - Data x coordinate.
      * @return {Object} The properties for a specific column.
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      */
     setColumnProperties: function(x, properties) {
         var column = this.getColumn(x);
         if (!column) {
             throw 'Expected column.';
         }
-        var result = _(column.properties).extendOwn(properties);
+        var result = Object.assign(column.properties, properties);
         this.changed();
         return result;
     },
@@ -1028,23 +989,28 @@ var Behavior = Base.extend('Behavior', {
     /**
      * Clears all cell properties of given column or of all columns.
      * @param {number} [x] - Omit for all columns.
+     * @memberOf Behavior#
      */
     clearAllCellProperties: function(x) {
-        if (x === undefined) {
-            // todo: More efficient might be to undefine `dataModel.getData(*).__META`.
-            for (var i = this.allColumns.length - 1; i >= 0; --i) {
-                this.getColumn(i).clearAllCellProperties();
-            }
-        } else {
-            var column = this.getColumn(i);
+        if (x !== undefined) {
+            var column = this.getColumn(x);
             if (column) {
                 column.clearAllCellProperties();
             }
+        } else if (this.subgrids) {
+            this.subgrids.forEach(function(dataModel) {
+                for (var i = dataModel.getRowCount(); i--;) {
+                    delete dataModel.getRow(i).__META;
+                    // todo: test if optimizer wants following instead
+                    // dataRow = dataModel.getRow(i);
+                    // if (dataRow.__META !== undefined) { dataRow.__META = undefined; }
+                }
+            });
         }
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @return {string[]} All the currently hidden column header labels.
      */
     getHiddenColumnDescriptors: function() {
@@ -1066,15 +1032,15 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
-     * @return {integer} The number of fixed columns.
+     * @memberOf Behavior#
+     * @return {number} The number of fixed columns.
      */
     getFixedColumnCount: function() {
         return this.grid.properties.fixedColumnCount;
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc set the number of fixed columns
      * @param {number} n - the integer count of how many columns to be fixed
      */
@@ -1083,8 +1049,12 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
-     * @return {integer} The number of fixed rows.
+     * @summary The number of "fixed rows."
+     * @desc The number of (non-scrollable) rows preceding the (scrollable) data subgrid.
+     * @memberOf Behavior#
+     * @return {number} The sum of:
+     * 1. All rows of all subgrids preceding the data subgrid.
+     * 2. The first `fixedRowCount` rows of the data subgrid.
      */
     getFixedRowCount: function() {
         return (
@@ -1094,7 +1064,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc Set the number of fixed rows, which includes (top to bottom order):
      * 1. The header rows
      *    1. The header labels row (optional)
@@ -1111,31 +1081,13 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @summary Gets the number of "header rows".
-     * @desc Defined as the sum of all rows of all subgrids before the (first) data subgrid.
-     * @memberOf behaviors.JSON.prototype
-     */
-    getHeaderRowCount: function() {
-        var result = 0;
-
-        this.subgrids.find(function(subgrid) {
-            if (!subgrid.type) {
-                return true; // stop
-            }
-            result += subgrid.getRowCount();
-        });
-
-        return result;
-    },
-
-    /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc a dnd column has just been dropped, we've been notified
      */
     endDragColumnNotification: function() {},
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @return {null} the cursor at a specific x,y coordinate
      * @param {number} x - the x coordinate
      * @param {number} y - the y coordinate
@@ -1146,7 +1098,7 @@ var Behavior = Base.extend('Behavior', {
 
     /**
      * Number of _visible_ columns.
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @return {number} The total number of columns.
      */
     getActiveColumnCount: function() {
@@ -1164,13 +1116,13 @@ var Behavior = Base.extend('Behavior', {
      * * `'right'`
      *
      * Cascades to grid.
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc Quietly set the horizontal scroll position.
      * @param {number} x - The new position in pixels.
      */
     setScrollPositionX: function(x) {
         /**
-         * @memberOf Behavior.prototype
+         * @memberOf Behavior#
          * @type {number}
          */
         this.scrollPositionX = x;
@@ -1181,13 +1133,13 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc Quietly set the vertical scroll position.
      * @param {number} y - The new position in pixels.
      */
     setScrollPositionY: function(y) {
         /**
-         * @memberOf Behavior.prototype
+         * @memberOf Behavior#
          * @type {number}
          */
         this.scrollPositionY = y;
@@ -1198,12 +1150,12 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @return {cellEditor} The cell editor for the cell at the given coordinates.
      * @param {CellEvent} editPoint - The grid cell coordinates.
      */
     getCellEditorAt: function(event) {
-        return event.isGridColumn && (
+        return event.isDataColumn && (
             event.isFilterCell
                 ? this.grid.cellEditors.create('filterbox', event)
                 : event.column.getCellEditorAt(event)
@@ -1211,7 +1163,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @return {boolean} `true` if we should highlight on hover
      * @param {boolean} isColumnHovered - the column is hovered or not
      * @param {boolean} isRowHovered - the row is hovered or not
@@ -1221,7 +1173,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc this function is a hook and is called just before the painting of a cell occurs
      * @param {window.fin.rectangular.Point} cell
      */
@@ -1230,7 +1182,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc this function is a hook and is called just before the painting of a fixed row cell occurs
      * @param {window.fin.rectangular.Point} cell
      */
@@ -1239,7 +1191,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc this function is a hook and is called just before the painting of a fixed column cell occurs
      * @param {window.fin.rectangular.Point} cell
      */
@@ -1248,7 +1200,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc this function is a hook and is called just before the painting of a top left cell occurs
      * @param {window.fin.rectangular.Point} cell
      */
@@ -1257,14 +1209,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
-     * @desc this function enhance the double click event just before it's broadcast to listeners
-     * @param {Object} event - event to enhance
-     */
-    enhanceDoubleClickEvent: function(event) {},
-
-    /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @desc swap src and tar columns
      * @param {number} src - column index
      * @param {number} tar - column index
@@ -1282,7 +1227,7 @@ var Behavior = Base.extend('Behavior', {
     },
 
     /**
-     * @memberOf Behavior.prototype
+     * @memberOf Behavior#
      * @return {object} The object at y index.
      * @param {number} y - the row index of interest
      */
@@ -1314,8 +1259,8 @@ var Behavior = Base.extend('Behavior', {
 
     checkColumnAutosizing: function(force) {
         force = force === true;
-        this.autoSizeRowNumberColumn();
-        var autoSized = this.allColumns[-2].checkColumnAutosizing(force);
+        var autoSized = this.autoSizeRowNumberColumn() ||
+            this.hasHierarchyColumn() && this.allColumns[-2].checkColumnAutosizing(force);
         this.allColumns.forEach(function(column) {
             autoSized = column.checkColumnAutosizing(force) || autoSized;
         });
@@ -1323,53 +1268,73 @@ var Behavior = Base.extend('Behavior', {
     },
 
     autoSizeRowNumberColumn: function() {
-        if (this.grid.isRowNumberAutosizing()) {
-            this.allColumns[-1].checkColumnAutosizing(true);
+        if (this.grid.properties.showRowNumbers && this.grid.properties.rowNumberAutosizing) {
+            return this.allColumns[-1].checkColumnAutosizing(true);
         }
     },
 
     /**
-     * @summary _Getter_
-     * @method
-     * @returns {dataSourceHelperAPI} The grid's currently assigned filter.
-     * @memberOf Behavior.prototype
+     * @summary Get the given data controller.
+     * @param {string} type
+     * @returns {undefined|*} The data controller; or `undefined` if data controller unknown to data model.
+     * @memberOf Behavior#
      */
-    get filter() {
-        return this.dataModel.filter;
+    getController: function(type) {
+        return this.dataModel.getController(type);
     },
 
     /**
-     * @summary _Setter:_ Assign a filter to the grid.
-     * @method
-     * @param {dataSourceHelperAPI|undefined|null} filter - One of:
-     * * A filter object, turning filter *ON*.
-     * * If `undefined` or `null`, the null filter is reassigned to the grid, turning filtering *OFF*.
-     * @memberOf Behavior.prototype
+     * @summary Set the given data controller(s).
+     * @desc Triggers a shape change.
+     * @param {string} typeOrHashOfTypes - One of:
+     * * **object** - Hash of multiple data controllers, by type.
+     * * **string** - Type of the single data controller given in `controller`.
+     * @param {dataControlInterface} [controller] - Only required when 'hash' is a string; omit when `hash` is an object.
+     * @returns {object} - Hash of all results, by type. Each member will be:
+     * * The given data controller for that type when defined.
+     * * A new "null" data controller, generated by the data model when the given data controller for that type was `undefined`.
+     * * `undefined` - The data controller was unknown to the data model..
+     * @memberOf Behavior#
      */
-    set filter(filter) {
-        this.dataModel.filter = filter;
+    setController: function(typeOrHashOfTypes, controller) {
+        var results = this.dataModel.setController(typeOrHashOfTypes, controller);
+        this.changed();
+        return results;
     },
 
-    /**
-     * @summary _Getter_
-     * @method
-     * @returns {sorterAPI} The grid's currently assigned sorter.
-     * @memberOf dataModels.JSON.prototype
-     */
-    get sorter() {
-        return this.dataModel.sorter;
+    prop: function(type, columnIndex, keyOrHash, value) {
+        var result = this.dataModel.prop.apply(this.dataModel, arguments);
+        if (result === undefined) {
+            this.changed();
+        }
+        return result;
     },
 
-    /**
-     * @summary _Setter:_ Assign a sorter to the grid.
-     * @method
-     * @param {sorterAPI|undefined|null} sorter - One of:
-     * * A sorter object, turning sorting *ON*.
-     * * If `undefined` or `null`, the {@link dataModels.JSON~nullSorter|nullSorter} is reassigned to the grid, turning sorting *OFF.*
-     * @memberOf Hypergrid.prototype
-     */
-    set sorter(sorter) {
-        this.dataModel.sorter = sorter;
+    get charMap() {
+        return this.dataModel.charMap;
+    },
+
+    getColumns: function() {
+        return this.allColumns;
+    },
+
+    getActiveColumns: function() {
+        return this.columns;
+    },
+
+    getHiddenColumns: function() {
+        var visible = this.columns;
+        var all = this.allColumns;
+        var hidden = [];
+        for (var i = 0; i < all.length; i++) {
+            if (visible.indexOf(all[i]) === -1) {
+                hidden.push(all[i]);
+            }
+        }
+        hidden.sort(function(a, b) {
+            return a.header < b.header;
+        });
+        return hidden;
     },
 
     getSelectedRows: function() {
@@ -1393,63 +1358,22 @@ var Behavior = Base.extend('Behavior', {
     },
     getIndexedData: function() {
        this.dataModel.getIndexedData();
-    },
-
-    /**
-     * An array where each element represents a subgrid to be rendered in the hypergrid.
-     *
-     * The list should always include at least one "data" subgrid, typically {@link Behavior#dataModel|dataModel}.
-     * It may also include zero or more other types of subgrids such as header, filter, and summary subgrids.
-     *
-     * This object also serves as a dictionary of selected subgrids by name (i.e., for those subgrids that have a defined property `name`).
-     *
-     * The setter:
-     * * "Enlivens" any constructors
-     * * Reconstructs the dictionary
-     * * Calls {@link Behavior#shapeChanged|shpaeChanged()}.
-     *
-     * @type {DataModel[]}
-     * @memberOf Behavior.prototype
-     */
-    set subgrids(subgrids) {
-        this._subgrids = subgrids = subgrids.map(enlivenSubgrids, this);
-
-        subgrids.forEach(function(subgrid) {
-            subgrids[subgrid.name || subgrid.type || 'data'] = subgrid;
-        });
-
-        this.shapeChanged();
-    },
-    get subgrids() {
-        return this._subgrids;
     }
 });
 
-/**
- *
- * @param {DataModel|Array|function|undefined|null} [subgridSpec] - One of:
- * * `DataModel` - Mapped to self (passed through as is).
- * * `Array` - Mapped to newly instantiated data model: First element is assumed to be a `DataModel` constructor to be called with `new` keyword and `this.grid` as first arg and remaining elements as additional args.
- * * function - Mapped to newly instantiated data model: A `DataModel` constructor to be called with `new` keyword and `this.grid` as only arg.
- * * Falsy value - Mapped to the behavior's data model (`this.dataModel`).
- * @returns {DataModel}
- */
-function enlivenSubgrids(dataModel) {
-    if (!dataModel) {
-        dataModel = this.dataModel;
-    } else if (dataModel instanceof Array && dataModel.length) {
-        var Constructor = dataModel[0],
-            args = dataModel.slice(1);
-        dataModel = new (Function.prototype.bind.apply(Constructor, [null, this.grid].concat(args)));
-    } else if (typeof dataModel === 'function') {
-        dataModel = new dataModel(this.grid); // eslint-disable-line new-cap
-    }
-    return dataModel;
-}
+// synonyms
 
 /**
- * @memberOf Behavior.prototype
+ * Synonym of {@link Behavior#reindex}.
+ * @name applyAnalytics
+ * @deprecated
+ * @memberOf Behavior#
  */
-Behavior.prototype.reindex = Behavior.prototype.applyAnalytics;
+Behavior.prototype.applyAnalytics = Behavior.prototype.reindex;
+
+
+// mix-ins
+Behavior.prototype.mixIn(require('./subgrids'));
+
 
 module.exports = Behavior;
diff --git a/src/behaviors/Column.js b/src/behaviors/Column.js
index fafdf30..a230d62 100644
--- a/src/behaviors/Column.js
+++ b/src/behaviors/Column.js
@@ -6,8 +6,7 @@ var overrider = require('overrider');
 
 var deprecated = require('../lib/deprecated');
 var HypergridError = require('../lib/error');
-
-var warned = {};
+var images = require('../../images/index');
 
 /** @summary Create a new `Column` object.
  * @see {@link module:Cell} is mixed into Column.prototype.
@@ -26,24 +25,25 @@ var warned = {};
  *    -1   | Row header column
  *    -2   | Tree (drill-down) column
  */
-function Column(behavior, options) {
-    var index, schema;
+function Column(behavior, indexOrOptions) {
+    var index, schema, options;
 
     this.behavior = behavior;
     this.dataModel = behavior.dataModel;
 
     schema = this.behavior.dataModel.schema;
 
-    switch (typeof options) {
+    switch (typeof indexOrOptions) {
         case 'number':
-            index = options;
+            index = indexOrOptions;
             options = {};
             break;
         case 'string':
-            index = getIndexFromName(options);
+            index = getIndexFromName(indexOrOptions);
             options = {};
             break;
         case 'object':
+            options = indexOrOptions;
             index = options.index !== undefined
                 ? options.index
                 : getIndexFromName(options.name);
@@ -61,29 +61,33 @@ function Column(behavior, options) {
 
     this._index = index;
 
-    this.clearAllCellProperties();
+    this.properties = options;
 
     switch (index) {
         case -1:
+            // Width of icon + 3-pixel spacer (checked and unchecked should be same width)
+            var icon = images[Object.create(this.properties.rowHeader, { isDataRow: { value: true } }).leftIcon];
+            this.properties.minimumColumnWidth = icon ? icon.width + 3 : 0;
+            break;
         case -2:
+            // This case avoids the "out of range" error.
             break;
         default:
             if (index < 0) {
                 throw '`index` out of range';
-            } else {
-                this.properties = options;
             }
     }
 }
 
 Column.prototype = {
     constructor: Column.prototype.constructor,
+    $$CLASS_NAME: 'Column',
+    deprecated: deprecated,
 
     HypergridError: HypergridError,
 
     mixIn: overrider.mixIn,
 
-    deprecated: deprecated,
     set: function(options) {
         return this.deprecated('set(options)', 'setProperties(options)', '1.2.0', arguments);
     },
@@ -98,10 +102,11 @@ Column.prototype = {
 
     /**
      * @summary Name of this column from the `fields` array.
-     * @returns {string}
+     * @returns {string|undefined} Returns `undefined` if the column is not in the schema (such as for handle column).
      */
     get name() { // read-only (no setter)
-        return this.dataModel.schema[this._index].name;
+        var columnSchema = this.dataModel.schema[this._index];
+        return columnSchema && columnSchema.name;
     },
 
     /**
@@ -115,7 +120,7 @@ Column.prototype = {
      */
     set header(headerText) {
         this.dataModel.schema[this.index].header = headerText;
-        this.behavior.filter.prop(this.index, 'header', headerText);
+        this.dataModel.prop(null, this.index, 'header', headerText);
         this.behavior.grid.repaint();
     },
     get header() {
@@ -133,13 +138,15 @@ Column.prototype = {
      */
     set calculator(calculator) {
         var schema = this.dataModel.schema;
-        if (calculator === undefined) {
-            delete schema[this.index].calculator;
-        } else {
-            schema[this.index].calculator = calculator;
+        if (calculator !== schema[this.index].calculator) {
+            if (calculator === undefined) {
+                delete schema[this.index].calculator;
+            } else {
+                schema[this.index].calculator = calculator;
+            }
+            this.behavior.prop(null, this.index, 'calculator', calculator);
+            this.behavior.applyAnalytics();
         }
-        this.behavior.filter.prop(this.index, 'calculator', calculator);
-        this.behavior.applyAnalytics();
     },
     get calculator() {
         return this.dataModel.schema[this.index].calculator;
@@ -155,8 +162,7 @@ Column.prototype = {
     set type(type) {
         this._type = type;
         //TODO: This is calling reindex for every column during grid init. Maybe defer all reindex calls until after an grid 'ready' event
-        this.behavior.filter.prop(this.index, 'type', type);
-        this.behavior.sorter.prop(this.index, 'type', type);
+        this.dataModel.prop(null, this.index, 'type', type);
         this.behavior.reindex();
     },
     get type() {
@@ -176,36 +182,32 @@ Column.prototype = {
     },
 
     getWidth: function() {
-        return this.properties && this.properties.width || this.behavior.grid.properties.defaultColumnWidth;
+        return this.properties.width || this.behavior.grid.properties.defaultColumnWidth;
     },
 
     setWidth: function(width) {
-        this.properties.width = Math.max(5, width);
-    },
-
-    getCellRenderer: function(config, cellEvent) {
-        config.untranslatedX = cellEvent.gridCell.x;
-        config.y = cellEvent.gridCell.y;
-
-        config.x = this.index;
-        config.normalizedY = cellEvent.dataCell.y;
-
-        return this.dataModel.getCell(config, cellEvent.getCellProperty('renderer'));
+        width = Math.max(this.properties.minimumColumnWidth, width);
+        if (width !== this.properties.width) {
+            this.properties.width = width;
+            this.properties.columnAutosizing = false;
+        }
     },
 
     checkColumnAutosizing: function(force) {
-        var properties = this.properties;
-        var a, b, d, autoSized;
-        if (properties) {
-            a = properties.width;
-            b = properties.preferredWidth || a;
-            d = properties.columnAutosized && !force;
-            if (a !== b || !d) {
-                properties.width = !d ? b : Math.max(a, b);
+        var properties = this.properties,
+            width, preferredWidth, autoSized;
+
+        if (properties.columnAutosizing) {
+            width = properties.width;
+            preferredWidth = properties.preferredWidth || width;
+            force = force || !properties.columnAutosized;
+            if (width !== preferredWidth || force && preferredWidth !== undefined) {
+                properties.width = force ? preferredWidth : Math.max(width, preferredWidth);
                 properties.columnAutosized = !isNaN(properties.width);
-                autoSized = properties.width !== a;
+                autoSized = properties.width !== width;
             }
         }
+
         return autoSized;
     },
 
@@ -266,45 +268,37 @@ Column.prototype = {
     },
 
     get properties() {
-        var tableState = this.behavior.grid.properties,
-            result = tableState.columnProperties[this.index];
-
-        if (!result) {
-            result = tableState.columnProperties[this.index] = this.createColumnProperties();
-        }
-
-        return result;
+        return this._properties;
     },
-    set properties(properties) {
-        var key, descriptor, obj = this.properties;
-
-        for (key in obj) {
-            descriptor = Object.getOwnPropertyDescriptor(obj, key);
-            if (!descriptor || descriptor.configurable) {
-                delete obj[key];
-            }
-        }
-
-        this.addProperties(properties);
+    set properties(ownProperties) {
+        this._properties = this.createColumnProperties();
+        this.addProperties(ownProperties);
     },
 
     getProperties: function() {
         return this.deprecated('getProperties()', 'properties', '1.2.0');
     },
 
+    /** This method is provided because some grid renderer optimizations require that the grid renderer be informed when column colors change. Due to performance concerns, they cannot take the time to figure it out for themselves. Along the same lines, making the property a getter/setter (in columnProperties.js), though doable, might present performance concerns as this property is possibly the most accessed of all column properties.
+     * @param color
+     */
+    setBackgroundColor: function(color) {
+        if (this.properties.backgroundColor !== color) {
+            this.properties.backgroundColor = color;
+            this.behavior.grid.renderer.rebundleGridRenderers();
+        }
+    },
+
     /**
      * @param {object} properties
      * @param {boolean} [preserve=false]
      */
     setProperties: function(properties, preserve) {
         if (!preserve) {
-            if (!warned.setProperties) {
-                warned.setProperties = true;
-                console.warn('setProperties(properties) has been deprecated in favor of properties (setter) as of v1.2.0 and will be removed in a future version. This advice only pertains to usages of setProperties when called with a single parameter. When called with a truthy second parameter, use the new addProperties(properties) call instead.');
-            }
+            this.deprecated('setProperties', 'setProperties(properties) has been deprecated in favor of properties (setter) as of v1.2.0. (Will be removed in a future version.) This advice only pertains to usages of setProperties when called with a single parameter. When called with a truthy second parameter, use the new addProperties(properties) call instead.');
             this.properties = properties;
         } else {
-            this.deprecated('setProperties(properties, preserve)', 'addProperties(properties)', '1.2.0', arguments, 'This warning pertains to setProperties only when preserve is truthy. When preserve is faulty, use the new properties setter.');
+            this.deprecated('setPropertiesPreserve', 'setProperties(properties, preserve)', 'addProperties(properties)', '1.2.0', arguments, 'This warning pertains to setProperties only when preserve is truthy. When preserve is faulty, use the new properties setter.');
         }
     },
 
@@ -312,45 +306,37 @@ Column.prototype = {
         var key, descriptor, obj = this.properties;
 
         for (key in properties) {
-            descriptor = Object.getOwnPropertyDescriptor(obj, key);
-            if (!descriptor || descriptor.writable || descriptor.set) {
-                obj[key] = properties[key];
+            if (properties.hasOwnProperty(key)) {
+                descriptor = Object.getOwnPropertyDescriptor(obj, key);
+                if (!descriptor || descriptor.writable || descriptor.set) {
+                    obj[key] = properties[key];
+                }
             }
         }
     },
 
     /**
-     * This method determines the proposed cell editor name from the render properties. The algorithm is:
-     * 1. `editor` render property (cell editor name)
-     * 2. `format` render property (localizer name)
+     * @summary Get a new cell editor.
+     * @desc The cell editor to use must be registered with the key in the cell's `editor` property.
+     *
+     * The cell's `format` property is mixed into the provided cellEvent for possible overriding by developer's override of {@link DataModel.prototype.getCellEditorAt} before being used by {@link CellEditor} to parse and format the cell value.
      *
-     * Note that "render property" means in each case the first defined property found on the cell, column, or grid.
+     * @param {CellEvent} cellEvent
      *
-     * @param {number} y - The grid row index.
-     * @param {object} options - Will be decorated with `format` and `column`.
-     * @param {CellEvent} options.editPoint
-     * @returns {undefined|CellEditor} Falsy value means either no declared cell editor _or_ instantiation aborted by falsy return return from fireRequestCellEdit.
+     * @returns {undefined|CellEditor} Falsy value means either no declared cell editor _or_ instantiation aborted by falsy return from `fireRequestCellEdit`.
      */
-    getCellEditorAt: function(event) {
+    getCellEditorAt: function(cellEvent) {
         var columnIndex = this.index,
-            rowIndex = event.gridCell.y,
-            editorName = event.getCellProperty('editor'),
-            options = Object.defineProperties(event, {
+            rowIndex = cellEvent.gridCell.y,
+            editorName = cellEvent.properties.editor,
+            options = Object.create(cellEvent, {
                 format: {
-                    // `options.fomrat` is a copy of the cell's `format` property which is:
+                    // `options.format` is a copy of the cell's `format` property which is:
                     // 1. Subject to adjustment by the `getCellEditorAt` override.
                     // 2. Then used by the cell editor to reference the predefined localizer.
                     writable: true,
-                    value: event.getCellProperty('format')
-                },
-                editPoint: {
-                    get: function() {
-                        if (!warned.editPoint) {
-                            warned.editPoint = true;
-                            console.warn('The .editPoint property has been deprecated as of v1.2.0 in favor of .gridCell. It may be removed in a future release.');
-                        }
-                        return this.gridCell;
-                    }
+                    enumerable: true, // so cell editor will copy it to self
+                    value: cellEvent.properties.format
                 }
             }),
             cellEditor = this.dataModel.getCellEditorAt(columnIndex, rowIndex, editorName, options);
diff --git a/src/behaviors/JSON.js b/src/behaviors/JSON.js
index a4fa826..ee7673c 100644
--- a/src/behaviors/JSON.js
+++ b/src/behaviors/JSON.js
@@ -29,12 +29,11 @@ var JSON = Behavior.extend('behaviors.JSON', {
     },
 
     features: [
+        features.Filters,
         features.CellSelection,
         features.KeyPaging,
-        features.ColumnPicker,
         features.ColumnResizing,
-        features.RowResizing,
-        features.Filters,
+        // features.RowResizing,
         features.RowSelection,
         features.ColumnSelection,
         features.ColumnMoving,
@@ -45,11 +44,9 @@ var JSON = Behavior.extend('behaviors.JSON', {
     ],
 
     createColumns: function() {
-        var schema = this.dataModel.schema;
+        Behavior.prototype.createColumns.call(this);
 
-        this.clearColumns();
-
-        schema.forEach(function(columnSchema, index) {
+        this.dataModel.schema.forEach(function(columnSchema, index) {
             this.addColumn({
                 index: index,
                 header: columnSchema.header,
@@ -66,6 +63,7 @@ var JSON = Behavior.extend('behaviors.JSON', {
      * @param key
      * @todo move columnEnum code from core to demo
      * @returns {string}
+     * @memberOf behaviors.JSON.prototype
      */
     columnEnumKey: function(key) {
         return key.replace(REGEX_CAMEL_CASE, '$1_$2').toUpperCase();
@@ -119,13 +117,12 @@ var JSON = Behavior.extend('behaviors.JSON', {
      * @memberOf behaviors.JSON.prototype
      */
     setPipeline: function(DataSources, options) {
+        this.dataModel.setPipeline.apply(this.dataModel, arguments);
+
         if (!Array.isArray(DataSources)) {
             options = DataSources;
-            DataSources = undefined;
         }
 
-        this.dataModel.setPipeline(DataSources, options);
-
         if (!options || options.apply === undefined || options.apply) {
             this.reindex();
         }
@@ -137,6 +134,7 @@ var JSON = Behavior.extend('behaviors.JSON', {
      * @param {string} [whichStash]
      * @param {object} [options] - Takes first argument position when `DataSources` omitted.
      * @param {boolean} [options.apply=true] Apply data transformations to the new data.
+     * @memberOf behaviors.JSON.prototype
      */
     unstashPipeline: function(stash, options) {
         if (typeof stash === 'object') {
@@ -177,58 +175,48 @@ var JSON = Behavior.extend('behaviors.JSON', {
         }
 
         if (!Array.isArray(dataRows)) {
-            throw 'Data is not an array';
+            throw 'Expected data to be an array (of data row objects).';
         }
 
         options = options || {};
-        var grid = this.grid;
 
-        this.dataModel.setData(
-            dataRows,
-            this.unwrap(options.schema) || [] // *always* define a new schema on reset
-        );
+        var grid = this.grid,
+            schema = this.unwrap(options.schema), // *always* define a new schema on reset
+            schemaChanged = schema || !this.subgrids.lookup.data.schema.length, // schema will change if a new schema was provided OR data model has an empty schema now, which triggers schema generation on setData below
+            reindex = options.apply === undefined || options.apply; // defaults to true
+
+        // Inform interested data models of data.
+        this.subgrids.forEach(function(dataModel) {
+            if (dataModel.setData && !dataModel.hasOwnData) {
+                dataModel.setData(dataRows, schema);
+            }
+        });
 
         if (grid.cellEditor) {
             grid.cellEditor.cancelEditing();
         }
 
-        if (options.apply === undefined || options.apply) {
+        if (reindex) {
             this.reindex();
         }
 
-        var self = this;
-        this.createColumns();
-        if (self.grid.isColumnAutosizing()) {
-            setTimeout(function() {
-                self.autosizeAllColumns();
-            }, 100);
-            self.grid.allowEvents(self.dataModel.getRowCount() > 0);
-        } else {
-            setTimeout(function() {
-                self.getColumn(-1).checkColumnAutosizing(true);
-                self.grid.allowEvents(self.dataModel.getRowCount() > 0);
-            });
+        if (schemaChanged) {
+            this.createColumns();
         }
+
+        grid.allowEvents(this.dataModel.getRowCount() > 0);
     },
+
     /**
      * @summary Rebinds the data without reshaping it.
+     * @desc See {@link behaviors.JSON#setData|setData}'s parameter descriptions.
      * @param dataRows
      * @param options
      * @memberOf behaviors.JSON.prototype
      */
-    updateData: function(dataRows, options){
-        options = options || {};
-        if (!(Array.isArray(dataRows) || typeof dataRows === 'function')) {
-            options = dataRows;
-            dataRows = options && options.data;
-        }
-        dataRows = this.unwrap(dataRows);
-        this.dataModel.setData(
-            dataRows,
-            this.unwrap(options.schema) // undefined will be ignored
-        );
-
-        this.reindex();
+    updateData: function(dataRows, options) {
+        this.deprecated('updateData(dataRows, options)', 'setData(dataRows, options)', 'v1.2.10', arguments,
+            'To update data without changing column definitions, call setData _without a schema._');
     },
 
     /**
@@ -247,15 +235,6 @@ var JSON = Behavior.extend('behaviors.JSON', {
         console.warn('This function does not do anything');
     },
 
-    /**
-     * @memberOf behaviors.JSON.prototype
-     * @description Enhance the double-click event just before it's broadcast to listeners.
-     * @param {Point} event
-     */
-    enhanceDoubleClickEvent: function(event) {
-        event.row = this.getRow(event.gridCell.y);
-    },
-
     //Not being used. Should be repurposed??
     setDataProvider: function(dataProvider) {
         this.dataModel.setDataProvider(dataProvider);
@@ -265,28 +244,13 @@ var JSON = Behavior.extend('behaviors.JSON', {
         return this.dataModel.hasHierarchyColumn();
     },
 
-    getHiddenColumns: function() {
-        return this.dataModel.getHiddenColumns();
-    },
-
-    getActiveColumns: function() {
-        return this.dataModel.getActiveColumns();
-    },
     getVisibleColumns: function() {
         return this.deprecated('getVisibleColumns()', 'getActiveColumns()', '1.0.6', arguments);
     },
 
-    getSelectedColumns: function() {
-        return this.grid.selectionModel.getSelectedColumns();
-    },
-
     getSelections: function() {
         return this.grid.selectionModel.getSelections();
     },
-
-    getSortedColumnIndexes: function(){
-      return this.dataModel.getSortedColumnIndexes();
-    }
 });
 
 module.exports = JSON;
diff --git a/src/behaviors/cellProperties.js b/src/behaviors/cellProperties.js
index e896776..dbc955d 100644
--- a/src/behaviors/cellProperties.js
+++ b/src/behaviors/cellProperties.js
@@ -2,8 +2,6 @@
 
 'use strict';
 
-var _ = require('object-iterators');
-
 /**
  * Column.js mixes this module into its prototype.
  * @module
@@ -30,7 +28,7 @@ var cell = {
      * @memberOf Column#
      */
     setCellProperties: function(rowIndex, properties, dataModel) {
-        return _(newCellPropertiesObject.call(this, rowIndex, dataModel)).extendOwn(properties);
+        return Object.assign(newCellPropertiesObject.call(this, rowIndex, dataModel), properties);
     },
 
     /**
@@ -41,7 +39,7 @@ var cell = {
      * @memberOf Column#
      */
     addCellProperties: function(rowIndex, properties, dataModel) {
-        return _(getCellPropertiesObject.call(this, rowIndex, dataModel)).extendOwn(properties);
+        return Object.assign(getCellPropertiesObject.call(this, rowIndex, dataModel), properties);
     },
 
     /**
@@ -57,18 +55,26 @@ var cell = {
      *
      * Call this method only when you need to know if the the cell has its own properties object; otherwise call {@link Column#getCellProperties|getCellProperties}.
      * @param {number} rowIndex - Data row coordinate.
-     * @returns {undefined|object} The "own" properties of the cell at x,y in the grid. If the cell does not own a properties object, returns `undefined`.
+     * @returns {null|object} The "own" properties of the cell at x,y in the grid. If the cell does not own a properties object, returns `undefined`.
      * @memberOf Column#
      */
     getCellOwnProperties: function(rowIndex, dataModel) {
         var rowData;
         return (
-            this.index >= 0 && // no cell props on row handle cells
-            (rowData = (dataModel || this.dataModel).getRow(rowIndex)) && // no cell props on non-existant rows
-            rowData.__META && rowData.__META[this.name] // undefined if not previously created
+            // this.index >= 0 && // no cell props on row handle cells
+            (rowData = (dataModel || this.dataModel).getRow(rowIndex)) && // no cell props on non-existent rows
+            rowData.__META && rowData.__META[this.name] ||
+            null // null means not previously created
         );
     },
 
+    deleteCellOwnProperties: function(rowIndex, dataModel) {
+        var rowData = (dataModel || this.dataModel).getRow(rowIndex);
+        if (rowData.__META) {
+            delete rowData.__META[this.name];
+        }
+    },
+
     /**
      * @summary Return a specific cell property.
      * @desc If there is no cell properties object, defers to column properties object.
@@ -89,14 +95,34 @@ var cell = {
      * @memberOf Column#
      */
     setCellProperty: function(rowIndex, key, value, dataModel) {
-        var propertiesObject = getCellPropertiesObject.call(this, rowIndex, dataModel);
-        propertiesObject[key] = value;
-        return propertiesObject;
+        var cellProps = getCellPropertiesObject.call(this, rowIndex, dataModel);
+        cellProps[key] = value;
+        return cellProps;
+    },
+
+    deleteCellProperty: function(rowIndex, key, dataModel) {
+        var cellProps = this.getCellOwnProperties(rowIndex, dataModel);
+        if (cellProps) {
+            delete cellProps[key];
+        }
     },
 
     clearAllCellProperties: function() {
-        // Unimplemented!
-        // Need to undefine all `dataModel.getData(*).__META[this.name]`.
+        var key = this.name;
+        this.behavior.subgrids.forEach(function(dataModel) {
+            for (var i = dataModel.getRowCount(); i--;) {
+                var rowData = dataModel.getRow(i),
+                    meta = rowData.__META;
+                if (meta) {
+                    if (Object.keys(meta).length === 1) {
+                        delete rowData.__META;
+                    }
+                    if (meta) {
+                        delete meta[key];
+                    }
+                }
+            }
+        });
     }
 };
 
@@ -112,6 +138,7 @@ function getCellPropertiesObject(rowIndex, dataModel) {
 
 /**
  * @todo: For v8 optimization, consider setting the new `__META` object to a "regularly shaped object" (i.e., with all the columns) instead of simply to `{}`. Considerations include how many of these objects are there, how often are they referenced, etc.
+ * @todo: We need a function to reset the prototypes of pre-existing __META members to their respective column properties objects.
  * @this {Column}
  * @param {number} rowIndex - Data row coordinate.
  * @returns {object}
@@ -120,7 +147,7 @@ function getCellPropertiesObject(rowIndex, dataModel) {
 function newCellPropertiesObject(rowIndex, dataModel) {
     var rowData = (dataModel || this.dataModel).getRow(rowIndex),
         metaData = rowData.__META = rowData.__META || {};
-    return (metaData[this.name] = Object.create(this.properties));
+    return (metaData[this.name] = Object.create(this._index >= 0 ? this.properties : this.properties.rowHeader));
 }
 
 module.exports = cell;
diff --git a/src/behaviors/columnProperties.js b/src/behaviors/columnProperties.js
index 2074d2a..c56e541 100644
--- a/src/behaviors/columnProperties.js
+++ b/src/behaviors/columnProperties.js
@@ -1,54 +1,15 @@
 'use strict';
 
-/**
- * @param {function|string} string
- * @returns {function}
- * @private
- */
-function toFunction(string) {
-    switch (typeof string) {
-        case 'undefined':
-        case 'function':
-            return string;
-        case 'string':
-            break;
-        default:
-            throw 'Expected string, function, or undefined.';
-    }
-
-    var args = string.match(/function\s*\(([^]*?)\)/);
-    if (!args) {
-        throw 'Expected function keyword with formal parameter list.';
-    }
-    args = args[1].split(',').map(function(s, i) {
-        s = s.match(/\s*(\w*)\s*/); // trim each argument
-        if (!s && i) {
-            throw 'Expected formal parameter.';
-        }
-        return s[1];
-    });
-
-    var body = string.match(/{\s*([^]*?)\s*}/);
-    if (!body) {
-        throw 'Expected function body.';
-    }
-    body = body[1];
-
-    if (args.length === 1 && !args[0]) {
-        args[0] = body;
-    } else {
-        args = args.concat(body);
-    }
-
-    return Function.apply(null, args);
-}
+var toFunction = require('../lib/toFunction');
 
 var FIELD = 'columnProperties.field is deprecated as of v1.1.0 in favor of columnProperties.name. (Will be removed in a future release.)',
-    COLUMN_NAME = 'columnProperties.columnName is deprecated as of v1.1.0 in favor of columnProperties.name. (Will be removed in a future release.)';
+    COLUMN_NAME = 'columnProperties.columnName is deprecated as of v1.1.0 in favor of columnProperties.name. (Will be removed in a future release.)',
+    COLUMN_ONLY_PROPERTY = 'Attempt to set column-only property on a non-column properties object.';
 
 /**
  * @this {Column}
  * @returns {object}
+ * @memberOf Column#
  */
 function createColumnProperties() {
     var column = this,
@@ -58,18 +19,21 @@ function createColumnProperties() {
     properties = Object.create(tableState, {
 
         index: { // read-only (no setter)
+            enumerable: true,
             get: function() {
                 return column.index;
             }
         },
 
         name: { // read-only (no setter)
+            enumerable: true,
             get: function() {
                 return column.name;
             }
         },
 
         field: { // read-only (no setter)
+            enumerable: true,
             get: function() {
                 if (FIELD) { console.warn(FIELD); FIELD = undefined; }
                 return column.name;
@@ -77,6 +41,7 @@ function createColumnProperties() {
         },
 
         columnName: { // read-only (no setter)
+            enumerable: true,
             get: function() {
                 if (COLUMN_NAME) { console.warn(COLUMN_NAME); COLUMN_NAME = undefined; }
                 return column.name;
@@ -84,348 +49,393 @@ function createColumnProperties() {
         },
 
         header: {
+            enumerable: true,
             get: function() {
                 return column.header;
             },
             set: function(header) {
+                if (this !== column.properties) {
+                    throw new column.HypergridError(COLUMN_ONLY_PROPERTY);
+                }
                 column.header = header;
             }
         },
 
         type: {
+            enumerable: true,
             get: function() {
                 return column.type;
             },
             set: function(type) {
+                if (this !== column.properties) {
+                    throw new column.HypergridError(COLUMN_ONLY_PROPERTY);
+                }
                 column.type = type;
             }
         },
 
         calculator: {
+            enumerable: true,
             get: function() {
                 return column.calculator;
             },
             set: function(calculator) {
+                if (this !== column.properties) {
+                    throw new column.HypergridError(COLUMN_ONLY_PROPERTY);
+                }
                 column.calculator = toFunction(calculator);
             }
         }
 
     });
 
+    Object.defineProperty(properties, 'rowHeader', {
+        value: Object.create(properties, createColumnProperties.rowHeaderDescriptors)
+    });
 
-    Object.defineProperty(properties, 'rowNumbersProperties', { value: Object.create(properties, {
-        foregroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.columnHeaderForegroundSelectionColor;
-            },
-            set: function(value) {
-                this.columnHeaderForegroundSelectionColor = value;
-            }
+    Object.defineProperty(properties, 'treeHeader', {
+        value: Object.create(properties, createColumnProperties.treeHeaderDescriptors)
+    });
+
+    Object.defineProperty(properties, 'columnHeader', {
+        value: Object.create(properties, createColumnProperties.columnHeaderDescriptors)
+    });
+
+    Object.defineProperty(properties, 'filterProperties', {
+        value: Object.create(properties, createColumnProperties.filterDescriptors)
+    });
+
+    return properties;
+}
+
+createColumnProperties.treeHeaderDescriptors = {
+    font: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.rowHeaderFont;
         },
-        backgroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.columnHeaderBackgroundSelectionColor;
-            },
-            set: function(value) {
-                this.columnHeaderBackgroundSelectionColor = value;
-            }
+        set: function(value) {
+            this.rowHeaderFont = value;
         }
-    })});
-
-    Object.defineProperty(properties, 'rowHeader', { value: Object.create(properties, {
-        font: {
-            configurable: true,
-            get: function() {
-                return this.rowHeaderFont;
-            },
-            set: function(value) {
-                this.rowHeaderFont = value;
-            }
+    },
+    color: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.rowHeaderColor;
         },
-        color: {
-            configurable: true,
-            get: function() {
-                return this.rowHeaderColor;
-            },
-            set: function(value) {
-                this.rowHeaderColor = value;
-            }
+        set: function(value) {
+            this.rowHeaderColor = value;
+        }
+    },
+    backgroundColor: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.rowHeaderBackgroundColor;
         },
-        backgroundColor: {
-            configurable: true,
-            get: function() {
-                return this.rowHeaderBackgroundColor;
-            },
-            set: function(value) {
-                this.rowHeaderBackgroundColor = value;
-            }
+        set: function(value) {
+            this.rowHeaderBackgroundColor = value;
+        }
+    },
+    foregroundSelectionFont: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.rowHeaderForegroundSelectionFont;
         },
-        foregroundSelectionFont: {
-            configurable: true,
-            get: function() {
-                return this.rowHeaderForegroundSelectionFont;
-            },
-            set: function(value) {
-                this.rowHeaderForegroundSelectionFont = value;
-            }
+        set: function(value) {
+            this.rowHeaderForegroundSelectionFont = value;
+        }
+    },
+    foregroundSelectionColor: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.rowHeaderForegroundSelectionColor;
         },
-        foregroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.rowHeaderForegroundSelectionColor;
-            },
-            set: function(value) {
-                this.rowHeaderForegroundSelectionColor = value;
-            }
+        set: function(value) {
+            this.rowHeaderForegroundSelectionColor = value;
+        }
+    },
+    backgroundSelectionColor: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.rowHeaderBackgroundSelectionColor;
         },
-        backgroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.rowHeaderBackgroundSelectionColor;
-            },
-            set: function(value) {
-                this.rowHeaderBackgroundSelectionColor = value;
-            }
+        set: function(value) {
+            this.rowHeaderBackgroundSelectionColor = value;
         }
-    })});
+    }
+    //leftIcon: undefined
+};
 
-    Object.defineProperty(properties, 'columnHeader', { value: Object.create(properties, {
-        font: {
-            configurable: true,
-            get: function() {
-                return this.columnHeaderFont;
-            },
-            set: function(value) {
-                this.columnHeaderFont = value;
-            }
+createColumnProperties.rowHeaderDescriptors = {
+    font: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.rowHeaderFont;
         },
-        color: {
-            configurable: true,
-            get: function() {
-                return this.columnHeaderColor;
-            },
-            set: function(value) {
-                this.columnHeaderColor = value;
-            }
+        set: function(value) {
+            this.rowHeaderFont = value;
+        }
+    },
+    color: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.rowHeaderColor;
         },
-        backgroundColor: {
-            configurable: true,
-            get: function() {
-                return this.columnHeaderBackgroundColor;
-            },
-            set: function(value) {
-                this.columnHeaderBackgroundColor = value;
-            }
+        set: function(value) {
+            this.rowHeaderColor = value;
+        }
+    },
+    backgroundColor: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.rowHeaderBackgroundColor;
         },
-        foregroundSelectionFont: {
-            configurable: true,
-            get: function() {
-                return this.columnHeaderForegroundSelectionFont;
-            },
-            set: function(value) {
-                this.columnHeaderForegroundSelectionFont = value;
-            }
+        set: function(value) {
+            this.rowHeaderBackgroundColor = value;
+        }
+    },
+    foregroundSelectionFont: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.rowHeaderForegroundSelectionFont;
         },
-        foregroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.columnHeaderForegroundSelectionColor;
-            },
-            set: function(value) {
-                this.columnHeaderForegroundSelectionColor = value;
-            }
+        set: function(value) {
+            this.rowHeaderForegroundSelectionFont = value;
+        }
+    },
+    foregroundSelectionColor: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.rowHeaderForegroundSelectionColor;
         },
-        backgroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.columnHeaderBackgroundSelectionColor;
-            },
-            set: function(value) {
-                this.columnHeaderBackgroundSelectionColor = value;
-            }
+        set: function(value) {
+            this.rowHeaderForegroundSelectionColor = value;
+        }
+    },
+    backgroundSelectionColor: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.rowHeaderBackgroundSelectionColor;
         },
-        halign: {
-            configurable: true,
-            get: function() {
-                return this.columnHeaderHalign;
-            },
-            set: function(value) {
-                this.columnHeaderHalign = value;
-            }
+        set: function(value) {
+            this.rowHeaderBackgroundSelectionColor = value;
         }
-    })});
-
-    Object.defineProperty(properties, 'columnHeaderColumnSelection', { value: Object.create(properties.columnHeader, {
-        foregroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.columnHeaderForegroundColumnSelectionColor;
-            },
-            set: function(value) {
-                this.columnHeaderForegroundColumnSelectionColor = value;
-            }
+    },
+    leftIcon: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            var result;
+            if (this.isDataRow) {
+                result = this.isRowSelected ? 'checked' : 'unchecked';
+            } else if (this.isHeaderRow) {
+                result = this.allRowsSelected ? 'checked' : 'unchecked';
+            } else if (this.isFilterRow) {
+                result = 'filter-off';
+            }
+            return result;
         },
-        backgroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.columnHeaderBackgroundColumnSelectionColor;
-            },
-            set: function(value) {
-                this.columnHeaderBackgroundColumnSelectionColor = value;
-            }
+        set: function(value) {
+            // replace self with a simple instance var
+            Object.defineProperty(this, 'leftIcon', {
+                configurable: true,
+                enumerable: true,
+                writable: true,
+                value: value
+            });
         }
-    })});
+    }
+};
 
-    Object.defineProperty(properties, 'rowHeaderRowSelection', { value: Object.create(properties.rowHeader, {
-        foregroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.rowHeaderForegroundRowSelectionColor;
-            },
-            set: function(value) {
-                this.rowHeaderForegroundRowSelectionColor = value;
-            }
+createColumnProperties.filterDescriptors = {
+    font: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.filterFont;
         },
-        backgroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.rowHeaderBackgroundRowSelectionColor;
-            },
-            set: function(value) {
-                this.rowHeaderBackgroundRowSelectionColor = value;
-            }
+        set: function(value) {
+            this.filterFont = value;
         }
-    })});
-
-    Object.defineProperty(properties, 'filterProperties', { value: Object.create(properties, {
-        font: {
-            configurable: true,
-            get: function() {
-                return this.filterFont;
-            },
-            set: function(value) {
-                this.filterFont = value;
-            }
+    },
+    color: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.filterColor;
         },
-        color: {
-            configurable: true,
-            get: function() {
-                return this.filterColor;
-            },
-            set: function(value) {
-                this.filterColor = value;
-            }
+        set: function(value) {
+            this.filterColor = value;
+        }
+    },
+    backgroundColor: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.filterBackgroundColor;
         },
-        backgroundColor: {
-            configurable: true,
-            get: function() {
-                return this.filterBackgroundColor;
-            },
-            set: function(value) {
-                this.filterBackgroundColor = value;
-            }
+        set: function(value) {
+            this.filterBackgroundColor = value;
+        }
+    },
+    foregroundSelectionColor: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.filterForegroundSelectionColor;
         },
-        foregroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.filterForegroundSelectionColor;
-            },
-            set: function(value) {
-                this.filterForegroundSelectionColor = value;
-            }
+        set: function(value) {
+            this.filterForegroundSelectionColor = value;
+        }
+    },
+    backgroundSelectionColor: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.filterBackgroundSelectionColor;
         },
-        backgroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.filterBackgroundSelectionColor;
-            },
-            set: function(value) {
-                this.filterBackgroundSelectionColor = value;
-            }
+        set: function(value) {
+            this.filterBackgroundSelectionColor = value;
+        }
+    },
+    halign: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.filterHalign;
         },
-        halign: {
-            configurable: true,
-            get: function() {
-                return this.filterHalign;
-            },
-            set: function(value) {
-                this.filterHalign = value;
-            }
+        set: function(value) {
+            this.filterHalign = value;
         }
-    })});
+    },
+    renderer: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.filterRenderer;
+        },
+        set: function(value) {
+            this.filterRenderer = value;
+        }
+    },
+    rightIcon: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            var result;
+            if (this.filterable) {
+                result = this.value.length ? 'filter-on' : 'filter-off';
+            }
+            return result;
+        },
+        set: function(value) {
+            // replace self with a simple instance var
+            Object.defineProperty(this, 'rightIcon', {
+                configurable: true,
+                enumerable: true,
+                writable: true,
+                value: value
+            });
+        }
+    }
+};
 
-    Object.defineProperty(properties, 'treeColumnProperties', { value: Object.create(properties, {
-        font: {
-            configurable: true,
-            get: function() {
-                return this.treeColumnFont;
-            },
-            set: function(value) {
-                this.treeColumnFont = value;
-            }
+createColumnProperties.columnHeaderDescriptors = {
+    font: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.columnHeaderFont;
         },
-        color: {
-            configurable: true,
-            get: function() {
-                return this.treeColumnColor;
-            },
-            set: function(value) {
-                this.treeColumnColor = value;
-            }
+        set: function(value) {
+            this.columnHeaderFont = value;
+        }
+    },
+    color: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.columnHeaderColor;
         },
-        backgroundColor: {
-            configurable: true,
-            get: function() {
-                return this.treeColumnBackgroundColor;
-            },
-            set: function(value) {
-                this.treeColumnBackgroundColor = value;
-            }
+        set: function(value) {
+            this.columnHeaderColor = value;
+        }
+    },
+    backgroundColor: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.columnHeaderBackgroundColor;
         },
-        foregroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.treeColumnForegroundSelectionColor;
-            },
-            set: function(value) {
-                this.treeColumnForegroundSelectionColor = value;
-            }
+        set: function(value) {
+            this.columnHeaderBackgroundColor = value;
+        }
+    },
+    foregroundSelectionFont: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.columnHeaderForegroundSelectionFont;
         },
-        backgroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.treeColumnBackgroundSelectionColor;
-            },
-            set: function(value) {
-                this.treeColumnBackgroundSelectionColor = value;
-            }
+        set: function(value) {
+            this.columnHeaderForegroundSelectionFont = value;
         }
-    })});
-
-    Object.defineProperty(properties, 'treeColumnPropertiesColumnSelection', { value: Object.create(properties.treeColumnProperties, {
-        foregroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.treeColumnForegroundColumnSelectionColor;
-            },
-            set: function(value) {
-                this.treeColumnForegroundColumnSelectionColor = value;
-            }
+    },
+    foregroundSelectionColor: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.columnHeaderForegroundSelectionColor;
         },
-        backgroundSelectionColor: {
-            configurable: true,
-            get: function() {
-                return this.treeColumnBackgroundColumnSelectionColor;
-            },
-            set: function(value) {
-                this.treeColumnBackgroundColumnSelectionColor = value;
-            }
+        set: function(value) {
+            this.columnHeaderForegroundSelectionColor = value;
         }
-    })});
-
-    return properties;
-}
+    },
+    backgroundSelectionColor: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.columnHeaderBackgroundSelectionColor;
+        },
+        set: function(value) {
+            this.columnHeaderBackgroundSelectionColor = value;
+        }
+    },
+    halign: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.columnHeaderHalign;
+        },
+        set: function(value) {
+            this.columnHeaderHalign = value;
+        }
+    },
+    renderer: {
+        configurable: true,
+        enumerable: true,
+        get: function() {
+            return this.columnHeaderRenderer;
+        },
+        set: function(value) {
+            this.columnHeaderRenderer = value;
+        }
+    },
+    leftIcon: { writable: true, value: undefined},
+    centerIcon: { writable: true, value: undefined},
+    rightIcon: { writable: true, value: undefined},
+};
 
 module.exports.createColumnProperties = createColumnProperties;
diff --git a/src/behaviors/index.js b/src/behaviors/index.js
index b0d79f9..e1626fc 100644
--- a/src/behaviors/index.js
+++ b/src/behaviors/index.js
@@ -1,7 +1,7 @@
 'use strict';
 
 module.exports = {
-    Behavior: require('./Behavior'), // abstract base class
+    Behavior: require('./Behavior'),
     JSON: require('./JSON'),
     Column: require('./Column')
 };
diff --git a/src/behaviors/subgrids.js b/src/behaviors/subgrids.js
new file mode 100644
index 0000000..40bc47f
--- /dev/null
+++ b/src/behaviors/subgrids.js
@@ -0,0 +1,149 @@
+'use strict';
+
+var dataModels = require('../dataModels');
+
+/** @typedef subgridConstructorRef
+ * @summary Type definition.
+ * @desc One of:
+ * * **`function` type** - Assumed to already be a data model constructor.
+ * * **`string` type** - The name of a data model "class" (constructor) registered in the {@link src/dataModels} namespace. Used to look up the constructor in the namespace.
+ */
+
+/** @typedef subgridSpec
+ * @summary Type definition.
+ * @desc One of:
+ * * **`object` type** _(except when an array)_ - Assumed to be a reference to an already-instantiated data model. Used as is.
+ * * **`'data'` special value** - Set to the data subgrid (_i.e.,_ the behavior's already-instantiated data model).
+ * * **{@link subgridConstructorRef}** _(see)_ - The constructor ref is resolved and called with the `new` keyword + a reference to the grid as the sole parameter.
+ * * **`Array` object**  Accommodates data model constructor arguments. The constructor ref is resolved and called with the `new` keyword + a reference to the grid as the first parameter + the remaining elements as additional parameters. (If you don't have remaining elements, don't give an array here; just provide a simple `subgridConstructorRef` instead.) The array should have two or more elements:
+ *   * The first element is a {@link subgridConstructorRef}.
+ *   * Remaining elements are used as additional parameters to the constructor.
+ */
+
+module.exports = {
+    dataModels: {
+        HeaderSubgrid: dataModels.HeaderSubgrid
+    },
+
+    defaultSubgridSpecs: [
+        'HeaderSubgrid',
+        'data'
+    ],
+
+    /**
+     * An array where each element represents a subgrid to be rendered in the hypergrid.
+     *
+     * The list should always include at least one "data" subgrid, typically {@link Behavior#dataModel|dataModel}.
+     * It may also include zero or more other types of subgrids such as header, filter, and summary subgrids.
+     *
+     * This object also sports a dictionary of subgrids in `lookup` property where each dictionary key is one of:
+     * * **`subgrid.name`** (for those that have a defined name, which is presumed to be unique)
+     * * **`subgrid.type`** (not unique, so if you plan on having multiple, name them!)
+     * * **`'data'`** for the (one and only) data subgrid when unnamed (note that data subgrids have no `type`)
+     *
+     * The setter:
+     * * "Enlivens" any constructors (see {@link Behavior~createSubgrid|createSubgrid} for details).
+     * * Reconstructs the dictionary.
+     * * Calls {@link Behavior#shapeChanged|shapeChanged()}.
+     *
+     * @param {subgridSpec[]} subgridSpecs
+     *
+     * @type {dataModelAPI[]}
+     *
+     * @memberOf Behavior#
+     */
+    set subgrids(subgridSpecs) {
+        var subgrids = this._subgrids = [];
+
+        subgrids.lookup = {};
+
+        subgridSpecs.forEach(function(spec) {
+            if (spec) {
+                subgrids.push(this.createSubgrid(spec));
+            }
+        }, this);
+
+        this.shapeChanged();
+    },
+    get subgrids() {
+        return this._subgrids;
+    },
+
+    /**
+     * @summary Maps a `subgridSpec` to a data model.
+     * @desc The spec may describe either an existing data model, or a constructor for a new data model.
+     * @param {subgridSpec} spec
+     * @returns {dataModelAPI} A data model.
+     * @memberOf Behavior#
+     */
+    createSubgrid: function(spec, args) {
+        var subgrid, Constructor, variableArgArray;
+
+        if (spec === 'data') {
+            subgrid = this.dataModel;
+        } else if (spec instanceof Array && spec.length) {
+            Constructor = derefSubgridRef.call(this, spec[0]);
+            variableArgArray = spec.slice(1);
+            subgrid = this.createApply(Constructor, variableArgArray, this.grid);
+        } else if (typeof spec === 'object') {
+            subgrid = spec;
+        } else {
+            Constructor = derefSubgridRef.call(this, spec);
+            variableArgArray = Array.prototype.slice.call(arguments, 1);
+            subgrid = this.createApply(Constructor, variableArgArray, this.grid);
+        }
+
+        // undefined type is data
+        subgrid.type = subgrid.type || 'data';
+
+        // make dictionary lookup entry
+        var key = subgrid.name || subgrid.type;
+        this._subgrids.lookup[key] = this._subgrids.lookup[key] || subgrid; // only save first with this key
+
+        // make isType boolean
+        subgrid['is' + subgrid.type[0].toUpperCase() + subgrid.type.substr(1)] = true;
+
+        return subgrid;
+    },
+
+    /**
+     * @summary Gets the number of "header rows".
+     * @desc Defined as the sum of all rows of all subgrids before the (first) data subgrid.
+     * @memberOf behaviors.JSON.prototype
+     */
+    getHeaderRowCount: function() {
+        var result = 0;
+
+        this.subgrids.find(function(subgrid) {
+            if (subgrid.isData) {
+                return true; // stop
+            }
+            result += subgrid.getRowCount();
+        });
+
+        return result;
+    }
+};
+
+/**
+ * @summary Resolves a subgrid constructor reference.
+ * @desc The ref is resolved to a data model constructor.
+ * @this {Behavior}
+ * @param {subgridConstructorRef} ref
+ * @returns {DataModel} A data model constructor.
+ * @memberOf Behavior~
+ */
+function derefSubgridRef(ref) {
+    var Constructor;
+    switch (typeof ref) {
+        case 'string':
+            Constructor = this.dataModels[ref];
+            break;
+        case 'function':
+            Constructor = ref;
+            break;
+        default:
+            throw new this.HypergridError('Expected subgrid ref to be registered name or constructor, but found ' + typeof ref + '.');
+    }
+    return Constructor;
+}
diff --git a/src/cellEditors/CellEditor.js b/src/cellEditors/CellEditor.js
index 8eb94a0..f01001d 100644
--- a/src/cellEditors/CellEditor.js
+++ b/src/cellEditors/CellEditor.js
@@ -3,7 +3,6 @@
 'use strict';
 
 var mustache = require('mustache');
-var _ = require('object-iterators');
 
 var Base = require('../Base');
 var effects = require('../lib/DOM/effects');
@@ -21,11 +20,9 @@ var CellEditor = Base.extend('CellEditor', {
      * @param {string} [options.format] - Name of a localizer with which to override prototype's `localizer` property.
      */
     initialize: function(grid, options) {
-        // Mix in all enumerable properties for mustache use.
+        // Mix in all enumerable properties for mustache use, typically `column` and `format`.
         for (var key in options) {
-            if (options.hasOwnProperty(key) && this[key] !== null) {
-                this[key] = options[key];
-            }
+            this[key] = options[key];
         }
 
         this.event = options;
@@ -76,6 +73,10 @@ var CellEditor = Base.extend('CellEditor', {
         var self = this;
         this.el.addEventListener('keyup', this.keyup.bind(this));
         this.el.addEventListener('keydown', function(e) {
+            if (e.keyCode === 9) {
+                // prevent TAB from leaving input control
+                e.preventDefault();
+            }
             grid.fireSyntheticEditorKeyDownEvent(self, e);
         });
         this.el.addEventListener('keypress', function(e) {
@@ -88,7 +89,7 @@ var CellEditor = Base.extend('CellEditor', {
 
     // If you override this method, be sure to call it as a final step (or call stopPropagation yourself).
     onmousedown: function(event) {
-        event.stopPropagation(); // Catch mouseodwn here before it gets to the document listener defined in Hypergrid().
+        event.stopPropagation(); // Catch mousedown here before it gets to the document listener defined in Hypergrid().
     },
 
     localizer: Localization.prototype.null,
@@ -101,19 +102,52 @@ var CellEditor = Base.extend('CellEditor', {
     },
 
     keyup: function(e) {
-        if (e) {
-            var specialKeyup = this.specialKeyups[e.keyCode];
+        var grid = this.grid,
+            cellProps = this.event.properties,
+            feedbackCount = cellProps.feedbackCount,
+            keyChar = grid.canvas.getKeyChar(e),
+            specialKeyup,
+            stopped;
+
+        // STEP 1: Call the special key handler as needed
+        if (
+            (specialKeyup = this.specialKeyups[e.keyCode]) &&
+            (stopped = this[specialKeyup](feedbackCount))
+        ) {
+            grid.repaint();
+        }
 
-            if (specialKeyup) {
-                e.preventDefault();
-                if (this[specialKeyup](3)) {
-                    this.grid.repaint();
-                    this.grid.takeFocus();
-                }
+        // STEP 2: If this is a possible "nav key" consumable by CellSelection#handleKeyDown, try to stop editing and send it along
+        if (cellProps.mappedNavKey(keyChar, e.ctrlKey)) {
+            if (
+                !specialKeyup &&
+                // We didn't try to stop editing above so try to stop it now
+                (stopped = this.stopEditing(feedbackCount))
+            ) {
+                grid.repaint();
             }
 
-            this.grid.fireSyntheticEditorKeyUpEvent(this, e);
+            if (stopped) {
+                // Editing successfully stopped
+                // -> send the event down the feature chain
+                var finEvent = grid.canvas.newEvent(e, 'fin-editor-keydown', {
+                    alt: e.altKey,
+                    ctrl: e.ctrlKey,
+                    char: keyChar,
+                    code: e.charCode,
+                    key: e.keyCode,
+                    meta: e.metaKey,
+                    shift: e.shiftKey,
+                    identifier: e.key,
+                    editor: this
+                });
+                grid.delegateKeyDown(finEvent);
+            }
         }
+
+        this.grid.fireSyntheticEditorKeyUpEvent(this, e);
+
+        return stopped;
     },
 
     /**
@@ -145,20 +179,11 @@ var CellEditor = Base.extend('CellEditor', {
      * @desc move the editor to the current editor point
      */
     moveEditor: function() {
-        var cellBounds = this.event.bounds;
-
-        //hack to accommodate bootstrap margin issues...
-        var xOffset =
-            this.grid.div.getBoundingClientRect().left -
-            this.grid.divCanvas.getBoundingClientRect().left;
-
-        cellBounds.x -= xOffset;
-
-        this.setBounds(cellBounds);
+        this.setBounds(this.event.bounds);
     },
 
     beginEditing: function() {
-        if (this.grid.fireRequestCellEdit(this.event.gridCell, this.initialValue)) {
+        if (this.grid.fireRequestCellEdit(this.event, this.initialValue)) {
             this.checkEditorPositionFlag = true;
             this.checkEditor();
         }
@@ -209,8 +234,14 @@ var CellEditor = Base.extend('CellEditor', {
      * 1. If `feedback` was omitted, cancels editing, discarding the edited value.
      * 2. If `feedback` was provided, gives the user some feedback (see `feedback`, below).
      *
-     * @param {number} [feedback] What to do on validation failure:
-     * * If omitted, simply cancels editing without saving edited value.
+     * @param {number} [feedback] What to do on validation failure. One of:
+     * * **`undefined`** - Do not show the error effect or the end effect. Just discard the value and close the editor (as if `ESC` had been typed).
+     * * **`0`** - Just shows the error effect (see the {@link CellEditor#errorEffect|errorEffect} property).
+     * * **`1`** - Shows the error feedback effect followed by the detailed explanation.
+     * * `2` or more:
+     *   1. Shows the error feedback effect
+     *   2. On every `feedback` tries, shows the detailed explanation.
+     * * If `undefined` (omitted), simply cancels editing without saving edited value.
      * * If 0, shows the error feedback effect (see the {@link CellEditor#errorEffect|errorEffect} property).
      * * If > 0, shows the error feedback effect _and_ calls the {@link CellEditor#errorEffectEnd|errorEffectEnd} method) every `feedback` call(s) to `stopEditing`.
      * @returns {boolean} Truthy means successful stop. Falsy means syntax error prevented stop. Note that editing is canceled when no feedback requested and successful stop includes (successful) cancel.
@@ -242,9 +273,7 @@ var CellEditor = Base.extend('CellEditor', {
             this.hideEditor();
             this.grid.cellEditor = null;
             this.el.remove();
-        } else if (feedback >= 0) { // never true when `feedback` undefined
-            var point = this.event.gridCell;
-            this.grid.selectViewportCell(point.x, point.y - this.grid.getHeaderRowCount());
+        } else if (feedback >= 0) { // false when `feedback` undefined
             this.errorEffectBegin(++this.errors % feedback === 0 && error);
         } else { // invalid but no feedback
             this.cancelEditing();
@@ -266,27 +295,21 @@ var CellEditor = Base.extend('CellEditor', {
     },
 
     /**
-     * Calls the effect function indicated in the {@link CellEditor#errorEffect|errorEffect} property which triggers a series of CSS transitions.
+     * Calls the effect function indicated in the {@link module:defaults.feedbackEffect|feedbackEffect} property, which triggers a series of CSS transitions.
      * @param {boolean|string|Error} [error] - If defined, call the {@link CellEditor#errorEffectEnd|errorEffectEnd} method at the end of the last effect transition with this error.
      * @memberOf CellEditor.prototype
      */
     errorEffectBegin: function(error) {
-        var options = { callback: error && this.errorEffectEnd.bind(this, error) },
-            effect = this.errorEffect;
+        var spec = this.grid.properties.feedbackEffect, // spec may e a string or an object with name and options props
+            options = Object.assign({}, spec.options), // if spec is a string, spec.options will be undefined
+            effect = effects[spec.name || spec]; // if spec is a string, spec.name will be undefined
 
-        if (typeof effect === 'string') {
-            effect = this.errorEffects[effect];
-        }
-
-        if (typeof effect === 'object') {
-            _(options).extendOwn(effect.options);
-            effect = effect.effector;
+        if (error) {
+            options.callback = this.errorEffectEnd.bind(this, error);
         }
 
-        if (typeof effect === 'function') {
+        if (effect) {
             effect.call(this, options);
-        } else {
-            throw 'Expected `this.errorEffect` to resolve to an error effect function.';
         }
     },
 
@@ -295,7 +318,7 @@ var CellEditor = Base.extend('CellEditor', {
      * @this {CellEditor}
      * @param {boolean|string|Error} [error]
      */
-    errorEffectEnd: function(error) {
+    errorEffectEnd: function(error, options) {
         if (error) {
             var msg =
                 'Invalid value. To resolve, do one of the following:\n\n' +
@@ -321,42 +344,22 @@ var CellEditor = Base.extend('CellEditor', {
                 msg += '\n\nAdditional information about this error: ' + error;
             }
 
-            alert(msg); // eslint-disable-line no-alert
+            setTimeout(function() { // allow animation to complete
+                alert(msg); // eslint-disable-line no-alert
+            });
         }
     },
 
-    /** @typedef effectObject
-     * @property {effectFunction} effector
-     * @property {object} [options] - An options object with which to call the function.
-     */
-    /**
-     * May be one of:
-     * * **string** - Name of registered error effect.
-     * * **effectFunction** - Reference to an effect function.
-     * * **effectObject** - Reference to an effectObject containing an {@link effectFunction} and an `options` object with which to call the function.
-     * @type {string|effectFunction|effectObject}
-     * @memberOf CellEditor.prototype
-     */
-    errorEffect: 'shaker',
-
-    /**
-     * Hash of registered {@link effectFunction}s or {@link effectObject}s.
-     * @memberOf CellEditor.prototype
-     */
-    errorEffects: {
-        shaker: effects.shaker,
-        glower: effects.glower
-    },
-
     /**
      * @desc save the new value into the behavior (model)
      * @returns {boolean} Data changed and pre-cell-edit event was not canceled.
      * @memberOf CellEditor.prototype
      */
     saveEditorValue: function(value) {
-        var save =
+        var save = (
             !(value && value === this.initialValue) && // data changed
-            this.grid.fireBeforeCellEdit(this.event.gridCell, this.initialValue, value, this); // proceed
+            this.grid.fireBeforeCellEdit(this.event.gridCell, this.initialValue, value, this) // proceed
+        );
 
         if (save) {
             this.grid.behavior.setValue(this.event, value);
diff --git a/src/cellEditors/ComboBox.js b/src/cellEditors/ComboBox.js
index 5ed3031..a5c054a 100644
--- a/src/cellEditors/ComboBox.js
+++ b/src/cellEditors/ComboBox.js
@@ -9,7 +9,6 @@
 var Textfield = require('./Textfield');
 var prototype = require('./CellEditor').prototype;
 var Queueless = require('../lib/DOM/queueless');
-var elfor = require('../lib/DOM/elfor');
 
 /*********************************/
 /* eslint-disable no-unused-vars */
@@ -98,44 +97,52 @@ var ComboBox = Textfield.extend('ComboBox', {
     ],
 
     showEditor: function() {
-        var menuModesSource = this.menuModesSource,
-            menuModes = this.menuModes = {};
-
-        // build the proxy
-        this.modes.forEach(function(mode) {
-            var modeName = mode.name;
-            if (modeName in menuModesSource) {
-                menuModes[modeName] = menuModesSource[modeName];
-            }
-        });
-
-        // wire-ups
-        if (this.controllable) {
-            this.controls.addEventListener('click', onModeIconClick.bind(this));
-        }
-
         // set the initial state of the mode toggles
-        this.modes.forEach(function(mode) {
-            // create a toggle
-            var toggle = document.createElement('span');
+        if (!this.built) {
+            var menuModesSource = this.menuModesSource,
+                menuModes = this.menuModes = {};
+
+            // build the proxy
+            this.modes.forEach(function(mode) {
+                var modeName = mode.name;
+                if (modeName in menuModesSource) {
+                    menuModes[modeName] = menuModesSource[modeName];
+                }
+            });
+
+            // wire-ups
             if (this.controllable) {
-                toggle.className = TOGGLE_MODE_PREFIX + mode.name;
-                toggle.title = 'Toggle ' + (mode.label || mode.name).toLowerCase();
-                toggle.textContent = mode.symbol;
-            }
-            this.controls.appendChild(toggle);
-
-            // create and label a new optgroup
-            if (mode.selector) {
-                var optgroup = document.createElement('optgroup');
-                optgroup.label = mode.label;
-                optgroup.className = 'submenu-' + mode.name;
-                optgroup.style.backgroundColor = mode.backgroundColor;
-                this.dropdown.add(optgroup);
+                this.controls.addEventListener('click', onModeIconClick.bind(this));
             }
 
-            setModeIconAndOptgroup.call(this, toggle, mode.name, menuModes[mode.name]);
-        }.bind(this));
+            this.modes.forEach(function(mode) {
+                // create a toggle
+                var toggle = document.createElement('span');
+                if (this.controllable) {
+                    toggle.className = TOGGLE_MODE_PREFIX + mode.name;
+                    toggle.title = 'Toggle ' + (mode.label || mode.name).toLowerCase();
+                    if (mode.tooltip) {
+                        toggle.title += '\n' + mode.tooltip;
+                    }
+                    toggle.textContent = mode.symbol;
+                }
+
+                this.controls.appendChild(toggle);
+
+                // create and label a new optgroup
+                if (mode.selector) {
+                    var optgroup = document.createElement('optgroup');
+                    optgroup.label = mode.label;
+                    optgroup.className = 'submenu-' + mode.name;
+                    optgroup.style.backgroundColor = mode.backgroundColor;
+                    this.dropdown.add(optgroup);
+                }
+
+                setModeIconAndOptgroup.call(this, toggle, mode.name, menuModes[mode.name]);
+            }, this);
+
+            this.built = true;
+        }
 
         prototype.showEditor.call(this);
     },
@@ -183,7 +190,8 @@ function onModeIconClick(e) {
 function setModeIconAndOptgroup(ctrl, name, state) {
     var style, optgroup, sum, display,
         dropdown = this.dropdown,
-        mode = this.modes.find(function(mode) { return mode.name === name; }); // eslint-disable-line no-shadow
+        mode = this.modes.find(function(mode) { return mode.name === name; }), // eslint-disable-line no-shadow
+        selector = mode.selector;
 
     // set icon state (color)
     ctrl.classList.toggle('active', !!state);
@@ -195,8 +203,8 @@ function setModeIconAndOptgroup(ctrl, name, state) {
         style.cursor = 'progress';
         setTimeout(function() { style.cursor = null; }, 333);
 
-        if (mode.selector) {
-            optgroup = dropdown.querySelector(mode.selector);
+        if (selector) {
+            optgroup = dropdown.querySelector(selector);
             sum = mode.appendOptions.call(this, optgroup);
 
             // update sum
@@ -215,12 +223,11 @@ function setModeIconAndOptgroup(ctrl, name, state) {
     }
 
     // hide/show the group
-    var selector = mode.selector;
     if (!selector) {
         selector = 'option,optgroup:not([class])';
         var mustBeChildren = true; // work-around for ':scope>option,...' not avail in IE11
     }
-    elfor.each(selector, iteratee, dropdown);
+    Array.prototype.forEach.call(dropdown.querySelectorAll(selector), iteratee);
 
     function iteratee(el) {
         if (!mustBeChildren || el.parentElement === dropdown) {
@@ -244,7 +251,7 @@ function slideDown() {
     this.options.style.visibility = 'visible';
     var dropDownTopMargin = getFloat(this.dropdown, 'marginTop'),
         dropDownRows = this.dropdown.size,
-        optionHeight = Math.ceil((this.dropdown.length ? getFloat(this.dropdown[0], 'height') : 13.1875) * 2) / 2 + 1;
+        optionHeight = Math.ceil((this.dropdown.length && getFloat(this.dropdown[0], 'height') || 13.1875) * 2) / 2 + 1;
     this.options.style.height = dropDownTopMargin + optionHeight * dropDownRows + 'px'; // starts the slide down effect
 
     // while in drop-down, listen for clicks in text box which means abprt
diff --git a/src/cellEditors/FilterBox.js b/src/cellEditors/FilterBox.js
index 0ec73f8..39f2a37 100644
--- a/src/cellEditors/FilterBox.js
+++ b/src/cellEditors/FilterBox.js
@@ -5,7 +5,7 @@
 var popMenu = require('pop-menu');
 
 var ComboBox = require('./ComboBox');
-var prototype = require('./CellEditor').prototype;
+var CellEditor = require('./CellEditor');
 
 
 /**
@@ -71,7 +71,7 @@ var FilterBox = ComboBox.extend('FilterBox', {
 
     },
 
-    abortEditing: prototype.cancelEditing,
+    abortEditing: CellEditor.prototype.cancelEditing,
 
     /**
      * When there's only one mode defined here, the control area portion of the UI is hidden.
@@ -102,10 +102,13 @@ var FilterBox = ComboBox.extend('FilterBox', {
             name: 'columnNames',
             label: 'Column Names',
             selector: 'optgroup.submenu-columnNames',
+            tooltip: '(Hold down alt/option key while clicking to include hidden column names.)',
             symbol: 'A',
             backgroundColor: '#eff',
             appendOptions: function(optgroup) {
-                var columns = this.grid.behavior.columns,
+                var columns = window.event.altKey
+                        ? this.grid.behavior.getColumns()
+                        : this.grid.behavior.getActiveColumns(),
                     x = this.event.gridCell.x;
 
                 while (optgroup.firstElementChild) {
@@ -152,13 +155,15 @@ var FilterBox = ComboBox.extend('FilterBox', {
         ComboBox.prototype.hideEditor.call(this);
     },
 
-    keyup: function(e) {
-        if (e) {
-            prototype.keyup.call(this, e);
-
-            if (this.grid.properties.filteringMode === 'immediate') {
+    keyup: function(event) {
+        if (
+            !CellEditor.prototype.keyup.call(this, event) &&
+            this.grid.properties.filteringMode === 'immediate'
+        ) {
+            try {
                 this.saveEditorValue(this.getEditorValue());
-                this.moveEditor();
+            } catch (err) {
+                // ignore syntax errors in immediate mode
             }
         }
     },
@@ -207,11 +212,20 @@ var FilterBox = ComboBox.extend('FilterBox', {
     },
 
     saveEditorValue: function(value) {
-        prototype.saveEditorValue.call(this, value);
-        this.grid.behavior.applyAnalytics();
+        CellEditor.prototype.saveEditorValue.call(this, value);
+        this.grid.behavior.reindex();
+    },
+
+    stopEditing: function(feedbackCount) {
+        var result = CellEditor.prototype.stopEditing.call(this, feedbackCount);
+
+        if (result) {
+            this.grid.clearSelections();
+        }
+
+        return result;
     }
 
 });
 
-
 module.exports = FilterBox;
diff --git a/src/cellEditors/Textfield.js b/src/cellEditors/Textfield.js
index 636581f..7706a8c 100644
--- a/src/cellEditors/Textfield.js
+++ b/src/cellEditors/Textfield.js
@@ -15,7 +15,7 @@ var Textfield = CellEditor.extend('Textfield', {
     template: '<input type="text" lang="{{locale}}" class="hypergrid-textfield" style="{{style}}">',
 
     initialize: function() {
-        this.input.style.textAlign = this.event.getCellProperty('halign');
+        this.input.style.textAlign = this.event.properties.halign;
     },
 
     localizer: Localization.prototype.string,
diff --git a/src/cellEditors/index.js b/src/cellEditors/index.js
index 676d7ff..68ce923 100644
--- a/src/cellEditors/index.js
+++ b/src/cellEditors/index.js
@@ -1,7 +1,3 @@
-/**
- * @module cellEditors
- */
-
 'use strict';
 
 /**
@@ -48,7 +44,7 @@ CellEditors.prototype = {
      *
      * @returns {CellEditor} A newly registered constructor extended from {@link CellEditor}.
      *
-     * @memberOf module:cellEditors
+     * @memberOf CellEditors#
      */
     add: function(name, Constructor) {
         if (typeof name === 'function') {
@@ -67,7 +63,7 @@ CellEditors.prototype = {
      * @param {string} synonymName
      * @param {string} existingName
      * @returns {CellEditor} The previously registered constructor this new synonym points to.
-     * @memberOf CellEditors.prototype
+     * @memberOf CellEditors#
      */
     addSynonym: function(synonymName, existingName) {
         var cellEditor = this.get(existingName);
@@ -77,7 +73,7 @@ CellEditors.prototype = {
     /**
      * @param {string} name - Name of a registered editor.
      * @returns {CellEditor} A registered constructor extended from {@link CellEditor}.
-     * @memberOf CellEditors.prototype
+     * @memberOf CellEditors#
      */
     get: function(name) {
         return this.editors[name && name.toLowerCase()];
@@ -89,7 +85,7 @@ CellEditors.prototype = {
      * @returns {CellEditor} New instance of the named cell editor.
      * @param {string} name - Name of a registered editor.
      * @param {string} [options] - Properties to add to the instantiated editor primarily for mustache's use.
-     * @memberOf CellEditors.prototype
+     * @memberOf CellEditors#
      */
     create: function(name, options) {
         var cellEditor,
@@ -108,7 +104,7 @@ CellEditors.prototype = {
     /**
      * The cell editor registry containing all the "preregistered" cell editor constructors.
      * @private
-     * @memberOf CellEditors.prototype
+     * @memberOf CellEditors#
      */
     editors: {}
 };
diff --git a/src/cellRenderers/Button.js b/src/cellRenderers/Button.js
index f1d2737..f0d08c5 100644
--- a/src/cellRenderers/Button.js
+++ b/src/cellRenderers/Button.js
@@ -15,8 +15,8 @@ var Button = CellRenderer.extend('Button', {
      */
     paint: function(gc, config) {
         var val = config.value,
-            c = config.x,
-            r = config.y,
+            c = config.dataCell.x,
+            r = config.gridCell.y,
             bounds = config.bounds,
             x = bounds.x + 1,
             y = bounds.y + 1,
@@ -34,21 +34,21 @@ var Button = CellRenderer.extend('Button', {
         }
 
         // draw the background
-        gc.fillStyle = config.backgroundColor;
+        gc.cache.fillStyle = config.backgroundColor;
         gc.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
 
         // draw the capsule
-        gc.fillStyle = arcGradient;
-        gc.strokeStyle = '#000000';
+        gc.cache.fillStyle = arcGradient;
+        gc.cache.strokeStyle = '#000000';
         this.roundRect(gc, x, y, width, height, radius, arcGradient, true);
 
-        var ox = (width - config.getTextWidth(gc, val)) / 2;
-        var oy = (height - config.getTextHeight(gc.font).descent) / 2;
+        var ox = (width - gc.getTextWidth(val)) / 2;
+        var oy = (height - gc.getTextHeight(gc.cache.font).descent) / 2;
 
         // draw the text
-        gc.textBaseline = 'middle';
-        gc.fillStyle = '#333333';
-        gc.font = height - 2 + 'px sans-serif';
+        gc.cache.textBaseline = 'middle';
+        gc.cache.fillStyle = '#333333';
+        gc.cache.font = height - 2 + 'px sans-serif';
         config.backgroundColor = 'rgba(0,0,0,0)';
         gc.fillText(val, x + ox, y + oy);
 
diff --git a/src/cellRenderers/CellRenderer.js b/src/cellRenderers/CellRenderer.js
index 8cfe97e..ad2295c 100644
--- a/src/cellRenderers/CellRenderer.js
+++ b/src/cellRenderers/CellRenderer.js
@@ -5,7 +5,7 @@ var Base = require('../Base');
 /** @typedef paintFunction
  * @type {function}
  * @this {CellEditor}
- * @param {CanvasGraphicsContext} gc
+ * @param {CanvasRenderingContext2D} gc
  * @param {object} config
  * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
  * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
@@ -30,7 +30,7 @@ var CellRenderer = Base.extend('CellRenderer', {
 
     /**
      * @desc A simple implementation of rounding a cell.
-     * @param {CanvasGraphicsContext} gc
+     * @param {CanvasRenderingContext2D} gc
      * @param {number} x - the x grid coordinate of my origin
      * @param {number} y - the y grid coordinate of my origin
      * @param {number} width - the width I'm allowed to draw within
diff --git a/src/cellRenderers/ErrorCell.js b/src/cellRenderers/ErrorCell.js
index e1461ce..b0e5f41 100644
--- a/src/cellRenderers/ErrorCell.js
+++ b/src/cellRenderers/ErrorCell.js
@@ -24,45 +24,28 @@ var ErrorCell = CellRenderer.extend('ErrorCell', {
      *
      * Before doing anything else, this function should clear the cell by setting `gc.fillStyle` and calling `gc.fill()`.
      *
-     * @param {CanvasGraphicsContext} gc
+     * @param {CanvasRenderingContext2D} gc
      * @param {object} config
      * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
-     * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
-     * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
-     * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
-     * @param {number} config.y - the vertical grid coordinate measured from top header row
      * @memberOf ErrorCell.prototype
      */
     paint: function(gc, config, message) {
         //var images = require('../../images/index');
         var x = config.bounds.x,
             y = config.bounds.y,
-            width = config.bounds.width,
+            // width = config.bounds.width,
             height = config.bounds.height;
 
         // clear the cell
         // (this makes use of the rect path defined by the caller)
-        gc.fillStyle = '#FFD500';
+        gc.cache.fillStyle = '#FFD500';
         gc.fill();
-        // render cell border
-        //gc.strokeStyle = gc.createPattern(images.caution, 'repeat'); // Causes Error
-        gc.lineWidth = 5;
-        gc.beginPath();
-        gc.moveTo(x, y); // caution: do not use rect() here because Chrome does not clip its stroke properly
-        gc.lineTo(x + width, y);
-        gc.lineTo(x + width, y + height);
-        gc.lineTo(x, y + height);
-        gc.lineTo(x, y);
-        gc.stroke();
-        // adjust clip region to prevent text from rendering over right border should it overflow
-        gc.beginPath();
-        gc.rect(x, y, width - 2, height);
-        gc.clip();
+
         // render message text
-        gc.fillStyle = '#A00';
-        gc.textAlign = 'start';
-        gc.textBaseline = 'middle';
-        gc.font = 'bold 6pt "arial narrow", verdana, geneva';
+        gc.cache.fillStyle = '#A00';
+        gc.cache.textAlign = 'start';
+        gc.cache.textBaseline = 'middle';
+        gc.cache.font = 'bold 6pt "arial narrow", verdana, geneva';
         gc.fillText(message, x + 4, y + height / 2 + 0.5);
     }
 });
diff --git a/src/cellRenderers/LastSelection.js b/src/cellRenderers/LastSelection.js
index 0bd01fe..a6d5797 100644
--- a/src/cellRenderers/LastSelection.js
+++ b/src/cellRenderers/LastSelection.js
@@ -14,41 +14,32 @@ var LastSelection = CellRenderer.extend('LastSelection', {
      * @memberOf LastSelection.prototype
      */
     paint: function(gc, config) {
-        var x = config.bounds.x,
-            y = config.bounds.y,
-            width = config.bounds.width,
-            height = config.bounds.height;
-
-        // var focusLineStep =  [
-        //     [5, 5],
-        //     [0, 1, 5, 4],
-        //     [0, 2, 5, 3],
-        //     [0, 3, 5, 2],
-        //     [0, 4, 5, 1],
-        //     [0, 5, 5, 0],
-        //     [1, 5, 4, 0],
-        //     [2, 5, 3, 0],
-        //     [3, 5, 2, 0],
-        //     [4, 5, 1, 0]
-        // ];
-        gc.rect(x + 1, y, width - 2, height - 2);
-        gc.fillStyle = config.selectionRegionOverlayColor;
-        gc.fill();
-        gc.lineWidth = 1;
-        gc.strokeStyle = config.selectionRegionOutlineColor;
-
-        // animate the dashed line a bit here for fun
-
-        gc.stroke();
-
-        // gc.rect(x, y, width, height);
-        //
-        // gc.strokeStyle = 'white';
-        //
-        // //animate the dashed line a bit here for fun
-        // gc.setLineDash(focusLineStep[Math.floor(10 * (Date.now() / 300 % 1)) % focusLineStep.length]);
-        //
-        // gc.stroke();
+        var visOverlay = gc.alpha(config.selectionRegionOverlayColor) > 0,
+            visOutline = gc.alpha(config.selectionRegionOutlineColor) > 0;
+
+        if (visOverlay || visOutline) {
+            var x = config.bounds.x,
+                y = config.bounds.y,
+                width = config.bounds.width,
+                height = config.bounds.height;
+
+            gc.beginPath();
+
+            gc.rect(x, y, width, height);
+
+            if (visOverlay) {
+                gc.cache.fillStyle = config.selectionRegionOverlayColor;
+                gc.fill();
+            }
+
+            if (visOutline) {
+                gc.cache.lineWidth = 1;
+                gc.cache.strokeStyle = config.selectionRegionOutlineColor;
+                gc.stroke();
+            }
+
+            gc.closePath();
+        }
     }
 });
 
diff --git a/src/cellRenderers/SimpleCell.js b/src/cellRenderers/SimpleCell.js
index e7400f9..749065a 100644
--- a/src/cellRenderers/SimpleCell.js
+++ b/src/cellRenderers/SimpleCell.js
@@ -1,6 +1,9 @@
 'use strict';
 
 var CellRenderer = require('./CellRenderer');
+var images = require('../../images/index');
+
+var WHITESPACE = /\s\s+/g;
 
 /**
  * @constructor
@@ -10,7 +13,7 @@ var SimpleCell = CellRenderer.extend('SimpleCell', {
 
     /**
      * @summary The default cell rendering function for rendering a vanilla cell.
-     * @desc Great care has been taken in crafting this function as it needs to perform extremely fast. Reads on the gc object are expensive but not quite as expensive as writes to it. We do our best to avoid writes, then avoid reads. Clipping bounds are not set here as this is also an expensive operation. Instead, we truncate overflowing text and content by filling a rectangle with background color column by column instead of cell by cell.  This column by column fill happens higher up on the stack in a calling function from fin-hypergrid-renderer.  Take note we do not do cell by cell border renderering as that is expensive.  Instead we render many fewer gridlines after all cells are rendered.
+     * @desc Great care has been taken in crafting this function as it needs to perform extremely fast. Reads on the gc object are expensive but not quite as expensive as writes to it. We do our best to avoid writes, then avoid reads. Clipping bounds are not set here as this is also an expensive operation. Instead, we truncate overflowing text and content by filling a rectangle with background color column by column instead of cell by cell.  This column by column fill happens higher up on the stack in a calling function from fin-hypergrid-renderer.  Take note we do not do cell by cell border rendering as that is expensive.  Instead we render many fewer gridlines after all cells are rendered.
      * @implements paintFunction
      * @memberOf SimpleCell.prototype
      */
@@ -21,257 +24,296 @@ var SimpleCell = CellRenderer.extend('SimpleCell', {
             y = bounds.y,
             width = bounds.width,
             height = bounds.height,
-            leftPadding = 2; //TODO: fix this
-
-        var leftIcon, rightIcon, centerIcon, ixoffset, iyoffset, font;
+            iconPadding = config.iconPadding,
+            partialRender = config.prefillColor === undefined, // signifies abort before rendering if same
+            snapshot = config.snapshot,
+            same = snapshot && partialRender,
+            valWidth = 0,
+            textColor, textFont,
+            ixoffset, iyoffset,
+            leftIcon, rightIcon, centerIcon,
+            leftPadding, rightPadding,
+            hover, hoverColor, selectColor, foundationColor, inheritsBackgroundColor,
+            c, colors;
 
         // setting gc properties are expensive, let's not do it needlessly
 
         if (val && val.constructor === Array) {
             leftIcon = val[0];
             rightIcon = val[2];
-            val = val[1];
-            if (val && typeof val === 'object') {
-                if (val.constructor.name === 'HTMLImageElement') { // must be an image
-                    centerIcon = val;
-                    val = null;
-                }
-            }
-            if (leftIcon && leftIcon.nodeName !== 'IMG') {
-                leftIcon = null;
-            }
-            if (rightIcon && rightIcon.nodeName !== 'IMG') {
-                rightIcon = null;
-            }
-            if (centerIcon && centerIcon.nodeName !== 'IMG') {
-                centerIcon = null;
+            val = config.exec(val[1]);
+            if (val && val.naturalWidth !== undefined) { // must be an image (much faster than instanceof HTMLImageElement)
+                centerIcon = val;
+                val = null;
             }
+        } else {
+            leftIcon = images[config.leftIcon];
+            centerIcon = images[config.centerIcon];
+            rightIcon = images[config.rightIcon];
         }
 
-        if (config.isUserDataArea) {
-            val = valOrFunc(val, config, config.calculator);
-        }
+        // Note: vf == 0 is fastest equivalent of vf === 0 || vf === false which excludes NaN, null, undefined
+        var renderValue = val || config.renderFalsy && val == 0; // eslint-disable-line eqeqeq
 
-        val = config.formatValue(val);
+        if (renderValue) {
+            val = config.formatValue(val, config);
 
-        font = config.isSelected ? config.foregroundSelectionFont : config.font;
+            textFont = config.isSelected ? config.foregroundSelectionFont : config.font;
 
-        if (gc.font !== font) {
-            gc.font = font;
+            textColor = gc.cache.strokeStyle = config.isSelected
+                ? config.foregroundSelectionColor
+                : config.color;
+        } else {
+            val = '';
         }
 
-        if (gc.textAlign !== 'left') {
-            gc.textAlign = 'left';
-        }
-        if (gc.textBaseline !== 'middle') {
-            gc.textBaseline = 'middle';
-        }
+        same = same &&
+            val === snapshot.value &&
+            textFont === snapshot.textFont &&
+            textColor === snapshot.textColor;
 
         // fill background only if our bgColor is populated or we are a selected cell
-        var backgroundColor, hover, hoverColor, selectColor,
-            colors = [];
-
+        colors = [];
+        c = 0;
         if (config.isCellHovered && config.hoverCellHighlight.enabled) {
             hoverColor = config.hoverCellHighlight.backgroundColor;
         } else if (config.isRowHovered && (hover = config.hoverRowHighlight).enabled) {
-            hoverColor = config.isGridColumn || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
+            hoverColor = config.isDataColumn || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
         } else if (config.isColumnHovered && (hover = config.hoverColumnHighlight).enabled) {
-            hoverColor = config.isGridRow || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
+            hoverColor = config.isDataRow || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
         }
-        if (alpha(hoverColor) < 1) {
+        if (gc.alpha(hoverColor) < 1) {
             if (config.isSelected) {
-                selectColor = valOrFunc(config.backgroundSelectionColor, config);
+                selectColor = config.backgroundSelectionColor;
             }
-            if (alpha(selectColor) < 1) {
-                backgroundColor = valOrFunc(config.backgroundColor, config);
-                if (alpha(backgroundColor) > 0) {
-                    colors.push(backgroundColor);
+
+            if (gc.alpha(selectColor) < 1) {
+                inheritsBackgroundColor = (config.backgroundColor === config.prefillColor);
+                if (!inheritsBackgroundColor) {
+                    foundationColor = true;
+                    colors.push(config.backgroundColor);
+                    same = same &&  foundationColor === snapshot.foundationColor &&
+                        config.backgroundColor === snapshot.colors[c++];
                 }
             }
+
             if (selectColor !== undefined) {
                 colors.push(selectColor);
+                same = same && selectColor === snapshot.colors[c++];
             }
         }
         if (hoverColor !== undefined) {
             colors.push(hoverColor);
+            same = same && hoverColor === snapshot.colors[c++];
         }
-        layerColors(gc, colors, x, y, width, height);
 
-        // draw text
-        var theColor = valOrFunc(config.isSelected ? config.foregroundSelectionColor : config.color, config);
-        if (gc.fillStyle !== theColor) {
-            gc.fillStyle = theColor;
-            gc.strokeStyle = theColor;
+        // todo check if icons have changed
+        if (same && c === snapshot.colors.length) {
+            return;
         }
 
-        if (config.isHeaderRow && config.headerTextWrapping) {
-            this.renderMultiLineText(gc, config, val);
-        } else {
-            this.renderSingleLineText(gc, config, val);
+        // return a snapshot to save in cellEvent for future comparisons by partial renderer
+        config.snapshot = {
+            value: val,
+            textColor: textColor,
+            textFont: textFont,
+            foundationColor: foundationColor,
+            colors: colors
+        };
+
+        layerColors(gc, colors, x, y, width, height, foundationColor);
+
+        // Measure left and right icons, needed for rendering and for return value (min width)
+        leftPadding = leftIcon ? iconPadding + leftIcon.width + iconPadding : config.cellPadding;
+        rightPadding = rightIcon ? iconPadding + rightIcon.width + iconPadding : config.cellPadding;
+
+        if (renderValue) {
+            // draw text
+            gc.cache.fillStyle = textColor;
+            gc.cache.font = textFont;
+            valWidth = config.isHeaderRow && config.headerTextWrapping
+                ? renderMultiLineText(gc, config, val, leftPadding, rightPadding)
+                : renderSingleLineText(gc, config, val, leftPadding, rightPadding);
+        } else if (centerIcon) {
+            // Measure & draw center icon
+            iyoffset = Math.round((height - centerIcon.height) / 2);
+            ixoffset = Math.round((width - centerIcon.width) / 2);
+            gc.drawImage(centerIcon, x + width - ixoffset - centerIcon.width, y + iyoffset);
+            valWidth = iconPadding + centerIcon.width + iconPadding;
         }
 
-        var iconWidth = 0;
         if (leftIcon) {
+            // Draw left icon
             iyoffset = Math.round((height - leftIcon.height) / 2);
-            gc.drawImage(leftIcon, x + leftPadding, y + iyoffset);
-            iconWidth = Math.max(leftIcon.width + 2);
+            gc.drawImage(leftIcon, x + iconPadding, y + iyoffset);
         }
-        if (rightIcon && width > 1.75 * height) {
-            iyoffset = Math.round((height - rightIcon.height) / 2);
-            var rightX = x + width - rightIcon.width;
-            if (backgroundColor !== undefined) {
-                layerColors(gc, colors, rightX, y, rightIcon.width, height);
-            } else {
-                gc.clearRect(rightX, y, rightIcon.width, height);
+
+        if (rightIcon) {
+            // Repaint background before painting right icon, because text may have flowed under where it will be.
+            // This is a work-around to clipping which is too expensive to perform here.
+            var rightX = x + width - (rightIcon.width + iconPadding);
+            if (inheritsBackgroundColor) {
+                foundationColor = true;
+                colors.unshift(config.backgroundColor);
             }
+            layerColors(gc, colors, rightX, y, rightPadding, height, foundationColor);
+
+            // Draw right icon
+            iyoffset = Math.round((height - rightIcon.height) / 2);
             gc.drawImage(rightIcon, rightX, y + iyoffset);
-            iconWidth = Math.max(rightIcon.width + 2);
-        }
-        if (centerIcon) {
-            iyoffset = Math.round((height - centerIcon.height) / 2);
-            ixoffset = Math.round((width - centerIcon.width) / 2);
-            gc.drawImage(centerIcon, x + width - ixoffset - centerIcon.width, y + iyoffset);
-            iconWidth = Math.max(centerIcon.width + 2);
         }
+
         if (config.cellBorderThickness) {
             gc.beginPath();
             gc.rect(x, y, width, height);
-            gc.lineWidth = config.cellBorderThickness;
-            gc.strokeStyle = config.cellBorderStyle;
-
-            // animate the dashed line a bit here for fun
-
+            gc.cache.lineWidth = config.cellBorderThickness;
+            gc.cache.strokeStyle = config.cellBorderStyle;
             gc.stroke();
             gc.closePath();
         }
-        config.minWidth = config.minWidth + 2 * (iconWidth);
-    },
 
-    /**
-     * @summary Renders single line text.
-     * @param {CanvasGraphicsContext} gc
-     * @param {object} config
-     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
-     * @param {*} val - The text to render in the cell.
-     * @memberOf SimpleCell.prototype
-     */
-    renderMultiLineText: function(gc, config, val) {
-        var x = config.bounds.x,
-            y = config.bounds.y,
-            width = config.bounds.width,
-            height = config.bounds.height;
-        var lines = fitText(gc, config, val, width);
-        if (lines.length === 1) {
-            return this.renderSingleLineText(gc, config, squeeze(val));
-        }
+        config.minWidth = leftPadding + valWidth + rightPadding;
+    }
+});
+
+/**
+ * @summary Renders single line text.
+ * @param {CanvasRenderingContext2D} gc
+ * @param {object} config
+ * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
+ * @param {*} val - The text to render in the cell.
+ * @memberOf SimpleCell.prototype
+ */
+function renderMultiLineText(gc, config, val, leftPadding, rightPadding) {
+    var x = config.bounds.x,
+        y = config.bounds.y,
+        width = config.bounds.width,
+        height = config.bounds.height,
+        cleanVal = (val + '').trim().replace(WHITESPACE, ' '), // trim and squeeze whitespace
+        lines = findLines(gc, config, cleanVal.split(' '), width);
+
+    if (lines.length === 1) {
+        return renderSingleLineText(gc, config, cleanVal, leftPadding, rightPadding);
+    }
 
-        var colHEdgeOffset = config.cellPadding,
-            halignOffset = 0,
-            valignOffset = config.voffset,
-            halign = config.halign,
-            textHeight = config.getTextHeight(config.font).height;
+    var halignOffset = leftPadding,
+        valignOffset = config.voffset,
+        halign = config.halign,
+        textHeight = gc.getTextHeight(config.font).height;
 
-        switch (halign) {
-            case 'right':
-                halignOffset = width - colHEdgeOffset;
-                break;
-            case 'center':
-                halignOffset = width / 2;
-                break;
-            case 'left':
-                halignOffset = colHEdgeOffset;
-                break;
-        }
+    switch (halign) {
+        case 'right':
+            halignOffset = width - rightPadding;
+            break;
+        case 'center':
+            halignOffset = width / 2;
+            break;
+    }
 
-        var hMin = 0, vMin = Math.ceil(textHeight / 2);
+    var hMin = 0, vMin = Math.ceil(textHeight / 2);
 
-        valignOffset += Math.ceil((height - (lines.length - 1) * textHeight) / 2);
+    valignOffset += Math.ceil((height - (lines.length - 1) * textHeight) / 2);
 
-        halignOffset = Math.max(hMin, halignOffset);
-        valignOffset = Math.max(vMin, valignOffset);
+    halignOffset = Math.max(hMin, halignOffset);
+    valignOffset = Math.max(vMin, valignOffset);
 
-        gc.save(); // define a clipping region for cell
-        gc.beginPath();
-        gc.rect(x, y, width, height);
-        gc.clip();
+    gc.cache.save(); // define a clipping region for cell
+    gc.beginPath();
+    gc.rect(x, y, width, height);
+    gc.clip();
 
-        gc.textAlign = halign;
+    gc.cache.textAlign = halign;
+    gc.cache.textBaseline = 'middle';
 
-        for (var i = 0; i < lines.length; i++) {
-            gc.fillText(lines[i], x + halignOffset, y + valignOffset + (i * textHeight));
-        }
+    for (var i = 0; i < lines.length; i++) {
+        gc.simpleText(lines[i], x + halignOffset, y + valignOffset + (i * textHeight));
+    }
 
-        gc.restore(); // discard clipping region
-    },
+    gc.cache.restore(); // discard clipping region
 
-    /**
-     * @summary Renders single line text.
-     * @param {CanvasGraphicsContext} gc
-     * @param {object} config
-     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
-     * @param {*} val - The text to render in the cell.
-     * @memberOf SimpleCell.prototype
-     */
-    renderSingleLineText: function(gc, config, val) {
-        var x = config.bounds.x,
-            y = config.bounds.y,
-            width = config.bounds.width,
-            height = config.bounds.height;
-        var colHEdgeOffset = config.cellPadding,
-            halignOffset = 0,
-            valignOffset = config.voffset,
-            halign = config.halign,
-            isCellHovered = config.isCellHovered,
-            isLink = config.link;
-
-        var fontMetrics = config.getTextHeight(config.font);
-        var textWidth = config.getTextWidth(gc, val);
-
-        //we must set this in order to compute the minimum width
-        //for column autosizing purposes
-        config.minWidth = textWidth + (2 * colHEdgeOffset);
+    return width;
+}
 
+/**
+ * @summary Renders single line text.
+ * @param {CanvasRenderingContext2D} gc
+ * @param {object} config
+ * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
+ * @param {*} val - The text to render in the cell.
+ * @memberOf SimpleCell.prototype
+ */
+function renderSingleLineText(gc, config, val, leftPadding, rightPadding) {
+    var x = config.bounds.x,
+        y = config.bounds.y,
+        width = config.bounds.width,
+        halignOffset = leftPadding,
+        halign = config.halign,
+        minWidth,
+        metrics;
+
+    if (config.columnAutosizing) {
+        metrics = gc.getTextWidthTruncated(val, width - leftPadding, config.truncateTextWithEllipsis);
+        minWidth = metrics.width;
+        val = metrics.string || val;
         switch (halign) {
             case 'right':
-                //textWidth = config.getTextWidth(gc, config.value);
-                halignOffset = width - colHEdgeOffset - textWidth;
+                halignOffset = width - rightPadding - metrics.width;
                 break;
             case 'center':
-                //textWidth = config.getTextWidth(gc, config.value);
-                halignOffset = (width - textWidth) / 2;
-                break;
-            case 'left':
-                halignOffset = colHEdgeOffset;
+                halignOffset = (width - metrics.width) / 2;
                 break;
         }
+    } else {
+        metrics = gc.getTextWidthTruncated(val, width - leftPadding, config.truncateTextWithEllipsis, true);
+        minWidth = 0;
+        if (metrics.string !== undefined) {
+            val = metrics.string;
+        } else {
+            switch (halign) {
+                case 'right':
+                    halignOffset = width - rightPadding - metrics.width;
+                    break;
+                case 'center':
+                    halignOffset = (width - metrics.width) / 2;
+                    break;
+            }
+        }
+    }
 
-        halignOffset = Math.max(0, halignOffset);
-        valignOffset += Math.ceil(height / 2);
+    if (val !== null) {
+        x += Math.max(leftPadding, halignOffset);
+        y += config.bounds.height / 2;
 
-        if (val !== null) {
-            gc.fillText(val, x + halignOffset, y + valignOffset);
-        }
+        if (config.isUserDataArea) {
+            if (config.link) {
+                if (config.isCellHovered || !config.linkOnHover) {
+                    if (config.linkColor) {
+                        gc.cache.strokeStyle = config.linkColor;
+                    }
+                    gc.beginPath();
+                    underline(config, gc, val, x, y, 1);
+                    gc.stroke();
+                    gc.closePath();
+                }
+                if (config.linkColor && (config.isCellHovered || !config.linkColorOnHover)) {
+                    gc.cache.fillStyle = config.linkColor;
+                }
+            }
 
-        if (isCellHovered) {
-            gc.beginPath();
-            if (isLink) {
-                underline(config, gc, val, x + halignOffset, y + valignOffset + Math.floor(fontMetrics.height / 2), 1);
+            if (config.strikeThrough === true) {
+                gc.beginPath();
+                strikeThrough(config, gc, val, x, y, 1);
                 gc.stroke();
+                gc.closePath();
             }
-            gc.closePath();
         }
-        if (config.strikeThrough === true) {
-            gc.beginPath();
-            strikeThrough(config, gc, val, x + halignOffset, y + valignOffset + Math.floor(fontMetrics.height / 2), 1);
-            gc.stroke();
-            gc.closePath();
-        }
-    }
-});
 
+        gc.cache.textAlign = 'left';
+        gc.cache.textBaseline = 'middle';
+        gc.simpleText(val, x, y);
+    }
 
-function fitText(gc, config, string, width) {
-    return findLines(gc, config, squeeze(string).split(' '), width);
+    return minWidth;
 }
 
 function findLines(gc, config, words, width) {
@@ -280,118 +322,83 @@ function findLines(gc, config, words, width) {
         return words;
     }
 
-    // starting with just the first word
+    // starting with just the first word...
     var stillFits, line = [words.shift()];
     while (
-        // so lone as line still fits within current column
-    (stillFits = config.getTextWidth(gc, line.join(' ')) < width)
-    // AND there are more words available
+        // so lone as line still fits within current column...
+    (stillFits = gc.getTextWidth(line.join(' ')) < width)
+    // ...AND there are more words available...
     && words.length
         ) {
-        // add another word to end of line and retest
+        // ...add another word to end of line and retest
         line.push(words.shift());
     }
 
     if (
-        !stillFits // if line is now too long
-        && line.length > 1 // AND is multiple words
+        !stillFits // if line is now too long...
+        && line.length > 1 // ...AND is multiple words...
     ) {
-        words.unshift(line.pop()); // back off by (i.e., remove) one word
+        words.unshift(line.pop()); // ...back off by (i.e., remove) one word
     }
 
     line = [line.join(' ')];
 
-    if (words.length) { // if there's anything left
-        line = line.concat(findLines(gc, config, words, width)); // break it up as well
+    if (words.length) { // if there's anything left...
+        line = line.concat(findLines(gc, config, words, width)); // ...break it up as well
     }
 
     return line;
 }
 
-// trim string; then reduce all runs of multiple spaces to a single space
-function squeeze(string) {
-    return (string + '').trim().replace(/\s\s+/g, ' ');
-}
-
 function strikeThrough(config, gc, text, x, y, thickness) {
-    var fontMetrics = config.getTextHeight(config.font);
-    var width = config.getTextWidth(gc, text);
-    y -= fontMetrics.height * 0.4;
+    var textWidth = gc.getTextWidth(text);
 
-    switch (gc.textAlign) {
+    switch (gc.cache.textAlign) {
         case 'center':
-            x -= width / 2;
+            x -= textWidth / 2;
             break;
         case 'right':
-            x -= width;
+            x -= textWidth;
             break;
     }
 
-    //gc.beginPath();
-    gc.lineWidth = thickness;
-    gc.moveTo(x + 0.5, y + 0.5);
-    gc.lineTo(x + width + 0.5, y + 0.5);
+    y = Math.round(y + 0.5) - 0.5;
+
+    gc.cache.lineWidth = thickness;
+    gc.moveTo(x - 1, y);
+    gc.lineTo(x + textWidth + 1, y);
 }
 
 function underline(config, gc, text, x, y, thickness) {
-    var width = config.getTextWidth(gc, text);
+    var textHeight = gc.getTextHeight(config.font).height,
+        textWidth = gc.getTextWidth(text);
 
-    switch (gc.textAlign) {
+    switch (gc.cache.textAlign) {
         case 'center':
-            x -= width / 2;
+            x -= textWidth / 2;
             break;
         case 'right':
-            x -= width;
+            x -= textWidth;
             break;
     }
 
-    //gc.beginPath();
-    gc.lineWidth = thickness;
-    gc.moveTo(x + 0.5, y + 0.5);
-    gc.lineTo(x + width + 0.5, y + 0.5);
-}
+    y = Math.round(y + textHeight / 2) - 0.5;
 
-function layerColors(gc, colors, x, y, width, height) {
-    colors.forEach(function(color) {
-        gc.fillStyle = color;
-        gc.fillRect(x, y, width, height);
-    });
+    //gc.beginPath();
+    gc.cache.lineWidth = thickness;
+    gc.moveTo(x, y);
+    gc.lineTo(x + textWidth, y);
 }
 
-function valOrFunc(vf, config, calculator) {
-    var result = vf;
-    if (config.isGridColumn && config.isGridRow && config.dataRow) {
-        calculator = (typeof vf)[0] === 'f' && vf || calculator;
-        if (calculator) {
-            result = calculator(config.dataRow, config.name);
+function layerColors(gc, colors, x, y, width, height, foundationColor) {
+    for (var i = 0; i < colors.length; i++) {
+        if (foundationColor && !i) {
+            gc.clearFill(x, y, width, height, colors[i]);
+        } else {
+            gc.cache.fillStyle = colors[i];
+            gc.fillRect(x, y, width, height);
         }
     }
-    return result || result === 0 || result === false ? result : '';
-}
-
-function alpha(cssColorSpec) {
-    if (cssColorSpec === undefined) {
-        // undefined so not visible; treat as transparent
-        return 0;
-    }
-
-    var matches = cssColorSpec.match(alpha.regex);
-
-    if (matches === null) {
-        // an opaque color (a color spec with no alpha channel)
-        return 1;
-    }
-
-    var A = matches[4];
-
-    if (A === undefined) {
-        // cssColorSpec must have been 'transparent'
-        return 0;
-    }
-
-    return Number(A);
 }
 
-alpha.regex = /^(transparent|((RGB|HSL)A\(.*,\s*([\d\.]+)\)))$/i;
-
 module.exports = SimpleCell;
diff --git a/src/cellRenderers/SliderCell.js b/src/cellRenderers/SliderCell.js
index aa7d50e..cace002 100644
--- a/src/cellRenderers/SliderCell.js
+++ b/src/cellRenderers/SliderCell.js
@@ -18,7 +18,7 @@ var Slider = CellRenderer.extend('Slider', {
             y = config.bounds.y,
             width = config.bounds.width,
             height = config.bounds.height;
-        gc.strokeStyle = 'white';
+        gc.cache.strokeStyle = 'white';
         var val = config.value;
         var radius = height / 2;
         var offset = width * val;
@@ -29,12 +29,12 @@ var Slider = CellRenderer.extend('Slider', {
         var arcGradient = gc.createLinearGradient(x, y, x, y + height);
         arcGradient.addColorStop(0, '#aaaaaa');
         arcGradient.addColorStop(1, '#777777');
-        gc.fillStyle = btnGradient;
+        gc.cache.fillStyle = btnGradient;
         this.roundRect(gc, x, y, width, height, radius, btnGradient);
         if (val < 1.0) {
-            gc.fillStyle = arcGradient;
+            gc.cache.fillStyle = arcGradient;
         } else {
-            gc.fillStyle = '#eeeeee';
+            gc.cache.fillStyle = '#eeeeee';
         }
         gc.beginPath();
         gc.arc(x + Math.max(offset - radius, radius), y + radius, radius, 0, 2 * Math.PI);
diff --git a/src/cellRenderers/SparkBar.js b/src/cellRenderers/SparkBar.js
index e372904..c504386 100644
--- a/src/cellRenderers/SparkBar.js
+++ b/src/cellRenderers/SparkBar.js
@@ -28,10 +28,10 @@ var SparkBar = CellRenderer.extend('SparkBar', {
         var eWidth = width / count;
         var fgColor = config.isSelected ? config.foregroundSelectionColor : config.color;
         if (config.backgroundColor || config.isSelected) {
-            gc.fillStyle = config.isSelected ? 'blue' : config.backgroundColor;
+            gc.cache.fillStyle = config.isSelected ? 'blue' : config.backgroundColor;
             gc.fillRect(x, y, width, height);
         }
-        gc.fillStyle = fgColor;
+        gc.cache.fillStyle = fgColor;
         for (var i = 0; i < val.length; i++) {
             var barheight = val[i] / 110 * height;
             gc.fillRect(x + 5, y + height - barheight, eWidth * 0.6666, barheight);
diff --git a/src/cellRenderers/SparkLine.js b/src/cellRenderers/SparkLine.js
index 0bde5b0..0f2fe4d 100644
--- a/src/cellRenderers/SparkLine.js
+++ b/src/cellRenderers/SparkLine.js
@@ -29,11 +29,11 @@ var SparkLine = CellRenderer.extend('SparkLine', {
 
         var fgColor = config.isSelected ? config.foregroundSelectionColor : config.color;
         if (config.backgroundColor || config.isSelected) {
-            gc.fillStyle = config.isSelected ? config.backgroundSelectionColor : config.backgroundColor;
+            gc.cache.fillStyle = config.isSelected ? config.backgroundSelectionColor : config.backgroundColor;
             gc.fillRect(x, y, width, height);
         }
-        gc.strokeStyle = fgColor;
-        gc.fillStyle = fgColor;
+        gc.cache.strokeStyle = fgColor;
+        gc.cache.fillStyle = fgColor;
         gc.beginPath();
         var prev;
         for (var i = 0; i < val.length; i++) {
diff --git a/src/cellRenderers/TreeCell.js b/src/cellRenderers/TreeCell.js
index b9db55d..e5e90ed 100644
--- a/src/cellRenderers/TreeCell.js
+++ b/src/cellRenderers/TreeCell.js
@@ -25,7 +25,7 @@ var TreeCell = CellRenderer.extend('TreeCell', {
 
         //fill background only if our bgColor is populated or we are a selected cell
         if (config.backgroundColor || config.isSelected) {
-            gc.fillStyle = config.isSelected ? config.backgroundColor : config.backgroundColor;
+            gc.cache.fillStyle = config.isSelected ? config.backgroundColor : config.backgroundColor;
             gc.fillRect(x, y, width, height);
         }
 
@@ -34,10 +34,10 @@ var TreeCell = CellRenderer.extend('TreeCell', {
         }
         var valignOffset = Math.ceil(height / 2);
 
-        gc.fillStyle = config.isSelected ? config.backgroundColor : config.backgroundColor;
+        gc.cache.fillStyle = config.isSelected ? config.backgroundColor : config.backgroundColor;
         gc.fillText(icon + val, x + indent, y + valignOffset);
 
-        var textWidth = config.getTextWidth(gc, icon + val);
+        var textWidth = gc.getTextWidth(icon + val);
         var minWidth = x + indent + textWidth + 10;
         config.minWidth = minWidth;
     }
diff --git a/src/cellRenderers/index.js b/src/cellRenderers/index.js
index eaf1c01..bbc2275 100644
--- a/src/cellRenderers/index.js
+++ b/src/cellRenderers/index.js
@@ -1,11 +1,7 @@
-/**
- * @summary API of cell renderer object constructors, plus some access methods.
- * @module cellRenderers
- */
-
 'use strict';
 
 /**
+ * @classdesc API of cell renderer object constructors, plus some access methods.
  * @param {boolean} [privateRegistry=false] - This instance will use a private registry.
  * @constructor
  */
@@ -35,7 +31,7 @@ CellRenderers.prototype = {
      * @summary Register and instantiate a cell renderer singleton.
      * @desc Adds a custom cell renderer to the `singletons` hash using the provided name (or the class name), converted to all lower case.
      *
-     * > All native cell renderers are "preregistered" in `singletons`. Add more by calling `get`.
+     * > All native cell renderers are "preregistered" in `singletons`. Add more by calling `add`.
      *
      * @param {string} [name] - Case-insensitive renderer key. If not given, `YourCellRenderer.prototype.$$CLASS_NAME` is used.
      *
@@ -77,7 +73,14 @@ CellRenderers.prototype = {
      * @memberOf CellRenderers.prototype
      */
     get: function(name) {
-        return this.singletons[name && name.toLowerCase()];
+        var result = this.singletons[name]; // for performance reasons, do not convert to lower case
+        if (!result) {
+            result = this.singletons[name.toLowerCase()]; // name may differ in case only
+            if (result) {
+                this.singletons[name] = result; // register found name as a synonym
+            }
+        }
+        return result;
     },
 
     /**
diff --git a/src/dataModels/DataModel.js b/src/dataModels/DataModel.js
index 2d56ac0..00bd6d8 100644
--- a/src/dataModels/DataModel.js
+++ b/src/dataModels/DataModel.js
@@ -40,22 +40,28 @@ var DataModel = Base.extend('DataModel', {
      * Overriding this method with a null function (that always returns `undefined`) will have the effect of making all cells uneditable.
      *
      * @param {number} columnIndex - Absolute column index. I.e., the position of the column in the data source's original `fields` array, as echoed in `behavior.allColumns[]`.
+     *
      * @param {number} rowIndex - Row index of the data row in the currently filtered and sorted list of rows, regardless of vertical scroll position, offset by the number of header rows (all the rows above the first data row including the filter row). I.e., after subtracting out the number of header rows, this is the position of the data row in the `index` array of the data source (i.e., the last data source pipeline).
+     *
      * @param {string} declaredEditorName - The proposed cell editor name (from the render properties).
-     * @param {object} options - Properties to copy to the new cell editor primarily for mustache's use. Additionally, always includes the following:
-     * @param {string} options.format - The value of the `format` render prop. May be `undefined`.
-     * @param {object} options.column - For convenience, the column object in `behavior.allColumns[]` to which `columnIndex` refers.
-     * @param {Point} options.editPoint - Deprecated; use `options.gridCell`.
-     * @param {Point} options.gridCell - The grid coordinates of the cell to edit.
-     * @param {number} options.gridCell.x - The horizontal model coordinate of the cell to edit. This is the grid coordinate regardless of horizontal scroll position. I.e., the position of the column in the ordered list of selected columns (`behavior.columns[]`). (This is the coordinate required by {@link Hypergrid#editAt|editAt}.)
-     * @param {number} options.gridCell.y - Same as `rowIndex`.
+     *
+     * @param {CellEvent} cellEvent - All enumerable properties of this object will be copied to the new cell editor object for two purposes:
+     * * Used in cell editor logic.
+     * * For access from the cell editor's HTML template (via mustache).
+     *
+     * {@link CellEditor} requires both of the following:
+     * * **`format`** - The cell's `format` render prop (name of localizer to use to format the editor preload and parse the edited value). May be `undefined` (no formatting or parsing). Added by calling {@link Column#getCellEditorAt|getCellEditorAt} method. Developer's override is free to alter this property.
+     * * _CellEvent props_ - `column` ({@link Column} object) is the only enumerable property of the native `CellEvent` object. Read-only.
+     * * _Custom props_ - Developer's override of this method may add additional properties, for both purposes listed above.
+     *
+     * Note that the `editPoint` property previously available to cell editors has been deprecated in favor of options.gridCell. `editPoint` will still work for the time being but with a deprecation warning in the console to use `cellEvent.gridCell` instead.
      *
      * @returns {undefined|CellEditor} An object instantiated from the registered cell editor constructor named in `declaredEditorName`. A falsy return means the cell is not editable because the `declaredEditorName` was not registered.
      *
      * @memberOf DataModel.prototype
      */
-    getCellEditorAt: function(columnIndex, rowIndex, declaredEditorName, options) {
-        return this.grid.cellEditors.create(declaredEditorName, options);
+    getCellEditorAt: function(columnIndex, rowIndex, declaredEditorName, cellEvent) {
+        return this.grid.cellEditors.create(declaredEditorName, cellEvent);
     }
 
 });
diff --git a/src/dataModels/FilterSubgrid.js b/src/dataModels/FilterSubgrid.js
deleted file mode 100644
index d43ca3f..0000000
--- a/src/dataModels/FilterSubgrid.js
+++ /dev/null
@@ -1,49 +0,0 @@
-'use strict';
-
-var images = require('../../images');
-
-function FilterRow(grid) {
-    this.grid = grid;
-    this.behavior = grid.behavior;
-    this.dataRow = {}; // for meta data (__HEIGHT)
-}
-
-FilterRow.prototype = {
-    constructor: FilterRow.prototype.constructor,
-
-    type: 'filter',
-
-    getRowCount: function() {
-        return this.grid.isShowFilterRow() ? 1 : 0;
-    },
-
-    getValue: function(x, y) {
-        checkForColumnFilters.call(this);
-
-        var column = this.behavior.getColumn(x),
-            result = this.behavior.filter.getColumnFilterState(column.name) || '';
-
-        result = [null, result, images.filter(result.length)];
-
-        return result;
-    },
-
-    setValue: function(x, y, value) {
-        checkForColumnFilters.call(this);
-
-        var column = this.behavior.getColumn(x);
-        this.behavior.filter.setColumnFilterState(column.name, value);
-    },
-
-    getRow: function(y) {
-        return this.dataRow;
-    }
-};
-
-function checkForColumnFilters() {
-    if (!this.behavior.filter.getColumnFilterState) {
-        throw new this.behavior.HypergridError('Column filters not available.');
-    }
-}
-
-module.exports = FilterRow;
diff --git a/src/dataModels/HeaderSubgrid.js b/src/dataModels/HeaderSubgrid.js
index 6f32c03..1b1205e 100644
--- a/src/dataModels/HeaderSubgrid.js
+++ b/src/dataModels/HeaderSubgrid.js
@@ -1,42 +1,46 @@
 'use strict';
 
-function HeaderRow(grid) {
+/**
+ * @implements dataModelAPI
+ * @param {Hypergrid} grid
+ * @param {object} [options]
+ * @param {string} [options.name]
+ * @constructor
+ */
+function HeaderSubgrid(grid, options) {
     this.grid = grid;
     this.behavior = grid.behavior;
+
+    /**
+     * @type {dataRowObject}
+     */
     this.dataRow = {}; // for meta data (__HEIGHT)
+
+    if (options && options.name) {
+        this.name = options.name;
+    }
 }
 
-HeaderRow.prototype = {
-    constructor: HeaderRow.prototype.constructor,
+HeaderSubgrid.prototype = {
+    constructor: HeaderSubgrid.prototype.constructor,
 
     type: 'header',
 
+    format: 'header', // override column format
+
     getRowCount: function() {
-        return this.grid.isShowHeaderRow() ? 1 : 0;
+        return this.grid.properties.showHeaderRow ? 1 : 0;
     },
 
     getValue: function(x, y) {
-        var column = this.behavior.getColumn(x),
-            result = column.header || column.name, // uses field name when header undefined
-            sortString = this.behavior.dataModel.getSortImageForColumn(x),
-            groups;
-
-        if (sortString) {
-            // if grouped header, prepend group headers to sort direction indicator
-            if ((groups = result.lastIndexOf(this.behavior.groupHeaderDelimiter) + 1)) {
-                sortString = result.substr(0, groups) + sortString;
-                result = result.substr(groups);
-            }
-
-            // prepend sort direction indicator to column header
-            result = sortString + result;
-        }
-
-        return result;
+        var column = this.behavior.getColumn(x);
+        return column.header || column.name; // use field name when header undefined
     },
 
     setValue: function(x, y, value) {
-        this.behavior.getColumn(x).header = value;
+        if (y < this.getRowCount()) {
+            this.behavior.getColumn(x).header = value;
+        }
     },
 
     getRow: function(y) {
@@ -44,4 +48,4 @@ HeaderRow.prototype = {
     }
 };
 
-module.exports = HeaderRow;
+module.exports = HeaderSubgrid;
diff --git a/src/dataModels/JSON.js b/src/dataModels/JSON.js
index 5d6e54d..358a252 100644
--- a/src/dataModels/JSON.js
+++ b/src/dataModels/JSON.js
@@ -1,7 +1,7 @@
 'use strict';
 
 var DataModel = require('./DataModel');
-var DataSourceOrigin = require('../dataSources/DataSourceOrigin');
+var DataSourceOrigin = require('../lib/DataSourceOrigin');
 
 /** @typedef {object} dataSourcePipelineObject
  * @property {string} type - A "DataSourceOrigin" style constructor name.
@@ -10,28 +10,6 @@ var DataSourceOrigin = require('../dataSources/DataSourceOrigin');
  */
 
 /**
- * @implements dataSourceHelperAPI
- * @desc This is a simple "null" helper API implementation with only a null `properties` method is defined.
- * @see {@link http://c2.com/cgi/wiki?NullObject}
- * @memberOf dataModels.JSON
- * @inner
- */
-var nullDataSourceHelperAPI = {
-    properties: function(properties) {
-        var result,
-            isGetter = 'getPropName' in properties;
-
-        if (isGetter) {
-            // All props are undefined in this null API regardless of their name; and
-            // undefined props return `null` as per interface definition.
-            result = null;
-        }
-
-        return result;
-    }
-};
-
-/**
  * @name dataModels.JSON
  * @constructor
  * @extends DataModel
@@ -39,64 +17,79 @@ var nullDataSourceHelperAPI = {
 var JSON = DataModel.extend('dataModels.JSON', {
 
     initialize: function(grid, options) {
+        /**
+         * @summary Hash of controllers.
+         * @desc Keyed by data source type.
+         * Data controller are only accepted by data sources that have a defined `type` property.
+         * @see {@link dataControlInterface}
+         * @type {object}
+         * @memberOf dataModels.JSON.prototype
+         */
+        this.controllers = {};
+
+        this.charMap = new CharMap(this);
+
         this.reset(options);
     },
 
     /**
      * Override to use a different origin.
      * @type(DataSourceBase}
+     * @memberOf dataModels.JSON.prototype
      */
     DataSourceOrigin: DataSourceOrigin,
 
     /**
      * @type {dataSourcePipelineObject[][]}
      * @summary Pipeline stash push-down list.
-     * @desc The pipeline stash may be shared or instanced. This is the shared stash. An instance may override this with an instance stash variable (of the same name). See {@link dataModels.JSON.prototype#getPipelineSchemaStash}.
+     * @desc The pipeline stash may be shared or instanced. This is the shared stash. An instance may override this with an instance stash variable (of the same name). See {@link dataModels.JSON#getPipelineSchemaStash}.
      * @memberOf dataModels.JSON.prototype
      */
     pipelineSchemaStash: [],
 
     /**
-     * @memberOf dataModels.JSON.prototype
      * @param {object} [options]
+     * @param {object} [options.pipeline] - Consumed by {@link dataModels.JSON#setPipeline}.
+     * If omitted, previously established pipeline is reused.
+     * @param {object} [options.controllers] - Consumed by {@link dataModels.JSON#setPipeline}.
+     * If omitted, previously established controllers.
+     * * @memberOf dataModels.JSON.prototype
      */
     reset: function(options) {
-        this.selectedData = [];
-
-        /**
-         * @summary Hash of data source helper APIs.
-         * @desc Keyed by data source type. An API is required by data sources with an `api` property.
-         * @see {@link dataModels.JSON/updateDataSources}
-         * @type {object}
-         */
-        this.api = {};
-
         delete this.pipelineSchemaStash; // remove existing "own" version if any
 
-        this.source = new this.DataSourceOrigin(options.data, options.schema);
+        options = options || {};
+        this.source = new this.DataSourceOrigin(
+            options.data,
+            options.schema
+        );
 
-        this.setPipeline();
-        //Register Defaults
-        this.registerHelperAPI('filter');
-        this.registerHelperAPI('sorter');
+        this.setPipeline({
+            pipeline: options.pipeline,
+            controllers: options.controllers
+        });
     },
 
     /**
-     * @summary The default data sources for a new pipeline when none are give.
-     * @desc For now Filtering is hardcoded in the grid.
-     * In the future, this will likely be empty (unless overridden by application developer for his own purposes).
+     * Application developer should override to set up a default pipeline.
      * @type {pipelineSchema}
      * @memberOf dataModels.JSON.prototype
      */
     defaultPipelineSchema: [],
 
     clearSelectedData: function() {
-        this.selectedData.length = 0;
+        var key = 'clearSelectedData()',
+            warned = this.$$DEPRECATION_WARNED = this.$$DEPRECATION_WARNED || {};
+        if (!(key in warned)) {
+            warned[key] = 0;
+            console.warn(key + ' has been deprecated as of v1.2.23. This function no longer has any meaning; calls should be removed.');
+        }
     },
 
     /**
      * @deprecated As of v1.0.7, reference the `dataSource` property instead.
      * @returns {*}
+     * @memberOf dataModels.JSON.prototype
      */
     getDataSource: function() {
         return this.deprecated('getDataSource()', 'dataSource', '1.0.7');
@@ -107,7 +100,8 @@ var JSON = DataModel.extend('dataModels.JSON', {
     },
 
     /**
-     * @deprecated As of v1.1.0, use getIndexedData
+     * @deprecated As of v1.1.0, use `getIndexedData()` instead.
+     * @memberOf dataModels.JSON.prototype
      */
     getFilteredData: function() {
         return this.deprecated('getFilteredData()', 'getIndexedData()', '1.2.0', arguments);
@@ -141,7 +135,8 @@ var JSON = DataModel.extend('dataModels.JSON', {
 
     /**
      * @param {number} y - Data row coordinate.
-     * @returns {*}
+     * @returns {nunber} Row index in raw data array after dereferencing all data source indexing.
+     * @memberOf dataModels.JSON.prototype
      */
     getDataIndex: function(y) {
         return this.dataSource.getDataIndex(y);
@@ -237,7 +232,7 @@ var JSON = DataModel.extend('dataModels.JSON', {
      * @memberOf dataModels.JSON.prototype
      */
     reindex: function(options) {
-        selectedDataRowsBackingSelectedGridRows.call(this);
+        var selectedRowSourceIndexes = getUnderlyingIndexesOfSelectedRows.call(this);
 
         this.pipeline.forEach(function(dataSource) {
             if (dataSource) {
@@ -247,7 +242,7 @@ var JSON = DataModel.extend('dataModels.JSON', {
             }
         });
 
-        reselectGridRowsBackedBySelectedDataRows.call(this);
+        reselectRowsByUnderlyingIndexes.call(this, selectedRowSourceIndexes);
     },
 
     /**
@@ -259,8 +254,7 @@ var JSON = DataModel.extend('dataModels.JSON', {
         this.source.setData(dataSource, schema);
     },
 
-    /** @typedef pipelineSchema
-     * @type {DataSourceBase[]}
+    /** @typedef {DataSourceBase[]} pipelineSchema
      * @summary Describes a new pipeline.
      * @desc Consists of an ordered list of data source constructors, descendants of `DataSourceBase`.
      * May contain `undefined` elements, which are ignored.
@@ -277,20 +271,42 @@ var JSON = DataModel.extend('dataModels.JSON', {
      * The last pipe is assigned the synonym `this.dataSource`.
      * @param {pipelineSchema} [DataSources] - New pipeline description. If not given, uses the default {@link dataModels.JSON#DataSources|this.defaultPipelineSchema}.
      * @param {object} [options] - Takes first argument position when `DataSources` omitted.
-     * @param {string} [options.stash] - See {@link dataModels.JSON.prototype#getPipelineSchemaStash}. If given, saves the currently defined pipeline onto the indicated stash stack and then resets it with the given `DataSources`.
+     * @param {string} [options.stash] - See {@link dataModels.JSON#getPipelineSchemaStash}. If given, saves the currently defined pipeline onto the indicated stash stack and then resets it with the given `DataSources`.
      * @memberOf dataModels.JSON.prototype
      */
     setPipeline: function(DataSources, options) {
         if (!Array.isArray(DataSources)) {
             options = DataSources;
-            DataSources = undefined;
+            DataSources = options.pipeline;
         }
 
-        if (options && options.stash) {
-            this.getPipelineSchemaStash(options.stash).push(this.DataSources);
+        options = options || {};
+
+        if (DataSources) {
+            DataSources = DataSources.slice();
+        } else if (this.DataSources) {
+            DataSources = this.DataSources;
+        } else {
+            DataSources = this.defaultPipelineSchema.slice();
         }
 
-        var dataSource = this.source;
+        this.DataSources = DataSources;
+
+        var pipeline = [],
+            dataSource = this.source;
+        if (DataSources.length) {
+            if (options.stash) {
+                this.getPipelineSchemaStash(options.stash).push(DataSources);
+            }
+
+            DataSources.forEach(function(DataSource) {
+                if (DataSource) {
+                    dataSource = new DataSource(dataSource);
+                    pipeline.push(dataSource);
+                }
+            }, this);
+        }
+        this.dataSource = dataSource;
 
         /**
          * @summary Currently defined pipeline.
@@ -300,33 +316,16 @@ var JSON = DataModel.extend('dataModels.JSON', {
          * @type {dataSourcePipelineObject[]}
          * @memberOf dataModels.JSON.prototype
          */
-        this.pipeline = [];
-
-        DataSources = DataSources || this.defaultPipelineSchema;
+        this.pipeline = pipeline;
 
-        DataSources.forEach(function(DataSource) {
-            if (DataSource) {
-                dataSource = new DataSource(dataSource);
-                this.pipeline.push(dataSource);
-
-                // Ensure a null helper API defined for all data sources that require one
-                if (dataSource.type && dataSource.set && !this.api[dataSource.type]) {
-                    this.registerHelperAPI(dataSource.type);
-                }
-            }
-        }, this);
-
-        this.updateDataSources();
-
-        this.dataSource = dataSource;
-
-        this.DataSources = DataSources;
+        this.setController(options.controllers || this.controllers); // set the new or previously set data controller(s) on the new pipeline
     },
 
     /**
      * Find the last data source in the pipeline of specified type.
      * @param {string} type
      * @returns {DataSourceBase}
+     * @memberOf dataModels.JSON.prototype
      */
     findDataSourceByType: function(type) {
         var dataSource;
@@ -339,39 +338,12 @@ var JSON = DataModel.extend('dataModels.JSON', {
     },
 
     /**
-     * @summary Update data sources with APIs of matching types.
-     * @desc Only updates _qualified_ data sources, which include:
-     * * those for which an API of the data source's type is defined in `this.api`; and
-     * * those that can accept an API (have an `api` property to set).
-     * @param {string} [type] - Type of data source to update. If omitted, updates all data sources.
-     * @returns {number|object} One of:
-     * `type` specified - The number of updated data sources of the specified type.
-     * `type` omitted - Hash containing the number of updated data sources by type.
-     */
-    updateDataSources: function(type) {
-        var results = {},
-            api = this.api;
-
-        this.pipeline.forEach(function(dataSource) {
-            if (
-                (!type || dataSource.type === type) &&
-                api[dataSource.type]
-            ) {
-                dataSource.set(api[dataSource.type]);
-                results[dataSource.type] = (results[dataSource.type] || 0) + 1;
-            }
-        });
-
-        return type ? results[type] : results;
-    },
-
-    /**
      * @summary The pipeline stash currently in use (either shared or instance).
      * @desc Instance stash is created here when requested and instance doesn't yet have its "own" version.
-     * @param {string} [whichStash] - One of:
+     * @param {string} [whichStash='default'] - One of:
      * * `'shared'` - Use shared stash.
      * * `'own'' or `'instance'` - Use instance stash, creating it if it does not exist.
-     * * `'default'` or `undefined` - Use instance stash if previously created; otherwise use shared stash.
+     * * `'default'` - Use instance stash if previously created; otherwise use shared stash.
      * @returns The pipeline stash push-down list.
      * @memberOf dataModels.JSON.prototype
      */
@@ -400,7 +372,7 @@ var JSON = DataModel.extend('dataModels.JSON', {
 
     /**
      * Pops the last stashed pipeline off the stash stack, making it the currently defined pipeline.
-     * @param {string} [whichStash] - See {@link dataModels.JSON.prototype#getPipelineSchemaStash}.
+     * @param {string} [whichStash] - See {@link dataModels.JSON#getPipelineSchemaStash}.
      * @memberOf dataModels.JSON.prototype
      */
     unstashPipeline: function(whichStash) {
@@ -425,23 +397,23 @@ var JSON = DataModel.extend('dataModels.JSON', {
     },
 
     /**
-     * @deprecated
+     * @deprecated As pf v1.1.0, use `this.grid.behavior.setTopTotals()` instead.
      * @summary Set the top total row(s).
      * @param {dataRowObject[]} totalRows - Array of 0 or more rows containing summary data. Omit to set to empty array.
      * @memberOf dataModels.JSON.prototype
      */
     setTopTotals: function(totalRows) {
-        return this.deprecate('setTopTotals(rows)', 'grid.behavior.setTopTotals(rows)', '1.1.0', arguments);
+        return this.deprecated('setTopTotals(rows)', 'grid.behavior.setTopTotals(rows)', '1.1.0', arguments);
     },
 
     /**
-     * @deprecated
+     * @deprecated As pf v1.1.0, use `this.grid.behavior.getTopTotals()` instead.
      * @summary Get the top total row(s).
      * @returns {dataRowObject[]}
      * @memberOf dataModels.JSON.prototype
      */
     getTopTotals: function() {
-        return this.deprecate('getTopTotals(rows)', 'grid.behavior.getTopTotals(rows)', '1.1.0', arguments);
+        return this.deprecated('getTopTotals(rows)', 'grid.behavior.getTopTotals(rows)', '1.1.0', arguments);
     },
 
     /**
@@ -451,32 +423,31 @@ var JSON = DataModel.extend('dataModels.JSON', {
      * @memberOf dataModels.JSON.prototype
      */
     setBottomTotals: function(totalRows) {
-        return this.deprecate('setBottomTotals(rows)', 'grid.behavior.setBottomTotals(rows)', '1.1.0', arguments);
+        return this.deprecated('setBottomTotals(rows)', 'grid.behavior.setBottomTotals(rows)', '1.1.0', arguments);
     },
 
     /**
-     * @deprecated
      * @summary Get the bottom total row(s).
+     * @deprecated As pf v1.1.0, use `this.grid.behavior.getBottomTotals()` instead.
      * @returns {dataRowObject[]}
      * @memberOf dataModels.JSON.prototype
      */
     getBottomTotals: function() {
-        return this.deprecate('getBottomTotals(rows)', 'grid.behavior.getBottomTotals(rows)', '1.1.0', arguments);
+        return this.deprecated('getBottomTotals()', 'grid.behavior.getBottomTotals()', '1.1.0');
     },
 
     /**
      * @memberOf dataModels.JSON.prototype
-     * @returns {object[]}
+     * @returns {Column[]}
      */
     getActiveColumns: function() {
-        return this.grid.behavior.columns.filter(function(column) {
-            return column.name !== 'tree';
-        });
+        return this.deprecated('getActiveColumns()', 'grid.behavior.getActiveColumns()', '1.2.14', arguments);
     },
 
     /**
+     * @memberOf dataModels.JSON.prototype
      * @deprecated As of v1.0.6, use `this.getActiveColumns` instead.
-     * @returns {*}
+     * @returns {Column[]}
      */
     getVisibleColumns: function() {
         return this.deprecated('getVisibleColumns()', 'getActiveColumns()', '1.0.6', arguments);
@@ -487,18 +458,7 @@ var JSON = DataModel.extend('dataModels.JSON', {
      * @returns {object[]}
      */
     getHiddenColumns: function() {
-        var visible = this.grid.behavior.columns;
-        var all = this.grid.behavior.allColumns;
-        var hidden = [];
-        for (var i = 0; i < all.length; i++) {
-            if (visible.indexOf(all[i]) === -1) {
-                hidden.push(all[i]);
-            }
-        }
-        hidden.sort(function(a, b) {
-            return a.header < b.header;
-        });
-        return hidden;
+        return this.deprecated('getHiddenColumns()', 'grid.behavior.getHiddenColumns()', '1.2.14', arguments);
     },
     /**
      * @memberOf dataModels.JSON.prototype
@@ -530,7 +490,7 @@ var JSON = DataModel.extend('dataModels.JSON', {
         if (arguments.length === 2) {
             return this.deprecated('cellClicked(cell, event)', 'cellClicked(event)', '1.2.0', arguments);
         }
-        return this.toggleRow(event.dataCell.y);
+        return this.toggleRow(event.dataCell.y, undefined, event);
     },
 
     /**
@@ -543,16 +503,17 @@ var JSON = DataModel.extend('dataModels.JSON', {
      * * `true` - Expand row.
      * * `false` - Collapse row.
      * * `undefined` (or omitted) - Toggle state of row.
+     * @param event
      * @returns {boolean|undefined} Changed. Specifically, one of:
      * * `undefined` row had no drill-down control
      * * `true` drill-down changed
      * * `false` drill-down unchanged (was already in requested state)
      * @memberOf dataModels.JSON.prototype
      */
-    toggleRow: function(y, expand) {
+    toggleRow: function(y, expand, event) {
         //TODO: fire a row toggle event
         var changed;
-        if (this.isDrillDown()) {
+        if (this.isDrillDown(event)) {
             changed = this.dataSource.click(y, expand);
             if (changed) {
                 this.reindex({rowClick: true});
@@ -572,67 +533,158 @@ var JSON = DataModel.extend('dataModels.JSON', {
     },
 
     /**
-     * @summary _Getter:_ Return the filter from the data model.
-     * @method
-     * @returns {dataSourceHelperAPI} The grid's currently assigned filter.
-     * @memberOf dataModels.JSON.prototype
-     */
-    get filter() {
-        return this.api.filter;
-    },
+     * @summary Get the given data controller.
+     * @param {string} type
+     * @returns {undefined|*} The data controller; or `undefined` if data controller unknown to data model.
+     * @memberOf dataModels.JSON#
+     */
+    getController: function(type) {
+        return this.controllers[type]; // alternatively: this.dataSource.getController(type)
+    },
+
+    /**
+     * @summary Set the given data controller(s).
+     * @param {string} typeOrHashOfTypes - One of:
+     * * **object** - Hash of multiple data controllers, by type.
+     * * **string** - Type of the single data controller given in `controller`.
+     * @param {dataControlInterface} [controller] - Only required when 'hash' is a string; omit when `hash` is an object.
+     * @returns {object} - Hash of all results, by type. Each member will be:
+     * * The given data controller for that type when defined.
+     * * A new "null" data controller, generated by the data model when the given data controller for that type was `undefined`.
+     * * `undefined` - The data controller was unknown to the data model.
+     * @memberOf dataModels.JSON#
+     */
+    setController: function(typeOrHashOfTypes, controller) {
+        var dataSource = this.dataSource,
+            controllers = this.controllers,
+            result, results = {},
+            atLeastOneAccepted,
+            hash;
+
+        if (typeof typeOrHashOfTypes === 'string') {
+            var type = typeOrHashOfTypes;
+            hash = {};
+            hash[type] = controller;
+        } else {
+            hash = typeOrHashOfTypes;
+        }
 
-    /**
-     * @summary _Setter:_ Assign a filter to the data model.
-     * @method
-     * @param {dataSourceHelperAPI|undefined|null} filter - One of:
-     * * A filter object - Turns the filter *ON*.
-     * * `undefined` or `null` - Turns the filter *OFF.*
-     * @memberOf dataModels.JSON.prototype
-     */
-    set filter(filter) {
-        this.registerHelperAPI('filter', filter);
-    },
-    /**
-     * @summary _Getter_
-     * @method
-     * @returns {sorterAPI} The grid's currently assigned sorter.
-     * @memberOf dataModels.JSON.prototype
-     */
-    get sorter() {
-        return this.api.sorter;
-    },
+        Object.keys(hash).forEach(function(type) {
+            result = dataSource.setController(type, hash[type]);
+            atLeastOneAccepted = atLeastOneAccepted || result;
+            results[type] = result;
+        });
 
-    /**
-     * @summary _Setter:_ Assign a sorter to the grid.
-     * @method
-     * @param {sorterAPI|undefined|null} sorter - One of:
-     * * A sorter object, turning sorting *ON*.
-     * * If `undefined` or `null`, the {@link dataModels.JSON~nullSorter|nullSorter} is reassigned to the grid, turning sorting *OFF.*
-     * @memberOf dataModels.JSON.prototype
-     */
-    set sorter(sorter) {
-        this.registerHelperAPI('sorter', sorter);
+        // add in the results to the active list including rejections
+        Object.assign(controllers, results);
+
+        // prune rejections from the active list
+        Object.keys(controllers).forEach(function(type) {
+            if (!controllers[type]) {
+                delete controllers[type];
+            }
+        });
+
+        if (atLeastOneAccepted) {
+            this.reindex();
+        }
+
+        return results;
     },
 
     /**
-     * @summary Register the data source helper API.
-     * @desc The API is immediately applied to all data sources in the pipeline of the given type; and reassigned later whenever the pipeline is reset.
-     * @param {string} dataSourceType
-     * @param {dataSourceHelperAPI|undefined|null} helper - One of:
-     * * A filter object - Turns the data source *ON*.
-     * * `undefined` or `null` - Turns the data source *OFF.*
-     * * A helper API. Turns the data source *ON*.
-     */
-    registerHelperAPI: function(dataSourceType, helper) {
-        this.api[dataSourceType] = helper = helper || nullDataSourceHelperAPI;
+     * @summary Digests `(columnIndex, propName, value)` and calls specified data controllers `properties()` method.
+     * @desc Digests the three parameters `(columnIndex, propName, value)` detailed below, creating a single {@link dataControlInterface} object with which it then calls the `properties` method of the data controller specified by `type`.
+     *
+     * This method is overloaded in the jQuery style: You can both set a data controller prop (when value give) and a get a data controller prop (when value omitted); or you can give a hash in place of the property name to set several properties at once. Whichever way you use it, you can in addition specify a column index for column-specific properties.
+     *
+     * @param {null|string} type - The controller type from which to get or to which to set the given property value(s). `null` in a setter operation applies the value(s) to all data controllers; `null` has questionable usefulness in a getter operation.
+     *
+     * @param {number} [columnIndex] - If given, this is a property on a specific column. If omitted, this is a property on the whole data controller properties object.
+     *
+     * @param {string|object} propNameOrPropHash - _If `columnIndex` is omitted, this arg takes its place._
+     *
+     * One of these types:
+     * * **string** - Property name. The name of the explicit property to either get or (if `value` also given) set on the properties object.
+     * * **object** - Hash of properties to set on the properties object.
+     *
+     * @param [value] - _If `columnIndex` is omitted, this arg takes its place._
+     *
+     * One of:
+     * * If omitted when `propNameOrPropHash` is a string, this is the "getter" action:
+     * Return the value from the properties object of the key in `property`.
+     * * Provided when `propNameOrPropHash` is a string, this is the "setter" action:
+     * Copy this value to properties object using the key in `property`.
+     * * When `propNameOrPropHash` is a hash and `value` is given: Unexpected; throws an error.
+     *
+     * @returns {propObject}
+     *
+     * @memberOf dataModels.JSON#
+     */
+    prop: function(type, columnIndex, propNameOrPropHash, value) {
+        var result, invalid,
+            properties = {},
+            argCount = arguments.length,
+            controllers = this.controllers,
+            types = (type !== null) ? [type] : Object.keys(controllers);
+
+        controllers = types
+            .map(function(type) { return controllers[type]; })
+            .filter(function(controller) { return controller; });
+
+        if (controllers.length) {
+            if (typeof columnIndex === 'number') {
+                argCount--;
+            } else {
+                value = propNameOrPropHash;
+                propNameOrPropHash = columnIndex;
+                columnIndex = undefined;
+            }
 
-        if (typeof helper.properties === 'function' && helper.properties.length === 1) {
-            helper.prop = propPrep.bind(helper, this);
-        }
+            switch (argCount) {
 
-        if (this.updateDataSources(dataSourceType)) {
-            this.reindex();
+                case 2: // getter propName name or setter hash
+                    if (typeof propNameOrPropHash === 'object') {
+                        properties = propNameOrPropHash; // prop is object
+                    } else {
+                        properties.GETTER = propNameOrPropHash; // prop is name
+                    }
+                    break;
+
+                case 3: // setter for value
+                    if (typeof propNameOrPropHash === 'string') {
+                        properties[propNameOrPropHash] = value; // prop is name
+                    } else {
+                        invalid = true;
+                    }
+                    break;
+
+                default: // too few or too many args
+                    invalid = true;
+
+            }
+
+            if (invalid) {
+                throw 'Invalid overload.';
+            }
+
+            if (columnIndex !== undefined) {
+                // non-enumerable propName:
+                Object.defineProperty(properties, 'COLUMN', {
+                    value: {
+                        index: columnIndex,
+                        name: this.schema[columnIndex].name
+                    }
+                });
+            }
+
+            // Use the prepared propObject to get or set the properties on the controller
+            controllers.forEach(function(controller) {
+                result = controller.properties(properties);
+            });
         }
+
+        return result;
     },
 
     /**
@@ -667,181 +719,98 @@ var JSON = DataModel.extend('dataModels.JSON', {
         return newDataRow;
     },
 
-    get schema() { return this.source.schema; },
+    get schema() { return this.dataSource.schema; },
 
     set schema(schema) {
-        this.source.setSchema(schema);
+        this.dataSource.setSchema(schema);
     }
 });
 
 // LOCAL METHODS -- to be called with `.call(this`
 
 /**
- * Accumulate actual data row objects backing current grid row selections.
+ * Save underlying data row indexes backing current grid row selections.
  * This call should be paired with a subsequent call to `reselectGridRowsBackedBySelectedDataRows`.
  * @private
  * @this {dataModels.JSON}
- * @memberOf dataModels.JSON.prototype
+ * @memberOf dataModels.JSON~
  */
-function selectedDataRowsBackingSelectedGridRows() {
-    var selectedData = this.selectedData,
-        hasRowSelections = this.grid.selectionModel.hasRowSelections(),
-        needIndexedDataList = selectedData.length || hasRowSelections;
-
-    if (needIndexedDataList) {
-        var indexedData = this.getIndexedData();
-    }
+function getUnderlyingIndexesOfSelectedRows() {
+    var sourceIndexes = [],
+        dataSource = this.dataSource;
 
-    // STEP 1: Remove any filtered data rows from the recently selected list.
-    selectedData.forEach(function(dataRow, index) {
-        if (indexedData.indexOf(dataRow) >= 0) {
-            delete selectedData[index];
-        }
-    });
-
-    // STEP 2: Accumulate the data rows backing any currently selected grid rows in `this.selectedData`.
-    if (hasRowSelections) { // any current grid row selections?
+    if (this.grid.properties.checkboxOnlyRowSelections) {
         this.grid.getSelectedRows().forEach(function(selectedRowIndex) {
-            var dataRow = indexedData[selectedRowIndex];
-            if (selectedData.indexOf(dataRow) < 0) {
-                selectedData.push(dataRow);
-            }
+            sourceIndexes.push(dataSource.getDataIndex(selectedRowIndex));
         });
     }
+
+    return sourceIndexes;
 }
 
 /**
- * Re-establish grid row selections based on actual data row objects accumulated by `selectedDataRowsBackingSelectedGridRows` which should be called first.
+ * Re-establish grid row selections based on underlying data row indexes saved by `getSelectedDataRowsBackingSelectedGridRows` which should be called first.
  * @private
  * @this {dataModels.JSON}
- * @memberOf dataModels.JSON.prototype
+ * @memberOf dataModels.JSON~
  */
-function reselectGridRowsBackedBySelectedDataRows() {
-    if (this.selectedData.length) { // any data row objects added from previous grid row selections?
-        var selectionModel = this.grid.selectionModel,
-            offset = this.grid.getHeaderRowCount(),
-            filteredData = this.getIndexedData();
-
-        selectionModel.clearRowSelection();
-
-        this.selectedData.forEach(function(dataRow) {
-            var index = filteredData.indexOf(dataRow);
-            if (index >= 0) {
-                selectionModel.selectRow(offset + index);
+function reselectRowsByUnderlyingIndexes(sourceIndexes) {
+    var i, r,
+        rowCount = this.getRowCount(),
+        selectedRowCount = sourceIndexes.length,
+        rowIndexes = [],
+        selectionModel = this.grid.selectionModel;
+
+    selectionModel.clearRowSelection();
+
+    if (this.grid.properties.checkboxOnlyRowSelections) {
+        for (r = 0; selectedRowCount && r < rowCount; ++r) {
+            i = sourceIndexes.indexOf(this.dataSource.getDataIndex(r));
+            if (i >= 0) {
+                rowIndexes.push(r);
+                delete sourceIndexes[i]; // might make indexOf increasingly faster as deleted elements are not enumerable
+                selectedRowCount--; // count down so we can bail early if all found
             }
-        });
-    }
-}
-
-/**
- * @inner
- * @summary Digests `(columnIndex, propName, value)` and calls `properties`.
- * @desc Digests the three parameters `(columnIndex, propName, value)` detailed below, creating a single object with which it then calls the helper API `properties` method.
- *
- * A helper API `properties` method:
- * * Supports two types of actions:
- *   * **Getter** call where you supply just the property name. The method gets the property value from the API and returns it.
- *   * **Setter** call where you supply a value along with the property name; or you supply a hash of property name/value pairs. The method sets the property on the API and returns nothing. All values are valid with the exception of `undefined` which deletes the property of the given name rather than setting it to `undefined`.
- * * Supports two types of properties:
- *   * **Global properties** affect the API globally.
- *   * **Column properties** pertain to specific columns.
- *
- * This method is overloaded. The way it is called as explained in the Parameters section below determines both the type of action (getter, setter) and the kind of property (global, column).
- *
- * Note: Not all API properties are dynamic; some are static and updating them later will have no effect.
- *
- * @this {dataSourceHelperAPI}
- *
- * @param {DataSourceBase} dataModel - The data model. This parameter is bound to the call by {@link dataModels.JSON#setHelperAPI|setHelperAPI}.
- *
- * @param {number} [columnIndex] - If given, this is a property on a specific column. If omitted, this is a property on the whole API properties object.
- *
- * @param {string|object} property - _If `columnIndex` is omitted, this arg takes its place._
- *
- * One of these types:
- * * **string** - Property name. The name of the explicit property to either get or (if `value` also given) set on the properties object.
- * * **object** - Hash of properties to set on the properties object.
- *
- * @param [value] - _If `columnIndex` is omitted, this arg takes its place._
- *
- * One of:
- * * Omitted (when `property` is a string), this is the "getter" action: Return the value from the properties object of the key in `property`.
- * * When `property` is a string and `value` is given, this is the "setter" action: Copy this value to properties object using the key in `property`.
- * * When `property` is a hash and `value` is given: Unexpected; throws an error.
- *
- * @returns {propObject}
- */
-function propPrep(dataModel, columnIndex, propName, value) {
-    var invalid,
-        properties = {},
-        argCount = arguments.length;
-
-    if (typeof columnIndex === 'number') {
-        argCount--;
-    } else {
-        value = propName;
-        propName = columnIndex;
-        columnIndex = undefined;
-    }
-
-    switch (argCount) {
-
-        case 2: // getter propName name or setter hash
-            if (typeof propName === 'object') {
-                properties = propName;
-            } else {
-                properties.getPropName = propName;
-            }
-            break;
-
-        case 3: // setter for value
-            if (typeof propName !== 'string') {
-                invalid = true;
-            } else {
-                properties[propName] = value;
-            }
-            break;
-
-        default: // too few or too many args
-            invalid = true;
-
-    }
-
-    if (invalid) {
-        throw 'Invalid overload.';
-    }
+        }
 
-    if (columnIndex !== undefined) {
-        // non-enumerable propName:
-        Object.defineProperty(properties, 'column', {
-            value: {
-                index: columnIndex,
-                name: dataModel.source.schema[columnIndex].name
-            }
+        rowIndexes.forEach(function(rowIndex) {
+            selectionModel.selectRow(rowIndex);
         });
     }
 
-    return this.properties(properties);
+    return rowIndexes.length;
 }
 
-var warned = {};
 /**
  * @private
  * @param {string} propName
  * @this DataSourceOrigin#
- * @returns {*[]}
+ * @returns {Array}
+ * @memberOf dataModels.JSON~
  */
 function getSchemaPropArr(propName, deprecatedMethodName) {
-    if (!warned[deprecatedMethodName]) {
-        console.warn(deprecatedMethodName + '() has been deprecated as of v1.2.0 and will be removed in a future release. Constructs like ' + deprecatedMethodName + '()[i] should be changed to schema[i]. (This deprecated method now returns a new array derived from schema.)');
-        warned[deprecatedMethodName] = true;
-    }
+    this.deprecated(deprecatedMethodName, deprecatedMethodName + '() has been deprecated as of v1.2.0 and will be removed in a future release. Constructs like ' + deprecatedMethodName + '()[i] should be changed to schema[i]. (This deprecated method now returns a new array derived from schema.)');
     return this.schema.map(function(columnSchema) {
         return columnSchema[propName];
     }, this);
 }
 
+function CharMap(dataModel) {
+    this.dataModel = dataModel;
+}
+CharMap.prototype = {
+    mixIn: require('overrider').mixIn,
+
+    get OPEN() { return this.dataModel.dataSource.drillDownCharMap.OPEN; },
+    set OPEN(s) { this.dataModel.dataSource.drillDownCharMap.OPEN = s; },
+
+    get CLOSE() { return this.dataModel.dataSource.drillDownCharMap.CLOSE; },
+    set CLOSE(s) { this.dataModel.dataSource.drillDownCharMap.CLOSE = s; },
+};
+
 /**
+ * Synonym of {@link JSON.prototype.reindex}.
+ * @name applyAnalytics
  * @deprecated
  * @memberOf dataModels.JSON.prototype
  */
diff --git a/src/dataModels/SummarySubgrid.js b/src/dataModels/SummarySubgrid.js
deleted file mode 100644
index 8943302..0000000
--- a/src/dataModels/SummarySubgrid.js
+++ /dev/null
@@ -1,46 +0,0 @@
-'use strict';
-
-function SummaryRow(grid, options) {
-    this.behavior = grid.behavior;
-
-    /**
-     * @type {dataRowObject[]}
-     */
-    this.data = [];
-
-    if (options && options.name) {
-        this.name = options.name;
-    }
-}
-
-SummaryRow.prototype = {
-    constructor: SummaryRow.prototype.constructor,
-
-    type: 'summary',
-
-    getRowCount: function() {
-        return this.getData().length;
-    },
-
-    getData: function() {
-        return this.behavior.dataModel.dataSource.getGrandTotals() || this.data;
-    },
-
-    setData: function(data) {
-        this.data = data || [];
-    },
-
-    getValue: function(x, y) {
-        return this.data[y][x];
-    },
-
-    setValue: function(x, y, value) {
-        this.data[x] = value;
-    },
-
-    getRow: function(y) {
-        return this.data[y];
-    }
-};
-
-module.exports = SummaryRow;
diff --git a/src/dataModels/index.js b/src/dataModels/index.js
index 21e76b0..eb3361c 100644
--- a/src/dataModels/index.js
+++ b/src/dataModels/index.js
@@ -1,9 +1,9 @@
 'use strict';
 
-module.exports = {
-    DataModel: require('./DataModel'), // abstract base class
+var dataModels = {
+    DataModel: require('./DataModel'),
     JSON: require('./JSON'),
-    HeaderSubgrid: require('./HeaderSubgrid'),
-    FilterSubgrid: require('./FilterSubgrid'),
-    SummarySubgrid: require('./SummarySubgrid')
+    HeaderSubgrid: require('./HeaderSubgrid')
 };
+
+module.exports = dataModels;
diff --git a/src/dataSources/DataSourceOrigin.js b/src/dataSources/DataSourceOrigin.js
deleted file mode 100644
index daf849b..0000000
--- a/src/dataSources/DataSourceOrigin.js
+++ /dev/null
@@ -1,342 +0,0 @@
-'use strict';
-
-var DataSourceBase = require('fin-hypergrid-data-source-base');
-
-/**
- * See {@link DataSourceOrigin#initialize} for constructor parameters.
- * @constructor
- */
-var DataSourceOrigin = DataSourceBase.extend('DataSourceOrigin',  {
-
-    /**
-     * Currently a synonym for {@link DataSourceOrigin#setData} (see).
-     */
-    initialize: function(data, schema) {
-        delete this.dataSource; // added by DataSourceBase#initialize but we don't want here
-        this.setData.call(this, data, schema || []);
-    },
-
-    /**
-     * @memberOf DataSourceOrigin#
-     */
-    setData: setData,
-
-    get schema() { return this._schema; },
-    set schema(schema) { this._schema = schema; },
-
-    /**
-     * @memberOf DataSourceOrigin#
-     * @returns {columnSchemaObject[]}
-     */
-    getSchema:  function(){
-        return this._schema;
-    },
-    /**
-     * @memberOf DataSourceOrigin#
-     * Caveat: Do not call on a data update when you expect to reuse the existing schema.
-     * @param schema
-     */
-    setSchema: function(schema){
-        if (!schema.length) {
-            var fields = computeFieldNames(this.data[0]);
-
-            schema = Array(fields.length);
-
-            for (var i = 0; i < fields.length; i++) {
-                schema[i] = { name: fields[i] };
-            }
-        }
-
-        /**
-         * @summary The array of column schema objects.
-         * @name schema
-         * @type {columnSchemaObject[]}
-         * @memberOf DataSourceOrigin#
-         */
-        this._schema = schema;
-    },
-
-    isNullObject: false,
-
-    getDataIndex: function(y) {
-        return y;
-    },
-
-    /**
-     * @memberOf DataSourceOrigin#
-     * @param y
-     * @returns {dataRowObject}
-     */
-    getRow: function(y) {
-        return this.data[y];
-    },
-
-    /**
-     * @summary Find, replace, or update a row by it's primary key column.
-     * @param {string|object} columnName - One of:
-     * * _string_ - Column name. See `value`.
-     * * _object_ - Hash of 0 or more key-value pairs to search for.
-     * @param {string[]|*} [value] - One of:
-     * _omitted_ - When `columnName` is a hash and you want to search all its keys.
-     * _string[]_ - When `columnName` is a hash but you only want to search certain keys.
-     * _otherwise_ - When `columnName` is a string. Value to search for.
-     * Note that `null` is a valid search value.
-     * @param {object|null|undefined} [replacement] - One of:
-     * * _omitted_ - Ignored.
-     * * _object_ - Replacement for the data row if found.
-     * * `null` - Flag to delete the data row if found. The found data row is nonetheless returned.
-     * * `undefined` - Flag to return index of found row instead of row object itself.
-     * @returns {object|number|undefined} One of:
-     * * `undefined` - data row not found
-     * * _object_ - found data row object (will have been deleted if `replacement` was `null`)
-     * * _number_ - index of found data row object in `this.data` (if `replacement` was `undefined`)
-     * @todo Use a binary search (rather than `Array..find`) when column is known to be indexed (sorted).
-     * @memberOf DataSourceOrigin#
-     */
-    findRow: function findRow(columnName, value, replacement) {
-        var result, index, keys, hash, args;
-
-        if (typeof columnName === 'object') {
-            hash = columnName;
-
-            if (value instanceof Array) {
-                args = 2;
-                keys = value;
-                if (keys.reduce(function(sum, key) {
-                        if (key in hash) {
-                            sum++;
-                        }
-                        return sum;
-                    }, 0) !== keys.length) {
-                    throw 'Expected all keys given in 2nd arg to be found in hash given in 1st arg.';
-                }
-            } else {
-                args = 1;
-                keys = Object.keys(hash);
-                replacement = value; // promote
-            }
-
-            if (keys.length === 1) {
-                columnName = keys[0];
-                value = hash[columnName];
-                hash = undefined;
-            } else if (keys.length) {
-                result = this.data.find(function(row, idx) {
-                    if (!row) {
-                        return;
-                    }
-                    index = idx;
-                    for (var key in keys) {
-                        columnName = keys[key];
-                        if (row[columnName] !== hash[columnName]) {
-                            return; // bail
-                        }
-                    }
-                    return true; // found!
-                });
-            }
-        } else {
-            if (arguments.length < 2) {
-                throw 'Expected at least 2 arguments when first argument not object but found ' + arguments.length + '.';
-            }
-            args = 2;
-        }
-
-        if (!hash) {
-            result = this.data.find(function(row, idx) {
-                if (!row) { return; }
-                index = idx;
-                return row[columnName] === value;
-            });
-        }
-
-        if (result) {
-            this.foundRowIndex = index;
-            if (replacement === null) {
-                this.data.splice(index, 1);
-            } else if (typeof replacement === 'object') {
-                this.data[index] = replacement;
-            } else if (replacement === undefined) {
-                if (arguments.length > args) {
-                    delete this.data[index];
-                }
-            } else {
-                throw 'Expected null, undefined, or object but found ' + typeof replacement + '.';
-            }
-        } else {
-            this.foundRowIndex = undefined;
-        }
-
-        return result;
-    },
-
-    /**
-     * @summary Find, replace, or update a row by it's index.
-     * @param {number} index - Row index that is being accessed
-     * @param {object|null|undefined} [replacement] - One of:
-     * * _omitted_ - Ignored.
-     * * _object_ - Replacement for the data row if found.
-     * * `null` - Flag to delete the data row if found. The found data row is nonetheless returned.
-     * * `undefined` - Flag to delete the row at that index.
-     * @returns {object|number|undefined} One of:
-     * * `undefined` - data row not found
-     * * _object_ - found data row object (will have been deleted if `replacement` was `null`)
-     * @todo Use a binary search (rather than `Array..find`) when column is known to be indexed (sorted).
-     * @memberOf DataSourceOrigin#
-     */
-    findRowByIndex: function findRow(index, replacement) {
-        var result;
-
-        if (arguments.length < 1) {
-            throw 'Expected at least 1 argument but found ' + arguments.length + '.';
-        }
-
-        if (typeof index !== 'number') {
-            throw 'Expected at index to be a number but got ' + index + '.';
-        }
-
-        result = this.data[index];
-
-        if (result) {
-            if (replacement === null) {
-                this.data.splice(index, 1);
-            } else if (typeof replacement === 'object') {
-                this.data[index] = replacement;
-            } else if (replacement === undefined && arguments.length >= 2) {
-                delete this.data[index];
-            } else if (replacement !== undefined) {
-                throw 'Expected null, undefined, or object but found ' + typeof replacement + '.';
-            }
-        }
-
-        return result;
-    },
-
-
-    /**
-     * @memberOf DataSourceOrigin#
-     * @param x
-     * @param y
-     * @returns {*}
-     */
-    getValue: function(x, y) {
-        var row = this.getRow(y);
-        if (!row) {
-            return null;
-        }
-        return row[this.schema[x].name];
-    },
-
-    /**
-     * @memberOf DataSourceOrigin#
-     * @param {number} x
-     * @param {number} y
-     * @param value
-     */
-    setValue: function(x, y, value) {
-        this.getRow(y)[this.schema[x].name] = value;
-    },
-
-    /**
-     * @memberOf DataSourceOrigin#
-     * @returns {number}
-     */
-    getRowCount: function() {
-        return this.data.length;
-    },
-
-    /**
-     * @memberOf DataSourceOrigin#
-     * @returns {number}
-     */
-    getColumnCount: function() {
-        return this.schema.length;
-    },
-
-    /**
-     * @memberOf DataSourceOrigin#
-     * @returns {number[]}
-     */
-    getFields: function() {
-        return this.schema.map(function(columnSchema) { return columnSchema.name; });
-    },
-
-    /**
-     * @memberOf DataSourceOrigin#
-     * @returns {string[]}
-     */
-    getHeaders: function() {
-        return this.schema.map(function(columnSchema) { return columnSchema.header; });
-    },
-
-    /**
-     * @memberOf DataSourceOrigin#
-     * @param {string[]} fields
-     */
-    setFields: function(fields) {
-        if (!(Array.isArray(fields) && fields.length === this.schema.length)) {
-            throw new this.DataSourceError('Expected argument to be an array with correct length.');
-        }
-        fields.forEach(function(field, i) {
-            this.schema[i].field = field;
-        }, this);
-    },
-
-    /**
-     * @memberOf DataSourceOrigin#
-     * @param {string[]} [headers] - If omitted, headers will be reset to their derived defaults on next call to `getHeaders`.
-     */
-    setHeaders: function(headers) {
-        if (!(Array.isArray(headers) && headers.length === this.schema.length)) {
-            throw new this.DataSourceError('Expected argument to be an array with correct length.');
-        }
-        headers.forEach(function(header, i) {
-            this.schema[i].header = header;
-        }, this);
-    }
-});
-
-/** @typedef {object} columnSchemaObject
- * @property {string} name - The required column name.
- * @property {string} [header] - An override for derived header
- * @property {function} [calculator] - A function for a computed column. Undefined for normal data columns.
- * @property {string} [type] - Used for sorting when and only when comparator not given.
- * @property {object} [comparator] - For sorting, both of following required:
- * @property {function} comparator.asc - ascending comparator
- * @property {function} comparator.desc - descending comparator
- */
-
-/**
- * @param {object[]} [data=[]] - Array of uniform objects containing the grid data.
- * @param {columnSchemaObject[]} [schema=[]]
- * @memberOf DataSourceOrigin#
- */
-function setData(data, schema) {
-    /**
-     * @summary The array of uniform data objects.
-     * @name schema
-     * @type {columnSchemaObject[]}
-     * @memberOf DataSourceOrigin#
-     */
-    this.data = data || [];
-
-    if (schema) {
-        this.setSchema(schema);
-    }
-}
-
-/**
- * @private
- * @param {object} object
- * @returns {string[]}
- */
-function computeFieldNames(object) {
-    if (!object) {
-        return [];
-    }
-    return Object.getOwnPropertyNames(object || []).filter(function(e) {
-        return e.substr(0, 2) !== '__';
-    });
-}
-
-module.exports = DataSourceOrigin;
diff --git a/src/dataSources/index.js b/src/dataSources/index.js
deleted file mode 100644
index a072b82..0000000
--- a/src/dataSources/index.js
+++ /dev/null
@@ -1,6 +0,0 @@
-'use strict';
-
-module.exports = {
-    dataSourceOrigin: require('./DataSourceOrigin'),
-    DataSourceBase: require('fin-hypergrid-data-source-base')
-};
diff --git a/src/defaults.js b/src/defaults.js
index d97e8f2..e8f844b 100644
--- a/src/defaults.js
+++ b/src/defaults.js
@@ -1,9 +1,11 @@
-/* eslint-env browser */
-
 'use strict';
 
-var LRUCache = require('lru-cache');
+var graphics = require('./lib/graphics');
+var HypergridError = require('./lib/error');
+
+var COLUMN_ONLY_PROPERTY = 'Attempt to set column-only property on a non-column properties object.';
 
+var warned = {};
 
 /**
  * This module lists the properties that can be set on a {@link Hypergrid} along with their default values.
@@ -11,13 +13,21 @@ var LRUCache = require('lru-cache');
  * @module defaults
  */
 
-module.exports = {
+var defaults = {
+
+    set name(x) { throw new HypergridError(COLUMN_ONLY_PROPERTY); },
+    set type(x) { throw new HypergridError(COLUMN_ONLY_PROPERTY); },
+    set header(x) { throw new HypergridError(COLUMN_ONLY_PROPERTY); },
+    set calculator(x) { throw new HypergridError(COLUMN_ONLY_PROPERTY); },
+
+    mixIn: require('overrider').mixIn,
 
     /**
-     * The font for data cells.
+     * The default message to display in front of the canvas when there are no grid rows.
+     * Format is HTML.
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
     noDataMessage: '',
 
@@ -26,7 +36,7 @@ module.exports = {
      * The font for data cells.
      * @default
      * @type {cssFont}
-     * @instance
+     * @memberOf module:defaults
      */
     font: '13px Tahoma, Geneva, sans-serif',
 
@@ -34,7 +44,7 @@ module.exports = {
      * Font color for data cells.
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
     color: 'rgb(25, 25, 25)',
 
@@ -42,7 +52,7 @@ module.exports = {
      * Background color for data cells.
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
     backgroundColor: 'rgb(241, 241, 241)',
 
@@ -50,7 +60,7 @@ module.exports = {
      * Font style for selected cell(s).
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
     foregroundSelectionFont: 'bold 13px Tahoma, Geneva, sans-serif',
 
@@ -58,20 +68,14 @@ module.exports = {
      * Font color for selected cell(s).
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
     foregroundSelectionColor: 'rgb(0, 0, 128)',
     /**
-     * @default
-     * @type {boolean}
-     * @instance
-     */
-    sortOnHiddenColumns: true,
-    /**
      * Background color for selected cell(s).
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
     backgroundSelectionColor: 'rgba(147, 185, 255, 0.625)',
 
@@ -83,14 +87,14 @@ module.exports = {
     /**
      * @default
      * @type {cssFont}
-     * @instance
+     * @memberOf module:defaults
      */
     columnHeaderFont: '12px Tahoma, Geneva, sans-serif',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     columnHeaderColor: 'rgb(25, 25, 25)',
 
@@ -98,51 +102,44 @@ module.exports = {
      * Font style for selected columns' headers.
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
     columnHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     columnHeaderBackgroundColor: 'rgb(223, 227, 232)',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     columnHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     columnHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',
 
     /**
      * @default
-     * @type {cssColor}
-     * @instance
-     */
-    columnHeaderForegroundColumnSelectionColor: 'rgb(25, 25, 25)',
-
-    /**
-     * @default
-     * @type {cssColor}
-     * @instance
+     * @type {string}
+     * @memberOf module:defaults
      */
-    columnHeaderBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',
+    columnHeaderHalign: 'center',
 
     /**
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
-    columnHeaderHalign: 'center',
+    columnHeaderRenderer: 'SimpleCell',
 
 
     /********** SECTION: ROW HEADER COLORS **********/
@@ -150,28 +147,28 @@ module.exports = {
     /**
      * @default
      * @type {cssFont}
-     * @instance
+     * @memberOf module:defaults
      */
     rowHeaderFont: '12px Tahoma, Geneva, sans-serif',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     rowHeaderColor: 'rgb(25, 25, 25)',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     rowHeaderBackgroundColor: 'rgb(223, 227, 232)',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     rowHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',
 
@@ -179,238 +176,257 @@ module.exports = {
      * Font style for selected rows' headers.
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
     rowHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     rowHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',
 
-    /**
-     * @default
-     * @type {cssColor}
-     * @instance
-     */
-    rowHeaderForegroundRowSelectionColor: 'rgb(25, 25, 25)',
-
-    /**
-     * @default
-     * @type {cssColor}
-     * @instance
-     */
-    rowHeaderBackgroundRowSelectionColor: 'rgb(255, 180, 0)',
-
 
     /********** SECTION: FILTER ROW COLORS **********/
 
     /**
      * @default
      * @type {cssFont}
-     * @instance
+     * @memberOf module:defaults
      */
     filterFont: '12px Tahoma, Geneva, sans-serif',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     filterColor: 'rgb(25, 25, 25)',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     filterBackgroundColor: 'white',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     filterForegroundSelectionColor: 'rgb(25, 25, 25)',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     filterBackgroundSelectionColor: 'rgb(255, 220, 97)',
 
     /**
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
     filterHalign: 'center',
 
-
-    /********** SECTION: TREE COLUMN COLORS **********/
-    // The "tree column" contains the hierarchical drill-down controls.
-
     /**
      * @default
-     * @type {cssFont}
-     * @instance
+     * @type {string}
+     * @memberOf module:defaults
      */
-    treeColumnFont: '12px Tahoma, Geneva, sans-serif',
+    filterRenderer: 'SimpleCell',
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
-    treeColumnColor: 'rgb(25, 25, 25)',
+    backgroundColor2: 'rgb(201, 201, 201)',
 
     /**
      * @default
-     * @type {cssColor}
-     * @instance
+     * @type {number}
+     * @memberOf module:defaults
      */
-    treeColumnBackgroundColor: 'rgb(223, 227, 232)',
+    voffset: 0,
 
     /**
      * @default
-     * @type {cssColor}
-     * @instance
+     * @type {string}
+     * @memberOf module:defaults
      */
-    treeColumnForegroundSelectionColor: 'rgb(25, 25, 25)',
+    scrollbarHoverOver: 'visible',
 
     /**
      * @default
-     * @type {cssColor}
-     * @instance
+     * @type {string}
+     * @memberOf module:defaults
      */
-    treeColumnBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',
+    scrollbarHoverOff: 'hidden',
 
     /**
      * @default
-     * @type {cssColor}
-     * @instance
+     * @type {boolean}
+     * @memberOf module:defaults
      */
-    treeColumnForegroundColumnSelectionColor: 'rgb(25, 25, 25)',
+    scrollingEnabled: true,
 
     /**
      * @default
-     * @type {cssColor}
-     * @instance
+     * @type {string}
+     * @memberOf module:defaults
      */
-    treeColumnBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',
+    vScrollbarClassPrefix: '',
 
     /**
      * @default
-     * @type {cssColor}
-     * @instance
+     * @type {string}
+     * @memberOf module:defaults
      */
-    backgroundColor2: 'rgb(201, 201, 201)',
+    hScrollbarClassPrefix: '',
 
     /**
      * @default
-     * @type {number}
-     * @instance
+     * @type {string}
+     * @memberOf module:defaults
      */
-    voffset: 0,
+    halign: 'center',
 
     /**
+     * Padding to left and right of cell value.
+     *
+     * NOTE: Right padding may not be visible if column is not sized wide enough.
+     *
+     * See also {@link module:defaults.iconPadding|iconPadding}.
      * @default
-     * @type {string}
-     * @instance
+     * @type {number}
+     * @memberOf module:defaults
      */
-    scrollbarHoverOver: 'visible',
+    cellPadding: 5,
 
     /**
+     * Padding to left and right of cell icons.
+     *
+     * Overrides {@link module:defaults.cellPadding|cellPadding}:
+     * * Left icon + `iconPadding` overrides left {@link module:defaults.cellPddingg|cellPddingg}.
+     * * Right icon + `iconPadding` overrides right {@link module:defaults.cellPddingg|cellPddingg}.
+     * @see {@link module:defaults.leftIcon|leftIcon}
+     * @see {@link module:defaults.centerIcon|centerIcon}
+     * @see {@link module:defaults.rightIcon|rightIcon}
      * @default
-     * @type {string}
-     * @instance
+     * @type {number}
+     * @memberOf module:defaults
      */
-    scrollbarHoverOff: 'hidden',
+    iconPadding: 3,
 
     /**
+     * @summary Name of image to appear at right of cell.
+     * Must be a key from {@link module:images|images}.
+     * @desc Used by {@link SimpleCell} cell renderer.
+     * @see {@link module:defaults.centerIcon|centerIcon}
+     * @see {@link module:defaults.rightIcon|rightIcon}
+     * @see {@link module:defaults.iconPadding|iconPadding}
      * @default
-     * @type {boolean}
-     * @instance
+     * @type {string}
+     * @memberOf module:defaults
      */
-    scrollingEnabled: true,
+    leftIcon: undefined,
 
     /**
+     * @summary Name of image to appear at right of cell.
+     * Must be a key from {@link module:images|images}.
+     * @desc Used by {@link SimpleCell} cell renderer.
+     * @see {@link module:defaults.leftIcon|leftIcon}
+     * @see {@link module:defaults.rightIcon|rightIcon}
+     * @see {@link module:defaults.iconPadding|iconPadding}
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
-    vScrollbarClassPrefix: '',
+    centerIcon: undefined,
 
     /**
+     * @summary Name of image to appear at right of cell.
+     * Must be a key from {@link module:images|images}.
+     * @desc Used by {@link SimpleCell} cell renderer.
+     * @see {@link module:defaults.leftIcon|leftIcon}
+     * @see {@link module:defaults.centerIcon|centerIcon}
+     * @see {@link module:defaults.iconPadding|iconPadding}
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
-    hScrollbarClassPrefix: '',
-
-    //these used to be in the constants element
+    rightIcon: undefined,
 
     /**
+     * Set to `true` to render `0` and `false`. Otherwise these value appear as blank cells.
      * @default
-     * @type {string}
-     * @instance
+     * @type {boolean}
+     * @memberOf module:defaults
      */
-    fixedRowAlign: 'center',
+    renderFalsy: false,
 
     /**
      * @default
-     * @type {string}
-     * @instance
+     * @type {boolean}
+     * @memberOf module:defaults
      */
-    fixedColAlign: 'center',
+    gridLinesH: true,
+
     /**
      * @default
-     * @type {string}
-     * @instance
+     * @type {boolean}
+     * @memberOf module:defaults
      */
-    halign: 'center',
+    gridLinesV: true,
 
     /**
+     * Draw horizontal grid line before first rendered column.
      * @default
-     * @type {number}
-     * @instance
+     * @type {boolean}
+     * @memberOf module:defaults
      */
-    cellPadding: 5,
+    gridBorderLeft: false,
 
     /**
+     * Draw horizontal grid line after last rendered column.
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
-    gridLinesH: true,
+    gridBorderRight: false,
 
     /**
+     * Draw horizontal grid line above first rendered row.
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
-    gridLinesV: true,
+    gridBorderTop: false,
+
     /**
+     * Draw horizontal grid line below last rendered row.
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
-    gridLinesVOverflow: false,
+    gridBorderBottom: true,
 
     /**
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
     lineColor: 'rgb(199, 199, 199)',
 
     /**
+     * Caveat: `lineWidth` should be an integer (whole pixel)
      * @default
      * @type {number}
-     * @instance
+     * @memberOf module:defaults
      */
     lineWidth: 1,
 
@@ -418,30 +434,37 @@ module.exports = {
     /**
      * @default
      * @type {number}
-     * @instance
+     * @memberOf module:defaults
      */
     defaultRowHeight: 15,
 
     /**
      * @default
      * @type {number}
-     * @instance
+     * @memberOf module:defaults
      */
     defaultColumnWidth: 100,
 
+    /**
+     * @default
+     * @type {number}
+     * @memberOf module:defaults
+     */
+    minimumColumnWidth: 5,
+
     //for immediate painting, set these values to 0, true respectively
 
     /**
      * @default
      * @type {number}
-     * @instance
+     * @memberOf module:defaults
      */
     repaintIntervalRate: 60,
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     repaintImmediately: false,
 
@@ -450,7 +473,7 @@ module.exports = {
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     useBitBlit: false,
 
@@ -458,80 +481,264 @@ module.exports = {
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     useHiDPI: true,
 
     /**
-     * @default ['alt', 'esc']
-     * @type {string}
-     * @instance
+     * @summary Mappings for cell navigation keys.
+     * @desc Cell navigation is handled in the {@link CellSelection} "feature". This property gives you control over which keypresses the built-in mechanism will respond to.
+     *
+     * (If this built-in cell selection logic is insufficient for your needs, you can also listen for the various "fin-key" events and carry out more complex operations in your listeners.)
+     *
+     * The keypress names used here are defined in Canvas.js. Note that all keypresses actually have two names, a normal name and a shifted name. The latter name is used when either **shift** is depressed.
+     *
+     * The built-in nav keypresses are as follows:
+     * * **`UP`** _(up-arrow key)_ - Replace all selections with a single cell, one row up from the last selection.
+     * * **`DOWN`** _(down-arrow key)_ - Replace all selections with a single cell, one row down from the last selection.
+     * * **`LEFT`** _(left-arrow key)_ - Replace all selections with a single cell, one column to the left of the last selection.
+     * * **`RIGHT`** _(right-arrow key)_ - Replace all selections with a single cell, one column to the right of the last selection.
+     * * **`UPSHIFT`** _(shift + up-arrow)_ - Extend the last selection up one row.
+     * * **`DOWNSHIFT`** _(shift + down-arrow)_ - Extend the last selection down one row.
+     * * **`LEFTSHIFT`** _(shift + left-arrow)_ - Extend the last selection left one column.
+     * * **`RIGHTSHIFT`** _(shift + right-arrow)_ - Extend the last selection right one column.
+     *
+     * To alter these or add other mappings see the examples below.
+     *
+     * A note regarding the other meta keys (**trl**, **option**, and **command**): Although these meta keys can be detected, they do not modify the key names as **shift** does. This is because they are more for system use and generally (with the possibly exception fo **ctrl**) should not be depended upon, as system functions will take priority and your app will never see these key presses.
+     *
+     * A special accommodation has been made to the {@link module:defaults.editOnKeydown|editOnKeydown} property:
+     * * If `editOnKeydown` truthy AND mapped character is an actual (non-white-space) character (as opposed to say **tab** or **return**), then navigation requires **ctrl** key to distinguish between nav and data.
+     * * If `editOnKeydown` falsy, the **ctrl** key is ignored.
+     *
+     * So in the last example, if `editOnKeydown` is ON, then `a` (without **ctrl**) would start editing the cell and **ctrl** + `a` would move the selection one column to the left.
+     *
+     * @example
+     * // To void the above build-ins:
+     * navKeyMap: {
+     *     UP: undefined,
+     *     UPSHIFT: undefined,
+     *     DOWN: undefined,
+     *     ...
+     * }
+     *
+     * @example
+     * // To map alternative nav keypresses to RETURN and TAB (default mapping):
+     * navKeyMap: {
+     *     RETURN: 'DOWN',
+     *     RETURNSHIFT: 'UP',
+     *     TAB: 'RIGHT',
+     *     TABSHIFT: 'LEFT'
+     * }
+     *
+     * @example
+     * // To map alternative nav keypresses to a/w/d/s and extend select to A/W/D/S:
+     * navKeyMap: {
+     *     a: 'LEFT', A: 'LEFTSHIFT',
+     *     w: 'UP', W: 'UPSHIFT',
+     *     s: 'DOWN', S: 'DOWNSHIFT',
+     *     d: 'RIGHT', D: 'RIGHTSHIFT'
+     * }
+     *
+     * @default
+     * @type {object|undefined}
+     * @memberOf module:defaults
      */
-    editorActivationKeys: ['alt', 'esc'],
+    navKeyMap: {
+        RETURN: 'DOWN',
+        RETURNSHIFT: 'UP',
+        TAB: 'RIGHT',
+        TABSHIFT: 'LEFT'
+    },
+
+    /**
+     * Returns any value of `keyChar` that passes the following logic test:
+     * 1. If a non-printable, white-space character, then nav key.
+     * 2. If not (i.e., a normal character), can still be a nav key if not editing on key down.
+     * 3. If not, can still be a nav key if CTRL key is down.
+     *
+     * Note: Callers are typcially only interested in the following values of `keyChar` and will ignore all others:
+     * * `'LEFT'` and `'LEFTSHIFT'`
+     * * `'RIGHT'` and `'RIGHTSHIFT'`
+     * * `'UP'` and `'UPSHIFT'`
+     * * `'DOWN'` and `'DOWNSHIFT'`
+     *
+     * @param {string} keyChar - A value from Canvas's `charMap`.
+     * @param {boolean} [ctrlKey=false] - The CTRL key was down.
+     * @returns {undefined|string} `undefined` means not a nav key; otherwise returns `keyChar`.
+     * @memberOf module:defaults
+     */
+    navKey: function(keyChar, ctrlKey) {
+        var result;
+        if (keyChar.length > 1 || !this.editOnKeydown || ctrlKey) {
+            result = keyChar; // return the mapped value
+        }
+        return result;
+    },
+
+    /**
+     * Returns only values of `keyChar` that, when run through {@link module:defaults.navKeyMap|navKeyMap}, pass the {@link module:defaults.navKey|navKey} logic test.
+     *
+     * @param {string} keyChar - A value from Canvas's `charMap`, to be remapped through {@link module:defaults.navKeyMap|navKeyMap}.
+     * @param {boolean} [ctrlKey=false] - The CTRL key was down.
+     * @returns {undefined|string} `undefined` means not a nav key; otherwise returns `keyChar`.
+     * @memberOf module:defaults
+     */
+    mappedNavKey: function(keyChar, ctrlKey) {
+        keyChar = this.navKeyMap[keyChar];
+        return keyChar && this.navKey(keyChar);
+    },
+
+    /** @summary Validation failure feedback.
+     * @desc Validation occurs on {@link CellEditor#stopEditing}, normally called on commit (`TAB`, `ENTER`, or any other keys listed in `navKeyMap`).
+     *
+     * On successful validation, the value is saved back to the data source and the editor is closed.
+     *
+     * On validation failure, feedback is shown to the user in the form of an "error effect" possibly followed by an "end effect" containing a detailed explanation.
+     *
+     * The error effect to use is named in `feedbackEffect
+     *
+     * The value of this property is the number of times to show the "error effect" on validation failure before showing the detailed explanation.
+     *
+     * `feedback` may be set to one of:
+     * * **`undefined`** - Do not show the error effect or the alert. Just discard the value and close the editor (as if `ESC` had been typed).
+     * * **`0`** - Just shows the error feedback effect (see the {@link CellEditor#errorEffect|errorEffect} property).
+     * * **`1`** - Shows the error feedback effect followed by the detailed explanation.
+     * * `2` or more:
+     *   1. Shows the error feedback effect
+     *   2. On every `feedback` tries, shows the detailed explanation.
+     * @default
+     * @type {number|undefined}
+     * @memberOf module:defaults
+     */
+    feedbackCount: 3,
+
+    /**
+     * @default
+     * @type {{name:string,options:object}|string}
+     * @memberOf module:defaults
+     */
+    feedbackEffect: 'shaker',
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     readOnly: false,
 
     // inherited by cell renderers
 
     /**
-     * @default `getTextWidth`
+     * This function is referenced here so it will be available to the renderer and cell renderers.
+     * @default {@link module:defaults.getTextWidth|getTextWidth}
      * @type {function}
-     * @instance
+     * @memberOf module:defaults
      */
-    getTextWidth: getTextWidth,
+    getTextWidth: function(gc, string) {
+        if (!warned.getTextWidth) {
+            warned.getTextWidth = true;
+            console.warn('getTextWidth(gc, string) has been deprecated on the properties (or config) object as of v1.2.4 in favor of the graphics context (aka gc) object and will be removed from the properties object in a future release. Please change your calling context to gc.getTextWidth(string), excluding the first parameter (gc) from your call.');
+        }
+        return graphics.getTextWidth.apply(gc, string);
+    },
 
     /**
-     * @default `getTextHeight`
+     * This function is referenced here so it will be available to the renderer and cell renderers.
+     * @default {@link module:defaults.getTextHeight|getTextHeight}
      * @type {function}
-     * @instance
+     * @memberOf module:defaults
      */
-    getTextHeight: getTextHeight,
+    getTextHeight: function(font) {
+        if (!warned.getTextHeight) {
+            warned.getTextHeight = true;
+            console.warn('getTextHeight(font) has been deprecated on the properties (or config) object as of v1.2.4 in favor of the graphics context (aka gc) object and will be removed from the properties object in a future release. Please change your calling context to gc.getTextHeight(font).');
+        }
+        return graphics.getTextHeight(font);
+    },
+
+    get x() {
+        if (!warned.x) {
+            warned.x = true;
+            console.warn('config.x has been deprecated as of v1.2.10 in favor of config.dataCell.x. (Will be removed in a future release.)');
+        }
+        return this.dataCell.x;
+    },
+
+    get untranslatedX() {
+        if (!warned.untranslatedX) {
+            warned.untranslatedX = true;
+            console.warn('config.untranslatedX has been deprecated as of v1.2.10 in favor of config.gridCell.x. (Will be removed in a future release.)');
+        }
+        return this.gridCell.x;
+    },
+
+    get y() {
+        if (!warned.y) {
+            warned.y = true;
+            console.warn('config.y has been deprecated as of v1.2.10 in favor of config.gridCell.y. (Will be removed in a future release.)');
+        }
+        return this.gridCell.y;
+    },
+
+    get normalizedY() {
+        if (!warned.normalizedY) {
+            warned.normalizedY = true;
+            console.warn('config.normalizedY has been deprecated as of v1.2.10 in favor of config.dataCell.y. (Will be removed in a future release.)');
+        }
+        return this.dataCell.y;
+    },
 
+    /**
+     * @summary Execute value if "calculator" (function) or if column has calculator.
+     * @desc This function is referenced here so:
+     * 1. it will be available to the cell renderers.
+     * 2. Its context will naturally be the `config` object
+     * @default {@link module:defaults.exec|exec}
+     * @type {function}
+     * @memberOf module:defaults
+     */
+    exec: exec,
 
     /**
      * @default
      * @type {number}
-     * @instance
+     * @memberOf module:defaults
      */
     fixedColumnCount: 0,
 
     /**
      * @default
      * @type {number}
-     * @instance
+     * @memberOf module:defaults
      */
     fixedRowCount: 0,
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     showRowNumbers: true,
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     showTreeColumn: true,
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     showHeaderRow: true,
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     showFilterRow: false,
 
@@ -539,104 +746,118 @@ module.exports = {
     /** Clicking in a cell "selects" it; it is added to the select region and repainted with "cell selection" colors.
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     cellSelection: true,
 
     /** Clicking in a column header (top row) "selects" the column; the entire column is added to the select region and repainted with "column selection" colors.
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     columnSelection: true,
 
     /** Clicking in a row header (leftmost column) "selects" the row; the entire row is added to the select region and repainted with "row selection" colors.
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     rowSelection: true,
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     singleRowSelectionMode: true,
 
     /**
+     * @summary Fill color for last selection overlay.
+     * @desc The color should be translucent (or transparent). Note that "Partial" grid renderers (such as the {@link paintCellsAsNeeded} renderer) do not draw overlay because it just gets darker and darker for non-updated cells.
      * @default
      * @type {cssColor}
-     * @instance
+     * @memberOf module:defaults
      */
-    selectionRegionOverlayColor: 'rgba(0, 0, 48, 0.2)',
+    selectionRegionOverlayColor: 'transparent', // 'rgba(0, 0, 48, 0.2)',
 
     /**
+     * @summary Stroke color for last selection overlay.
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
     selectionRegionOutlineColor: 'rgb(69, 69, 69)',
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     columnAutosizing: true,
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     rowNumberAutosizing: true,
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     headerTextWrapping: false,
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     rowResize: false,
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     editable: true,
 
     /**
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     filterable: true,
 
     /**
+     * This is used only by FilterBox cell editor.
+     * One of:
+     * * **`'onCommit'`** - Column filter state not set until keyup === `\r` (return/enter key)
+     * * **`'immediate'`** - Column filter state set on each key press
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
+     */
+    filteringMode: 'onCommit',
+
+    /**
+     * @default
+     * @type {boolean}
+     * @memberOf module:defaults
      */
     editOnDoubleClick: true,
 
     /**
      * @default
      * @type {number}
-     * @instance
+     * @memberOf module:defaults
      */
     doubleClickDelay: 325,
 
     /**
      * Grid-level property.
-     * When user presses a printable character key _or_ BACKSPACE _or_ DELETE:
+     * When user presses a "printable" keyboard character _or_ BACKSPACE _or_ DELETE:
      * 1. Activate cell editor on current cell (i.e., origin of most recent selection).
      * 2. If cell editor is a text editor:
      *    1. Replace current value with the character the user typed; or
@@ -646,23 +867,62 @@ module.exports = {
      *
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     editOnKeydown: true,
 
     /**
+     * @summary Open cell editor when cell selected via keyboard navigation.
+     * @desc Keyboard navigation always includes:
+     * 1. The four arrow keys -- but only when there is no active text cell editor open
+     * 2. Additional keys mapped to the four directs in {@link module:defaults.navKeyMap}
+     *
+     * Generally set at the grid level. If set at the column (or cell) level, note that the property pertains to the cell navigated _to,_ not the cell navigated _away from._
+     * @default
+     * @type {boolean}
+     * @memberOf module:defaults
+     */
+    editOnNextCell: false,
+
+    /**
+     * @summary Retain row selections.
+     * @desc When falsy, row selections are cleared when selecting cells; when truthy, row selections are kept as is when selecting cells.
+     * @todo Deprecate in favor of something simpler like `keepRowSelections`. (The current name is misleading and has caused some confusion among both developers and users. At the very least it should have been called `checkboxOnlyRowDeselections`.)
      * @default
      * @type {boolean}
-     * @instance
+     * @memberOf module:defaults
      */
     checkboxOnlyRowSelections: false,
 
+    /**
+     * @summary Select cell's entire row.
+     * @desc When truthy, selecting a cell will also select the entire row it is in, subject to note #1 below.
+     *
+     * Notes:
+     * 1. Ineffectual unless `checkboxOnlyRowSelections` is set to `false`.
+     * 2. To allow auto-selection of _multiple rows,_ set `singleRowSelectionMode` to `false`.
+     *
+     * @default
+     * @type {boolean}
+     * @memberOf module:defaults
+     */
+    autoSelectRows: false,
+
+    /**
+     * @summary Select cell's entire column.
+     * @desc When truthy, selecting a cell will also select the entire column it is in.
+     * @default
+     * @type {boolean}
+     * @memberOf module:defaults
+     */
+    autoSelectColumns: false,
+
     /** @summary Name of a formatter for cell text.
      * @desc The default (`undefined`) falls back to `column.type`.
      * The value `null` does no formatting.
      * @default undefined
      * @type {undefined|null|string}
-     * @instance
+     * @memberOf module:defaults
      * @tutorial localization
      */
     format: undefined,
@@ -671,7 +931,7 @@ module.exports = {
      * @desc Not editable if named editor is does not exist.
      * @default undefined
      * @type {undefined|null|string}
-     * @instance
+     * @memberOf module:defaults
      * @tutorial cell-editors
      */
     editor: undefined,
@@ -680,10 +940,20 @@ module.exports = {
      * Name of cell renderer from the {@link module:cellRenderers|cellRenderers API}.
      * @default
      * @type {string}
-     * @instance
+     * @memberOf module:defaults
      */
     renderer: 'SimpleCell',
 
+    /**
+     * Name of grid renderer.
+     * Renderer must have been registered.
+     * @see {@link Renderer#registerGridRenderer}.
+     * @default
+     * @type {string}
+     * @memberOf module:defaults
+     */
+    gridRenderer: 'by-columns-and-rows',
+
     /********** HOVER COLORS **********/
 
     /** @typedef hoverColors
@@ -695,7 +965,7 @@ module.exports = {
     /** On mouse hover, whether to repaint the cell background and how.
      * @type {hoverColors}
      * @default '{ enabled: true, background: rgba(160, 160, 40, 0.30) }'
-     * @instance
+     * @memberOf module:defaults
      */
     hoverCellHighlight: {
         enabled: true,
@@ -705,7 +975,7 @@ module.exports = {
     /** On mouse hover, whether to repaint the row background and how.
      * @type {hoverColors}
      * @default '{ enabled: true, background: rgba(100, 100, 25, 0.15) }'
-     * @instance
+     * @memberOf module:defaults
      */
     hoverRowHighlight: {
         enabled: true,
@@ -716,40 +986,108 @@ module.exports = {
     /** On mouse hover, whether to repaint the column background and how.
      * @type {hoverColors}
      * @default '{ enabled: true, background: rgba(60, 60, 15, 0.15) }'
-     * @instance
+     * @memberOf module:defaults
      */
     hoverColumnHighlight: {
         enabled: true,
         backgroundColor: 'rgba(60, 60, 15, 0.15)'
     },
 
-
-    /** Display cell font with under-score line drawn over it.
-     * > Implementation of links right now is not automatic; you must attach a 'fin-click' listener to the hypergrid object, etc.
+    /** @summary Display cell value as a link (with underline).
+     * @desc One of:
+     * * `boolean` - No action occurs on click; you would need to attach a 'fin-click' listener to the hypergrid object.
+     *   * `true` - Displays the cell as a link.
+     *   * _falsy_ - Displays the cell normally.
+     * * `string` -  The URL is decorated (see {}) and then opened in a separate window/tab. See also {@link module:defaults.linkTarget|linkTarget}.
+     *   * `'*'` - Use the cell value as the URL, ready for decorating (see {CellClick#openLink|openLink)).
+     *   * _field name_ - Fetches the string from the named field in the same row, assumed to be a URL ready for decorating. (May contain only alphanumerics and underscore; no spaces or other punctuation.)
+     *   * _otherwise_ Assumed to contains a URL ready for decorating.
+     * * `function` - A function to execute to get the URL ready for decorating. The function is passed a single parameter, `cellEvent`, from which you can get the field `name`, `dataRow`, _etc._
+     * * `Array` - An array to "apply" to {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/open window.open} in its entirety. The first element is interpreted as above for `string` or `function`.
+     *
+     * In the case of `string` or `Array`, the link is further unpacked by {@link module:CellClick.openLink|openLink} and then sent to `grid.windowOpen`.
+     *
+     * @example
+     * // following affect upper-left data cell:
+     * grid.behavior.setCellProperty(0, 0, 'https://nytimes.com'); // absolute address using specific protocol
+     * grid.behavior.setCellProperty(0, 0, '//nytimes.com'); // absolute address using current protocol
+     * grid.behavior.setCellProperty(0, 0, '/page2.com'); // relative to current site
+     * grid.behavior.setCellProperty(0, 0, 'mypage.com'); // relative to current page
+     * grid.behavior.setCellProperty(0, 0, 'mypage.com?id=%value'); // cell's value will replace %value
+     * grid.behavior.setCellProperty(0, 0, ['//www.newyorker.com', 'ny', undefined, true]) // target='ny', replace=true
+     * @type {boolean|string|Array}
      * @type {boolean}
      * @default
-     * @instance
+     * @memberOf module:defaults
      */
     link: false,
 
+    /** @summary The window (or tab) in which to open the link.
+     * @desc The default ('_blank'`) will open a new window for every click.
+     *
+     * To have the first click open a new window and all subsequent clicks reuse that same window, set this to an arbitrary string.
+     *
+     * Otherwise, specific columns or cells can be set to open their links in their own window by setting the appropriate column's or cell's `linkTarget` property.
+     * @default
+     * @memberOf module:defaults
+     */
+    linkTarget: '_blank',
+
+    /** @summary Underline link on hover only.
+     * @type {boolean}
+     * @default
+     * @memberOf module:defaults
+     */
+    linkOnHover: false,
+
+    /** @summary Color for link.
+     * @desc Falsy means defer to foreground color.
+     * @type {string}
+     * @default
+     * @memberOf module:defaults
+     */
+    linkColor: 'blue',
+
+    /** @summary Color for visited link.
+     * @desc Falsy means defer to foreground color.
+     * @type {string}
+     * @default
+     * @memberOf module:defaults
+     */
+    linkVisitedColor: 'purple',
+
+    /** @summary Color link on hover only.
+     * @type {boolean}
+     * @default
+     * @memberOf module:defaults
+     */
+    linkColorOnHover: false,
+
     /** Display cell font with strike-through line drawn over it.
      * @type {boolean}
      * @default
-     * @instance
+     * @memberOf module:defaults
      */
     strikeThrough: false,
 
     /** Ignore sort interaction (double-click).
      * @type {boolean}
      * @default
-     * @instance
+     * @memberOf module:defaults
      */
     unsortable: false,
 
+    /**
+     * @default
+     * @type {boolean}
+     * @memberOf module:defaults
+     */
+    sortOnHiddenColumns: true,
+
     /** Allow multiple cell region selections.
      * @type {boolean}
      * @default
-     * @instance
+     * @memberOf module:defaults
      */
     multipleSelections: false,
 
@@ -760,40 +1098,91 @@ module.exports = {
      * * The Hypergrid renderer gobbles up CPU time even when the grid appears idle (the very scenario `repaint()` is designed to avoid). For this reason, we emphatically advise against shipping applications using this mode.
      * @type {boolean}
      * @default
-     * @instance
+     * @memberOf module:defaults
      */
     enableContinuousRepaint: false,
 
     /** @summary Allow user to move columns .
      * @desc Columns can be reordered through either of two interfaces:
      * * Column Dragging feature
-     * * Column Picker dialog
+     * * behavior.columns API
      * @type {boolean}
      * @default
-     * @instance
+     * @memberOf module:defaults
      */
     columnsReorderable: true,
 
     /** @summary Apply cell properties before `getCell`.
      * @type {boolean}
      * @default
-     * @instance
+     * @memberOf module:defaults
      */
     applyCellProperties: true,
 
     /** @summary Reapply cell properties after `getCell`.
      * @type {boolean}
      * @default
-     * @instance
+     * @memberOf module:defaults
      */
     reapplyCellProperties: false,
 
     /** @summary Column grab within this number of pixels from top of cell.
      * @type {number}
      * @default
-     * @instance
+     * @memberOf module:defaults
      */
-    columnGrabMargin: 5
+    columnGrabMargin: 5,
+
+    /** @summary Set up a clipping region around each column before painting cells.
+     * @desc One of:
+     * * `true` - Clip column.
+     * * `false` - Do not clip column.
+     * * `null` - Clip iff last active column.
+     *
+     * Clipping prevents text that overflows to the right of the cell from being rendered.
+     * If you can guarantee that none of your text will overflow, turn column clipping off
+     * for better performance. If not, you may still be able to get away without clipping.
+     * If the background color of the next column is opaque, you don't really need to clip,
+     * although text can leak out to the right of the last column. Clipping the last column
+     * only can help this but not solve it since the leaked text from (say) the column before
+     * the last column could stretch across the entire last column and leak out anyway.
+     * The solution to this is to clip the rendered string so at most only a partial character
+     * will overflow.
+     * @type {boolean|undefined}
+     * @default
+     * @memberOf module:defaults
+     */
+    columnClip: true,
+
+    /**
+     * @summary Repeating pattern of property overrides for grid rows.
+     * @desc Notes:
+     * * "Grid row" refers to data rows.
+     * * Row index modulo is applied when dereferencing this array. In other words, this array represents a _repeating pattern_ of properties to be applied to the data rows.
+     * * For no row properties, specify a falsy value in place of the array.
+     * * Do not specify an empty array (will throw an error).
+     * * Each element of the array may be either:
+     *   * An object containing property overrides to be applied to every cell of the row; or
+     *   * A falsy value signifying that there are no row properties for this specific row.
+     * * Caveat: Row properties use `Object.assign()` to copy properties and therefore are not as performant as column properties which use prototype chain.
+     * * `Object.assign()` is a polyfill in older versions of Chrome (<45) and in all Internet Explorer (through 11).
+     * @type {undefined|object[]}
+     * @default
+     * @memberOf module:defaults
+     */
+    rowProperties: undefined,
+
+    /** @summary How to truncate text.
+     * @desc A "quaternary" value, one of:
+     * * `undefined` - Text is not truncated.
+     * * `true` (default) - Truncate sufficient characters to fit ellipsis if possible. Most acceptable option that avoids need for clipping.
+     * * `false` - Truncate *before* last partially visible character. Visibly annoying; semantically jarring.
+     * * `null` - Truncate *after* partially visible character. Less visibly annoying; still semantically confusing. Best solution when combined with either column clipping or painting over with next column's background.
+     * @type {boolean|null|undefined}
+     * @default
+     * @memberOf module:defaults
+     */
+    truncateTextWithEllipsis: true
 };
 
 /** @typedef {string} cssColor
@@ -803,70 +1192,14 @@ module.exports = {
  * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font
  */
 
-var textWidthCache = new LRUCache(2000);
-
-function getTextWidth(gc, string) {
-    if (string === null || string === undefined) {
-        return 0;
-    }
-    string += '';
-    if (string.length === 0) {
-        return 0;
-    }
-    var key = gc.font + string;
-    var width = textWidthCache.get(key);
-    if (!width) {
-        width = gc.measureText(string).width;
-        textWidthCache.set(key, width);
-    }
-    return width;
-}
-
-var fontData = {};
-
-function getTextHeight(font) {
-    var result = fontData[font];
-
-    if (!result) {
-        result = {};
-
-        var text = document.createElement('span');
-        text.textContent = 'Hg';
-        text.style.font = font;
-
-        var block = document.createElement('div');
-        block.style.display = 'inline-block';
-        block.style.width = '1px';
-        block.style.height = '0px';
-
-        var div = document.createElement('div');
-        div.appendChild(text);
-        div.appendChild(block);
-
-        div.style.position = 'absolute';
-        document.body.appendChild(div);
-
-        try {
-
-            block.style.verticalAlign = 'baseline';
-
-            var blockRect = block.getBoundingClientRect();
-            var textRect = text.getBoundingClientRect();
-
-            result.ascent = blockRect.top - textRect.top;
-
-            block.style.verticalAlign = 'bottom';
-            result.height = blockRect.top - textRect.top;
-
-            result.descent = result.height - result.ascent;
-
-        } finally {
-            document.body.removeChild(div);
-        }
-        if (result.height !== 0) {
-            fontData[font] = result;
+function exec(vf) {
+    if (this.dataRow) {
+        var calculator = (typeof vf)[0] === 'f' && vf || this.calculator;
+        if (calculator) {
+            vf = calculator(this.dataRow, this.name);
         }
     }
-
-    return result;
+    return vf;
 }
+
+module.exports = defaults;
diff --git a/src/dialogs/ColumnPicker.js b/src/dialogs/ColumnPicker.js
deleted file mode 100644
index 531735e..0000000
--- a/src/dialogs/ColumnPicker.js
+++ /dev/null
@@ -1,151 +0,0 @@
-/* eslint-env browser */
-
-'use strict';
-
-var ListDragon = require('list-dragon');
-
-var Dialog = require('./Dialog');
-var stylesheet = require('../lib/stylesheet');
-
-/**
- * @constructor
- * @extends Dialog
- */
-var ColumnPicker = Dialog.extend('ColumnPicker', {
-    /**
-     * @param {Hypergrid} grid
-     * @param {object} [options] - May include `Dialog` options.
-     */
-    initialize: function(grid, options) {
-        var behavior = grid.behavior;
-
-        this.grid = grid;
-
-        if (behavior.isColumnReorderable()) {
-            // parse & add the drag-and-drop stylesheet addendum
-            var stylesheetAddendum = stylesheet.inject('list-dragon-addendum');
-
-            // grab the group lists from the behavior
-            if (behavior.setGroups) {
-                this.selectedGroups = {
-                    title: 'Groups',
-                    models: behavior.getGroups()
-                };
-
-                this.availableGroups = {
-                    title: 'Available Groups',
-                    models: behavior.getAvailableGroups()
-                };
-
-                var groupPicker = new ListDragon([
-                    this.selectedGroups,
-                    this.availableGroups
-                ]);
-
-                // add the drag-and-drop sets to the dialog
-                this.append(groupPicker.modelLists[0].container);
-                this.append(groupPicker.modelLists[1].container);
-            }
-
-            // grab the column lists from the behavior
-            this.inactiveColumns = {
-                title: 'Inactive Columns',
-                models: behavior.getHiddenColumns().sort(compareByName)
-            };
-
-            this.activeColumns = {
-                title: 'Active Columns',
-                models: behavior.getActiveColumns()
-            };
-
-            this.sortOnHiddenColumns = this.wasSortOnHiddenColumns = grid.properties.sortOnHiddenColumns;
-
-            var columnPicker = new ListDragon([
-                this.inactiveColumns,
-                this.activeColumns
-            ], {
-                // add the list-dragon-base stylesheet right before the addendum
-                cssStylesheetReferenceElement: stylesheetAddendum,
-                // these models have a header property as their labels
-                label: '{header}'
-            });
-
-            // add the drag-and-drop sets to the dialog
-            this.append(columnPicker.modelLists[0].container);
-            this.append(columnPicker.modelLists[1].container);
-
-            //Listen to the visible column changes
-            columnPicker.modelLists[1].element.addEventListener('listchanged', function(e){
-                grid.fireSyntheticOnColumnsChangedEvent();
-            });
-
-            this.sortOnHiddenColumns = this.grid.properties.sortOnHiddenColumns;
-        } else {
-            var div = document.createElement('div');
-            div.style.textAlign = 'center';
-            div.style.marginTop = '2em';
-            div.innerHTML = 'The selection of visible columns in the grid may not be changed.';
-            this.append(div);
-        }
-
-        // Add checkbox to control panel for sorting on hidden fields
-        var label = document.createElement('label');
-        label.innerHTML = '<input type="checkbox"> Allow sorting on hidden columns';
-        label.style.fontWeight = 'normal';
-        label.style.marginRight = '2em';
-
-        var checkbox = label.querySelector('input');
-        checkbox.checked = this.sortOnHiddenColumns;
-        checkbox.addEventListener('click', function(e){
-            self.sortOnHiddenColumns = checkbox.checked;
-            e.stopPropagation();
-        });
-
-        var panel = this.el.querySelector('.hypergrid-dialog-control-panel');
-        panel.insertBefore(label, panel.firstChild);
-
-        // add the dialog to the DOM
-        this.open(options.container);
-    },
-
-    onClosed: function() {
-        var behavior = this.grid.behavior,
-            columns = behavior.columns;
-
-        if (this.activeColumns) {
-            var tree = columns[0];
-
-            // TODO: breaking encapsulation; should be using setters and getters on the behavior
-            columns.length = 0;
-            if (tree && tree.label === 'Tree') {
-                columns.push(tree);
-            }
-            this.activeColumns.models.forEach(function(column) {
-                columns.push(column);
-            });
-
-            if (this.sortOnHiddenColumns !== this.wasSortOnHiddenColumns) {
-                this.grid.addProperties({ sortOnHiddenColumns: this.sortOnHiddenColumns });
-                behavior.sortChanged(this.inactiveColumns.models);
-            }
-
-            behavior.changed();
-        }
-
-        if (this.selectedGroups){
-            var groupBys = this.selectedGroups.models.map(function(e) {
-                return e.id;
-            });
-            behavior.setGroups(groupBys);
-        }
-    }
-});
-
-function compareByName(a, b) {
-    a = a.header.toString().toUpperCase();
-    b = b.header.toString().toUpperCase();
-    return a < b ? -1 : a > b ? +1 : 0;
-}
-
-
-module.exports = ColumnPicker;
diff --git a/src/dialogs/Dialog.js b/src/dialogs/Dialog.js
deleted file mode 100644
index f0de733..0000000
--- a/src/dialogs/Dialog.js
+++ /dev/null
@@ -1,215 +0,0 @@
-/* eslint-env browser */
-
-'use strict';
-
-var automat = require('automat');
-
-var Base = require('../Base');
-var markup = require('../../html');
-var images = require('../../images');
-var elfor = require('../lib/DOM/elfor');
-
-/**
- * Creates and services a DOM element used as a cntainer for a dialog. The standard `markup.dialog` is simply a div with a _control panel_ containing a close box and a settings gear icon.
- *
- * You can supply an alternative dialog template. The interface is:
- * * Class name `hypergrid-dialog`.
- * * At least one child element. Content will be inserted before this first child.
- * * Typically contains a close-box element with class name `hypergrid-dialog-close` and possibly other controls with class name `hypergrid-dialog-xxxx` (where _xxxx_ is a unique name for your control).
- *
- * @constructor
- */
-var Dialog = Base.extend('Dialog', {
-
-    /**
-     * Creates a basic dialog box in `this.el`.
-     * @param {Hypergrid} grid
-     * @param {object} [options]
-     * @param {string|function} [options.dialogTemplate] - An alternate dialog template. The last child element must be the "control panel."
-     * @param {boolean} [options.settings=true] - Control box has settings icon. (Settings icon must be included in template. This option removes it. That is, if explicitly `false` _and_ there is a settings control, remove it.)
-     * @param {string|boolean} [options.backgroundImage=images.dialog.src] - A URI for a background image. If explicitly `false`, background image is suppressed.
-     * @param {function} [terminate]
-     */
-    initialize: function(grid, options) {
-        options = options || {};
-
-        this.grid = grid;
-
-        // create the backdrop; it is absolute-positioned and stretched
-        this.el = automat.firstChild(options.dialogTemplate || markup.dialog, options.dialogReplacements);
-
-        this.originalFirstChild = this.el.firstElementChild;
-
-        if (options.settings === false) {
-            var settings = this.el.querySelector('.hypergrid-dialog-settings');
-            if (settings) {
-                settings.remove();
-            }
-        }
-
-        // add background image
-        if (options.backgroundImage !== false) {
-            this.el.style.backgroundImage = 'url(\'' + (options.backgroundImage || images.dialog.src) + '\')';
-        }
-
-        // listen for clicks
-        this.el.addEventListener('click', onClick.bind(this));
-
-        if (options.terminate) {
-            this.terminate = options.terminate;
-        }
-    },
-
-    /**
-     * @summary Adds DOM `Node`s to dialog.
-     * @desc Input can be nodes or a template from which to create nodes. The nodes are inserted into the dialog's DOM (`this.el`), right before the "control panel."
-     * @param {string|function|Node|Node[]} nodes - See `automat`.
-     * @param {...*} [replacements] - See `automat`.
-     */
-    append: function(nodes, replacements/*...*/) {
-        var el = this.el;
-
-        if (typeof nodes === 'string' || typeof nodes === 'function') {
-            var args = Array.prototype.slice.call(arguments);
-            args.splice(1, 0, el, this.originalFirstChild);
-            automat.append.apply(null, args);
-
-        } else if ('length' in nodes) {
-            for (var i = 0; i < nodes.length; ++i) {
-                el.insertBefore(nodes[i], this.originalFirstChild);
-            }
-
-        } else {
-            el.insertBefore(nodes, this.originalFirstChild);
-        }
-    },
-
-    /**
-     * Insert dialog into DOM.
-     *
-     * @param {HTMLElement} [container] - If undefined, dialog is appended to body.
-     *
-     * If defined, dialog is appended to container. When container is not body, it will be:
-     * # made visible before append (it should initially be hidden)
-     * # made hidden after remove
-     */
-    open: function(container) {
-        var error;
-
-        if (!(this.opened || this.opening || this.closed || this.closing)) {
-            error = this.onOpen();
-
-            if (!error) {
-                var el = this.el;
-
-                this.opening = true;
-
-                container = container || document.querySelector('body');
-
-                if (container.tagName !== 'BODY') {
-                    container.style.visibility = 'visible';
-                }
-
-                // insert the new dialog markup into the DOM
-                container.appendChild(el);
-
-                // schedule it for a show transition
-                setTimeout(function() { el.classList.add('hypergrid-dialog-visible'); }, 50);
-
-                // at end of show transition, hide all the hypergrids behind it to prevent any key/mouse events from getting to them
-                // todo: pause all hypergrids so they don't spin uselessly
-                el.addEventListener('transitionend', this.hideAppBound = hideApp.bind(this));
-            }
-        }
-
-        return error;
-    },
-
-    /**
-     * Remove dialog from DOM.
-     */
-    close: function() {
-        var error;
-
-        if (this.opened && !(this.closed || this.closing)) {
-            error = this.onClose();
-
-            if (!error) {
-                var el = this.el;
-
-                this.closing = true;
-
-                // unhide all the hypergrids behind the dialog
-                this.appVisible('visible');
-
-                // start a hide transition of dialog revealing grids behind it
-                el.classList.remove('hypergrid-dialog-visible');
-
-                // at end of hide transition, remove dialog from the DOM
-                el.addEventListener('transitionend', this.removeDialogBound = removeDialog.bind(this));
-            }
-        }
-
-        return error;
-    },
-
-    appSelector: 'canvas.hypergrid',
-    appVisible: function(visibility) {
-        elfor.each(this.appSelector, function(el) {
-            el.style.visibility = visibility;
-        });
-    },
-
-    onOpen: nullPattern,
-    onOpened: nullPattern,
-    onClose: nullPattern,
-    onClosed: nullPattern,
-    terminate: nullPattern
-});
-
-function nullPattern() {}
-
-function removeDialog(evt) {
-    if (evt.target === this.el && evt.propertyName === 'opacity') {
-        if (this.el.parentElement.tagName !== 'BODY') {
-            this.el.parentElement.style.visibility = 'hidden';
-        }
-        this.el.remove();
-        delete this.el;
-
-        this.onClosed();
-        this.terminate();
-        this.closing = false;
-        this.closed = true;
-    }
-}
-
-function hideApp(evt) {
-    if (evt.target === this.el && evt.propertyName === 'opacity') {
-        this.appVisible('hidden');
-        this.el.removeEventListener('transitionend', this.hideAppBound);
-        this.onOpened();
-        this.opening = false;
-        this.opened = true;
-    }
-}
-
-function onClick(evt) {
-    if (this) {
-        if (evt.target.classList.contains('hypergrid-dialog-close')) {
-            evt.preventDefault(); // ignore href
-            this.close();
-
-        } else if (evt.target.classList.contains('hypergrid-dialog-settings')) {
-            evt.preventDefault(); // ignore href
-            if (this.settings) { this.settings(); }
-
-        } else if (this.onClick && !this.onClick.call(this, evt) && evt.target.tagName === 'A') {
-            evt.preventDefault(); // ignore href of handled event
-        }
-    }
-
-    evt.stopPropagation(); // the click stops here, handled or not
-}
-
-module.exports = Dialog;
diff --git a/src/dialogs/ManageFilters.js b/src/dialogs/ManageFilters.js
deleted file mode 100644
index 602cd3c..0000000
--- a/src/dialogs/ManageFilters.js
+++ /dev/null
@@ -1,347 +0,0 @@
-/* eslint-env browser */
-
-'use strict';
-
-var Tabz = require('tabz');
-var popMenu = require('pop-menu');
-var automat = require('automat');
-
-var Dialog = require('./Dialog');
-var markup = require('../../html');
-var copyInput = require('../lib/DOM/copy-input');
-
-var tabProperties = {
-    tableQB: {
-        isTableFilter: true
-    },
-    tableSQL: {
-        isTableFilter: true,
-        language: 'SQL'
-    },
-    columnsQB: {
-        isColumnFilter: true
-    },
-    columnsSQL: {
-        isColumnFilter: true,
-        language: 'SQL'
-    },
-    columnsCQL: {
-        isColumnFilter: true,
-        language: 'CQL'
-    }
-};
-
-/**
- * @constructor
- * @extends Dialog
- */
-var ManageFilters = Dialog.extend('ManageFilters', {
-
-    /**
-     * @param {Hypergrid} grid
-     * @param {object} [options] - May include `Dialog` options.
-     * @param {HTMLElement} [options.container=document.body]
-     */
-    initialize: function(grid, options) {
-        this.filter = grid.filter;
-
-        this.append(markup.filterTrees);
-
-        // initialize the folder tabs
-        var tabz = this.tabz = new Tabz({
-            root: this.el,
-            onEnable: renderFolder.bind(this),
-            onDisable: saveFolders.bind(this, null) // null options
-        });
-
-        // wire-up the New Column drop-down
-        var newColumnDropDown = this.el.querySelector('#add-column-filter-subexpression');
-        newColumnDropDown.onmousedown = onNewColumnMouseDown.bind(this);
-        newColumnDropDown.onchange = onNewColumnChange.bind(this);
-
-        // put the two subtrees in the two panels
-        tabz.folder('#tableQB').appendChild(this.filter.tableFilter.el);
-        tabz.folder('#columnsQB').appendChild(this.filter.columnFilters.el);
-
-        // copy the SQL more-info block from the table to the columns tab
-        var columnSqlEl = tabz.folder('#columnsSQL');
-        var moreSqlInfo = tabz.folder('#tableSQL').firstElementChild.cloneNode(true);
-        columnSqlEl.insertBefore(moreSqlInfo, columnSqlEl.firstChild);
-
-        // add it to the DOM
-        this.open(options.container);
-
-        // following needed for unclear reasons to get drop-down to display correctly
-        newColumnDropDown.selectedIndex = 0;
-    },
-
-    onClose: function() {
-        return saveFolders.call(this);
-    },
-
-    onClosed: function() {
-        var behavior = this.grid.behavior;
-        behavior.reindex();
-        behavior.changed();
-    },
-
-    /**
-     * Custom click handlers; called by curtain.onclick in context
-     * @param evt
-     * @returns {boolean}
-     */
-    onClick: function(evt) { // to be called with filter object as syntax
-        var ctrl = evt.target;
-
-        if (ctrl.classList.contains('more-info')) {
-            // find all more-info links and their adjacent blocks (blocks always follow links)
-            var els = this.el.querySelectorAll('.more-info');
-
-            // hide all more-info blocks except the one following this link (unless it's already visible in which case hide it too).
-            for (var i = 0; i < els.length; ++i) {
-                var el = els[i];
-                if (el.tagName === 'A') {
-                    var found = el === ctrl;
-                    el.classList[found ? 'toggle' : 'remove']('hide-info');
-                    el = els[i + 1];
-                    el.style.display = found && el.style.display !== 'block' ? 'block' : 'none';
-                }
-            }
-
-        } else if (ctrl.classList.contains('filter-copy')) {
-            var isCopyAll = ctrl.childNodes.length; // contains "All"
-            if (isCopyAll) {
-                ctrl = this.tabz.folder(ctrl).querySelector(copyInput.selectorTextControls);
-                copyInput(ctrl, this.filter.columnFilters.getState({ syntax: 'SQL' }));
-            } else {
-                copyInput(ctrl.parentElement.querySelector(copyInput.selectorTextControls));
-            }
-
-        } else {
-            return true; // means unhandled
-        }
-    }
-});
-
-/**
- * @param options
- * @param tab
- * @param folder
- * @param [panel] Panel to save (from tab click). If omitted, save both panels (from onclose).
- * @returns {boolean|undefined|string}
- */
-function saveFolders(options, tab, folder, panel) {
-    return (
-        (!panel || panel.id === 'tableFilterPanel') && saveFolder.call(this, this.filter.tableFilter, options) ||
-        (!panel || panel.id === 'columnFiltersPanel') && saveFolder.call(this, this.filter.columnFilters, options)
-    );
-}
-
-/**
- * @this Filter
- * @param {DefaultFilter} subtree
- * @param {object} [options={alert:true,focus:true}] - Side effects as per `FilterTree.prototype.invalid`'s `options`' parameter.
- * @returns {undefined|string} - Validation error text; falsy means valid (no error).
- */
-function saveFolder(subtree, options) { // to be called with filter object as syntax
-    var isColumnFilters = subtree === this.filter.columnFilters,
-        tabQueryBuilder = this.tabz.tab(isColumnFilters ? '#columnsQB' : '#tableQB'),
-        tab = this.tabz.enabledTab(tabQueryBuilder),
-        folder = this.tabz.folder(tab),
-        isQueryBuilder = tab === tabQueryBuilder,
-        defaultedOptions = options || {
-            alert: true,
-            focus: true
-        },
-        enhancedOptions = {
-            alert: defaultedOptions.alert,
-            focus: defaultedOptions.focus && isQueryBuilder
-        },
-        error, ctrl;
-
-    if (isColumnFilters || isQueryBuilder) {
-        error = subtree.invalid(enhancedOptions);
-    } else { // table filter SQL tab
-        ctrl = folder.querySelector('textarea');
-        error = this.filter.setTableFilterState(ctrl.value, options);
-    }
-
-    if (error && !isQueryBuilder) {
-        // If there was a validation error, move the focus from the query builder control to the text box control.
-        if (isColumnFilters) {
-            // We're in SQL or CQL tab so find text box that goes with this subexpression and focus on it instead of QB control.
-            var errantColumnName = error.node.el.parentElement.querySelector('input').value;
-            ctrl = folder.querySelector('[name="' + errantColumnName + '"]');
-        }
-    }
-
-    if (ctrl) {
-        decorateFilterInput(ctrl, error);
-    }
-
-    return error;
-}
-
-function decorateFilterInput(ctrl, error) {
-    ctrl.classList.toggle('filter-tree-error', !!error);
-
-    ctrl.focus();
-
-    // find the nearby warning element
-    var warningEl;
-    do {
-        ctrl = ctrl.parentElement;
-        warningEl = ctrl.querySelector('.filter-tree-warn');
-    } while (!warningEl);
-
-    // show or hide the error
-    warningEl.innerHTML = error.message || error || '';
-}
-
-function onNewColumnMouseDown(evt) { // to be called with filter object as syntax
-    if (saveFolder.call(this, this.filter.columnFilters)) {
-        evt.preventDefault(); // do not drop down
-    } else {
-        // (re)build the drop-down contents, with same prompt, but excluding columns with active filter subexpressions
-        var ctrl = evt.target,
-            prompt = ctrl.options[0].text.replace('', ''), // use original but w/o ellipsis as .build() appends one
-            blacklist = this.filter.columnFilters.children.map(function(columnFilter) {
-                return columnFilter.children.length && columnFilter.children[0].column;
-            }),
-            options = {
-                prompt: prompt,
-                blacklist: blacklist
-            };
-
-        popMenu.build(ctrl, this.filter.root.schema, options);
-    }
-}
-
-function onNewColumnChange(evt) {
-    var ctrl = evt.target,
-        tabColumnQB = this.tabz.folder('#tableQB'),
-        tab = this.tabz.enabledTab(tabColumnQB.parentElement),
-        isQueryBuilder = tab === tabColumnQB,
-        tabProps = tabProperties[tab.id];
-
-    this.filter.columnFilters.add({
-        state: {
-            type: 'columnFilter',
-            children: [ { column: ctrl.value } ]
-        },
-        focus: isQueryBuilder
-    });
-
-    if (tabProps.isColumnFilter && tabProps.lanugage) {
-        renderFolder.call(this, tab);
-    }
-
-    // remove all but the prompt option (first child)
-    ctrl.selectedIndex = 0;
-    while (ctrl.lastChild !== ctrl.firstChild) {
-        ctrl.removeChild(ctrl.lastChild);
-    }
-}
-
-function renderFolder(tab) { // to be called with filter object as syntax
-    var tabProps = tabProperties[tab.id],
-        queryLanguage = tabProps.language;
-
-    if (queryLanguage) {
-        var globalFilter = this.filter,
-            folder = this.tabz.folder(tab);
-
-        if (tabProps.isTableFilter) {
-
-            folder.querySelector('textarea').value = globalFilter.tableFilter.getState({ syntax: 'SQL' });
-
-        } else { // column filter
-
-            var columnFilters = globalFilter.columnFilters.children,
-                el = folder.lastElementChild,
-                msgEl = el.querySelector('span'),
-                listEl = el.querySelector('ol'),
-                copyAllLink = el.querySelector('a:first-of-type');
-
-            msgEl.innerHTML = activeFiltersMessage(columnFilters.length);
-            listEl.innerHTML = '';
-
-            // for each column filter subtree, append an <li>...</li> element containing:
-            // column title, "(copy)" link, and editable text input box containing the subexpression
-            columnFilters.forEach(function(filter) {
-                var conditional = filter.children[0],
-                    item = conditional.schema[0],
-                    name = conditional.column,
-                    alias = item.alias || name,
-                    expression = filter.getState({ syntax: queryLanguage }),
-                    isNull = expression === '(NULL IS NULL)' || expression === '',
-                    content = isNull ? '' : expression,
-                    className = isNull ? 'filter-tree-error' : '',
-                    li = automat.firstChild(markup[queryLanguage], alias, name, content, className);
-
-                listEl.appendChild(li);
-            });
-
-            folder.onkeyup = setColumnFilterState.bind(this, queryLanguage);
-
-            if (copyAllLink) {
-                // if there's a "(copy all)" link, hide it if only 0 or 1 subexpressions
-                copyAllLink.style.display = columnFilters.length > 1 ? 'block' : 'none';
-            }
-        }
-
-    }
-}
-
-//var RETURN_KEY = 0x0d, ESCAPE_KEY = 0x1b;
-/**
- * Called from key-up events from `#columnSQL` and `#columnCQL` tabs.
- * @this Filter
- * @param {string} queryLanguage
- * @param {KeyboardEvent} evt
- */
-function setColumnFilterState(queryLanguage, evt) {
-    var ctrl = evt.target;
-
-    // Only handle if key was pressed inside a text box.
-    if (ctrl.classList.contains('filter-text-box')) {
-        //switch (evt.keyCode) {
-        //    case ESCAPE_KEY:
-        //        ctrl.value = oldArg;
-        //    case RETURN_KEY: // eslint-disable-line no-fallthrough
-        //        ctrl.blur();
-        //        break;
-        //    default:
-        var error,
-            options = { syntax: queryLanguage, alert: true };
-
-        try {
-            error = this.filter.setColumnFilterState(ctrl.name, ctrl.value, options);
-        } catch (err) {
-            error = err;
-        }
-
-        decorateFilterInput(ctrl, error);
-        //}
-    }
-}
-
-function activeFiltersMessage(n) {
-    var result;
-
-    switch (n) {
-        case 0:
-            result = 'There are no active column filters.';
-            break;
-        case 1:
-            result = 'There is 1 active column filter:';
-            break;
-        default:
-            result = 'There are ' + n + ' active column filters:';
-    }
-
-    return result;
-}
-
-
-module.exports = ManageFilters;
diff --git a/src/dialogs/index.js b/src/dialogs/index.js
deleted file mode 100644
index 5a43a16..0000000
--- a/src/dialogs/index.js
+++ /dev/null
@@ -1,4 +0,0 @@
-'use strict';
-
-module.exports.ColumnPicker = require('./ColumnPicker');
-module.exports.ManageFilters = require('./ManageFilters');
diff --git a/src/features/CellClick.js b/src/features/CellClick.js
index 2662b60..1f24389 100644
--- a/src/features/CellClick.js
+++ b/src/features/CellClick.js
@@ -8,25 +8,104 @@ var Feature = require('./Feature');
  */
 var CellClick = Feature.extend('CellClick', {
 
+    handleMouseMove: function(grid, event) {
+        var link = event.properties.link,
+            isActionableLink = link && typeof link !== 'boolean'; // actionable with truthy other than `true`
+
+        this.cursor = isActionableLink ? 'pointer' : null;
+
+        if (this.next) {
+            this.next.handleMouseMove(grid, event);
+        }
+    },
+
     /**
-     * @memberOf CellClick.prototype
      * @param {Hypergrid} grid
-     * @param {Object} event - the event details
+     * @param {CellEvent} event - the event details
+     * @memberOf CellClick#
      */
     handleClick: function(grid, event) {
-        var consumed;
-
-        if (
-            event.gridCell.y >= grid.behavior.getHeaderRowCount() &&
-            event.gridCell.x >= 0
-        ) {
-            consumed = grid.cellClicked(event);
-        }
+        var consumed = event.isDataCell && (
+            this.openLink(grid, event) !== undefined ||
+            grid.cellClicked(event)
+        );
 
         if (!consumed && this.next) {
             this.next.handleClick(grid, event);
         }
+    },
+
+    /**
+     * @summary Open the cell's URL.
+     *
+     * @desc The URL is found in the cell's {@link module:defaults.link|link} property, which serves two functions:
+     * 1. **Renders as a link.** When truthy causes {@link SimpleCell} cell renderer to render the cell underlined with {@link module:defaults.linkColor|linkColor}. (See also {@link module:defaults.linkOnHover|linkOnHover} and {@link module:defaults.linkColorOnHover|linkColorOnHover}.) Therefore, setting this property to `true` will render as a link, although clicking on it will have no effect. This is useful if you wish to handle the click yourself by attaching a `'fin-click'` listener to your hypergrid.
+     * 2. **Fetch the URL.** The value of the link property is interpreted as per {@link module:defaults.link|link}.
+     * 3. **Decorate the URL.** The cell name (_i.e.,_ the data column name) and cell value are merged into the URL wherever the respective substrings `'%name'` and `'%value'` are found. For example, if the column name is "age" and the cell value is 6 (or a function returning 25), and the link is `'http://www.abc.com?%name=%value'`, then the actual link (first argument given to `grid.windowOpen`) would be `'http://www.abc.com?age=25'`.
+     * 4. **Open the URL.** The link is then opened by {@link Hypergrid#windowOpen|grid.windowOpen}. If `link` is an array, it is "applied" to `grid.windowOpen` in its entirety; otherwise, `grid.windowOpen` is called with the link as the first argument and {@link module:defaults.linkTarget|linkTarget} as the second.
+     * 5. **Decorate the link.** On successful return from `windowOpen()`, the text is colored as "visited" as per the cell's {@link module:defaults.linkVisitedColor|linkVisitedColor} property (by setting the cell's `linkColor` property to its `linkVisitedColor` property).
+
+     * @param {Hypergrid} grid
+     * @param {CellEvent} cellEvent - Event details.
+     *
+     * @returns {boolean|window|null|undefined} One of:
+     *
+     * | Value | Meaning |
+     * | :---- | :------ |
+     * | `undefined` | no link to open |
+     * | `null` | `grid.windowOpen` failed to open a window |
+     * | _otherwise_ | A `window` reference returned by a successful call to `grid.windowOpen`. |
+     *
+     * @memberOf CellClick#
+     */
+    openLink: function(grid, cellEvent) {
+        var result, url,
+            dataRow = cellEvent.dataRow,
+            config = Object.create(cellEvent.properties, { dataRow: { value: dataRow } }),
+            value = config.exec(cellEvent.value),
+            linkProp = cellEvent.properties.link,
+            isArray = linkProp instanceof Array,
+            link = isArray ? linkProp[0] : linkProp;
+
+        // STEP 2: Fetch the URL
+        switch (typeof link) {
+            case 'string':
+                if (link === '*') {
+                    url = value;
+                } else if (/^\w+$/.test(link)) {
+                    url = dataRow[link];
+                }
+                break;
+
+            case 'function':
+                url = link(cellEvent);
+                break;
+        }
+
+        if (url) {
+            // STEP 3: Decorate the URL
+            url = url.toString().replace(/%name/g, config.name).replace(/%value/g, value);
+
+            // STEP 4: Open the URL
+            if (isArray) {
+                linkProp = linkProp.slice();
+                linkProp[0] = url;
+                result = grid.windowOpen.apply(grid, linkProp);
+            } else {
+                result = grid.windowOpen(url, cellEvent.properties.linkTarget);
+            }
+        }
+
+        // STEP 5: Decorate the link as "visited"
+        if (result) {
+            cellEvent.setCellProperty('linkColor', grid.properties.linkVisitedColor);
+            grid.renderer.resetCellPropertiesCache(cellEvent);
+            grid.repaint();
+        }
+
+        return result;
     }
+
 });
 
 module.exports = CellClick;
diff --git a/src/features/CellEditing.js b/src/features/CellEditing.js
index 81ad265..5a54150 100644
--- a/src/features/CellEditing.js
+++ b/src/features/CellEditing.js
@@ -17,7 +17,7 @@ var CellEditing = Feature.extend('CellEditing', {
     handleDoubleClick: function(grid, event) {
         if (
             grid.properties.editOnDoubleClick &&
-            event.isGridCell
+            event.isDataCell
         ) {
             grid.onEditorActivate(event);
         } else if (this.next) {
@@ -28,7 +28,7 @@ var CellEditing = Feature.extend('CellEditing', {
     handleClick: function(grid, event) {
         if (
             !grid.properties.editOnDoubleClick &&
-            event.isGridCell
+            event.isDataCell
         ) {
             grid.onEditorActivate(event);
         } else if (this.next) {
@@ -42,10 +42,11 @@ var CellEditing = Feature.extend('CellEditing', {
      * @memberOf KeyPaging.prototype
      */
     handleKeyDown: function(grid, event) {
-        var char, isVisibleChar, isDeleteChar, currentCell, editor;
+        var char, isVisibleChar, isDeleteChar, editor, cellEvent;
 
         if (
-            grid.properties.editOnKeydown &&
+            (cellEvent = grid.getGridCellFromLastSelection()) &&
+            cellEvent.properties.editOnKeydown &&
             !grid.cellEditor &&
             (
                 (char = event.detail.char) === 'F2' ||
@@ -53,21 +54,15 @@ var CellEditing = Feature.extend('CellEditing', {
                 (isDeleteChar = char === 'DELETE' || char === 'BACKSPACE')
             )
         ) {
-            currentCell = grid.selectionModel.getLastSelection();
-            if (currentCell) {
-                var pseudoEvent = new grid.behavior.CellEvent(currentCell.origin.x,
-                    currentCell.origin.y + grid.behavior.getHeaderRowCount());
+            editor = grid.onEditorActivate(cellEvent);
 
-                editor = grid.onEditorActivate(pseudoEvent);
-
-                if (editor instanceof CellEditor) {
-                    if (isVisibleChar) {
-                        editor.input.value = char;
-                    } else if (isDeleteChar) {
-                        editor.setEditorValue('');
-                    }
-                    event.detail.primitiveEvent.preventDefault();
+            if (editor instanceof CellEditor) {
+                if (isVisibleChar) {
+                    editor.input.value = char;
+                } else if (isDeleteChar) {
+                    editor.setEditorValue('');
                 }
+                event.detail.primitiveEvent.preventDefault();
             }
         } else if (this.next) {
             this.next.handleKeyDown(grid, event);
diff --git a/src/features/CellSelection.js b/src/features/CellSelection.js
index 95044bd..8895849 100644
--- a/src/features/CellSelection.js
+++ b/src/features/CellSelection.js
@@ -62,7 +62,7 @@ var CellSelection = Feature.extend('CellSelection', {
             dy = event.dataCell.y,
             isSelectable = grid.behavior.getCellProperty(event.dataCell.x, event.gridCell.y, 'cellSelection');
 
-        if (isSelectable && event.isGridCell && !event.primitiveEvent.detail.isRightClick) {
+        if (isSelectable && event.isDataCell && !event.primitiveEvent.detail.isRightClick) {
             var dCell = grid.newPoint(dx, dy),
                 primEvent = event.primitiveEvent,
                 keys = primEvent.detail.keys;
@@ -79,12 +79,12 @@ var CellSelection = Feature.extend('CellSelection', {
      * @param {Object} event - the event details
      */
     handleMouseDrag: function(grid, event) {
-        if (this.dragging && grid.isCellSelection() && !event.primitiveEvent.detail.isRightClick) {
+        if (this.dragging && grid.properties.cellSelection && !event.primitiveEvent.detail.isRightClick) {
             this.currentDrag = event.primitiveEvent.detail.mouse;
             this.lastDragCell = grid.newPoint(event.gridCell.x, event.dataCell.y);
             this.checkDragScroll(grid, this.currentDrag);
             this.handleMouseDragCellSelection(grid, this.lastDragCell, event.primitiveEvent.detail.keys);
-        } else  if (this.next) {
+        } else if (this.next) {
             this.next.handleMouseDrag(grid, event);
         }
     },
@@ -95,9 +95,28 @@ var CellSelection = Feature.extend('CellSelection', {
      * @param {Object} event - the event details
      */
     handleKeyDown: function(grid, event) {
-        var handler;
-        if ((handler = this['handle' + event.detail.char])) {
-            handler.call(this, grid, event.detail);
+        var detail = event.detail,
+            cellEvent = grid.getGridCellFromLastSelection(),
+            navKey = cellEvent && (
+                cellEvent.properties.mappedNavKey(detail.char, detail.ctrl) ||
+                cellEvent.properties.navKey(detail.char, detail.ctrl)
+            ),
+            handler = this['handle' + navKey];
+
+        // STEP 1: Move the selection
+        if (handler) {
+            handler.call(this, grid, detail);
+
+            // STEP 2: Open the cell editor at the new position if it has `editOnNextCell` and is `editable`
+            cellEvent = grid.getGridCellFromLastSelection(); // new cell
+            if (cellEvent.properties.editOnNextCell) {
+                grid.editAt(cellEvent); // succeeds only if `editable`
+            }
+
+            // STEP 3: If editor not opened on new cell, take focus
+            if (!grid.cellEditor) {
+                grid.takeFocus();
+            }
         } else if (this.next) {
             this.next.handleKeyDown(grid, event);
         }
@@ -300,7 +319,7 @@ var CellSelection = Feature.extend('CellSelection', {
         event.primitiveEvent.preventDefault();
 
         var count = this.getAutoScrollAcceleration();
-        this.moveSingleSelect(grid, 0, count);
+        grid.moveSingleSelect(0, count);
     },
 
     /**
@@ -313,7 +332,7 @@ var CellSelection = Feature.extend('CellSelection', {
         event.primitiveEvent.preventDefault();
 
         var count = this.getAutoScrollAcceleration();
-        this.moveSingleSelect(grid, 0, -count);
+        grid.moveSingleSelect(0, -count);
     },
 
     /**
@@ -322,7 +341,7 @@ var CellSelection = Feature.extend('CellSelection', {
      * @param {Object} event - the event details
      */
     handleLEFT: function(grid) {
-        this.moveSingleSelect(grid, -1, 0);
+        grid.moveSingleSelect(-1, 0);
     },
 
     /**
@@ -331,7 +350,7 @@ var CellSelection = Feature.extend('CellSelection', {
      * @param {Object} event - the event details
      */
     handleRIGHT: function(grid) {
-        this.moveSingleSelect(grid, 1, 0);
+        grid.moveSingleSelect(1, 0);
     },
 
     /**
@@ -386,86 +405,9 @@ var CellSelection = Feature.extend('CellSelection', {
      * @param {number} offsetY - y coordinate to start at
      */
     moveShiftSelect: function(grid, offsetX, offsetY) {
-
-        var maxColumns = grid.getColumnCount() - 1,
-            maxRows = grid.getRowCount() - 1,
-
-            maxViewableColumns = grid.renderer.visibleColumns.length - 1,
-            maxViewableRows = grid.renderer.visibleRows.length - 1,
-
-            origin = grid.getMouseDown(),
-            extent = grid.getDragExtent(),
-
-            newX = extent.x + offsetX,
-            newY = extent.y + offsetY;
-
-        if (!grid.properties.scrollingEnabled) {
-            maxColumns = Math.min(maxColumns, maxViewableColumns);
-            maxRows = Math.min(maxRows, maxViewableRows);
-        }
-
-        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));
-        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));
-
-        grid.clearMostRecentSelection();
-        grid.select(origin.x, origin.y, newX, newY);
-
-        grid.setDragExtent(grid.newPoint(newX, newY));
-
-        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
+        if (grid.extendSelect(offsetX, offsetY)) {
             this.pingAutoScroll();
         }
-        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
-            this.pingAutoScroll();
-        }
-
-        grid.repaint();
-
-    },
-
-    /**
-     * @memberOf CellSelection.prototype
-     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
-     * @param {Hypergrid} grid
-     * @param {number} offsetX - x coordinate to start at
-     * @param {number} offsetY - y coordinate to start at
-     */
-    moveSingleSelect: function(grid, offsetX, offsetY) {
-        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent()),
-
-            newX = mouseCorner.x + offsetX,
-            newY = mouseCorner.y + offsetY,
-
-            maxColumns = grid.getColumnCount() - 1,
-            maxRows = grid.getRowCount() - 1,
-
-            maxViewableColumns = grid.getVisibleColumnsCount() - 1,
-            maxViewableRows = grid.getVisibleRowsCount() - 1;
-
-        if (!grid.properties.scrollingEnabled) {
-            maxColumns = Math.min(maxColumns, maxViewableColumns);
-            maxRows = Math.min(maxRows, maxViewableRows);
-        }
-
-        newX = Math.min(maxColumns, Math.max(0, newX));
-        newY = Math.min(maxRows, Math.max(0, newY));
-
-        grid.clearSelections();
-        grid.select(newX, newY, 0, 0);
-        grid.setMouseDown(grid.newPoint(newX, newY));
-        grid.setDragExtent(grid.newPoint(0, 0));
-
-        grid.selectCellAndScrollToMakeVisible(newX, newY);
-
-        // if (grid.insureModelColIsVisible(newX, offsetX)) {
-        //     this.pingAutoScroll();
-        // }
-        // if (grid.insureModelRowIsVisible(newY, offsetY)) {
-        //     this.pingAutoScroll();
-        // }
-
-        grid.repaint();
-
     }
 
 });
diff --git a/src/features/ColumnAutosizing.js b/src/features/ColumnAutosizing.js
deleted file mode 100644
index 909aa8f..0000000
--- a/src/features/ColumnAutosizing.js
+++ /dev/null
@@ -1,29 +0,0 @@
-'use strict';
-
-var Feature = require('./Feature');
-
-/**
- * @constructor
- * @extends Feature
- */
-var ColumnAutosizing = Feature.extend('ColumnAutosizing', {
-
-    /**
-     * @param {Hypergrid} grid
-     * @param {Object} event - the event details
-     * @memberOf ColumnAutosizing.prototype
-     */
-    handleDoubleClick: function(grid, event) {
-        var headerRowCount = grid.getHeaderRowCount();
-        //var headerColCount = grid.getHeaderColumnCount();
-        var gridCell = event.gridCell;
-        if (gridCell.y <= headerRowCount) {
-            grid.autosizeColumn(gridCell.x);
-        } else if (this.next) {
-            this.next.handleDoubleClick(grid, event);
-        }
-    }
-
-});
-
-module.exports = ColumnAutosizing;
diff --git a/src/features/ColumnMoving.js b/src/features/ColumnMoving.js
index 0eef9c5..86848e3 100644
--- a/src/features/ColumnMoving.js
+++ b/src/features/ColumnMoving.js
@@ -526,7 +526,7 @@ var ColumnMoving = Feature.extend('ColumnMoving', {
         var doAFloat = dragColumnIndex > overCol;
         doAFloat = doAFloat || (overCol - dragColumnIndex >= 1);
 
-        if (doAFloat && !atMax && !autoScrollingNow) {
+        if (doAFloat && !autoScrollingNow) {
             var draggedToTheRight = dragColumnIndex < overCol;
             // if (draggedToTheRight) {
             //     overCol -= 1;
diff --git a/src/features/ColumnPicker.js b/src/features/ColumnPicker.js
deleted file mode 100644
index 1cfea46..0000000
--- a/src/features/ColumnPicker.js
+++ /dev/null
@@ -1,29 +0,0 @@
-/* eslint-env browser */
-/* global requestAnimationFrame */
-
-'use strict';
-
-var Feature = require('./Feature');
-
-/**
- * @constructor
- * @extends Feature
- */
-var ColumnPicker = Feature.extend('ColumnPicker', {
-
-    /**
-     * @memberOf ColumnPicker.prototype
-     * @param {Hypergrid} grid
-     * @param {Object} event - the event details
-     */
-    handleKeyUp: function(grid, event) {
-        var key = event.detail.char.toLowerCase();
-        var keys = grid.properties.editorActivationKeys;
-        if (keys.indexOf(key) > -1) {
-           grid.toggleDialog('ColumnPicker');
-        }
-    },
-
-});
-
-module.exports = ColumnPicker;
diff --git a/src/features/ColumnResizing.js b/src/features/ColumnResizing.js
index 2f4c70d..b3e5a96 100644
--- a/src/features/ColumnResizing.js
+++ b/src/features/ColumnResizing.js
@@ -9,17 +9,9 @@ var Feature = require('./Feature');
 var ColumnResizing = Feature.extend('ColumnResizing', {
 
     /**
-     * the index of the column wall were currently dragging
-     * @type {number}
-     * @default -2
-     * @memberOf ColumnResizing.prototype
-     */
-    dragIndex: -2,
-
-    /**
      * the pixel location of the where the drag was initiated
      * @type {number}
-     * @default -1
+     * @default
      * @memberOf ColumnResizing.prototype
      */
     dragStart: -1,
@@ -30,7 +22,7 @@ var ColumnResizing = Feature.extend('ColumnResizing', {
      * @default -1
      * @memberOf ColumnResizing.prototype
      */
-    dragIndexStartingSize: -1,
+    dragStartWidth: -1,
 
     /**
      * @memberOf ColumnResizing.prototype
@@ -44,78 +36,15 @@ var ColumnResizing = Feature.extend('ColumnResizing', {
 
     /**
      * @memberOf ColumnResizing.prototype
-     * @desc get the grid cell x,y coordinate
-     * @returns {number}
-     * @param {window.fin.rectangular.Point} gridCell
-     */
-    getGridCellValue: function(gridCell) {
-        return gridCell.y;
-    },
-
-    /**
-     * @memberOf ColumnResizing.prototype
-     * @desc return the grids x,y scroll value
-     * @returns {number}
-     * @param {Hypergrid} grid
-     */
-    getScrollValue: function(grid) {
-        return grid.getHScrollValue();
-    },
-
-    /**
-     * @memberOf ColumnResizing.prototype
-     * @desc return the width/height of the row/column of interest
-     * @returns {number}
-     * @param {Hypergrid} grid
-     * @param {number} index - the row/column index of interest
-     */
-    getAreaSize: function(grid, index) {
-        return grid.getColumnWidth(index);
-    },
-
-    /**
-     * @memberOf ColumnResizing.prototype
-     * @desc set the width/height of the row/column at index
-     * @returns {number}
-     * @param {Hypergrid} grid
-     * @param {number} index - the row/column index of interest
-     * @param {number} value - the width/height to set to
-     */
-    setAreaSize: function(grid, index, value) {
-        grid.setColumnWidth(index, value);
-    },
-
-    /**
-     * @memberOf ColumnResizing.prototype
-     * @desc return the recently rendered area's width/height
-     * @returns {number}
-     * @param {Hypergrid} grid
-     * @param {number} index - the row/column index of interest
-     */
-    getPreviousAbsoluteSize: function(grid, index) {
-        return grid.getRenderedWidth(index);
-    },
-
-    /**
-     * @memberOf ColumnResizing.prototype
      * @desc returns the index of which divider I'm over
      * @returns {number}
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
      */
     overAreaDivider: function(grid, event) {
-        return grid.overColumnDivider(event);
-    },
-
-    /**
-     * @memberOf ColumnResizing.prototype
-     * @desc am I over the column/row area
-     * @returns {boolean}
-     * @param {Hypergrid} grid
-     * @param {Object} event - the event details
-     */
-    isFirstFixedOtherArea: function(grid, event) {
-        return this.isFirstFixedRow(grid, event);
+        var leftMostColumnIndex = grid.properties.showRowNumbers ? -1 : 0;
+        return event.gridCell.x !== leftMostColumnIndex && event.mousePoint.x <= 3 ||
+            event.mousePoint.x >= event.bounds.width - 3;
     },
 
     /**
@@ -133,17 +62,9 @@ var ColumnResizing = Feature.extend('ColumnResizing', {
      * @param {Object} event - the event details
      */
     handleMouseDrag: function(grid, event) {
-        if (this.dragIndex > -2) {
-            //var fixedAreaCount = this.getFixedAreaCount(grid);
-            //var offset = this.getFixedAreaSize(grid, fixedAreaCount + areaIndex);
-            var mouse = this.getMouseValue(event);
-            var scrollValue = this.getScrollValue(grid);
-            if (this.dragIndex < this.getFixedAreaCount(grid)) {
-                scrollValue = 0;
-            }
-            var previous = this.getPreviousAbsoluteSize(grid, this.dragIndex - scrollValue);
-            var distance = mouse - previous;
-            this.setAreaSize(grid, this.dragIndex, distance);
+        if (this.dragColumn) {
+            var delta = this.getMouseValue(event) - this.dragStart;
+            grid.behavior.setColumnWidth(this.dragColumn, this.dragStartWidth + delta);
         } else if (this.next) {
             this.next.handleMouseDrag(grid, event);
         }
@@ -151,41 +72,31 @@ var ColumnResizing = Feature.extend('ColumnResizing', {
 
     /**
      * @memberOf ColumnResizing.prototype
-     * @desc get the width/height of a specific row/column
-     * @param {Hypergrid} grid
-     * @param {number} areaIndex - the row/column index of interest
-     */
-    getSize: function(grid, areaIndex) {
-        return this.getAreaSize(grid, areaIndex);
-    },
-
-    /**
-     * @memberOf ColumnResizing.prototype
-     * @desc return the fixed area rows/columns count
-     * @returns {number}
-     * @param {Hypergrid} grid
-     */
-    getOtherFixedAreaCount: function(grid) {
-        return grid.getFixedRowCount();
-    },
-
-    /**
-     * @memberOf ColumnResizing.prototype
      * @param {Hypergrid} grid
      * @param {Object} event - the event details
      */
     handleMouseDown: function(grid, event) {
-        var isEnabled = this.isEnabled(grid);
-        var overArea = this.overAreaDivider(grid, event);
-        if (isEnabled && overArea > -1 && this.isFirstFixedOtherArea(grid, event)) {
-            var scrollValue = this.getScrollValue(grid);
-            if (overArea < this.getFixedAreaCount(grid)) {
-                scrollValue = 0;
+        if (event.isHeaderRow && this.overAreaDivider(grid, event)) {
+            if (event.mousePoint.x <= 3) {
+                var columnIndex = event.gridCell.x - 1;
+                this.dragColumn = grid.behavior.getActiveColumn(columnIndex);
+                //this.dragStartWidth = grid.renderer.visibleColumns[columnIndex].width;
+                var visibleColIndex = -1;
+                var dragColumn = this.dragColumn;
+                grid.renderer.visibleColumns.forEach(function(vCol, vIndex){
+                    var col = vCol.column;
+                    if (col.index === dragColumn.index){
+                        visibleColIndex = vIndex;
+                    }
+                });
+                this.dragStartWidth = grid.renderer.visibleColumns[visibleColIndex].width;
+            } else {
+                this.dragColumn = event.column;
+                this.dragStartWidth = event.bounds.width;
             }
-            this.dragIndex = overArea - 1 + scrollValue;
+
             this.dragStart = this.getMouseValue(event);
-            this.dragIndexStartingSize = 0;
-            this.detachChain();
+            //this.detachChain();
         } else if (this.next) {
             this.next.handleMouseDown(grid, event);
         }
@@ -197,18 +108,17 @@ var ColumnResizing = Feature.extend('ColumnResizing', {
      * @param {Object} event - the event details
      */
     handleMouseUp: function(grid, event) {
-        var isEnabled = this.isEnabled(grid);
-        if (isEnabled && this.dragIndex > -2) {
+        if (this.dragColumn) {
             this.cursor = null;
-            this.dragIndex = -2;
+            this.dragColumn = false;
 
             event.primitiveEvent.stopPropagation();
             //delay here to give other events a chance to be dropped
-            var self = this;
+            //var self = this;
             grid.synchronizeScrollingBoundaries();
-            setTimeout(function() {
-                self.attachChain();
-            }, 200);
+            // setTimeout(function() {
+            //     self.attachChain();
+            // }, 200);
         } else if (this.next) {
             this.next.handleMouseUp(grid, event);
         }
@@ -220,70 +130,37 @@ var ColumnResizing = Feature.extend('ColumnResizing', {
      * @param {Object} event - the event details
      */
     handleMouseMove: function(grid, event) {
-        if (this.dragIndex > -2) {
-            return;
-        }
-        this.cursor = null;
-        if (this.next) {
-            this.next.handleMouseMove(grid, event);
-        }
-        this.checkForAreaResizeCursorChange(grid, event);
-    },
-
-    /**
-     * @memberOf ColumnResizing.prototype
-     * @desc fill this in
-     * @param {Hypergrid} grid
-     * @param {Object} event - the event details
-     */
-    checkForAreaResizeCursorChange: function(grid, event) {
-        var isEnabled = this.isEnabled(grid);
-        if (isEnabled && this.overAreaDivider(grid, event) > -1 && this.isFirstFixedOtherArea(grid, event)) {
-            this.cursor = this.getCursorName();
-        } else {
+        if (!this.dragColumn) {
             this.cursor = null;
-        }
 
-    },
+            if (this.next) {
+                this.next.handleMouseMove(grid, event);
+            }
 
-    /**
-     * @param {Hypergrid} grid
-     * @returns {number}
-     * @default -2
-     * @memberOf ColumnResizing.prototype
-     */
-    getFixedAreaCount: function(grid) {
-        var count = grid.getFixedColumnCount() + (grid.isShowRowNumbers() ? 1 : 0) + (grid.hasHierarchyColumn() ? 1 : 0);
-        return count;
+            this.cursor = event.isHeaderRow && this.overAreaDivider(grid, event) ? this.getCursorName() : null;
+        }
     },
 
     /**
      * @param {Hypergrid} grid
-     * @param event
-     * @default -2
+     * @param {CellEvent} cellEvent
      * @memberOf ColumnResizing.prototype
      */
     handleDoubleClick: function(grid, event) {
-        var isEnabled = this.isEnabled(grid);
-        var hasCursor = this.overAreaDivider(grid, event) > -1; //this.cursor !== null;
-        var headerRowCount = grid.getHeaderRowCount();
-        //var headerColCount = grid.getHeaderColumnCount();
-        var gridCell = event.gridCell;
-        if (isEnabled && hasCursor && (gridCell.y <= headerRowCount)) {
-            grid.autosizeColumn(gridCell.x - 1);
+        if (event.isHeaderRow && this.overAreaDivider(grid, event)) {
+            var column = event.mousePoint.x <= 3
+                ? grid.behavior.getActiveColumn(event.gridCell.x - 1)
+                : event.column;
+            column.addProperties({
+                columnAutosizing: true,
+                columnAutosized: false // todo: columnAutosizing should be a setter that automatically resets columnAutosized on state change to true
+            });
+            setTimeout(function() { // do after next render, which measures text now that auto-sizing is on
+                grid.autosizeColumn(column);
+            });
         } else if (this.next) {
             this.next.handleDoubleClick(grid, event);
         }
-    },
-
-    /**
-     * @param {Hypergrid} grid
-     * @returns {boolean}
-     * @default -2
-     * @memberOf ColumnResizing.prototype
-     */
-    isEnabled: function(grid) {
-        return true;
     }
 
 });
diff --git a/src/features/ColumnSelection.js b/src/features/ColumnSelection.js
index c37abc5..d3e4be7 100644
--- a/src/features/ColumnSelection.js
+++ b/src/features/ColumnSelection.js
@@ -86,7 +86,7 @@ var ColumnSelection = Feature.extend('ColumnSelection', {
 
         // todo: >= 5 depends on header being top-most row which is currently always true but we may allow header "section" to be arbitrary position within quadrant (see also handleMouseDown in ColumnMoving.js)
         if (
-            grid.isColumnSelection() &&
+            grid.properties.columnSelection &&
             event.mousePoint.y >= 5 &&
             !event.primitiveEvent.detail.isRightClick &&
             event.isHeaderCell
@@ -109,7 +109,7 @@ var ColumnSelection = Feature.extend('ColumnSelection', {
      */
     handleMouseDrag: function(grid, event) {
         if (
-            grid.isColumnSelection() &&
+            grid.properties.columnSelection &&
             !this.isColumnDragging(grid) &&
             !event.primitiveEvent.detail.isRightClick &&
             this.dragging
@@ -130,12 +130,12 @@ var ColumnSelection = Feature.extend('ColumnSelection', {
      * @param {Object} event - the event details
      */
     handleKeyDown: function(grid, event) {
-        var handler;
-        if (
-            grid.getLastSelectionType() === 'column' &&
-            (handler = this['handle' + event.detail.char])
-        ) {
-            handler.call(this, grid, event.detail);
+        var detail = event.detail,
+            handler = grid.getLastSelectionType() === 'column' &&
+                this['handle' + detail.char];
+
+        if (handler) {
+            handler.call(this, grid, detail);
         } else if (this.next) {
             this.next.handleKeyDown(grid, event);
         }
diff --git a/src/features/Feature.js b/src/features/Feature.js
index c4cffa4..fa99296 100644
--- a/src/features/Feature.js
+++ b/src/features/Feature.js
@@ -2,8 +2,6 @@
 
 var Base = require('../Base');
 
-var warned = {};
-
 /**
  * Instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
  * @constructor
@@ -143,6 +141,8 @@ var Feature = Base.extend('Feature', {
     handleKeyDown: function(grid, event) {
         if (this.next) {
             this.next.handleKeyDown(grid, event);
+        } else {
+            return true;
         }
     },
 
@@ -235,10 +235,7 @@ var Feature = Base.extend('Feature', {
      * @param {Object} event - the event details
      */
     isFixedRow: function(grid, event) {
-        if (!warned.isFixedRow) {
-            warned.isFixedRow = true;
-            console.warn('isFixedRow(grid, event) has been deprecated as of v1.2.0 in favor of event.isRowFixed and will be removed in a future version.');
-        }
+        this.deprecated('isFixedRow', 'isFixedRow(grid, event) has been deprecated as of v1.2.0 in favor of event.isRowFixed. (Will be removed in a future version.)');
         return event.isRowFixed;
     },
 
@@ -257,10 +254,7 @@ var Feature = Base.extend('Feature', {
      * @param {Object} event - the event details
      */
     isFixedColumn: function(grid, event) {
-        if (!warned.isFixedColumn) {
-            warned.isFixedColumn = true;
-            console.warn('isFixedColumn(grid, event) has been deprecated as of v1.2.0 in favor of event.isColumnFixed and will be removed in a future version.');
-        }
+        this.deprecated('isFixedColumn', 'isFixedColumn(grid, event) has been deprecated as of v1.2.0 in favor of event.isColumnFixed. (Will be removed in a future version.)');
         return event.isColumnFixed;
     },
 
@@ -279,10 +273,7 @@ var Feature = Base.extend('Feature', {
      * @param {Object} event - the event details
      */
     isTopLeft: function(grid, event) {
-        if (!warned.isTopLeft) {
-            warned.isTopLeft = true;
-            console.warn('isTopLeft(grid, event) has been deprecated as of v1.2.0 in favor of event.isCellFixed and will be removed in a future version.');
-        }
+        this.deprecated('isTopLeft', 'isTopLeft(grid, event) has been deprecated as of v1.2.0 in favor of event.isCellFixed. (Will be removed in a future version.)');
         return event.isCellFixed;
     },
 
diff --git a/src/features/Filters.js b/src/features/Filters.js
index 9fee051..da9a0e7 100644
--- a/src/features/Filters.js
+++ b/src/features/Filters.js
@@ -7,6 +7,39 @@ var Feature = require('./Feature');
  */
 var Filters = Feature.extend('Filters', {
 
+    /**
+     * Navigate away from the filter cell when:
+     * 1. Coming from a cell editor (`event.detail.editor` defined).
+     * 2. The cell editor was for a filter cell.
+     * 3. The key (`event.detail.char) maps (through {@link module:defaults.navKeyMap|navKeyMap}) to one of:
+     *    * `'UP'` or `'DOWN'` - Selects first visible data cell under filter cell.
+     *    * `'LEFT'` - Opens filter cell editor in previous filterable column; if nonesuch, selects first visible data cell under filter cell.
+     *    * `'RIGHT'` - Opens filter cell editor in next filterable column; if nonesuch, selects first visible data cell under filter cell.
+     */
+    handleKeyDown: function(grid, event) {
+        var cellEvent, mappedNavKey, handler,
+            detail = event.detail;
+
+        if (detail.editor) {
+            cellEvent = detail.editor.event;
+            if (cellEvent.isFilterCell) {
+                mappedNavKey = cellEvent.properties.mappedNavKey(detail.char);
+                handler = this['handle' + mappedNavKey];
+            }
+        }
+
+        if (handler) {
+            handler.call(this, grid, detail);
+        } else if (this.next) {
+            this.next.handleKeyDown(grid, event);
+        }
+    },
+
+    handleLEFT: function(grid, detail) { moveLaterally(grid, detail, -1); },
+    handleRIGHT: function(grid, detail) { moveLaterally(grid, detail, +1); },
+    handleUP: moveDown,
+    handleDOWN: moveDown,
+
     handleDoubleClick: function(grid, event) {
         if (event.isFilterCell) {
             grid.onEditorActivate(event);
@@ -25,4 +58,36 @@ var Filters = Feature.extend('Filters', {
 
 });
 
+function moveLaterally(grid, detail, deltaX) {
+    var cellEvent = detail.editor.event,
+        gridX = cellEvent.visibleColumn.index,
+        gridY = cellEvent.visibleRow.index,
+        originX = gridX,
+        C = grid.renderer.visibleColumns.length;
+
+    cellEvent = new grid.behavior.CellEvent; // redefine so we don't reset the original below
+
+    while (
+        (gridX = (gridX + deltaX + C) % C) !== originX &&
+        cellEvent.resetGridXY(gridX, gridY)
+    ) {
+        if (cellEvent.properties.filterable) {
+            // Select previous or next filterable column's filter cell
+            grid.editAt(cellEvent);
+            return;
+        }
+    }
+
+    moveDown(grid, cellEvent);
+}
+
+function moveDown(grid, detail) {
+    var cellEvent = detail.editor.event,
+        gridX = cellEvent.visibleColumn.columnIndex;
+
+    // Select first visible grid cell of this column
+    grid.selectViewportCell(gridX, 0);
+    grid.takeFocus();
+}
+
 module.exports = Filters;
diff --git a/src/features/OnHover.js b/src/features/OnHover.js
index 5cd9a42..f4d6d85 100644
--- a/src/features/OnHover.js
+++ b/src/features/OnHover.js
@@ -19,7 +19,7 @@ var OnHover = Feature.extend('OnHover', {
                 this.handleMouseExit(grid, hoverCell);
             }
             this.handleMouseEnter(grid, event);
-            grid.setHoverCell(event.gridCell);
+            grid.setHoverCell(event);
         } else if (this.next) {
             this.next.handleMouseMove(grid, event);
         }
diff --git a/src/features/RowResizing.js b/src/features/RowResizing.js
index 09ac433..5167f0c 100644
--- a/src/features/RowResizing.js
+++ b/src/features/RowResizing.js
@@ -98,7 +98,7 @@ var RowResizing = ColumnResizing.extend('RowResizing', {
      * @param {Object} event - the event details
      */
     overAreaDivider: function(grid, event) {
-        return grid.overRowDivider(event);
+
     },
 
     /**
@@ -124,29 +124,6 @@ var RowResizing = ColumnResizing.extend('RowResizing', {
     },
 
     /**
-     * @function
-     * @memberOf RowResizing.prototype
-     * @desc return the recently rendered area's width/height
-     * @returns {number}
-     * @param {Hypergrid} grid
-     * @param {number} index - the row/column index of interest
-     */
-    getPreviousAbsoluteSize: function(grid, index) {
-        return grid.getRenderedHeight(index);
-    },
-
-    /**
-     * @function
-     * @memberOf RowResizing.prototype
-     * @desc return the fixed area rows/columns count
-     * @returns {number}
-     * @param {Hypergrid} grid
-     */
-    getOtherFixedAreaCount: function(grid) {
-        return grid.getFixedColumnCount();
-    },
-
-    /**
      *
      * @param {Hypergrid} grid
      * @returns {number}
diff --git a/src/features/RowSelection.js b/src/features/RowSelection.js
index 0869645..6bc72e5 100644
--- a/src/features/RowSelection.js
+++ b/src/features/RowSelection.js
@@ -64,15 +64,15 @@ var RowSelection = Feature.extend('RowSelection', {
      * @param {Object} event - the event details
      */
     handleMouseDown: function(grid, event) {
-        var rowSelectable = grid.isRowSelection() &&
+        var rowSelectable = grid.properties.rowSelection &&
             !event.primitiveEvent.detail.isRightClick &&
-            grid.isShowRowNumbers() &&
+            grid.properties.showRowNumbers &&
             event.isHandleColumn;
 
         if (rowSelectable && event.isHeaderHandle) {
             //global row selection
             grid.toggleSelectAllRows();
-        } else if (rowSelectable && event.isGridRow)  {
+        } else if (rowSelectable && event.isDataRow)  {
             // if we are in the fixed area, do not apply the scroll values
             this.dragArmed = true;
             this.extendSelection(grid, event.dataCell.y, event.primitiveEvent.detail.keys);
@@ -89,7 +89,7 @@ var RowSelection = Feature.extend('RowSelection', {
     handleMouseDrag: function(grid, event) {
         if (
             this.dragArmed &&
-            grid.isRowSelection() &&
+            grid.properties.rowSelection &&
             !event.primitiveEvent.detail.isRightClick
         ) {
             //if we are in the fixed area do not apply the scroll values
diff --git a/src/features/index.js b/src/features/index.js
index ec31c64..4ef3fa5 100644
--- a/src/features/index.js
+++ b/src/features/index.js
@@ -5,7 +5,6 @@ module.exports = {
     CellClick: require('./CellClick'),
     CellEditing: require('./CellEditing'),
     CellSelection: require('./CellSelection'),
-    ColumnAutosizing: require('./ColumnAutosizing'),
     ColumnMoving: require('./ColumnMoving'),
     ColumnResizing: require('./ColumnResizing'),
     ColumnSelection: require('./ColumnSelection'),
@@ -13,8 +12,7 @@ module.exports = {
     Filters: require('./Filters'),
     KeyPaging: require('./KeyPaging'),
     OnHover: require('./OnHover'),
-    ColumnPicker: require('./ColumnPicker'),
-    RowResizing: require('./RowResizing'),
+    // RowResizing: require('./RowResizing'),
     RowSelection: require('./RowSelection'),
     ThumbwheelScrolling: require('./ThumbwheelScrolling')
 };
diff --git a/src/index.js b/src/index.js
index 4311006..be5dfcc 100644
--- a/src/index.js
+++ b/src/index.js
@@ -12,25 +12,81 @@
  * * This file is not a node module; it has no reference to `module.exports` or `exports`; it cannot be "required" by any other file.
  * * This file is blacklisted in .npmignore and is not published to npm.
  *
- * Note: The npm "main" entry point (as noted in package.json) is src/Hypergrid.js.
+ * Note: The npm "main" entry point is undefined in package.json implying /index.js.
  */
 
 var Hypergrid = require('./Hypergrid');
 
+Hypergrid.analytics = require('hyper-analytics'); // npm
+// Hypergrid.analytics = require('../../hyper-analytics'); // developer
+
 // Expose some namespaces to users of the hypergrid.js file through `fin.Hypergrid`:
 Hypergrid.images = require('../images');
 Hypergrid.behaviors = require('./behaviors');
 Hypergrid.dataModels = require('./dataModels');
 Hypergrid.features = require('./features');
-Hypergrid.analytics = require('./Shared.js').analytics;
-Hypergrid.DataSourceBase = require('./dataSources').DataSourceBase;
 Hypergrid.rectangular = require('rectangular');
+Hypergrid.lib = require('./lib');
+Hypergrid.Base = require('./Base');
+
+var windowRequire = window.require;
+
+// Recommended usage:
+// if (fin && fin.Hypergrid) { require = fin.Hypergrid.require; } // install
+// var Base = require('fin-hypergrid/src/Base');
+Hypergrid.require = function(path) {
+    var result, crumbs, i,
+        errMsg = 'Path ' + path + ' unknown or not exposed in build file.';
+
+    if (path.indexOf('fin-hypergrid/') === 0) {
+        result = Hypergrid;
+        crumbs = path.split('/');
+        i = 1;
+
+        if (crumbs[i] === 'src') {
+            switch (crumbs[++i]) {
+                case 'lib':
+                case 'Base':
+                case 'behaviors':
+                case 'dataModels':
+                case 'features':
+                    result = result[crumbs[i++]];
+                    break;
+                default:
+                    throw errMsg;
+            }
+        }
+
+        while (crumbs[i]) {
+            switch (crumbs[i]) {
+                case 'lib':
+                case 'Base':
+                case 'behaviors':
+                case 'dataModels':
+                case 'features':
+                    result = undefined;
+                    break;
+                default:
+                    result = result[crumbs[i++]];
+            }
+            if (!result) {
+                throw errMsg;
+            }
+        }
+
+        return result;
+    } else if (windowRequire) {
+        return windowRequire.apply(this, arguments);
+    } else {
+        throw errMsg;
+    }
+
+    return result;
+};
 
 // Create the `fin` namespace and the `fin.Hypergrid` objects:
 (window.fin = window.fin || {}).Hypergrid = Hypergrid;
 
-// Create the `datasaur` namespace and the `datasaur.base` objects:
-(window.datasaur = window.datasaur || {}).base = Hypergrid.DataSourceBase;
-
-// Note that while users of the npm module can also access the above namespaces through the Hypergrid object, in reality they also have access to any namespace through `require`, for example:
+// Note users of the npm module do not have this object.
+// THey have access to any namespace through `require`, for example:
 // var behaviorJSON = require('fin-hypergrid/src/behaviors/JSON');
diff --git a/src/jsdoc/external-types.js b/src/jsdoc/external-types.js
index a8b01c5..a56ba13 100644
--- a/src/jsdoc/external-types.js
+++ b/src/jsdoc/external-types.js
@@ -5,3 +5,6 @@
 /** @typedef Rectangle
  * @see http://openfin.github.io/rectangular/Rectangle.html
  */
+
+/** @typedef {object} dataRowObject
+ */
diff --git a/src/jsdoc/interfaces/data-api.js b/src/jsdoc/interfaces/data-api.js
deleted file mode 100644
index c5ad25f..0000000
--- a/src/jsdoc/interfaces/data-api.js
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- * @interface dataSourceHelperAPI
- * @summary Data transformer API.
- * @desc Hypergrid's _data source_ objects transform data row collections (for example, by indexing them). These might include _filter_ data sources that hide data rows and _sorter_ data sources that rearrange data rows.
- *
- * When such a data source is found in the transformation pipeline, Hypergrid sets its `api` property with a reference to an object that implements this interface.
- *
- * Later, the transformations are executed (by {@link dataModels.JSON#applyAnalytics|applyAnalytics}). The `apply` method of each data source is called in turn. A filtering data source's `apply` method calls this API's {@link dataSourceHelperAPI#test|test} method, once for each data row (typically to build an index of included rows).
- */
-
-/**
- * @method
- * @name dataSourceHelperAPI#test
- * @summary Tests data row for inclusion/exclusion from the grid display.
- * @desc Implementation of this method is required.
- * @param {object} dataRow
- * @returns {boolean} Truthy value means row "passes" the test, _i.e.,_ passes through the filter and should be included in the grid display.
- */
-
-/**
- * @method
- * @name dataSourceHelperAPI#properties
- * @summary Column property accessor.
- * @desc There are two types of calls:
- * * "Getter" call - when `properties.getPropName` is defined
- * * "Setter" call - when `properties.getPropName` is not defined
- *
- * For "setter" calls only: Assigns the values of all _enumerable_ members of `properties` to the filter properties with the same names, with the following exceptions:
- * * Value is `undefined` - The filter property is deleted instead of being assigned to the filter property.
- * * Value is a function - The function is only assigned to the filter when the property name appears in `this.firstClassProperties`. Otherwise, the function is called and the returned value is assigned to the filter instead.
- *
- * Note: `column` and `getPropName` are reserved names in the properties namespace because they have special meaning in the `properties` object passed to this function. Filter developers should not implement properties with these names.
- *
- * @param {object} properties - Contains property values to assign to the filter. This object is required. However, none of the following options are required.
- * @param {object} [properties.column] - If defined, value(s) pertain to the indicated column only. If omitted, value(s) pertain to the whole filter.
- *
- * Note that {@link dataModels.JSON~propPrep} defines `column` as non-enumerable. This makes it easy for your helper API's `properties` method implementation to ignore it.
- * .
- * @param {object} [properties.column.index] - Column index as defined by `dataSource.getFields()`.
- * @param {object} [properties.column.name] - Column name as defined in `dataSource.getFields()`.
- * @param {string} [properties.getPropName] - "Get" (return) the value of the property with the supplied name. If undefined,return `null`. (All other members of `properties` are ignored.)
- * @returns One of:
- * * Property value when `getPropName` defined.
- * * `null` when `getPropName` undefined.
- * * `undefined` when setting property value(s).
- */
-
-/** @typedef {object} propObject
- * @property {object} [column] - If omitted, this is a Global API property. If given, both of the following are defined:
- * @property {number} [column.index] - Index of the column in the `fields` array (the `columnIndex` parameter to the `parsePropOverloads` method.
- * @property {string} [column.name] - Name of the column from the `fields` array.
- * @property {object} properties - The name of the property to get or the values of the properties to set.
- * @property {string} [properties.getPropName] - If defined, this is a getter call and this property contains the name of the property value to get; all other defined properties are ignored. If undefined this is setter call.
- */
-
diff --git a/src/jsdoc/interfaces/dataControlInterface.js b/src/jsdoc/interfaces/dataControlInterface.js
new file mode 100644
index 0000000..074d342
--- /dev/null
+++ b/src/jsdoc/interfaces/dataControlInterface.js
@@ -0,0 +1,47 @@
+/**
+ * @interface dataControlInterface
+ * @summary Data Control Interface object (data controller).
+ * @desc Hypergrid's _data source_ objects transform data row collections (for example, by indexing them). These might include _filter_ data sources that hide data rows and _sorter_ data sources that rearrange data rows.
+ *
+ * Later, the transformations are executed (by {@link dataModels.JSON#reindex|reindex}). The `apply` method of each data source is called in turn. For example, a filtering data source's `apply` method would call its controller's {@link dataControlInterface#test|test} method, once for each data row (typically to build an index of included rows).
+ */
+
+/**
+ * @method
+ * @name dataControlInterface#properties
+ * @summary Column property accessor.
+ * @desc There are two types of calls:
+ * * "Getter" call - when `properties.GETTER` is defined
+ * * "Setter" call - when `properties.GETTER` is not defined
+ *
+ * For "setter" calls only: Assigns the values of all _enumerable_ members of `properties` to the data controller properties with the same names, with the following exceptions:
+ * * Value is a function - Functions should be executed by your implementation to get the actual value to be assigned to the data controller. (If you data controller has properties that are themselves functions and need to be able to have functions assigned to them, it is your responsibility to make exceptions to this rule for such properties.)
+ *
+ * Note: The `COLUMN` and `GETTER` and name properties are reserved.
+ *
+ * @param {object} properties - Contains property values to assign to the data controller. This object is required. However, none of the following options are required.
+ *
+ * @param {object} [properties.COLUMN] - If defined, value(s) pertain to the indicated column only. If omitted, value(s) pertain to the whole data controller.
+ *
+ * Note that {@link dataModels.JSON#prop} defines `COLUMN` as non-enumerable. This makes it easy for your helper data controller's `properties` method implementation to ignore it.
+ *
+ * @param {object} [properties.COLUMN.index] - Column index as defined by `dataSource.getFields()`.
+ * @param {object} [properties.COLUMN.name] - Column name as defined in `dataSource.getFields()`.
+ * @param {string} [properties.GETTER] - "Get" (return) the value of the property with the supplied name. If undefined,return `null`. (All other members of `properties` are ignored.)
+ *
+ * @returns {undefined|null|*} One of:
+ * * Setter: `undefined`
+ * * Getter:
+ *   * Property value (when the property name in `GETTER` is defined in the data controller).
+ *   * `null` (when the property name in `GETTER` is _not_ defined in the data controller).
+ *   * `undefined` when `COLUMN` is defined but the column it specifies is not found.
+ */
+
+/** @typedef {object} propObject
+ * @property {object} [COLUMN] - If omitted, this is a Global data controller property. If given, both of the following are defined:
+ * @property {number} [COLUMN.index] - Index of the column in the `fields` array (the `columnIndex` parameter to the `parsePropOverloads` method.
+ * @property {string} [COLUMN.name] - Name of the column from the `fields` array.
+ * @property {object} properties - The name of the property to get or the values of the properties to set.
+ * @property {string} [properties.GETTER] - If defined, this is a getter call and this property contains the name of the property value to get; all other defined properties are ignored. If undefined this is setter call.
+ */
+
diff --git a/src/jsdoc/interfaces/dataModelAPI.js b/src/jsdoc/interfaces/dataModelAPI.js
new file mode 100644
index 0000000..5989baa
--- /dev/null
+++ b/src/jsdoc/interfaces/dataModelAPI.js
@@ -0,0 +1,26 @@
+/**
+ * @interface dataModelAPI
+ * @summary Data model API.
+ * @desc Blah blah blah.
+ */
+
+/**
+ * @method
+ * @name dataModelAPI#getRowCount
+ * @returns {number} The number of data rows currently contained in the model.
+ */
+
+/**
+ * @method
+ * @name dataModelAPI#getRow
+ * @param {number} rowIndex
+ * @returns {number|undefined} The data row with the given `rowIndex`; or `undefined` if no such row.
+ */
+
+/**
+ * @method
+ * @name dataModelAPI#getValue
+ * @param {number} columnIndex
+ * @param {number} rowIndex
+ * @returns {string|number|boolean|null} The member with the given `columnIndex` from the data row with the given `rowIndex`.
+ */
diff --git a/src/jsdoc/tutorials/cell-renderer.md b/src/jsdoc/tutorials/cell-renderer.md
index 30f079a..ea81b36 100644
--- a/src/jsdoc/tutorials/cell-renderer.md
+++ b/src/jsdoc/tutorials/cell-renderer.md
@@ -191,9 +191,9 @@ function paintSparkRating(gc, config) {
     points.push(points[0]); // close the path
   }
 
-  gc.shadowColor = 'transparent';
+  gc.cache.shadowColor = 'transparent';
 
-  gc.lineJoin = 'round';
+  gc.cache.lineJoin = 'round';
   gc.beginPath();
   for (var i = 5, sx = x + 5 + outerRadius; i; --i, sx += diameter) {
     points.forEach(function(point, index) {
@@ -204,7 +204,7 @@ function paintSparkRating(gc, config) {
 
   val = val / domain * 5;
 
-  gc.fillStyle = color;
+  gc.cache.fillStyle = color;
   gc.save();
   gc.clip();
   gc.fillRect(x + 5, y,
@@ -212,17 +212,17 @@ function paintSparkRating(gc, config) {
     height);
   gc.restore(); // remove clipping region
 
-  gc.strokeStyle = stroke;
-  gc.lineWidth = 1;
+  gc.cache.strokeStyle = stroke;
+  gc.cache.lineWidth = 1;
   gc.stroke();
 
   if (fgColor && fgColor !== 'transparent') {
-    gc.fillStyle = fgColor;
-    gc.font = '11px verdana';
-    gc.textAlign = 'right';
-    gc.textBaseline = 'middle';
-    gc.shadowColor = shadowColor;
-    gc.shadowOffsetX = gc.shadowOffsetY = 1;
+    gc.cache.fillStyle = fgColor;
+    gc.cache.font = '11px verdana';
+    gc.cache.textAlign = 'right';
+    gc.cache.textBaseline = 'middle';
+    gc.cache.shadowColor = shadowColor;
+    gc.cache.shadowOffsetX = gc.cache.shadowOffsetY = 1;
     gc.fillText(val.toFixed(1), x + width + 10, y + height / 2);
   }
 }
@@ -234,7 +234,7 @@ function getDarkenedColor(color, factor) {
 
 function getRGBA(colorSpec) {
   // Normalize variety of CSS color spec syntaxes to one of two
-  gc.fillStyle = colorSpec, colorSpec = gc.fillStyle;
+  gc.cache.fillStyle = colorSpec, colorSpec = gc.cache.fillStyle;
 
   var rgba = colorSpec.match(REGEXP_CSS_HEX6);
   if (rgba) {
diff --git a/src/lib/Canvas.js b/src/lib/Canvas.js
new file mode 100644
index 0000000..83021d8
--- /dev/null
+++ b/src/lib/Canvas.js
@@ -0,0 +1,841 @@
+/* eslint-env browser */
+
+'use strict';
+
+if (typeof window.CustomEvent !== 'function') {
+    window.CustomEvent = function(event, params) {
+        params = params || { bubbles: false, cancelable: false, detail: undefined };
+        var evt = document.createEvent('CustomEvent');
+        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
+        return evt;
+    };
+
+    window.CustomEvent.prototype = window.Event.prototype;
+}
+
+var rectangular = require('rectangular');
+
+var RESIZE_POLLING_INTERVAL = 200,
+    paintables = [],
+    resizables = [],
+    paintRequest,
+    resizeInterval,
+    charMap = makeCharMap();
+
+function Canvas(div, component) {
+    var self = this;
+
+    // create the containing <div>...</div>
+    this.div = div;
+    this.component = component;
+
+    this.dragEndtime = Date.now();
+
+    // create and append the info <div>...</div> (to be displayed when there are no data rows)
+    this.infoDiv = document.createElement('div');
+    this.infoDiv.className = 'info';
+    this.div.appendChild(this.infoDiv);
+
+    // create and append the canvas
+    this.gc = getCachedContext(this.canvas = document.createElement('canvas'));
+    this.bc = getCachedContext(this.buffer = document.createElement('canvas'));
+
+    this.div.appendChild(this.canvas);
+
+    this.canvas.style.outline = 'none';
+
+    this.mouseLocation = new rectangular.Point(-1, -1);
+    this.dragstart = new rectangular.Point(-1, -1);
+    //this.origin = new rectangular.Point(0, 0);
+    this.bounds = new rectangular.Rectangle(0, 0, 0, 0);
+    this.hasMouse = false;
+
+    document.addEventListener('mousemove', function(e) {
+        if (self.hasMouse || self.isDragging()) {
+            self.finmousemove(e);
+        }
+    });
+    document.addEventListener('mouseup', function(e) {
+        self.finmouseup(e);
+    });
+    document.addEventListener('wheel', function(e) {
+        self.finwheelmoved(e);
+    });
+    document.addEventListener('keydown', function(e) {
+        self.finkeydown(e);
+    });
+    document.addEventListener('keyup', function(e) {
+        self.finkeyup(e);
+    });
+
+    this.canvas.onmouseover = function() {
+        self.hasMouse = true;
+    };
+    this.addEventListener('focus', function(e) {
+        self.finfocusgained(e);
+    });
+    this.addEventListener('blur', function(e) {
+        self.finfocuslost(e);
+    });
+    this.addEventListener('mousedown', function(e) {
+        self.finmousedown(e);
+    });
+    this.addEventListener('mouseout', function(e) {
+        self.hasMouse = false;
+        self.finmouseout(e);
+    });
+    this.addEventListener('click', function(e) {
+        self.finclick(e);
+    });
+    this.addEventListener('contextmenu', function(e) {
+        self.fincontextmenu(e);
+        e.preventDefault();
+        return false;
+    });
+
+    this.canvas.setAttribute('tabindex', 0);
+    this.canvas.contentEditable = true;
+
+    this.resize();
+
+    this.beginResizing();
+    this.beginPainting();
+}
+
+Canvas.prototype = {
+    constructor: Canvas.prototype.constructor,
+    div: null,
+    component: null,
+    canvas: null,
+    focuser: null,
+    buffer: null,
+    ctx: null,
+    mouseLocation: null,
+    dragstart: null,
+    origin: null,
+    bounds: null,
+    dirty: false,
+    size: null,
+    mousedown: false,
+    dragging: false,
+    repeatKeyCount: 0,
+    repeatKey: null,
+    repeatKeyStartTime: 0,
+    currentKeys: [],
+    hasMouse: false,
+    lastDoubleClickTime: 0,
+    dragEndTime: 0,
+    lastRepaintTime: 0,
+    currentPaintCount: 0,
+    currentFPS: 0,
+    lastFPSComputeTime: 0,
+
+    addEventListener: function(name, callback) {
+        this.canvas.addEventListener(name, callback);
+    },
+
+    removeEventListener: function(name, callback) {
+        this.canvas.removeEventListener(name, callback);
+    },
+
+    stopPaintLoop: stopPaintLoop,
+    restartPaintLoop: restartPaintLoop,
+
+    stopResizeLoop: stopResizeLoop,
+    restartResizeLoop: restartResizeLoop,
+
+    detached: function() {
+        this.stopPainting();
+        this.stopResizing();
+    },
+
+    getCurrentFPS:function() {
+        return this.currentFPS;
+    },
+
+
+    tickPaint: function(now) {
+        var isContinuousRepaint = this.component.properties.enableContinuousRepaint,
+            fps = this.component.properties.repaintIntervalRate;
+        if (fps === 0) {
+            return;
+        }
+        var interval = 1000 / fps;
+
+        var elapsed = now - this.lastRepaintTime;
+        if (elapsed > interval && (isContinuousRepaint || this.dirty)) {
+            this.paintNow();
+            this.lastRepaintTime = now;
+            /* - (elapsed % interval);*/
+            if (isContinuousRepaint) {
+                this.currentPaintCount++;
+                if (now - this.lastFPSComputeTime >= 1000) {
+                    this.currentFPS = (this.currentPaintCount * 1000) / (now - this.lastFPSComputeTime);
+                    this.currentPaintCount = 0;
+                    this.lastFPSComputeTime = now;
+                }
+            }
+        }
+    },
+
+    beginPainting: function() {
+        var self = this;
+        this.dirty = true;
+        this.tickPainter = function(now) {
+            self.tickPaint(now);
+        };
+        paintables.push(this);
+    },
+
+    stopPainting: function() {
+        paintables.splice(paintables.indexOf(this), 1);
+    },
+
+    beginResizing: function() {
+        var self = this;
+        this.tickResizer = function() {
+            self.checksize();
+        };
+        resizables.push(this);
+    },
+
+    stopResizing: function() {
+        resizables.splice(resizables.indexOf(this), 1);
+    },
+
+    start: function() {
+        this.beginPainting();
+        this.beginResizing();
+    },
+
+    stop: function() {
+        this.stopPainting();
+        this.stopResizing();
+    },
+
+    checksize: function() {
+        //this is expensive lets do it at some modulo
+        var sizeNow = this.div.getBoundingClientRect();
+        if (sizeNow.width !== this.size.width || sizeNow.height !== this.size.height) {
+            this.resize();
+        }
+    },
+
+    resize: function() {
+        var box = this.size = this.div.getBoundingClientRect();
+
+        this.width = box.width;
+        this.height = box.height;
+
+        //fix ala sir spinka, see
+        //http://www.html5rocks.com/en/tutorials/canvas/hidpi/
+        //just add 'hdpi' as an attribute to the fin-canvas tag
+        var ratio = 1;
+        var isHIDPI = window.devicePixelRatio && this.component.properties.useHiDPI;
+        if (isHIDPI) {
+            var devicePixelRatio = window.devicePixelRatio || 1;
+            var backingStoreRatio = this.gc.webkitBackingStorePixelRatio ||
+                this.gc.mozBackingStorePixelRatio ||
+                this.gc.msBackingStorePixelRatio ||
+                this.gc.oBackingStorePixelRatio ||
+                this.gc.backingStorePixelRatio || 1;
+
+            ratio = devicePixelRatio / backingStoreRatio;
+            //this.canvasCTX.scale(ratio, ratio);
+        }
+
+        this.buffer.width = this.canvas.width = this.width * ratio;
+        this.buffer.height = this.canvas.height = this.height * ratio;
+
+        this.canvas.style.width = this.buffer.style.width = this.width + 'px';
+        this.canvas.style.height = this.buffer.style.height = this.height + 'px';
+
+        this.bc.scale(ratio, ratio);
+        if (isHIDPI && !this.component.properties.useBitBlit) {
+            this.gc.scale(ratio, ratio);
+        }
+
+        this.bounds = new rectangular.Rectangle(0, 0, this.width, this.height);
+        this.component.setBounds(this.bounds);
+        this.resizeNotification();
+        this.paintNow();
+    },
+
+    resizeNotification: function() {
+        this.dispatchNewEvent(undefined, 'fin-canvas-resized', {
+            width: this.width,
+            height: this.height
+        });
+    },
+
+    getBounds: function() {
+        return this.bounds;
+    },
+
+    paintNow: function() {
+        var useBitBlit = this.component.properties.useBitBlit,
+            gc = useBitBlit ? this.bc : this.gc;
+
+        try {
+            gc.cache.save();
+            this.component.paint(gc);
+            this.dirty = false;
+        } catch (e) {
+            console.error(e);
+        } finally {
+            gc.cache.restore();
+        }
+
+        if (useBitBlit) {
+            this.flushBuffer();
+        }
+    },
+
+    flushBuffer: function() {
+        if (this.buffer.width > 0 && this.buffer.height > 0) {
+            this.gc.drawImage(this.buffer, 0, 0);
+        }
+    },
+
+    newEvent: function(primitiveEvent, name, detail) {
+        var event = {
+            detail: detail || {}
+        };
+        if (primitiveEvent) {
+            event.detail.primitiveEvent = primitiveEvent;
+        }
+        return new CustomEvent(name, event);
+    },
+
+    dispatchNewEvent: function(primitiveEvent, name, detail) {
+        return this.canvas.dispatchEvent(this.newEvent(primitiveEvent, name, detail));
+    },
+
+    dispatchNewMouseKeysEvent: function(event, name, detail) {
+        detail = detail || {};
+        detail.mouse = this.mouseLocation;
+        detail.keys = this.currentKeys;
+        return this.dispatchNewEvent(event, name, detail);
+    },
+
+    finmousemove: function(e) {
+        if (!this.isDragging() && this.mousedown) {
+            this.beDragging();
+            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragstart', {
+                isRightClick: this.isRightClick(e),
+                dragstart: this.dragstart
+            });
+            this.dragstart = new rectangular.Point(this.mouseLocation.x, this.mouseLocation.y);
+        }
+        this.mouseLocation = this.getLocal(e);
+        //console.log(this.mouseLocation);
+        if (this.isDragging()) {
+            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-drag', {
+                dragstart: this.dragstart,
+                isRightClick: this.isRightClick(e)
+            });
+        }
+        if (this.bounds.contains(this.mouseLocation)) {
+            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousemove');
+        }
+    },
+
+    finmousedown: function(e) {
+        this.mouseLocation = this.mouseDownLocation = this.getLocal(e);
+        this.mousedown = true;
+
+        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousedown', {
+            isRightClick: this.isRightClick(e)
+        });
+        this.takeFocus();
+    },
+
+    finmouseup: function(e) {
+        if (this.isDragging()) {
+            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragend', {
+                dragstart: this.dragstart,
+                isRightClick: this.isRightClick(e)
+            });
+            this.beNotDragging();
+            this.dragEndtime = Date.now();
+        }
+        this.mousedown = false;
+        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseup', {
+            dragstart: this.dragstart,
+            isRightClick: this.isRightClick(e)
+        });
+        //this.mouseLocation = new rectangular.Point(-1, -1);
+    },
+
+    finmouseout: function(e) {
+        if (!this.mousedown) {
+            this.mouseLocation = new rectangular.Point(-1, -1);
+        }
+        this.repaint();
+        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseout', {
+            dragstart: this.dragstart
+        });
+    },
+
+    finwheelmoved: function(e) {
+        if (this.isDragging() || !this.hasFocus()) {
+            return;
+        }
+        e.preventDefault();
+        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-wheelmoved', {
+            isRightClick: this.isRightClick(e)
+        });
+    },
+
+    finclick: function(e) {
+        var delay = this.component.properties.doubleClickDelay;
+        if (delay < 100) {
+            dispatchClickEvent.call(this, e);
+        } else if (this.doubleClickTimer && Date.now() - this.lastClickTime < delay) {
+            //this is a double click...
+            clearTimeout(this.doubleClickTimer); // prevent click event
+            this.doubleClickTimer = undefined;
+            this.findblclick(e);
+        } else {
+            this.lastClickTime = Date.now();
+            this.doubleClickTimer = setTimeout(dispatchClickEvent.bind(this, e), delay);
+        }
+    },
+
+    findblclick: function(e) {
+        this.mouseLocation = this.getLocal(e);
+        this.lastDoubleClickTime = Date.now();
+        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dblclick', {
+            isRightClick: this.isRightClick(e)
+        });
+        //console.log('dblclick', this.currentKeys);
+    },
+
+    getCharMap: function() {
+        return charMap;
+    },
+
+    getKeyChar: function(e) {
+        var key = e.keyCode || e.detail.key,
+            shift = e.shiftKey || e.detail.shift;
+        return charMap[key][shift ? 1 : 0];
+    },
+
+    finkeydown: function(e) {
+        if (!this.hasFocus()) {
+            return;
+        }
+
+        // prevent TAB from moving focus off the canvas element
+        if (e.keyCode === 9) {
+            e.preventDefault();
+        }
+
+        var keyChar = this.getKeyChar(e);
+        if (e.repeat) {
+            if (this.repeatKey === keyChar) {
+                this.repeatKeyCount++;
+            } else {
+                this.repeatKey = keyChar;
+                this.repeatKeyStartTime = Date.now();
+            }
+        } else {
+            this.repeatKey = null;
+            this.repeatKeyCount = 0;
+            this.repeatKeyStartTime = 0;
+        }
+        if (this.currentKeys.indexOf(keyChar) === -1) {
+            this.currentKeys.push(keyChar);
+        }
+
+        this.dispatchNewEvent(e, 'fin-canvas-keydown', {
+            alt: e.altKey,
+            ctrl: e.ctrlKey,
+            char: keyChar,
+            code: e.charCode,
+            key: e.keyCode,
+            meta: e.metaKey,
+            repeatCount: this.repeatKeyCount,
+            repeatStartTime: this.repeatKeyStartTime,
+            shift: e.shiftKey,
+            identifier: e.key,
+            currentKeys: this.currentKeys.slice(0)
+        });
+    },
+
+    finkeyup: function(e) {
+        if (!this.hasFocus()) {
+            return;
+        }
+
+        // prevent TAB from moving focus off the canvas element
+        if (e.keyCode === 9) {
+            e.preventDefault();
+        }
+
+        var keyChar = this.getKeyChar(e);
+        this.currentKeys.splice(this.currentKeys.indexOf(keyChar), 1);
+        this.repeatKeyCount = 0;
+        this.repeatKey = null;
+        this.repeatKeyStartTime = 0;
+        this.dispatchNewEvent(e, 'fin-canvas-keyup', {
+            alt: e.altKey,
+            ctrl: e.ctrlKey,
+            char: keyChar,
+            code: e.charCode,
+            key: e.keyCode,
+            meta: e.metaKey,
+            repeat: e.repeat,
+            shift: e.shiftKey,
+            identifier: e.key,
+            currentKeys: this.currentKeys.slice(0)
+        });
+    },
+
+    finfocusgained: function(e) {
+        this.dispatchNewEvent(e, 'fin-canvas-focus-gained');
+    },
+
+    finfocuslost: function(e) {
+        this.dispatchNewEvent(e, 'fin-canvas-focus-lost');
+    },
+
+    fincontextmenu: function(e) {
+        var delay = this.component.properties.doubleClickDelay;
+
+        if (e.ctrlKey && this.currentKeys.indexOf('CTRL') === -1) {
+            this.currentKeys.push('CTRL');
+        }
+
+        if (delay < 100) {
+            dispatchContextMenuEvent.call(this, e);
+        } else if (this.doubleRightClickTimer && Date.now() - this.lastClickTime < delay) {
+            //this is a double click...
+            clearTimeout(this.doubleRightClickTimer); // prevent context menu event
+            this.doubleRightClickTimer = undefined;
+            this.findblclick(e);
+        } else {
+            this.lastClickTime = Date.now();
+
+            this.doubleRightClickTimer = setTimeout(dispatchContextMenuEvent.bind(this, e), delay);
+        }
+    },
+
+    repaint: function() {
+        this.dirty = true;
+        if (!paintRequest || this.component.properties.repaintIntervalRate === 0) {
+            this.paintNow();
+        }
+    },
+
+    getMouseLocation: function() {
+        return this.mouseLocation;
+    },
+
+    getOrigin: function() {
+        var rect = this.canvas.getBoundingClientRect();
+        var p = new rectangular.Point(rect.left, rect.top);
+        return p;
+    },
+
+    getLocal: function(e) {
+        var rect = this.canvas.getBoundingClientRect();
+        var p = new rectangular.Point(e.clientX - rect.left, e.clientY - rect.top);
+        return p;
+    },
+
+    hasFocus: function() {
+        return document.activeElement === this.canvas;
+    },
+
+    takeFocus: function() {
+        var self = this;
+        if (!this.hasFocus()) {
+            setTimeout(function() {
+                self.canvas.focus();
+            }, 10);
+        }
+    },
+
+    beDragging: function() {
+        this.dragging = true;
+        this.disableDocumentElementSelection();
+    },
+
+    beNotDragging: function() {
+        this.dragging = false;
+        this.enableDocumentElementSelection();
+    },
+
+    isDragging: function() {
+        return this.dragging;
+    },
+
+    disableDocumentElementSelection: function() {
+        var style = document.body.style;
+        style.cssText = style.cssText + '-webkit-user-select: none';
+    },
+
+    enableDocumentElementSelection: function() {
+        var style = document.body.style;
+        style.cssText = style.cssText.replace('-webkit-user-select: none', '');
+    },
+
+    setFocusable: function(truthy) {
+        this.focuser.style.display = truthy ? '' : 'none';
+    },
+
+    isRightClick: function(e) {
+        var isRightMB;
+        e = e || window.event;
+
+        if ('which' in e) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
+            isRightMB = e.which === 3;
+        } else if ('button' in e) { // IE, Opera
+            isRightMB = e.button === 2;
+        }
+        return isRightMB;
+    },
+
+    dispatchEvent: function(e) {
+        return this.canvas.dispatchEvent(e);
+    },
+
+    setInfo: function(message, width) {
+        if (message) {
+            if (width !== undefined) {
+                if (width && !isNaN(Number(width))) {
+                    width += 'px';
+                }
+                this.infoDiv.style.width = width;
+            }
+
+            if (message.indexOf('<')) {
+                this.infoDiv.innerHTML = message;
+            } else {
+                this.infoDiv.innerText = message;
+            }
+        }
+
+        this.infoDiv.style.display = message ? 'block' : 'none';
+    }
+};
+
+function dispatchClickEvent(e) {
+    this.doubleClickTimer = undefined;
+    this.mouseLocation = this.getLocal(e);
+    this.dispatchNewMouseKeysEvent(e, 'fin-canvas-click', {
+        isRightClick: this.isRightClick(e)
+    });
+}
+
+function dispatchContextMenuEvent(e) {
+    this.doubleRightClickTimer = undefined;
+    this.dispatchNewMouseKeysEvent(e, 'fin-canvas-context-menu', {
+        isRightClick: this.isRightClick(e)
+    });
+}
+
+function paintLoopFunction(now) {
+    if (paintRequest) {
+        paintables.forEach(function(paintable) {
+            try {
+                paintable.tickPainter(now);
+            } catch (e) {
+                console.error(e);
+            }
+
+            if (paintable.component.tickNotification) {
+                paintable.component.tickNotification();
+            }
+        });
+        paintRequest = requestAnimationFrame(paintLoopFunction);
+    }
+}
+function restartPaintLoop() {
+    paintRequest = paintRequest || requestAnimationFrame(paintLoopFunction);
+}
+function stopPaintLoop() {
+    if (paintRequest) {
+        cancelAnimationFrame(paintRequest);
+        paintRequest = undefined;
+    }
+}
+restartPaintLoop();
+
+function resizablesLoopFunction(now) {
+    if (resizeInterval) {
+        for (var i = 0; i < resizables.length; i++) {
+            try {
+                resizables[i].tickResizer(now);
+            } catch (e) {
+                console.error(e);
+            }
+        }
+    }
+}
+function restartResizeLoop() {
+    resizeInterval = resizeInterval || setInterval(resizablesLoopFunction, RESIZE_POLLING_INTERVAL);
+}
+function stopResizeLoop() {
+    if (resizeInterval) {
+        clearInterval(resizeInterval);
+        resizeInterval = undefined;
+    }
+}
+restartResizeLoop();
+
+function makeCharMap() {
+    var map = [];
+
+    var empty = ['', ''];
+
+    for (var i = 0; i < 256; i++) {
+        map[i] = empty;
+    }
+
+    map[27] = ['ESC', 'ESCSHIFT'];
+    map[192] = ['`', '~'];
+    map[49] = ['1', '!'];
+    map[50] = ['2', '@'];
+    map[51] = ['3', '#'];
+    map[52] = ['4', '$'];
+    map[53] = ['5', '%'];
+    map[54] = ['6', '^'];
+    map[55] = ['7', '&'];
+    map[56] = ['8', '*'];
+    map[57] = ['9', '('];
+    map[48] = ['0', ')'];
+    map[189] = ['-', '_'];
+    map[187] = ['=', '+'];
+    map[8] = ['BACKSPACE', 'BACKSPACESHIFT'];
+    map[46] = ['DELETE', 'DELETESHIFT'];
+    map[9] = ['TAB', 'TABSHIFT'];
+    map[81] = ['q', 'Q'];
+    map[87] = ['w', 'W'];
+    map[69] = ['e', 'E'];
+    map[82] = ['r', 'R'];
+    map[84] = ['t', 'T'];
+    map[89] = ['y', 'Y'];
+    map[85] = ['u', 'U'];
+    map[73] = ['i', 'I'];
+    map[79] = ['o', 'O'];
+    map[80] = ['p', 'P'];
+    map[219] = ['[', '{'];
+    map[221] = [']', '}'];
+    map[220] = ['\\', '|'];
+    map[220] = ['CAPSLOCK', 'CAPSLOCKSHIFT'];
+    map[65] = ['a', 'A'];
+    map[83] = ['s', 'S'];
+    map[68] = ['d', 'D'];
+    map[70] = ['f', 'F'];
+    map[71] = ['g', 'G'];
+    map[72] = ['h', 'H'];
+    map[74] = ['j', 'J'];
+    map[75] = ['k', 'K'];
+    map[76] = ['l', 'L'];
+    map[186] = [';', ':'];
+    map[222] = ['\'', '|'];
+    map[13] = ['RETURN', 'RETURNSHIFT'];
+    map[16] = ['SHIFT', 'SHIFT'];
+    map[90] = ['z', 'Z'];
+    map[88] = ['x', 'X'];
+    map[67] = ['c', 'C'];
+    map[86] = ['v', 'V'];
+    map[66] = ['b', 'B'];
+    map[78] = ['n', 'N'];
+    map[77] = ['m', 'M'];
+    map[188] = [',', '<'];
+    map[190] = ['.', '>'];
+    map[191] = ['/', '?'];
+    map[16] = ['SHIFT', 'SHIFT'];
+    map[17] = ['CTRL', 'CTRLSHIFT'];
+    map[18] = ['ALT', 'ALTSHIFT'];
+    map[91] = ['COMMANDLEFT', 'COMMANDLEFTSHIFT'];
+    map[32] = ['SPACE', 'SPACESHIFT'];
+    map[93] = ['COMMANDRIGHT', 'COMMANDRIGHTSHIFT'];
+    map[18] = ['ALT', 'ALTSHIFT'];
+    map[38] = ['UP', 'UPSHIFT'];
+    map[37] = ['LEFT', 'LEFTSHIFT'];
+    map[40] = ['DOWN', 'DOWNSHIFT'];
+    map[39] = ['RIGHT', 'RIGHTSHIFT'];
+
+    map[33] = ['PAGEUP', 'PAGEUPSHIFT'];
+    map[34] = ['PAGEDOWN', 'PAGEDOWNSHIFT'];
+    map[35] = ['PAGERIGHT', 'PAGERIGHTSHIFT']; // END
+    map[36] = ['PAGELEFT', 'PAGELEFTSHIFT']; // HOME
+
+    map[112] = ['F1', 'F1SHIFT'];
+    map[113] = ['F2', 'F2SHIFT'];
+    map[114] = ['F3', 'F3SHIFT'];
+    map[115] = ['F4', 'F4SHIFT'];
+    map[116] = ['F5', 'F5SHIFT'];
+    map[117] = ['F6', 'F6SHIFT'];
+    map[118] = ['F7', 'F7SHIFT'];
+    map[119] = ['F8', 'F8SHIFT'];
+    map[120] = ['F9', 'F9SHIFT'];
+    map[121] = ['F10', 'F10SHIFT'];
+    map[122] = ['F11', 'F1S1HIFT'];
+    map[123] = ['F12', 'F121HIFT'];
+
+    return map;
+}
+
+function getCachedContext(canvasElement, type) {
+    var gc = canvasElement.getContext(type || '2d'),
+        props = {},
+        values = {};
+
+    // Stub out all the prototype members of the canvas 2D graphics context:
+    Object.keys(Object.getPrototypeOf(gc)).forEach(makeStub);
+
+    // Some older browsers (e.g., Chrome 40) did not have all members of canvas
+    // 2D graphics context in the prototype so we make this additional call:
+    Object.keys(gc).forEach(makeStub);
+
+    function makeStub(key) {
+        if (
+            !(key in props) &&
+            !/^(webkit|moz|ms|o)[A-Z]/.test(key) &&
+            typeof gc[key] !== 'function'
+        ) {
+            Object.defineProperty(props, key, {
+                get: function() {
+                    return (values[key] = values[key] || gc[key]);
+                },
+                set: function(value) {
+                    if (value !== values[key]) {
+                        gc[key] = values[key] = value;
+                    }
+                }
+            });
+        }
+    }
+
+    gc.cache = props;
+
+    gc.cache.save = function() {
+        gc.save();
+        values = Object.create(values);
+    };
+
+    gc.cache.restore = function() {
+        gc.restore();
+        values = Object.getPrototypeOf(values);
+    };
+
+    gc.conditionalsStack = [];
+
+    Object.getOwnPropertyNames(Canvas.graphicsContextAliases).forEach(function(alias) {
+        gc[alias] = gc[Canvas.graphicsContextAliases[alias]];
+    });
+
+    return Object.assign(gc, require('./graphics'));
+}
+
+Canvas.graphicsContextAliases = {
+    simpleText: 'fillText'
+};
+
+
+module.exports = Canvas;
diff --git a/src/lib/DOM/copy-input.js b/src/lib/DOM/copy-input.js
deleted file mode 100644
index 7c4ae87..0000000
--- a/src/lib/DOM/copy-input.js
+++ /dev/null
@@ -1,71 +0,0 @@
-/* eslint-env browser */
-
-'use strict';
-
-/**
- *
- * @param {HTMLElement} [containingEl=document]
- * @param {string} [prefix='']
- * @param {string} [separator='']
- * @param {string} [suffix='']
- * @param {function} [transformer=multiLineTrim] - Function to transform each input control's text value.
- */
-function copyAll(containingEl, prefix, separator, suffix, transformer) {
-    var texts = [], lastTextEl, text;
-
-    Array.prototype.forEach.call((containingEl || document).querySelectorAll(copyAll.selector), function(textEl) {
-        text = (transformer || multiLineTrim)(textEl.value);
-        if (text) { texts.push(text); }
-        lastTextEl = textEl;
-    });
-
-    if (lastTextEl) {
-        copy(lastTextEl, (prefix || '') + texts.join(separator || '') + (suffix || ''));
-    }
-}
-
-/**
- * 1. Trim the text in the given input element
- * 2. select it
- * 3. copy it to the clipboard
- * 4. deselect it
- * 5. return it
- * @param {HTMLElement|HTMLTextAreaElement} el
- * @param {string} [text=el.value] - Text to copy.
- * @returns {undefined|string} Trimmed text in element or undefined if unable to copy.
- */
-function copy(el, text) {
-    var result, textWas;
-
-    if (text) {
-        textWas = el.value;
-        el.value = text;
-    } else {
-        text = el.value;
-    }
-
-    el.value = multiLineTrim(text);
-
-    try {
-        el.select();
-        result = document.execCommand('copy');
-    } catch (err) {
-        result = false;
-    } finally {
-        if (textWas !== undefined) {
-            el.value = textWas;
-        }
-        el.blur();
-    }
-    return result;
-}
-
-function multiLineTrim(s) {
-    return s.replace(/^\s*(.*?)\s*$/, '$1');
-}
-
-copy.all = copyAll;
-copy.multiLineTrim = multiLineTrim;
-copy.selectorTextControls = 'input:not([type]), input[type=text], textarea';
-
-module.exports = copy;
diff --git a/src/lib/DOM/elfor.js b/src/lib/DOM/elfor.js
deleted file mode 100644
index 5d0b94e..0000000
--- a/src/lib/DOM/elfor.js
+++ /dev/null
@@ -1,11 +0,0 @@
-/* eslint-env browser */
-
-'use strict';
-
-module.exports.each = function(selector, iteratee, context) {
-    return Array.prototype.forEach.call((context || document).querySelectorAll(selector), iteratee);
-};
-
-module.exports.find = function(selector, iteratee, context) {
-    return Array.prototype.find.call((context || document).querySelectorAll(selector), iteratee);
-};
diff --git a/src/lib/DataSourceOrigin.js b/src/lib/DataSourceOrigin.js
new file mode 100644
index 0000000..0db8f5e
--- /dev/null
+++ b/src/lib/DataSourceOrigin.js
@@ -0,0 +1,335 @@
+/* eslint-env browser */
+
+'use strict';
+
+var DataSourceBase = require('fin-hypergrid-data-source-base');
+
+var getFieldNames = require('./fields').getFieldNames;
+
+/**
+ * See {@link DataSourceOrigin#initialize} for constructor parameters.
+ * @constructor
+ */
+var DataSourceOrigin = DataSourceBase.extend('DataSourceOrigin',  {
+
+    /**
+     * Currently a synonym for {@link DataSourceOrigin#setData} (see).
+     */
+    initialize: function(data, schema) {
+        delete this.dataSource; // added by DataSourceBase#initialize but we don't want here
+        this._schema = [];
+        this.setData(data, schema);
+    },
+
+    /** @typedef {object} columnSchemaObject
+     * @property {string} name - The required column name.
+     * @property {string} [header] - An override for derived header
+     * @property {function} [calculator] - A function for a computed column. Undefined for normal data columns.
+     * @property {string} [type] - Used for sorting when and only when comparator not given.
+     * @property {object} [comparator] - For sorting, both of following required:
+     * @property {function} comparator.asc - ascending comparator
+     * @property {function} comparator.desc - descending comparator
+     */
+
+    /**
+     * @param {object[]} [data=[]] - Array of uniform objects containing the grid data.
+     * @param {columnSchemaObject[]} [schema=[]]
+     * @memberOf DataSourceOrigin#
+     */
+    setData: function(data, schema) {
+        /**
+         * @summary The array of uniform data objects.
+         * @name schema
+         * @type {columnSchemaObject[]}
+         * @memberOf DataSourceOrigin#
+         */
+        this.data = data || [];
+
+        if (schema) {
+            this.setSchema(schema);
+        } else if (this.data.length && !this.schema.length) {
+            this.setSchema([]);
+        }
+    },
+
+    get schema() { return this._schema; },
+    set schema(schema) { this._schema = schema; },
+
+    /**
+     * @memberOf DataSourceOrigin#
+     * @returns {columnSchemaObject[]}
+     */
+    getSchema:  function(){
+        return this._schema;
+    },
+    /**
+     * @memberOf DataSourceOrigin#
+     * Caveat: Do not call on a data update when you expect to reuse the existing schema.
+     * @param schema
+     */
+    setSchema: function(schema){
+        if (!schema.length) {
+            var fields = getFieldNames(this.data[0]);
+
+            schema = Array(fields.length);
+
+            for (var i = 0; i < fields.length; i++) {
+                schema[i] = { name: fields[i] };
+            }
+        }
+
+        /**
+         * @summary The array of column schema objects.
+         * @name schema
+         * @type {columnSchemaObject[]}
+         * @memberOf DataSourceOrigin#
+         */
+        this._schema = schema;
+    },
+
+    isNullObject: false,
+
+    getDataIndex: function(y) {
+        return y;
+    },
+
+    /**
+     * @memberOf DataSourceOrigin#
+     * @param y
+     * @returns {dataRowObject}
+     */
+    getRow: function(y) {
+        return this.data[y];
+    },
+
+    /**
+     * @summary Find, replace, or update a row by it's primary key column.
+     * @param {string|object} columnName - One of:
+     * * _string_ - Column name. See `value`.
+     * * _object_ - Hash of 0 or more key-value pairs to search for.
+     * @param {string[]|*} [value] - One of:
+     * _omitted_ - When `columnName` is a hash and you want to search all its keys.
+     * _string[]_ - When `columnName` is a hash but you only want to search certain keys.
+     * _otherwise_ - When `columnName` is a string. Value to search for.
+     * Note that `null` is a valid search value.
+     * @param {object|null|undefined} [replacement] - One of:
+     * * _omitted_ - Ignored.
+     * * _object_ - Replacement for the data row if found.
+     * * `null` - Flag to delete the data row if found. The found data row is nonetheless returned.
+     * * `undefined` - Flag to return index of found row instead of row object itself.
+     * @returns {object|number|undefined} One of:
+     * * `undefined` - data row not found
+     * * _object_ - found data row object (will have been deleted if `replacement` was `null`)
+     * * _number_ - index of found data row object in `this.data` (if `replacement` was `undefined`)
+     * @todo Use a binary search (rather than `Array..find`) when column is known to be indexed (sorted).
+     * @memberOf DataSourceOrigin#
+     */
+    findRow: function findRow(columnName, value, replacement) {
+        var result, index, keys, hash, args;
+
+        if (typeof columnName === 'object') {
+            hash = columnName;
+
+            if (value instanceof Array) {
+                args = 2;
+                keys = value;
+                if (keys.reduce(function(sum, key) {
+                        if (key in hash) {
+                            sum++;
+                        }
+                        return sum;
+                    }, 0) !== keys.length) {
+                    throw 'Expected all keys given in 2nd arg to be found in hash given in 1st arg.';
+                }
+            } else {
+                args = 1;
+                keys = Object.keys(hash);
+                replacement = value; // promote
+            }
+
+            if (keys.length === 1) {
+                columnName = keys[0];
+                value = hash[columnName];
+                hash = undefined;
+            } else if (keys.length) {
+                result = this.data.find(function(row, idx) {
+                    if (!row) {
+                        return;
+                    }
+                    index = idx;
+                    for (var key in keys) {
+                        columnName = keys[key];
+                        if (row[columnName] !== hash[columnName]) {
+                            return; // bail
+                        }
+                    }
+                    return true; // found!
+                });
+            }
+        } else {
+            if (arguments.length < 2) {
+                throw 'Expected at least 2 arguments when first argument not object but found ' + arguments.length + '.';
+            }
+            args = 2;
+        }
+
+        if (!hash) {
+            result = this.data.find(function(row, idx) {
+                if (!row) { return; }
+                index = idx;
+                return row[columnName] === value;
+            });
+        }
+
+        if (result) {
+            this.foundRowIndex = index;
+            if (replacement === null) {
+                this.data.splice(index, 1);
+            } else if (typeof replacement === 'object') {
+                this.data[index] = replacement;
+            } else if (replacement === undefined) {
+                if (arguments.length > args) {
+                    delete this.data[index];
+                }
+            } else {
+                throw 'Expected null, undefined, or object but found ' + typeof replacement + '.';
+            }
+        } else {
+            this.foundRowIndex = undefined;
+        }
+
+        return result;
+    },
+
+    /**
+     * @summary Find, replace, or update a row by it's index.
+     * @param {number} index - Row index that is being accessed
+     * @param {object|null|undefined} [replacement] - One of:
+     * * _omitted_ - Ignored.
+     * * _object_ - Replacement for the data row if found.
+     * * `null` - Flag to delete the data row if found. The found data row is nonetheless returned.
+     * * `undefined` - Flag to delete the row at that index.
+     * @returns {object|number|undefined} One of:
+     * * `undefined` - data row not found
+     * * _object_ - found data row object (will have been deleted if `replacement` was `null`)
+     * @todo Use a binary search (rather than `Array..find`) when column is known to be indexed (sorted).
+     * @memberOf DataSourceOrigin#
+     */
+    findRowByIndex: function findRow(index, replacement) {
+        var result;
+
+        if (arguments.length < 1) {
+            throw 'Expected at least 1 argument but found ' + arguments.length + '.';
+        }
+
+        if (typeof index !== 'number') {
+            throw 'Expected at index to be a number but got ' + index + '.';
+        }
+
+        result = this.data[index];
+
+        if (result) {
+            if (replacement === null) {
+                this.data.splice(index, 1);
+            } else if (typeof replacement === 'object') {
+                this.data[index] = replacement;
+            } else if (replacement === undefined && arguments.length >= 2) {
+                delete this.data[index];
+            } else if (replacement !== undefined) {
+                throw 'Expected null, undefined, or object but found ' + typeof replacement + '.';
+            }
+        }
+
+        return result;
+    },
+
+
+    /**
+     * @memberOf DataSourceOrigin#
+     * @param x
+     * @param y
+     * @returns {*}
+     */
+    getValue: function(x, y) {
+        var row = this.getRow(y);
+        if (!row) {
+            return null;
+        }
+        return row[this.schema[x].name];
+    },
+
+    /**
+     * @memberOf DataSourceOrigin#
+     * @param {number} x
+     * @param {number} y
+     * @param value
+     */
+    setValue: function(x, y, value) {
+        this.getRow(y)[this.schema[x].name] = value;
+    },
+
+    /**
+     * @memberOf DataSourceOrigin#
+     * @returns {number}
+     */
+    getRowCount: function() {
+        return this.data.length;
+    },
+
+    /**
+     * @memberOf DataSourceOrigin#
+     * @returns {number}
+     */
+    getColumnCount: function() {
+        return this.schema.length;
+    },
+
+    /**
+     * @memberOf DataSourceOrigin#
+     * @returns {number[]}
+     */
+    getFields: function() {
+        return this.schema.map(function(columnSchema) { return columnSchema.name; });
+    },
+
+    /**
+     * @memberOf DataSourceOrigin#
+     * @returns {string[]}
+     */
+    getHeaders: function() {
+        return this.schema.map(function(columnSchema) { return columnSchema.header; });
+    },
+
+    /**
+     * @memberOf DataSourceOrigin#
+     * @param {string[]} fields
+     */
+    setFields: function(fields) {
+        if (!(Array.isArray(fields) && fields.length === this.schema.length)) {
+            throw new this.DataSourceError('Expected argument to be an array with correct length.');
+        }
+        fields.forEach(function(field, i) {
+            this.schema[i].field = field;
+        }, this);
+    },
+
+    /**
+     * @memberOf DataSourceOrigin#
+     * @param {string[]} [headers] - If omitted, headers will be reset to their derived defaults on next call to `getHeaders`.
+     */
+    setHeaders: function(headers) {
+        if (!(Array.isArray(headers) && headers.length === this.schema.length)) {
+            throw new this.DataSourceError('Expected argument to be an array with correct length.');
+        }
+        headers.forEach(function(header, i) {
+            this.schema[i].header = header;
+        }, this);
+    }
+});
+
+
+module.exports = DataSourceOrigin;
+
+
+// Create the `datasaur` namespace and the `datasaur.base` object for use by data sources included via <script> tags:
+(window.datasaur = window.datasaur || {}).base = require('fin-hypergrid-data-source-base');
diff --git a/src/lib/Localization.js b/src/lib/Localization.js
index 6bce2db..8dc1a19 100644
--- a/src/lib/Localization.js
+++ b/src/lib/Localization.js
@@ -376,6 +376,8 @@ function Localization(locale, numberOptions, dateOptions) {
 
 Localization.prototype = {
     constructor: Localization.prototype.constructor,
+    $$CLASS_NAME: 'Localization',
+    deprecated: deprecated,
 
     /** @summary Creates a localizer from a localizer factory object using the default locale.
      * @desc Performs the following actions:
@@ -387,7 +389,7 @@ Localization.prototype = {
      * @param {string} localizerName
      * @param {Constructor
      * @param {object} {factoryOptions}
-     * @returns {localizeInerface} The new localizer.
+     * @returns {localizerInterface} The new localizer.
      */
     construct: function(localizerName, Constructor, factoryOptions) {
         var constructorName = localizerName[0].toUpperCase() + localizerName.substr(1).toLowerCase() + 'Formatter',
@@ -405,7 +407,7 @@ Localization.prototype = {
      * @param {string} name
      * @param {localizerInterface} localizer
      * @memberOf Localization.prototype
-     * @returns {localizeInerface} The provided localizer.
+     * @returns {localizerInterface} The provided localizer.
      */
     add: function(name, localizer) {
         if (typeof name === 'object') {
@@ -429,7 +431,7 @@ Localization.prototype = {
 
         return localizer;
     },
-    deprecated: deprecated,
+
     set: function(name) {
         return this.deprecated('set(name, localizer)', 'add(name, localizer)', '1.0.6', arguments);
     },
diff --git a/src/lib/Renderer.js b/src/lib/Renderer.js
deleted file mode 100644
index 397f360..0000000
--- a/src/lib/Renderer.js
+++ /dev/null
@@ -1,1115 +0,0 @@
-/* eslint-env browser */
-/* global requestAnimationFrame */
-
-'use strict';
-
-var _ = require('object-iterators');
-
-var Base = require('../Base');
-var images = require('../../images');
-
-/** @typedef {object} CanvasRenderingContext2D
- * @see [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
- */
-
-/** @typedef {object} visibleColumnDescriptor
- * @property {number} index - A back reference to the element's array index in {@link Renderer#visibleColumns}.
- * @property {number} columnIndex - Dereferences {@link Behavior#columns}, the subset of _active_ columns, specifying which column to show in that position.
- * @property {number} left - Pixel coordinate of the left edge of this column, rounded to nearest integer.
- * @property {number} right - Pixel coordinate of the right edge of this column, rounded to nearest integer.
- * @property {number} width - Width of this column in pixels, rounded to nearest integer.
- */
-
-/** @typedef {object} visibleRowDescriptor
- * @property {number} index - A back reference to the element's array index in {@link Renderer#visibleRows}.
- * @property {number} rowIndex - Local vertical row coordinate within the subgrid to which the row belongs, adjusted for scrolling.
- * @property {DataModel} subgrid - A reference to the subgrid to which the row belongs.
- * @property {number} top - Pixel coordinate of the top edge of this row, rounded to nearest integer.
- * @property {number} bottom - Pixel coordinate of the bottom edge of this row, rounded to nearest integer.
- * @property {number} height - Height of this row in pixels, rounded to nearest integer.
- */
-
-/**
- * @constructor
- * @desc fin-hypergrid-renderer is the canvas enabled top level sub component that handles the renderering of the Grid.
- *
- * It relies on two other external subprojects
- *
- * 1. fin-canvas: a wrapper to provide a simpler interface to the HTML5 canvas component
- * 2. rectangular: a small npm module providing Point and Rectangle objects
- *
- * The fin-hypergrid-renderer is in a unique position to provide critical functionality to the fin-hypergrid in a hightly performant manner.
- * Because it MUST iterate over all the visible cells it can store various bits of information that can be encapsulated as a service for consumption by the fin-hypergrid component.
- *
- * Instances of this object have basically four main functions.
- *
- * 1. render fixed row headers
- * 2. render fixed col headers
- * 3. render main data cells
- * 4. render grid lines
- *
- * Same parameters as {@link Renderer#initialize|initialize}, which is called by this constructor.
- *
- */
-var Renderer = Base.extend('Renderer', {
-
-    //the shared single item "pooled" cell object for drawing each cell
-    cell: {
-        x: 0,
-        y: 0,
-        width: 0,
-        height: 0
-    },
-
-    scrollHeight: 0,
-
-    viewHeight: 0,
-
-    reset: function() {
-        this.bounds = {
-            width: 0,
-            height: 0
-        };
-        this.renderedColumnMinWidths = [];
-
-        /**
-         * Represents the ordered set of visible columns. Array size is always the exact number of visible columns, the last of which may only be partially visible.
-         *
-         * This sequence of elements' `columnIndex` values assumes one of three patterns. Which pattern is base on the following two questions:
-         * * Are there "fixed" columns on the left?
-         * * Is the grid horizontally scrolled?
-         *
-         * The set of `columnIndex` values consists of:
-         * 1. The first element will be -1 if the row handle column is being rendered.
-         * 2. A zero-based list of consecutive of integers representing the fixed columns (if any).
-         * 3. An n-based list of consecutive of integers representing the scrollable columns (where n = number of fixed columns + the number of columns scrolled off to the left).
-         * @type {visibleColumnDescriptor}
-         */
-        this.visibleColumns = [];
-
-        /**
-         * Represents the ordered set of visible rows. Array size is always the exact number of visible rows.
-         *
-         * The sequence of elements' `rowIndex` values is local to each subgrid.
-         * * **For each non-scrollable subgrid:** The sequence is a zero-based list of consecutive integers.
-         * * **For the scrollable subgrid:**
-         *   1. A zero-based list of consecutive of integers representing the fixed rows (if any).
-         *   2. An n-based list of consecutive of integers representing the scrollable rows (where n = number of fixed rows + the number of rows scrolled off the top).
-         *
-         * Note that non-scrollable subgrids can come both before _and_ after the scrollable subgrid.
-         * @type {visibleRowDescriptor}
-         */
-        this.visibleRows = [];
-
-        this.insertionBounds = [];
-    },
-
-    /**
-     * @summary Constructor logic
-     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
-     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
-     * @memberOf Renderer.prototype
-     */
-    initialize: function(grid) {
-        this.grid = grid;
-        this.reset();
-    },
-
-    /**
-     * This function creates several data structures:
-     * * {@link Renderer#visibleColumns}
-     * Original comment:
-     * "this function computes the grid coordinates used for extremely fast iteration over
-     * painting the grid cells. this function is very fast, for thousand rows X 100 columns
-     * on a modest machine taking usually 0ms and no more that 3 ms."
-     */
-    computeCellsBounds: function() {
-
-        //var startTime = Date.now();
-
-        var scrollTop = this.getScrollTop(),
-            scrollLeft = this.getScrollLeft(),
-
-            fixedColumnCount = this.getFixedColumnCount(),
-            fixedRowCount = this.getFixedRowCount(),
-
-            numRows = this.getRowCount(),
-            bounds = this.getBounds(),
-            grid = this.grid,
-            behavior = grid.behavior,
-            editorCellEvent = grid.cellEditor && grid.cellEditor.event,
-            dx = editorCellEvent && editorCellEvent.gridCell.x,
-            dy = editorCellEvent && editorCellEvent.dataCell.y,
-            vcEd,
-            vrEd,
-
-            insertionBoundsCursor = 0,
-            previousInsertionBoundsCursorValue = 0,
-
-            lineWidth = grid.properties.lineWidth,
-
-            start = this.grid.isShowRowNumbers() ? -1 : 0,
-            x, X, // horizontal pixel loop index and limit
-            y, Y, // vertical pixel loop index and limit
-            c, C, // column loop index and limit
-            g, G, // subgrid loop index and limit
-            r, R, // row loop index and limitrows in current subgrid
-            subrows, // rows in subgrid g
-            base, // sum of rows for all subgrids so far
-            subgrids = behavior.subgrids,
-            subgrid,
-            rowIndex,
-            scrollableSubgrid,
-            footerHeight,
-            vx, vy,
-            vr, vc,
-            width, height,
-            firstVX, lastVX,
-            firstVY, lastVY,
-            topR,
-            xSpaced, widthSpaced, heightSpaced; // adjusted for cell spacing
-
-        this.scrollHeight = 0;
-
-        this.visibleColumns.length = 0;
-        this.visibleRows.length = 0;
-
-        this.visibleColumnsByIndex = []; // array because number of columns will always be reasonable
-        this.visibleRowsByDataRowIndex = {}; // hash because keyed by (fixed and) scrolled row indexes
-
-        this.insertionBounds = [];
-
-        for (
-            x = 0, c = start, C = this.getColumnCount(), X = bounds.width || grid.canvas.width;
-            c < C && x <= X;
-            c++
-        ) {
-            vx = c;
-            if (c >= fixedColumnCount) {
-                lastVX = vx += scrollLeft;
-                if (firstVX === undefined) {
-                    firstVX = lastVX;
-                }
-            }
-            if (vx >= C) {
-                break; // scrolled beyond last column
-            }
-
-            width = grid.getColumnWidth(vx);
-
-            xSpaced = x ? x + lineWidth : x;
-            widthSpaced = x ? width - lineWidth : width;
-            this.visibleColumns[c] = this.visibleColumnsByIndex[vx] = vc = {
-                index: c,
-                columnIndex: vx,
-                left: xSpaced,
-                width: widthSpaced,
-                right: xSpaced + widthSpaced
-            };
-            if (dx === vx) {
-                vcEd = vc;
-            }
-
-            x += width;
-
-            insertionBoundsCursor += Math.round(width / 2) + previousInsertionBoundsCursorValue;
-            this.insertionBounds.push(insertionBoundsCursor);
-            previousInsertionBoundsCursorValue = Math.round(width / 2);
-        }
-
-        footerHeight = grid.properties.defaultRowHeight * subgrids.reduce(function(rows, subgrid) {
-            if (scrollableSubgrid) {
-                rows += subgrid.getRowCount();
-            } else {
-                scrollableSubgrid = !subgrid.type;
-            }
-            return rows;
-        }, 0);
-
-        for (
-            base = r = g = y = 0, G = subgrids.length, Y = bounds.height - footerHeight;
-            g < G;
-            g++, base += subrows
-        ) {
-            subgrid = subgrids[g];
-            subrows = subgrid.getRowCount();
-            scrollableSubgrid = !subgrid.type;
-            topR = r;
-
-            // For each row of each subgrid...
-            for (R = Math.min(numRows, r + subrows); r < R && y < Y; r++) {
-                vy = r;
-                if (scrollableSubgrid && r >= fixedRowCount) {
-                    vy += scrollTop;
-                    lastVY = vy - base;
-                    if (firstVY === undefined) {
-                        firstVY = lastVY;
-                    }
-                    if (vy >= R) {
-                        break; // scrolled beyond last row
-                    }
-                }
-
-
-                rowIndex = vy - base;
-                height = behavior.getRowHeight(rowIndex, subgrid);
-
-                heightSpaced = height - lineWidth;
-                this.visibleRows[r] = vr = {
-                    index: r,
-                    subgrid: subgrid,
-                    rowIndex: rowIndex,
-                    top: y,
-                    height: heightSpaced,
-                    bottom: y + heightSpaced
-                };
-                if (scrollableSubgrid) {
-                    this.visibleRowsByDataRowIndex[vy - base] = vr;
-                    if (dy === rowIndex) {
-                        vrEd = vr;
-                    }
-                }
-
-                y += height;
-            }
-
-            if (scrollableSubgrid) {
-                subrows = r - topR;
-                Y += footerHeight;
-            }
-        }
-
-        if (editorCellEvent) {
-            editorCellEvent.visibleColumn = vcEd;
-            editorCellEvent.visibleRow = vrEd;
-            editorCellEvent.gridCell.y = vrEd && vrEd.index;
-            editorCellEvent._bounds = null;
-        }
-
-        this.viewHeight = Y;
-
-        this.dataWindow = this.grid.newRectangle(firstVX, firstVY, lastVX - firstVX, lastVY - firstVY);
-    },
-
-    /**
-     * Keep in place! Used by fin-canvas.
-     * @memberOf Renderer.prototype
-     * @returns {Object} a property value at a key, delegates to the grid
-     */
-    resolveProperty: function(key) {
-        return this.grid.properties[key];
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @summary Notify the fin-hypergrid everytime we've repainted.
-     * @desc This is the entry point from fin-canvas.
-     * @param {CanvasRenderingContext2D} gc
-     */
-    paint: function(gc) {
-        if (this.grid) {
-            if (!this.hasData()) {
-                var message = this.grid.properties.noDataMessage;
-                gc.font = '20px Arial';
-                gc.fillText(message, 20, 30);
-            } else {
-                this.renderGrid(gc);
-                this.grid.gridRenderedNotification();
-            }
-        }
-    },
-
-    hasData: function() {
-        var data = this.grid.behavior.getData();
-        if (data) {
-            return data.length > 0;
-        }
-        return false;
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} Answer how many rows we rendered
-     */
-    getVisibleRowsCount: function() {
-        return this.visibleRows.length - 1;
-    },
-
-    getVisibleScrollHeight: function() {
-        return this.viewHeight - this.grid.getFixedRowsHeight();
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number[]} Rows we just rendered.
-     */
-    getVisibleRows: function() {
-        warn('getVisibleRows', 'The getVisibleRows() method has been deprecated as of v1.2.0 and will be removed in a future version. Previously returned the this.visibleRows array but because this.visibleRows is no longer a simple array of integers but is now an array of objects, it now returns an array mapped to this.visibleRows[*].rowIndex. Note however that this mapping is not equivalent to what this method previously returned because while each object\'s .rowIndex property is still adjusted for scrolling within the data subgrid, the index is now local to (zero-based within) each subgrid');
-        return this.visibleRows.map(function(vr) { return vr.rowIndex; });
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} Number of columns we just rendered.
-     */
-    getVisibleColumnsCount: function() {
-        return this.visibleColumns.length - 1;
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} Columns we just rendered.
-     */
-    getVisibleColumns: function() {
-        warn('visibleColumns', 'The getVisibleColumns() method has been deprecated as of v1.2.0 and will be removed in a future version. Previously returned the this.visibleColumns but because this.visibleColumns is no longer a simple array of integers but is now an array of objects, it now returns an array mapped to the equivalent visibleColumns[*].columnIndex.');
-        return this.visibleColumns.map(function(vc) { return vc.columnIndex; });
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} The column index when the mouseEvent coordinates are over a column divider.
-     */
-    overColumnDivider: function(x) {
-        var vc = this.visibleColumns,
-            xi = Math.round(x),
-            x1 = xi - 3,
-            x2 = xi + 1;
-
-        for (var c = (-1 in vc ? -1 : 0), C = vc.length; c < C; ++c) {
-            x = vc[c].right;
-            if (x1 <= x && x <= x2) {
-                return c + 1;
-            }
-        }
-
-        return -1;
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} The row index when the mouseEvent coordinates are over a row divider.
-     */
-    overRowDivider: function(y) {
-        var vr = this.visibleRows,
-            yi = Math.round(y),
-            y1 = yi - 3,
-            y2 = yi + 1;
-
-        for (var r = 0, R = vr.length; r < R; ++r) {
-            y = vr[r].bottom;
-            if (y1 <= y && y <= y2) {
-                return r + 1;
-            }
-        }
-
-        return -1;
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @param {CellEvent|number} x - CellEvent object or grid column coordinate.
-     * @param {number} [y] - Grid row coordinate. Omit if `xOrCellEvent` is a CellEvent.
-     * @returns {Rectangle} Bounding rect of cell with the given coordinates.
-     */
-    getBoundsOfCell: function(x, y) {
-        var vc = this.visibleColumns[x],
-            vr = this.visibleRows[y];
-
-        return {
-            x: vc.left,
-            y: vr.top,
-            width: vc.width,
-            height: vr.height
-        };
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @desc answer the column index under the coordinate at pixelX
-     * @param {number} pixelX - The horizontal coordinate.
-     * @returns {number} The column index under the coordinate at pixelX.
-     */
-    getColumnFromPixelX: function(pixelX) {
-        var width = 0,
-            fixedColumnCount = this.getFixedColumnCount(),
-            scrollLeft = this.grid.getHScrollValue(),
-            visibleColumns = this.visibleColumns;
-
-        for (var c = 1; c < visibleColumns.length - 1; c++) {
-            width = visibleColumns[c].left - (visibleColumns[c].left - visibleColumns[c - 1].left) / 2;
-            if (pixelX < width) {
-                if (c > fixedColumnCount) {
-                    c += scrollLeft;
-                }
-                return c - 1;
-            }
-        }
-        if (c > fixedColumnCount) {
-            c += scrollLeft;
-        }
-        return c - 1;
-    },
-
-
-    /**
-     * @memberOf Renderer.prototype
-     * @desc Answer specific data cell coordinates given mouse coordinates in pixels.
-     * @param {Point} point
-     * @returns {Point} Cell coordinates
-     */
-    getGridCellFromMousePoint: function(point) {
-        var x = point.x,
-            y = point.y,
-            vrs = this.visibleRows,
-            vcs = this.visibleColumns,
-            firstColumn = vcs[this.grid.isShowRowNumbers() ? -1 : 0],
-            inFirstColumn = x < firstColumn.right,
-            vc = inFirstColumn ? firstColumn : vcs.find(function(vc) { return x < vc.right; }) || vcs[vcs.length - 1],
-            vr = vrs.find(function(vr) { return y < vr.bottom; }) || vrs[vrs.length - 1],
-            mousePoint = this.grid.newPoint(x - vc.left, y - vr.top),
-            cellEvent = new this.grid.behavior.CellEvent(vc.columnIndex, vr.index);
-
-        // cellEvent.visibleColumn = vc;
-        // cellEvent.visibleRow = vr;
-
-        return Object.defineProperty(cellEvent, 'mousePoint', { value: mousePoint });
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @summary Determines if a column is visible.
-     * @param {number} colIndex - the column index*
-     * @returns {boolean} The given column is fully visible.
-     */
-    isColumnVisible: function(columnIndex) {
-        return !!this.visibleColumns.find(function(vc) { return vc.columnIndex === columnIndex; });
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} The width x coordinate of the last rendered column
-     */
-    getFinalVisibleColumnBoundary: function() {
-        var chop = this.isLastColumnVisible() ? 2 : 1;
-        var colWall = this.visibleColumns[this.visibleColumns.length - chop].right;
-        return Math.min(colWall, this.getBounds().width);
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @summary Determines visibility of a row.
-     * @param {number} y - The physical (unscrolled) grid row index.
-     * @returns {boolean} The given row is fully visible.
-     */
-    isRowVisible: function(y) {
-        return !!this.visibleRows[y];
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @summary Determines if a cell is selected.
-     * @param {number} x - the x cell coordinate
-     * @param {number} y - the y cell coordinate*
-     * @returns {boolean} The given cell is fully visible.
-     */
-    isSelected: function(x, y) {
-        return this.grid.isSelected(x, y);
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @desc This is the main forking of the renderering task.
-     * @param {CanvasRenderingContext2D} gc
-     */
-    renderGrid: function(gc) {
-        gc.beginPath();
-
-        this.paintCells(gc);
-        this.renderOverrides(gc);
-        this.renderLastSelection(gc);
-        gc.closePath();
-    },
-
-    renderLastSelection: function(gc) {
-        gc.beginPath();
-        this._renderLastSelection(gc);
-        gc.closePath();
-    },
-
-    _renderLastSelection: function(gc) {
-        var selections = this.grid.selectionModel.getSelections();
-        if (!selections || selections.length === 0) {
-            return;
-        }
-        var selection = this.grid.selectionModel.getLastSelection();
-
-        if (selection.origin.x === -1) {
-            // no selected area, lets exit
-            return;
-        }
-
-        var vci = this.visibleColumnsByIndex,
-            vri = this.visibleRowsByDataRowIndex,
-            lastColumn = this.visibleColumns[this.visibleColumns.length - 1], // last column in scrollable section
-            lastRow = vri[this.dataWindow.corner.y]; // last row in scrollable data section
-
-        if (
-            !lastColumn || !lastRow ||
-            selection.origin.x > lastColumn.columnIndex ||
-            selection.origin.y > lastRow.rowIndex
-        ) {
-            // selection area begins to right or below grid
-            return;
-        }
-
-        var vcOrigin = vci[selection.origin.x],
-            vcCorner = vci[selection.corner.x],
-            vrOrigin = vri[selection.origin.y],
-            vrCorner = vri[selection.corner.y];
-
-        if (
-            !(vcOrigin || vcCorner) || // entire selection scrolled out of view to left of scrollable region
-            !(vrOrigin || vrCorner)    // entire selection scrolled out of view above scrollable region
-        ) {
-            return;
-        }
-
-        var props = this.grid.properties;
-        vcOrigin = vcOrigin || lastColumn;
-        vcCorner = vcCorner || selection.corner.x > lastColumn.columnIndex
-            ? lastColumn.columnIndex
-            : vci[props.fixedColumnCount - 1];
-        vrOrigin = vrOrigin || lastRow;
-        vrCorner = vrCorner || selection.corner.y > lastRow.rowIndex
-            ? lastRow.rowIndex
-            : vri[props.fixedRowCount - 1];
-
-        // Render the selection model around the bounds
-        var config = {
-            bounds: {
-                x: vcOrigin.left,
-                y: vrOrigin.top,
-                width: vcCorner.right - vcOrigin.left,
-                height: vrCorner.bottom - vrOrigin.top
-            },
-            selectionRegionOverlayColor: this.grid.properties.selectionRegionOverlayColor,
-            selectionRegionOutlineColor: this.grid.properties.selectionRegionOutlineColor
-        };
-        this.grid.cellRenderers.get('lastselection').paint(gc, config);
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @desc iterate the renderering overrides and manifest each
-     * @param {CanvasRenderingContext2D} gc
-     */
-    renderOverrides: function(gc) {
-        var cache = this.grid.renderOverridesCache;
-        for (var key in cache) {
-            if (cache.hasOwnProperty(key)) {
-                var override = cache[key];
-                if (override) {
-                    this.renderOverride(gc, override);
-                }
-            }
-        }
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @desc copy each overrides specified area to it's target and blank out the source area
-     * @param {CanvasRenderingContext2D} gc
-     * @param {OverrideObject} override - an object with details contain an area and a target context
-     */
-    renderOverride: function(gc, override) {
-        //lets blank out the drag row
-        var hdpiRatio = override.hdpiratio;
-        var startX = override.startX; //hdpiRatio * edges[override.columnIndex];
-        var width = override.width + 1;
-        var height = override.height;
-        var targetCTX = override.ctx;
-        var imgData = gc.getImageData(startX, 0, Math.round(width * hdpiRatio), Math.round(height * hdpiRatio));
-        targetCTX.putImageData(imgData, 0, 0);
-        gc.fillStyle = this.grid.properties.backgroundColor2;
-        gc.fillRect(Math.round(startX / hdpiRatio), 0, width, height);
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} Current vertical scroll value.
-     */
-    getScrollTop: function() {
-        return this.grid.getVScrollValue();
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} Current horizontal scroll value.
-     */
-    getScrollLeft: function() {
-        return this.grid.getHScrollValue();
-    },
-
-    getColumnEdges: function() {
-        warn('columnEdges', 'The getColumnEdges() mehtod has been deprecated as of version 1.2.0 in favor of visibleColumns[*].top and will be removed in a future version. Note however that columnEdges had one additional element (representing the right edge of the last visible column) which visibleColumns lacks. Instead you can reference visibleColumns[*].bottom.');
-        return this.visibleColumns.map(function(vc) { return vc.left; }).concat([this.visibleColumns[this.visibleColumns.length - 1].right]);
-    },
-
-    getRowEdges: function() {
-        warn('rowEdges', 'The getRowEdges() method has been deprecated as of version 1.2.0 in favor of visibleRows[*].top and will be removed in a future version. Note however that rowEdges had one additional element (representing the bottom edge of the last visible row) which visibleRows lacks. Instead you can reference visibleRows[*].bottom.');
-        return this.visibleRows.map(function(vr) { return vr.top; }).concat([this.visibleRows[this.visibleRows.length - 1].bottom]);
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {boolean} The last col was rendered (is visible)
-     */
-    isLastColumnVisible: function() {
-        var lastColumnIndex = this.getColumnCount() - 1;
-        return !!this.visibleColumns.find(function(vc) { return vc.columnIndex === lastColumnIndex; });
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} The rendered column width at index
-     */
-    getRenderedWidth: function(index) {
-        var result,
-            columns = this.visibleColumns;
-
-        if (index >= columns.length) {
-            result = columns[columns.length - 1].right;
-        } else {
-            result = columns[index].left;
-        }
-
-        return result;
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} The rendered row height at index
-     */
-    getRenderedHeight: function(index) {
-        var result,
-            rows = this.visibleRows;
-
-        if (index >= rows.length) {
-            var last = rows[rows.length - 1];
-            result = last.bottom;
-        } else {
-            result = rows[index].top;
-        }
-
-        return result;
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {fin-canvas} my [fin-canvas](https://github.com/stevewirts/fin-canvas)
-     */
-    getCanvas: function() {
-        return this.grid.getCanvas();
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {boolean} User is currently dragging a column for reordering.
-     */
-    isDraggingColumn: function() {
-        return this.grid.isDraggingColumn();
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} The row to go to for a page up.
-     */
-    getPageUpRow: function() {
-        var grid = this.grid,
-            scrollHeight = this.getVisibleScrollHeight(),
-            top = this.dataWindow.origin.y - this.grid.properties.fixedRowCount - 1,
-            scanHeight = 0;
-        while (scanHeight < scrollHeight && top >= 0) {
-            scanHeight += grid.getRowHeight(top);
-            top--;
-        }
-        return top + 1;
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} The row to goto for a page down.
-     */
-    getPageDownRow: function() {
-        return this.dataWindow.corner.y - this.grid.properties.fixedRowCount + 1;
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} The number of columns.
-     */
-    getColumnCount: function() {
-        return this.grid.getColumnCount();
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} The number of rows.
-     */
-    getRowCount: function() {
-        return this.grid.getRowCount();
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} The number of fixed columns.
-     */
-    getFixedColumnCount: function() {
-        return this.grid.getFixedColumnCount();
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} The number of fixed rows.
-     */
-    getFixedRowCount: function() {
-        return this.grid.getFixedRowCount();
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @returns {number} The number of header rows.
-     */
-    getHeaderRowCount: function() {
-        return this.grid.getHeaderRowCount();
-    },
-
-    /** @summary Smart render the grid.
-     * @desc Paint all the cells of a grid, including all "fixed" columns and rows.
-     * We snapshot the context to insure against its pollution.
-     * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
-     * The error message is error-logged to console AND displayed in cell.
-     *
-     * For performance reasons, we do not create a new `CellEvent` on for each `_paintCell` call.
-     * Rather, we create one for all the calls and maintain the instance variables in the loops
-     * (which is why `CellEvent` uses `WritablePoint` instead of `Point` for `gridCell` and `dataCell`):
-     * * Set in column loop:
-     *   * `cellEvent.column`
-     *   * `cellEvent.gridCell.x`
-     *   * `cellEvent.dataCell.x`
-     *   * `cellEvent.bounds.x`
-     *   * `cellEvent.bounds.width`
-     * * Set in subgrid loop:
-     *   * `cellEvent.subgrid`
-     * * Set in row loop:
-     *   * `cellEvent.gridCell.y`
-     *   * `cellEvent.dataCell.y`
-     *   * `cellEvent.bounds.y`
-     *   * `cellEvent.bounds.height`
-     * @memberOf Renderer.prototype
-     * @param {CanvasRenderingContext2D} gc
-     */
-    paintCells: function(gc) {
-        var message,
-            behavior = this.grid.behavior,
-            c, C, // column loop index and limit
-            r, R, // row loop index and limit
-            cellEvent = new behavior.CellEvent(0, 0),
-            bounds = cellEvent._bounds = { x:0, y:0, width:0, height:0 },
-            gridCell = cellEvent.gridCell,
-            dataCell = cellEvent.dataCell,
-            vc, visibleColumns = this.visibleColumns,
-            vr, visibleRows = this.visibleRows,
-            clipHeight = this.getBounds().height;
-
-        this.buttonCells = {};
-
-        // For each column...
-        for (
-            c = this.grid.isShowRowNumbers() ? -1 : 0, C = visibleColumns.length;
-            c < C;
-            c++
-        ) {
-            cellEvent.visibleColumn = vc = visibleColumns[c];
-            cellEvent.column = behavior.getActiveColumn(vc.columnIndex);
-
-            gridCell.x = vc.columnIndex;
-            dataCell.x = cellEvent.column && cellEvent.column.index;
-
-            bounds.x = vc.left;
-            bounds.width = vc.width;
-
-            this.renderedColumnMinWidths[gridCell.x] = 0;
-
-            gc.save();
-
-            // Clip to visible portion of column to prevent overflow to right. Previously we clipped to entire visible grid and dealt with overflow by overpainting with next column. However, this strategy fails when transparent background (no background color).
-            // TODO: if extra clip() calls per column affect performance (not the clipping itself which was happening anyway, but the clip calls which set up the clipping), use previous strategy when there is a background color
-            gc.beginPath();
-            gc.rect(0, 0, bounds.x + bounds.width, clipHeight);
-            gc.clip();
-
-            // For each row of each subgrid (of each column)...
-            for (
-                r = 0, R = visibleRows.length;
-                r < R;
-                r++
-            ) {
-                cellEvent.visibleRow = vr = visibleRows[r];
-
-                bounds.y = vr.top;
-                bounds.height = vr.height;
-
-                gridCell.y = vr.index;
-                dataCell.y = vr.rowIndex;
-
-                try {
-                    this._paintCell(gc, cellEvent);
-                } catch (e) {
-                    message = e && (e.message || e) || 'Unknown error.';
-
-                    console.error(message);
-
-                    var rawGc = gc.gc || gc, // Don't log these canvas calls
-                        errX = vc.left, errWidth = vc.right,
-                        errY = vr.top, errHeight = vr.bottom,
-                        config = { bounds: { c: errX, y: errY, width: errWidth, height: errHeight } };
-
-                    rawGc.save(); // define clipping region
-                    rawGc.beginPath();
-                    rawGc.rect(errX, errY, errWidth, errHeight);
-                    rawGc.clip();
-
-                    this.grid.cellRenderers.get('errorcell').paint(rawGc, config, message);
-
-                    rawGc.restore(); // discard clipping region
-                }
-            }
-
-            gc.restore(); // Remove column's clip region (and anything else renderCellError() might have set)
-        }
-
-        setNumberColumnWidth(gc, behavior, this.grid.getRowCount());
-    },
-
-    /**
-     * @memberOf Renderer.prototype
-     * @param {CanvasRenderingContext2D} gc
-     * @param x
-     * @param y
-     */
-    paintCell: function(gc, x, y) {
-        gc.moveTo(0, 0);
-
-        var c = this.visibleColumns[x].index, // todo refac
-            r = this.visibleRows[y].index;
-
-        if (c) { //something is being viewed at at the moment (otherwise returns undefined)
-            this._paintCell(gc, c, r);
-        }
-    },
-
-    _paintCell: function(gc, cellEvent) {
-
-        var grid = this.grid,
-            behavior = grid.behavior,
-            x = cellEvent.gridCell.x,
-            // y = cellEvent.gridCell.y,
-            c = cellEvent.dataCell.x,
-            r = cellEvent.dataCell.y,
-
-            isHandleColumn = cellEvent.isHandleColumn,
-            isHierarchyColumn = cellEvent.isHierarchyColumn,
-            isColumnSelected = cellEvent.isColumnSelected,
-
-            isShowRowNumbers = grid.isShowRowNumbers(),
-            isRowHandleOrHierarchyColumn = isShowRowNumbers && isHandleColumn || isHierarchyColumn,
-
-            isGridRow = cellEvent.isGridRow,
-            isRowSelected = cellEvent.isRowSelected,
-            isCellSelected = cellEvent.isCellSelected,
-
-            isHeaderRow = cellEvent.isHeaderRow,
-            isFilterRow = cellEvent.isFilterRow,
-
-            cellProperties = behavior.getCellOwnProperties(cellEvent),
-            baseProperties,
-            nonGridCellProps,
-            config = this.config;
-
-        if (cellProperties && cellProperties.applyCellProperties) {
-            this.c = undefined;
-            config = undefined;
-            baseProperties = cellProperties;
-            nonGridCellProps = !isGridRow;
-        } else if (!config || c !== this.c) {
-            this.c = c;
-            config = undefined;
-        }
-
-        var configType;
-        if (isRowHandleOrHierarchyColumn) {
-            configType = isRowSelected ? 1 : 2;
-        } else if (isGridRow) {
-            configType = 3;
-        } else if (isFilterRow) {
-            configType = 4;
-        } else if (isColumnSelected) {
-            configType = 5;
-        } else { // header or summary or other
-            configType = 6;
-        }
-
-        if (!config || configType !== this.configType) {
-            this.configType = configType;
-            if (!baseProperties) {
-                baseProperties = behavior.getColumnProperties(c);
-                if (!baseProperties) {
-                    this.config = undefined;
-                    return;
-                }
-            }
-            switch (configType) {
-                case 1: config = Object.create(baseProperties.rowHeaderRowSelection); break;
-                case 2: config = Object.create(baseProperties.rowHeader); break;
-                case 3: config = Object.create(baseProperties); break;
-                case 4: config = Object.create(baseProperties.filterProperties); break;
-                case 5: config = Object.create(baseProperties.columnHeaderColumnSelection); break;
-                case 6: config = Object.create(baseProperties.columnHeader); break;
-            }
-            this.config = config;
-            this.baseProperties = baseProperties;
-        }
-
-        // Create `config` (render props) object
-        // * with appropriate prototype
-        // * set `isSelected` (added to `config` below as a read-only property)
-        // * for row handle column, set `config.halign` to `'right'`
-        // * for hierarchy column, set `config.halign` to `'left'`
-        var isSelected;
-        if (isRowHandleOrHierarchyColumn) {
-            isSelected = isRowSelected || grid.isCellSelectedInRow(r);
-            config.halign = isHierarchyColumn ? 'left' : 'right';
-        } else if (isGridRow) {
-            isSelected = isCellSelected || isRowSelected || isColumnSelected;
-        } else if (isFilterRow) {
-            isSelected = false;
-        } else if (isColumnSelected) {
-            isSelected = true;
-        } else { // header or summary or other
-            isSelected = grid.isCellSelectedInColumn(x);
-        }
-
-        // Set cell contents:
-        // * For all cells: set `config.value` (writable property)
-        // * For cells outside of row handle column: also set `config.dataRow` for use by valOrFunc
-        if (!isHandleColumn) {
-            config.dataRow = grid.getRow(r);
-            config.value = cellEvent.value;
-        } else if (isGridRow) {
-            // row handle for a data row
-            config.value = [images.checkbox(isRowSelected), r + 1, null]; // row number is 1-based
-        } else if (isHeaderRow) {
-            // row handle for header row: gets "master" checkbox
-            config.value = [images.checkbox(grid.areAllRowsSelected()), '', null];
-        } else if (isFilterRow) {
-            // row handle for filter row: gets filter icon
-            config.value = [images.filter(false), '', null];
-        } else {
-            // row handles for "summary" or other rows: empty
-            config.value = '';
-        }
-
-        config.isSelected = isSelected;
-        config.isGridColumn = !isRowHandleOrHierarchyColumn;
-        config.isGridRow = isGridRow;
-        config.isHeaderRow = isHeaderRow;
-        config.isFilterRow = isFilterRow;
-        config.isUserDataArea = !isRowHandleOrHierarchyColumn && isGridRow;
-        config.isColumnHovered = cellEvent.isColumnHovered;
-        config.isRowHovered = cellEvent.isRowHovered;
-        config.isCellHovered = cellEvent.isCellHovered;
-        config.bounds = cellEvent.bounds;
-        config.isCellSelected = isCellSelected;
-        config.isRowSelected = isRowSelected;
-        config.isColumnSelected = isColumnSelected;
-        config.isInCurrentSelectionRectangle = grid.isInCurrentSelectionRectangle(x, r);
-
-        if (grid.mouseDownState) {
-            config.mouseDown = grid.mouseDownState.gridCell.equals(cellEvent.gridCell);
-        }
-
-        // This call's dataModel.getCell which developer can override to:
-        // * mutate the (writable) properties of `config`
-        // * mutate cell renderer choice (instance of which is returned)
-        var cellRenderer = behavior.getCellRenderer(config, cellEvent);
-
-        // Overwrite possibly mutated cell properties, if requested to do so by `getCell` override
-        if (config.reapplyCellProperties || nonGridCellProps) {
-            _(config).extendOwn(cellProperties);
-        }
-
-        behavior.cellPropertiesPrePaintNotification(config);
-
-        //allow the renderer to identify itself if it's a button
-        config.buttonCells = this.buttonCells;
-
-        config.formatValue = grid.getFormatter(config.isUserDataArea && config.format);
-
-        cellRenderer.paint(gc, config);
-
-        this.renderedColumnMinWidths[x] = Math.max(config.minWidth || 0, this.renderedColumnMinWidths[x]);
-        this.baseProperties.preferredWidth = this.renderedColumnMinWidths[x];
-    },
-
-    isViewableButton: function(c, r) {
-        var key = c + ',' + r;
-        return this.buttonCells[key] === true;
-    },
-
-    startAnimator: function() {
-        var self = this;
-        requestAnimationFrame(function animate() {
-            self.animate();
-            requestAnimationFrame(animate);
-        });
-    },
-
-    animate: function() {
-        var ctx = this.getCanvas().canvasCTX;
-        ctx.beginPath();
-        ctx.save();
-        this.renderLastSelection(ctx);
-        ctx.restore();
-        ctx.closePath();
-    },
-
-    getBounds: function() {
-        return this.bounds;
-    },
-
-    setBounds: function(bounds) {
-        return (this.bounds = bounds);
-    }
-
-});
-
-function setNumberColumnWidth(gc, behavior, maxRow) {
-    var columnProperties = behavior.getColumnProperties(-1),
-        cellProperties = columnProperties.rowHeader,
-        icon = images.checked;
-
-    gc.font = cellProperties.font;
-
-    columnProperties.preferredWidth = icon.width + 7 + cellProperties.getTextWidth(gc, maxRow + 1);
-}
-
-var warnings = {};
-function warn(name, message) {
-    if (!warnings[name]) {
-        warnings[name] = true;
-        console.warn(message);
-    }
-}
-
-module.exports = Renderer;
diff --git a/src/lib/SelectionModel.js b/src/lib/SelectionModel.js
index 407f4c9..19448db 100644
--- a/src/lib/SelectionModel.js
+++ b/src/lib/SelectionModel.js
@@ -9,63 +9,8 @@ var RangeSelectionModel = require('sparse-boolean-array');
  */
 
 function SelectionModel(grid) {
-
     this.grid = grid;
-
-    /**
-     * @name multipleSelections
-     * @type {boolean}
-     * @summary Can select multiple cell regions.
-     * @memberOf SelectionModel.prototype
-     */
-    this.multipleSelections = grid[grid.behavior ? 'getProperties' : '_getProperties']().multipleSelections;
-
-    /**
-     * @name selections
-     * @type {Rectangle[]}
-     * @summary The selection rectangles.
-     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
-     * @memberOf SelectionModel.prototype
-     */
-    this.selections = [];
-
-    /**
-     * @name flattenedX
-     * @type {Rectangle[]}
-     * @summary The selection rectangles flattened in the horizontal direction (no width).
-     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
-     * @memberOf SelectionModel.prototype
-     */
-    this.flattenedX = [];
-
-    /**
-     * @name flattenedY
-     * @type {Rectangle[]}
-     * @summary The selection rectangles flattened in the vertical direction (no height).
-     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
-     * @memberOf SelectionModel.prototype
-     */
-    this.flattenedY = [];
-
-    /**
-     * @name rowSelectionModel
-     * @type {RangeSelectionModel}
-     * @summary The selection rectangles.
-     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
-     * @memberOf SelectionModel.prototype
-     */
-    this.rowSelectionModel = new RangeSelectionModel();
-
-    /**
-     * @name columnSelectionModel
-     * @type {RangeSelectionModel}
-     * @summary The selection rectangles.
-     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
-     * @memberOf SelectionModel.prototype
-     */
-    this.columnSelectionModel = new RangeSelectionModel();
-
-    this.setLastSelectionType('');
+    this.reset();
 }
 
 SelectionModel.prototype = {
@@ -78,6 +23,55 @@ SelectionModel.prototype = {
      */
     allRowsSelected: false,
 
+    reset: function() {
+        /**
+         * @name selections
+         * @type {Rectangle[]}
+         * @summary The selection rectangles.
+         * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
+         * @memberOf SelectionModel.prototype
+         */
+        this.selections = [];
+
+        /**
+         * @name flattenedX
+         * @type {Rectangle[]}
+         * @summary The selection rectangles flattened in the horizontal direction (no width).
+         * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
+         * @memberOf SelectionModel.prototype
+         */
+        this.flattenedX = [];
+
+        /**
+         * @name flattenedY
+         * @type {Rectangle[]}
+         * @summary The selection rectangles flattened in the vertical direction (no height).
+         * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
+         * @memberOf SelectionModel.prototype
+         */
+        this.flattenedY = [];
+
+        /**
+         * @name rowSelectionModel
+         * @type {RangeSelectionModel}
+         * @summary The selection rectangles.
+         * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
+         * @memberOf SelectionModel.prototype
+         */
+        this.rowSelectionModel = new RangeSelectionModel();
+
+        /**
+         * @name columnSelectionModel
+         * @type {RangeSelectionModel}
+         * @summary The selection rectangles.
+         * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
+         * @memberOf SelectionModel.prototype
+         */
+        this.columnSelectionModel = new RangeSelectionModel();
+
+        this.setLastSelectionType('');
+    },
+
     /**
      * @memberOf SelectionModel.prototype
      * @returns {*}
@@ -127,7 +121,7 @@ SelectionModel.prototype = {
             ? newSelection.corner
             : newSelection.origin;
 
-        if (this.multipleSelections) {
+        if (this.grid.properties.multipleSelections) {
             this.selections.push(newSelection);
             this.flattenedX.push(newSelection.flattenXAt(0));
             this.flattenedY.push(newSelection.flattenYAt(0));
@@ -176,9 +170,8 @@ SelectionModel.prototype = {
      * @memberOf SelectionModel.prototype
      * @desc Remove the last selection that was created.
      */
-    clearMostRecentSelection: function(dontClearRowSelections) {
-        dontClearRowSelections = dontClearRowSelections === true;
-        if (!dontClearRowSelections) {
+    clearMostRecentSelection: function(keepRowSelections) {
+        if (!keepRowSelections) {
             this.setAllRowsSelected(false);
         }
         if (this.selections.length) { --this.selections.length; }
@@ -307,13 +300,12 @@ SelectionModel.prototype = {
      * @desc empty out all our state
      *
      */
-    clear: function(dontClearRowSelections) {
-        dontClearRowSelections = dontClearRowSelections === true;
+    clear: function(keepRowSelections) {
         this.selections.length = 0;
         this.flattenedX.length = 0;
         this.flattenedY.length = 0;
         this.columnSelectionModel.clear();
-        if (!dontClearRowSelections) {
+        if (!keepRowSelections) {
             this.setAllRowsSelected(false);
             this.rowSelectionModel.clear();
         }
@@ -483,13 +475,12 @@ SelectionModel.prototype = {
      * @memberOf SelectionModel.prototype
      * @param offset
      */
-    selectRowsFromCells: function(offset, dontClearRowSelections) {
+    selectRowsFromCells: function(offset, keepRowSelections) {
         offset = offset || 0;
-        dontClearRowSelections = dontClearRowSelections === true;
 
         var sm = this.rowSelectionModel;
 
-        if (!dontClearRowSelections) {
+        if (!keepRowSelections) {
             this.setAllRowsSelected(false);
             sm.clear();
         }
diff --git a/src/lib/WritablePoint.js b/src/lib/WritablePoint.js
new file mode 100644
index 0000000..fa08f17
--- /dev/null
+++ b/src/lib/WritablePoint.js
@@ -0,0 +1,16 @@
+'use strict';
+
+var Point = require('rectangular').Point;
+
+/**
+ * Variation of `rectangular.Point` but with writable `x` and `y`
+ * @constructor
+ */
+function WritablePoint(x, y) {
+    // skip x and y initialization here for performance
+    // because typically reset after instantiation
+}
+
+WritablePoint.prototype = Point.prototype;
+
+module.exports = WritablePoint;
diff --git a/src/lib/buildTheme.js b/src/lib/buildTheme.js
new file mode 100644
index 0000000..dc5750b
--- /dev/null
+++ b/src/lib/buildTheme.js
@@ -0,0 +1,76 @@
+/* eslint-env browser */
+
+'use strict';
+
+function buildTheme(theme) {
+    clearObjectProperties(theme);
+    var pb = document.createElement('paper-button'); // styles were based on old polymer theme
+
+    pb.style.display = 'none';
+    pb.setAttribute('disabled', true);
+    document.body.appendChild(pb);
+    var p = window.getComputedStyle(pb);
+
+    var section = document.createElement('section');
+    section.style.display = 'none';
+    section.setAttribute('hero', true);
+    document.body.appendChild(section);
+
+    var h = window.getComputedStyle(document.querySelector('html'));
+    var hb = window.getComputedStyle(document.querySelector('html, body'));
+    var s = window.getComputedStyle(section);
+
+    theme.columnHeaderBackgroundColor = p.color;
+    theme.rowHeaderBackgroundColor = p.color;
+    theme.topLeftBackgroundColor = p.color;
+    theme.lineColor = p.backgroundColor;
+
+    theme.backgroundColor2 = hb.backgroundColor;
+
+    theme.color = h.color;
+    theme.fontFamily = h.fontFamily;
+    theme.backgroundColor = s.backgroundColor;
+
+    pb.setAttribute('disabled', false);
+    pb.setAttribute('secondary', true);
+    pb.setAttribute('raised', true);
+    p = window.getComputedStyle(pb);
+
+    theme.columnHeaderColor = p.color;
+    theme.rowHeaderColor = p.color;
+    theme.topLeftColor = p.color;
+
+
+    theme.backgroundSelectionColor = p.backgroundColor;
+    theme.foregroundSelectionColor = p.color;
+
+    pb.setAttribute('secondary', false);
+    pb.setAttribute('warning', true);
+
+    theme.columnHeaderForegroundSelectionColor = p.color;
+    theme.columnHeaderBackgroundSelectionColor = p.backgroundColor;
+    theme.rowHeaderForegroundSelectionColor = p.color;
+    theme.fixedColumnBackgroundSelectionColor = p.backgroundColor;
+
+    //check if there is actually a theme loaded if not, clear out all bogus values
+    //from my cache
+    if (theme.columnHeaderBackgroundSelectionColor === 'rgba(0, 0, 0, 0)' ||
+        theme.lineColor === 'transparent') {
+        clearObjectProperties(theme);
+    }
+
+    document.body.removeChild(pb);
+    document.body.removeChild(section);
+
+    return theme;
+}
+
+function clearObjectProperties(obj) {
+    for (var prop in obj) {
+        if (obj.hasOwnProperty(prop)) {
+            delete obj[prop];
+        }
+    }
+}
+
+module.exports = buildTheme;
diff --git a/src/lib/cellEventFactory.js b/src/lib/cellEventFactory.js
index 012620d..d989b81 100644
--- a/src/lib/cellEventFactory.js
+++ b/src/lib/cellEventFactory.js
@@ -1,41 +1,183 @@
 'use strict';
 
-var rectangular = require('rectangular');
+var deprecated = require('./deprecated');
+var WritablePoint = require('./WritablePoint');
 
-// Variation of rectangular.Point but with writable x and y:
-function WritablePoint(x, y) {
-    this.x = x;
-    this.y = y;
-}
-
-WritablePoint.prototype = rectangular.Point.prototype;
+var writableDescriptor = { writable: true };
+var eumerableDescriptor = { writable: true, enumerable: true };
 
 // The nullSubgrid is for CellEvents representing clicks below last row.
 // var nullSubgrid = {};
 
-var prototype = Object.defineProperties({}, {
+factory.prototypeDescriptors = Object.defineProperties({}, {
     value: {
         get: function() { return this.visibleRow.subgrid.getValue(this.dataCell.x, this.dataCell.y); },
         set: function(value) { this.visibleRow.subgrid.setValue(this.dataCell.x, this.dataCell.y, value); }
     },
 
+    dataRow: {
+        get: function() { return this.visibleRow.subgrid.getRow(this.dataCell.y); }
+    },
+
     formattedValue: {
-        get: function() { return this.grid.formatValue(this.getCellProperty('format'), this.value); }
+        get: function() { return this.grid.formatValue(this.properties.format, this.value); }
     },
 
-    bounds: {
-        get: function() {
-            return this._bounds || (this._bounds = {
-                x: this.visibleColumn.left,
-                y: this.visibleRow.top,
-                width: this.visibleColumn.width,
-                height: this.visibleRow.height
-            });
+    bounds: { get: function() {
+        return this._bounds || (this._bounds = {
+            x: this.visibleColumn.left,
+            y: this.visibleRow.top,
+            width: this.visibleColumn.width,
+            height: this.visibleRow.height
+        });
+    } },
+
+    columnProperties: { get: function() {
+        var cp = this._columnProperties;
+        if (!cp) {
+            cp = this.column.properties;
+            if (this.isHandleColumn){
+                cp = cp.rowHeader;
+            } else if (this.isHierarchyColumn) {
+                cp = cp.treeHeader;
+            } else if (this.isDataRow) {
+                // cp already set to basic props
+            } else if (this.isFilterRow) {
+                cp = cp.filterProperties;
+            } else { // unselected header, summary, etc., all have save look as unselected header
+                cp = cp.columnHeader;
+            }
+            this._columnProperties = cp;
         }
-    },
+        return cp;
+    } },
+    cellOwnProperties: { get: function() { // do not use for get/set prop because may return null; instead use  .getCellProperty('prop') or .properties.prop (preferred) to get and setCellProperty('prop', value) to set
+        if (this._cellOwnProperties === undefined) {
+            this._cellOwnProperties = this.column.getCellOwnProperties(this.dataCell.y, this.visibleRow.subgrid);
+        }
+        return this._cellOwnProperties; // null return means there is no cell properties object
+    } },
+    properties: { get: function() {
+        return this.cellOwnProperties || this.columnProperties;
+    } },
+    getCellProperty: { value: function(key) { // included for completeness but .properties[key] is preferred
+        return this.properties[key];
+    } },
+    setCellProperty: { value: function(key, value) { // do not use .cellOwnProperties[key] = value because object may be null (this method creates object as needed)
+        this._cellOwnProperties = this.column.setCellProperty(this.dataCell.y, key, value, this.visibleRow.subgrid);
+    } },
+
+    // special methods for use by renderer which reuses cellEvent object for performance reasons
+    reset: { value: function(visibleColumn, visibleRow) {
+        // getter caches
+        this._columnProperties = undefined;
+        this._cellOwnProperties = undefined;
+        this._bounds = undefined;
+
+        // partial render support
+        this.snapshot = undefined;
+        this.minWidth = undefined;
+        this.disabled = undefined;
+
+        this.visibleColumn = visibleColumn;
+        this.visibleRow = visibleRow;
+
+        this.subgrid = visibleRow.subgrid;
+
+        this.column = visibleColumn.column; // enumerable so will be copied to cell renderer object
+
+        this.gridCell.x = visibleColumn.columnIndex;
+        this.gridCell.y = visibleRow.index;
+
+        this.dataCell.x = this.column && this.column.index;
+        this.dataCell.y = visibleRow.rowIndex;
+    } },
+
+    /**
+     * Set up this `CellEvent` instance to point to the cell at the given grid coordinates.
+     * @desc If the requested cell is not be visible (due to being scrolled out of view or outside the bounds of the rendered grid), the instance is not reset.
+     * @param {number} gridC - Horizontal grid cell coordinate adjusted for horizontal scrolling after fixed columns.
+     * @param {number} gridY - Raw vertical grid cell coordinate.
+     * @returns {boolean} Visibility.
+     * @memberOf CellEvent#
+     */
+    resetGridCY: { value: function(gridC, gridY) {
+        var vr, vc, visible = (vc = this.renderer.getVisibleColumn(gridC)) && (vr = this.renderer.getVisibleRow(gridY));
+        if (visible) { this.reset(vc, vr); }
+        return visible;
+    } },
+
+    /**
+     * Set up this `CellEvent` instance to point to the cell at the given grid coordinates.
+     * @desc If the requested cell is not be visible (due to being scrolled out of view or outside the bounds of the rendered grid), the instance is not reset.
+     * @param {number} gridX - Raw horizontal grid cell coordinate.
+     * @param {number} gridY - Raw vertical grid cell coordinate.
+     * @returns {boolean} Visibility.
+     * @memberOf CellEvent#
+     */
+    resetGridXY: { value: function(gridX, gridY) {
+        var vr, vc, visible = (vc = this.renderer.visibleColumns[gridX]) && (vr = this.renderer.getVisibleRow(gridY));
+        if (visible) { this.reset(vc, vr); }
+        return visible;
+    } },
+
+    /**
+     * @summary Set up this `CellEvent` instance to point to the cell at the given data coordinates.
+     * @desc If the requested cell is not be visible (due to being scrolled out of view), the instance is not reset.
+     * @param {number} dataX - Horizontal data cell coordinate.
+     * @param {number} dataY - Vertical data cell coordinate.
+     * @param {dataModelAPI} [subgrid=this.behavior.subgrids.data]
+     * @returns {boolean} Visibility.
+     * @memberOf CellEvent#
+     */
+    resetDataXY: { value: function(dataX, dataY, subgrid) {
+        var vr, vc, visible = (vc = this.renderer.getVisibleDataColumn(dataX)) && (vr = this.renderer.getVisibleDataRow(dataY, subgrid));
+        if (visible) { this.reset(vc, vr); }
+        return visible;
+    } },
+
+    /**
+     * Set up this `CellEvent` instance to point to the cell at the given grid column and data row coordinates.
+     * @desc If the requested cell is not be visible (due to being scrolled out of view or outside the bounds of the rendered grid), the instance is not reset.
+     * @param {number} gridX - Horizontal grid cell coordinate (adjusted for horizontal scrolling after fixed columns).
+     * @param {number} dataY - Vertical data cell coordinate.
+     * @param {dataModelAPI} [subgrid=this.behavior.subgrids.data]
+     * @returns {boolean} Visibility.
+     * @memberOf CellEvent#
+     */
+    resetGridXDataY: { value: function(gridX, dataY, subgrid) {
+        var vr, vc, visible = (vc = this.renderer.getVisibleColumn(gridX)) && (vr = this.renderer.getVisibleDataRow(dataY, subgrid));
+        if (visible) { this.reset(vc, vr); }
+        return visible && this;
+    } },
+
+    /**
+     * Copy self with or without own properties
+     * @param {boolan} [assign=false] - Copy the own properties to the clone.
+     * @returns {CellEvent}
+     * @memberOf CellEvent#
+     */
+    clone: { value: function(assign) {
+        var cellEvent = new this.constructor;
+
+        cellEvent.resetGridXY(this.visibleColumn.index, this.visibleRow.index);
+
+        if (assign) {
+            // copy own props
+            Object.assign(cellEvent, this);
+        }
+
+        return cellEvent;
+    } },
 
-    getCellProperty: {
-        value: function(propName) { return this.column.getCellProperty(this.dataCell.y, propName, this.visibleRow.subgrid); }
+    editPoint: {
+        get: function() {
+            throw 'The `.editPoint` property is no longer available as of v1.2.10. Use the following coordinates instead:\n' +
+            '`.gridCell.x` - The active column index. (Adjusted for column scrolling after fixed columns.)\n' +
+            '`.gridCell.y` - The vertical grid coordinate. (Unaffected by row scrolling.)\n' +
+            '`.dataCell.x` - The data model\'s column index. (Unaffected by column scrolling.)\n' +
+            '`.dataCell.y` - The data model\'s row index. (Adjusted for data row scrolling after fixed rows.)\n';
+        }
     },
 
     // "Visible" means scrolled into view.
@@ -43,46 +185,62 @@ var prototype = Object.defineProperties({}, {
     isColumnVisible: { get: function() { return !!this.visibleColumn; } },
     isCellVisible:   { get: function() { return this.isRowVisible && this.isColumnVisible; } },
 
-    isGridRow:    { get: function() { return !this.visibleRow.subgrid.type; } },
-    isGridColumn: { get: function() { return this.gridCell.x >= 0; } },
-    isGridCell:   { get: function() { return this.isGridRow && this.isGridColumn; } },
+    isDataRow:    { get: function() { return this.visibleRow.subgrid.isData; } },
+    isDataColumn: { get: function() { return this.gridCell.x >= 0; } },
+    isDataCell:   { get: function() { return this.isDataRow && this.isDataColumn; } },
 
-    isRowSelected:    { get: function() { return this.isGridRow && this.selectionModel.isRowSelected(this.dataCell.y); } },
-    isColumnSelected: { get: function() { return this.isGridColumn && this.selectionModel.isColumnSelected(this.gridCell.x); } },
+    isRowSelected:    { get: function() { return this.isDataRow && this.selectionModel.isRowSelected(this.dataCell.y); } },
+    isColumnSelected: { get: function() { return this.isDataColumn && this.selectionModel.isColumnSelected(this.gridCell.x); } },
     isCellSelected:   { get: function() { return this.selectionModel.isCellSelected(this.gridCell.x, this.dataCell.y); } },
 
-    isRowHovered:    { get: function() { return this.isGridRow && this.grid.hoverCell && this.grid.hoverCell.y === this.gridCell.y; } },
-    isColumnHovered: { get: function() { return this.isGridColumn && this.grid.hoverCell && this.grid.hoverCell.x === this.gridCell.x; } },
+    isRowHovered:    { get: function() { return this.grid.canvas.hasMouse && this.isDataRow && this.grid.hoverCell && this.grid.hoverCell.y === this.gridCell.y; } },
+    isColumnHovered: { get: function() { return this.grid.canvas.hasMouse && this.isDataColumn && this.grid.hoverCell && this.grid.hoverCell.x === this.gridCell.x; } },
     isCellHovered:   { get: function() { return this.isRowHovered && this.isColumnHovered; } },
 
-    isRowFixed:    { get: function() { return this.isGridRow && this.dataCell.y < this.grid.properties.fixedRowCount; } },
-    isColumnFixed: { get: function() { return this.isGridColumn && this.gridCell.x < this.grid.properties.fixedColumnCount; } },
+    isRowFixed:    { get: function() { return this.isDataRow && this.dataCell.y < this.grid.properties.fixedRowCount; } },
+    isColumnFixed: { get: function() { return this.isDataColumn && this.gridCell.x < this.grid.properties.fixedColumnCount; } },
     isCellFixed:   { get: function() { return this.isRowFixed && this.isColumnFixed; } },
 
-    isHandleColumn: { get: function() { return !this.isGridColumn; } },
-    isHandleCell:   { get: function() { return this.isHandleColumn && this.isGridRow; } },
+    isHandleColumn: { get: function() { return !this.isDataColumn; } },
+    isHandleCell:   { get: function() { return this.isHandleColumn && this.isDataRow; } },
 
     isHierarchyColumn: { get: function() { return this.gridCell.x === 0 && this.grid.properties.showTreeColumn && this.dataModel.isDrillDown(this.dataCell.x); } },
 
-    isHeaderRow:    { get: function() { return this.visibleRow.subgrid.type === 'header'; } },
+    isHeaderRow:    { get: function() { return this.visibleRow.subgrid.isHeader; } },
     isHeaderHandle: { get: function() { return this.isHeaderRow && this.isHandleColumn; } },
-    isHeaderCell:   { get: function() { return this.isHeaderRow && this.isGridColumn; } },
+    isHeaderCell:   { get: function() { return this.isHeaderRow && this.isDataColumn; } },
 
-    isFilterRow:    { get: function() { return this.visibleRow.subgrid.type === 'filter'; } },
+    isFilterRow:    { get: function() { return this.visibleRow.subgrid.isFilter; } },
     isFilterHandle: { get: function() { return this.isFilterRow && this.isHandleColumn; } },
-    isFilterCell:   { get: function() { return this.isFilterRow && this.isGridColumn; } },
+    isFilterCell:   { get: function() { return this.isFilterRow && this.isDataColumn; } },
 
-    isSummaryRow:    { get: function() { return this.visibleRow.subgrid.type === 'summary'; } },
+    isSummaryRow:    { get: function() { return this.visibleRow.subgrid.isSummary; } },
     isSummaryHandle: { get: function() { return this.isSummaryRow && this.isHandleColumn; } },
-    isSummaryCell:   { get: function() { return this.isSummaryRow && this.isGridColumn; } },
+    isSummaryCell:   { get: function() { return this.isSummaryRow && this.isDataColumn; } },
 
-    isTopTotalsRow:    { get: function() { return this.visibleRow.subgrid === this.behavior.subgrids.topTotals; } },
+    isTopTotalsRow:    { get: function() { return this.visibleRow.subgrid === this.behavior.subgrids.lookup.topTotals; } },
     isTopTotalsHandle: { get: function() { return this.isTopTotalsRow && this.isHandleColumn; } },
-    isTopTotalsCell:   { get: function() { return this.isTopTotalsRow && this.isGridColumn; } },
+    isTopTotalsCell:   { get: function() { return this.isTopTotalsRow && this.isDataColumn; } },
 
-    isBottomTotalsRow:    { get: function() { return this.visibleRow.subgrid === this.behavior.subgrids.bottomTotals; } },
+    isBottomTotalsRow:    { get: function() { return this.visibleRow.subgrid === this.behavior.subgrids.lookup.bottomTotals; } },
     isBottomTotalsHandle: { get: function() { return this.isBottomTotalsRow && this.isHandleColumn; } },
-    isBottomTotalsCell:   { get: function() { return this.isBottomTotalsRow && this.isGridColumn; } }
+    isBottomTotalsCell:   { get: function() { return this.isBottomTotalsRow && this.isDataColumn; } },
+
+    $$CLASS_NAME: { value: 'CellEvent' },
+    deprecated: { value: deprecated },
+
+    isGridRow: { get: function() {
+        this.deprecated('isGridRow', '.isGridRow is deprecated as of v1.2.10 in favor of .isDataRow. (Will be removed in a future release.)');
+        return this.isDataRow;
+    } },
+    isGridColumn: { get: function() {
+        this.deprecated('isGridColumn', '.isGridColumn is deprecated as of v1.2.10 in favor of .isDataColumn. (Will be removed in a future release.)');
+        return this.isDataColumn;
+    } },
+    isGridCell: { get: function() {
+        this.deprecated('isGridCell', '.isGridCell is deprecated as of v1.2.10 in favor of .isDataCell. (Will be removed in a future release.)');
+        return this.isDataCell;
+    } },
 });
 
 /**
@@ -103,7 +261,7 @@ var prototype = Object.defineProperties({}, {
  *
  * @returns {CellEvent}
  */
-function CellEvent(grid) {
+function factory(grid) {
 
     /**
      * @summary Create a new CellEvent object.
@@ -111,25 +269,15 @@ function CellEvent(grid) {
      * * Includes `this.column` defined by constructor (as enumerable).
      * * Excludes `this.gridCell`, `this.dataCell`, `this.visibleRow.subgrid` defined by constructor (as non-enumerable).
      * * Any additional (enumerable) members mixed in by application's `getCellEditorAt` override.
-     * @param {number} x - grid cell coordinate (adjusted for horizontal scrolling after fixed columns)
-     * @param {number} y - grid cell coordinate, adjusted (adjusted for vertical scrolling if data subgrid)
+     *
+     * Omit params to defer the convenience call to {CellEvent#resetGridCY}.
+     * (See also the alternative {@link CellEvent#resetGridXY}; and {@link CellEvent#resetDataXY} which accepts `dataX`, `dataY`.)
+     *
+     * @param {number} [gridX] - grid cell coordinate (adjusted for horizontal scrolling after fixed columns).
+     * @param {number} [gridY] - grid cell coordinate, adjusted (adjusted for vertical scrolling if data subgrid)
      * @constructor
      */
-    function CellEvent(x, y) {
-        var visibleRow = grid.renderer.visibleRows[y];
-
-        /**
-         * @summary Reference to column's {@link Column} object.
-         * @desc Notes:
-         * * Defined as enumerable so that `CellEditor` constructor mixes into itself.
-         * * Defined as writable so it can be overwritten in `renderer.paintCells`.
-         * @name column
-         * @type {Column}
-         * @memberOf CellEvent#
-         */
-        this.column = grid.behavior.getActiveColumn(x);
-
-
+    function CellEvent(gridX, gridY) {
         // remaining instance vars are non-enumerable so `CellEditor` constructor won't mix them in (for mustache use).
         Object.defineProperties(this, {
             /**
@@ -137,20 +285,21 @@ function CellEvent(grid) {
              * @type {visibleColumnDescriptor}
              * @memberOf CellEvent#
              */
-            visibleColumn: {
-                writable: true, // Allow to be overwritten in `renderer.paintCells` and `.computeCellsBounds`.
-                value: this.grid.renderer.visibleColumns.find(function(vc) { return vc.columnIndex === x; })
-            },
+            visibleColumn: writableDescriptor,
 
             /**
              * @name visibleRow
              * @type {visibleRowDescriptor}
              * @memberOf CellEvent#
              */
-            visibleRow: {
-                writable: true, // Allow to be overwritten in `renderer.paintCells` and `.computeCellsBounds`.
-                value: visibleRow
-            },
+            visibleRow: writableDescriptor,
+
+            /**
+             * @name subgrid
+             * @type {dataModelAPI}
+             * @memberOf CellEvent#
+             */
+            subgrid: writableDescriptor,
 
             /**
              * @name gridCell
@@ -158,7 +307,7 @@ function CellEvent(grid) {
              * @memberOf CellEvent#
              */
             gridCell: {
-                value: new WritablePoint(x, y)
+                value: new WritablePoint
             },
 
             /**
@@ -167,12 +316,29 @@ function CellEvent(grid) {
              * @memberOf CellEvent#
              */
             dataCell: {
-                value: new WritablePoint(this.column && this.column.index, visibleRow.rowIndex)
-            }
+                value: new WritablePoint
+            },
+
+            // column is enumerable so it will be copied to cell event on CellEvent.prototype.initialize.
+            column: eumerableDescriptor,
+
+            // getter caches
+            _columnProperties: writableDescriptor,
+            _cellOwnProperties: writableDescriptor,
+            _bounds: writableDescriptor,
+
+            // Following supports cell renderers' "partial render" capability:
+            snapshot: writableDescriptor,
+            minWidth: writableDescriptor,
+            disabled: writableDescriptor
         });
+
+        if (arguments.length) {
+            this.resetGridCY(gridX, gridY);
+        }
     }
 
-    CellEvent.prototype = Object.create(prototype);
+    CellEvent.prototype = Object.create(factory.prototypeDescriptors);
 
     Object.defineProperties(CellEvent.prototype, {
         constructor: { value: CellEvent },
@@ -186,4 +352,4 @@ function CellEvent(grid) {
     return CellEvent;
 }
 
-module.exports = CellEvent;
+module.exports = factory;
diff --git a/src/lib/deprecated.js b/src/lib/deprecated.js
index bf0257d..fe464f8 100644
--- a/src/lib/deprecated.js
+++ b/src/lib/deprecated.js
@@ -8,24 +8,18 @@ if (!console.warn) {
     };
 }
 
-var warned = {};
-
-var regexIsMethod = /\)$/;
+var regexIsMethod = /^\w+\(.*\)$/;
 
 /**
  * User is warned and new property is returned or new method is called and the result is returned.
- * @param {string} methodName - Deprecated method name with parentheses (required) containing argument list (optional; see `args` below).
- * @param {string} dotProps - Dot-separated new property name to invoke or method name to call. Method names are indicated by including parentheses with optional argument list. The arguments in each list are drawn from the arguments presented in the `methodName` parameter.
+ * @param {string} methodName - Warning key paired with arbitrary warning in `dotProps` OR deprecated method name with parentheses containing optional argument list paired with replacement property or method in `dotProps`.
+ * @param {string} dotProps - Arbitrary warning paired with warning key in `methodName` OR dot-separated new property name to invoke or method name to call. Method names are indicated by including parentheses with optional argument list. The arguments in each list are drawn from the arguments presented in the `methodName` parameter.
  * @param {string} since - Version in which the name was deprecated.
  * @param {Arguments|Array} [args] - The actual arguments in the order listed in `methodName`. Only needed when arguments need to be forwarded.
  * @param {string} [notes] - Notes to add to message.
  * @returns {*} Return value of new property or method call.
  */
 var deprecated = function(methodName, dotProps, since, args, notes) {
-    if (!regexIsMethod.test(methodName)) {
-        throw 'Expected method name to have parentheses.';
-    }
-
     if (typeof args === 'string') {
         // `args` omitted
         notes = args;
@@ -33,27 +27,45 @@ var deprecated = function(methodName, dotProps, since, args, notes) {
     }
 
     var chain = dotProps.split('.'),
-        formalArgList = argList(methodName),
-        result = this;
+        warned = this.$$DEPRECATION_WARNED = this.$$DEPRECATION_WARNED || {},
+        result = this,
+        isSimpleWarning = dotProps.indexOf(' ') >= 0,
+        isMethodCall = regexIsMethod.test(methodName),
+        memberType,
+        warning;
 
     if (!(methodName in warned)) {
         warned[methodName] = deprecated.warnings;
     }
-    if (warned[methodName]) {
-        var memberType = regexIsMethod.test(dotProps) ? 'method' : 'property';
-        var warning = 'The .' + methodName + ' method is deprecated as of v' + since +
-            ' in favor of the .' + chain.join('.') + ' ' + memberType + '.' +
-            ' (Will be removed in a future release.)';
-
-        if (notes) {
-            warning += ' ' + notes;
-        }
 
-        console.warn(warning);
-
-        --warned[methodName];
+    if (isMethodCall) {
+        if (isSimpleWarning) {
+            throw 'Expected replacement method or property in 2nd parameter of deprecated() call.';
+        } else if (warned[methodName]) {
+            --warned[methodName];
+            memberType = regexIsMethod.test(dotProps) ? 'method' : 'property';
+            warning = 'The .' + methodName + ' method is deprecated as of v' + since +
+                ' in favor of the .' + chain.join('.') + ' ' + memberType + '.' +
+                ' (Will be removed in a future release.)';
+
+            if (notes) {
+                warning += ' ' + notes;
+            }
+
+            console.warn(warning);
+        }
+    } else if (isSimpleWarning) {
+        if (warned[methodName]) {
+            --warned[methodName];
+            console.warn(dotProps);
+        }
+        return;
+    } else {
+        throw 'Expected method name with parentheses in 1st parameter OR simple warning (containing one or more spaces) in 2nd parameter of deprecated() call.';
     }
 
+    var formalArgList = argList(methodName);
+
     function mapToFormalArg(argName) {
         var index = formalArgList.indexOf(argName);
         if (index === -1) {
@@ -65,14 +77,14 @@ var deprecated = function(methodName, dotProps, since, args, notes) {
     for (var i = 0, last = chain.length - 1; i <= last; ++i) {
         var link = chain[i],
             name = link.match(/\w+/)[0],
-            isMethod = regexIsMethod.test(link),
-            actualArgList = isMethod ? argList(link) : undefined,
+            linkIsMethodCall = regexIsMethod.test(link),
+            actualArgList = linkIsMethodCall ? argList(link) : undefined,
             actualArgs = [];
 
         if (actualArgList) {
             actualArgs = actualArgList.map(mapToFormalArg);
             result = result[name].apply(result, actualArgs);
-        } else if (isMethod) {
+        } else if (linkIsMethodCall) {
             result = result[name]();
         } else {
             result = result[name];
diff --git a/src/lib/dynamicProperties.js b/src/lib/dynamicProperties.js
new file mode 100644
index 0000000..aee8d8d
--- /dev/null
+++ b/src/lib/dynamicProperties.js
@@ -0,0 +1,46 @@
+'use strict';
+
+var defaults = require('../defaults');
+
+/**
+ * @summary Dynamic property getter/setters.
+ * @desc ### Backing store
+ * Dynamic properties can make use of a backing store.
+ * This backing store is created in the "own" layer by {@link Hypergrid#clearState|clearState}.
+ * The members of the backing store have the same names as the dynamic properties that utilize them.
+ * They are initialized by {@link Hypergrid#clearState|clearState} to the default values from {@link module:defaults|defaults} object members (also) of the same name.
+ *
+ * ### Themes
+ * This layer is also where themes are applied.
+ * @name dynamicProperties
+ * @module
+ */
+var dynamicProperties = Object.create(defaults, {
+    /**
+     * @memberOf module:dynamicProperties
+     */
+    gridRenderer: {
+        get: function() {
+            return this.var.gridRenderer;
+        },
+        set: function(rendererName) {
+            this.var.gridRenderer = rendererName;
+            this.grid.renderer.setGridRenderer(rendererName);
+        }
+    },
+
+    /**
+     * @memberOf module:dynamicProperties
+     */
+    columnIndexes: {
+        get: function() {
+            return this.grid.behavior.getActiveColumns().map(function(column) { return column.index; });
+        },
+        set: function(columnIndexes) {
+            this.grid.behavior.setColumnOrder(columnIndexes);
+            this.grid.behavior.changed();
+        }
+    },
+});
+
+module.exports = dynamicProperties;
diff --git a/src/lib/events.js b/src/lib/events.js
new file mode 100644
index 0000000..bbad997
--- /dev/null
+++ b/src/lib/events.js
@@ -0,0 +1,654 @@
+/* eslint-env browser */
+
+'use strict';
+
+var _ = require('object-iterators');
+
+var Behavior = require('../behaviors/Behavior');
+
+module.exports = {
+
+    /**
+     * @summary Add an event listener to me.
+     * @desc Listeners added by this method should only be removed by {@link Hypergrid#removeEventListener|grid.removeEventListener} (or {@link Hypergrid#removeAllEventListeners|grid.removeAllEventListeners}).
+     * @param {string} eventName - The type of event we are interested in.
+     * @param {function} listener - The event handler.
+     * @param {boolean} [internal=false] - Used by {@link Hypergrid#addInternalEventListener|grid.addInternalEventListener} (see).
+     * @memberOf Hypergrid#
+     */
+    addEventListener: function(eventName, listener, internal) {
+        var self = this,
+            listeners = this.listeners[eventName] = this.listeners[eventName] || [],
+            alreadyAttached = listeners.find(function(info) { return info.listener === listener; });
+
+        if (!alreadyAttached) {
+            var info = {
+                internal: internal,
+                listener: listener,
+                decorator: function(e) {
+                    if (self.allowEventHandlers){
+                        listener(e);
+                    }
+                }
+            };
+            listeners.push(info);
+            this.canvas.addEventListener(eventName, info.decorator);
+        }
+    },
+
+    /**
+     * @summary Add an internal event listener to me.
+     * @desc The new listener is flagged as "internal." Internal listeners are removed as usual by {@link Hypergrid#removeEventListener|grid.removeEventListener}. However, they are ignored by {@link Hypergrid#removeAllEventListeners|grid.removeAllEventListeners()} (as called by {@link Hypergrid#reset|reset}). (But see {@link Hypergrid#removeAllEventListeners|grid.removeAllEventListeners(true)}.)
+     *
+     * Listeners added by this method should only be removed by {@link Hypergrid#removeEventListener|grid.removeEventListener} (or {@link Hypergrid#removeAllEventListeners|grid.removeAllEventListeners(true)}).
+     * @param {string} eventName - The type of event we are interested in.
+     * @param {function} listener - The event handler.
+     * @memberOf Hypergrid#
+     */
+    addInternalEventListener: function(eventName, listener) {
+        this.addEventListener(eventName, listener, true);
+    },
+
+    /**
+     * @summary Remove an event listeners.
+     * @desc Removes the event listener with matching name and function that was added by {@link Hypergrid#addEventListener|grid.addEventListener}.
+     *
+     * NOTE: This method cannot remove event listeners added by other means.
+     * @memberOf Hypergrid#
+     */
+    removeEventListener: function(eventName, listener) {
+        var listenerList = this.listeners[eventName];
+
+        if (listenerList) {
+            listenerList.find(function(info, index) {
+                if (info.listener === listener) {
+                    listenerList.splice(index, 1); // remove it from the list
+                    this.canvas.removeEventListener(eventName, info.decorator);
+                    return true;
+                }
+            }, this);
+        }
+    },
+
+    /**
+     * @summary Remove all event listeners.
+     * @desc Removes all event listeners added with {@link Hypergrid#addEventListener|grid.addEventListener} except those added as "internal."
+     * @param {boolean} [internal=false] - Include internal listeners.
+     * @memberOf Hypergrid#
+     */
+    removeAllEventListeners: function(internal) {
+        _(this.listeners).each(function(listenerList, key) {
+            listenerList.forEach(function(info) {
+                if (internal || !info.internal) {
+                    this.removeEventListener(key, info.listener);
+                }
+            }, this);
+        }, this);
+    },
+
+    allowEvents: function(allow){
+        if ((this.allowEventHandlers = !!allow)){
+            this.behavior.featureChain.attachChain();
+        } else {
+            this.behavior.featureChain.detachChain();
+        }
+
+        this.behavior.changed();
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @param {number} c - grid column index.
+     * @param {string[]} keys
+     */
+    fireSyntheticColumnSortEvent: function(c, keys) {
+        return dispatchEvent.call(this, 'fin-column-sort', {
+            column: c,
+            keys: keys
+        });
+    },
+
+    fireSyntheticEditorKeyUpEvent: function(inputControl, keyEvent) {
+        return dispatchEvent.call(this, 'fin-editor-keyup', {
+            input: inputControl,
+            keyEvent: keyEvent,
+            char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
+        });
+    },
+
+    fireSyntheticEditorKeyDownEvent: function(inputControl, keyEvent) {
+        return dispatchEvent.call(this, 'fin-editor-keydown', {
+            input: inputControl,
+            keyEvent: keyEvent,
+            char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
+        });
+    },
+
+    fireSyntheticEditorKeyPressEvent: function(inputControl, keyEvent) {
+        return dispatchEvent.call(this, 'fin-editor-keypress', {
+            input: inputControl,
+            keyEvent: keyEvent,
+            char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
+        });
+    },
+
+    fireSyntheticEditorDataChangeEvent: function(inputControl, oldValue, newValue) {
+        return dispatchEvent.call(this, 'fin-editor-data-change', true, {
+            input: inputControl,
+            oldValue: oldValue,
+            newValue: newValue
+        });
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and fire a `fin-row-selection-changed` event.
+     */
+    fireSyntheticRowSelectionChangedEvent: function() {
+        return dispatchEvent.call(this, 'fin-row-selection-changed', {
+            rows: this.getSelectedRows(),
+            columns: this.getSelectedColumns(),
+            selections: this.selectionModel.getSelections(),
+        });
+   },
+
+    fireSyntheticColumnSelectionChangedEvent: function() {
+        return dispatchEvent.call(this, 'fin-column-selection-changed', {
+            rows: this.getSelectedRows(),
+            columns: this.getSelectedColumns(),
+            selections: this.selectionModel.getSelections()
+        });
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and fire a `fin-context-menu` event
+     * @param {keyEvent} event - The canvas event.
+     */
+    fireSyntheticContextMenuEvent: function(event) {
+        event.rows = this.getSelectedRows();
+        event.columns = this.getSelectedColumns();
+        event.selections = this.selectionModel.getSelections();
+        return dispatchEvent.call(this, 'fin-context-menu', {}, event);
+    },
+
+    fireSyntheticMouseUpEvent: function(event) {
+        event.rows = this.getSelectedRows();
+        event.columns = this.getSelectedColumns();
+        event.selections = this.selectionModel.getSelections();
+        return dispatchEvent.call(this, 'fin-mouseup', {}, event);
+    },
+
+    fireSyntheticMouseDownEvent: function(event) {
+        event.rows = this.getSelectedRows();
+        event.columns = this.getSelectedColumns();
+        event.selections = this.selectionModel.getSelections();
+        return dispatchEvent.call(this, 'fin-mousedown', {}, event);
+    },
+
+    fireSyntheticMouseMoveEvent: function(event) {
+        return dispatchEvent.call(this, 'fin-mousemove', {}, event);
+    },
+
+    fireSyntheticButtonPressedEvent: function(event) {
+        if (this.isViewableButton(event.dataCell.x, event.gridCell.y)) {
+            return dispatchEvent.call(this, 'fin-button-pressed', {}, event);
+        }
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and fire a `fin-column-drag-start` event.
+     */
+    fireSyntheticOnColumnsChangedEvent: function() {
+        return dispatchEvent.call(this, 'fin-column-changed-event', {});
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and fire a `fin-keydown` event.
+     * @param {keyEvent} event - The canvas event.
+     */
+    fireSyntheticKeydownEvent: function(keyEvent) {
+        return dispatchEvent.call(this, 'fin-keydown', keyEvent.detail);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and fire a `fin-keyup` event.
+     * @param {keyEvent} event - The canvas event.
+     */
+    fireSyntheticKeyupEvent: function(keyEvent) {
+        return dispatchEvent.call(this, 'fin-keyup', keyEvent.detail);
+    },
+
+    fireSyntheticFilterAppliedEvent: function() {
+        return dispatchEvent.call(this, 'fin-filter-applied', {});
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and fire a `fin-cell-enter` event
+     * @param {Point} cell - The pixel location of the cell in which the click event occurred.
+     * @param {MouseEvent} event - The system mouse event.
+     */
+    fireSyntheticOnCellEnterEvent: function(cellEvent) {
+        return dispatchEvent.call(this, 'fin-cell-enter', cellEvent);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and fire a `fin-cell-exit` event.
+     * @param {Point} cell - The pixel location of the cell in which the click event occured.
+     * @param {MouseEvent} event - The system mouse event.
+     */
+    fireSyntheticOnCellExitEvent: function(cellEvent) {
+        return dispatchEvent.call(this, 'fin-cell-exit', cellEvent);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and fire a `fin-cell-click` event.
+     * @param {Point} cell - The pixel location of the cell in which the click event occured.
+     * @param {MouseEvent} event - The system mouse event.
+     */
+    fireSyntheticClickEvent: function(cellEvent) {
+        return dispatchEvent.call(this, 'fin-click', {}, cellEvent);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and fire a `fin-double-click` event.
+     * @param {MouseEvent} event - The system mouse event.
+     */
+    fireSyntheticDoubleClickEvent: function(cellEvent) {
+        if (!this.abortEditing()) { return; }
+
+        if (this.behavior.cellDoubleClicked !== Behavior.prototype.cellDoubleClicked) {
+            this.deprecated('fin-double-click', 'behavior.cellDoubleClicked(gridCell, cellEvent) has been deprecated as of v1.2.6 in favor of handling in a \'fin-double-click\' event (event.detail.gridCell, event.primitiveEvent) and will be removed in a future release.');
+        }
+        // to deprecate, remove above warning + following line + abstract implementation in Behavior.js
+        this.behavior.cellDoubleClicked(cellEvent.gridCell, cellEvent);
+
+        return dispatchEvent.call(this, 'fin-double-click', {}, cellEvent);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and fire a rendered event.
+     */
+    fireSyntheticGridRenderedEvent: function() {
+       return dispatchEvent.call(this, 'fin-grid-rendered', { source: this });
+    },
+
+    fireSyntheticTickEvent: function() {
+        return dispatchEvent.call(this, 'fin-tick', { source: this });
+    },
+
+    fireSyntheticGridResizedEvent: function(e) {
+        return dispatchEvent.call(this, 'fin-grid-resized', e);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and fire a scroll event.
+     * @param {string} type - Should be either `fin-scroll-x` or `fin-scroll-y`.
+     * @param {number} oldValue - The old scroll value.
+     * @param {number} newValue - The new scroll value.
+     */
+    fireScrollEvent: function(eventName, oldValue, newValue) {
+        return dispatchEvent.call(this, eventName, {
+            oldValue: oldValue,
+            value: newValue
+        });
+    },
+
+    fireRequestCellEdit: function(cellEvent, value) {
+        return dispatchEvent.call(this, 'fin-request-cell-edit', true, { value: value }, cellEvent);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and fire a fin-before-cell-edit event.
+     * @param {Point} cell - The x,y coordinates.
+     * @param {Object} value - The current value.
+     * @returns {boolean} Proceed (don't cancel).
+     */
+    fireBeforeCellEdit: function(cellEvent, oldValue, newValue, control) {
+        return dispatchEvent.call(this, 'fin-before-cell-edit', true, {
+            oldValue: oldValue,
+            newValue: newValue,
+            input: control
+        }, cellEvent);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @returns {Renderer} sub-component
+     * @param {Point} cell - The x,y coordinates.
+     * @param {Object} oldValue - The old value.
+     * @param {Object} newValue - The new value.
+     */
+    fireAfterCellEdit: function(cellEvent, oldValue, newValue, control) {
+        return dispatchEvent.call(this, 'fin-after-cell-edit', {
+            newValue: newValue,
+            oldValue: oldValue,
+            input: control
+        }, cellEvent);
+    },
+
+    delegateCanvasEvents: function() {
+        var self = this;
+
+        function handleMouseEvent(e, cb) {
+            var c = self.getGridCellFromMousePoint(e.detail.mouse),
+                primitiveEvent,
+                decoratedEvent;
+
+            // No events on the whitespace of the grid unless they're drag events
+            if (!c.fake || e.detail.dragstart) {
+                primitiveEvent = c.cellEvent;
+            }
+
+            if (primitiveEvent) {
+                decoratedEvent = Object.defineProperty(
+                    primitiveEvent,
+                    'primitiveEvent',
+                    {
+                        value: e,
+                        enumerable: false,
+                        configurable: true,
+                        writable: true
+                    }
+                );
+                cb.call(self, decoratedEvent);
+            }
+        }
+
+        this.addInternalEventListener('fin-canvas-resized', function(e) {
+            self.resized();
+            self.fireSyntheticGridResizedEvent(e);
+        });
+
+        this.addInternalEventListener('fin-canvas-mousemove', function(e) {
+            if (self.properties.readOnly) {
+                return;
+            }
+            handleMouseEvent(e, function(mouseEvent) {
+                this.delegateMouseMove(mouseEvent);
+                this.fireSyntheticMouseMoveEvent(mouseEvent);
+            });
+        });
+
+        this.addInternalEventListener('fin-canvas-mousedown', function(e) {
+            if (self.properties.readOnly) {
+                return;
+            }
+            if (!self.abortEditing()) {
+                event.stopPropagation();
+                return;
+            }
+
+            handleMouseEvent(e, function(mouseEvent) {
+                mouseEvent.keys = e.detail.keys;
+                this.mouseDownState = mouseEvent;
+                this.delegateMouseDown(mouseEvent);
+                this.fireSyntheticMouseDownEvent(mouseEvent);
+                this.repaint();
+            });
+        });
+
+        this.addInternalEventListener('fin-canvas-click', function(e) {
+            if (self.properties.readOnly) {
+                return;
+            }
+            handleMouseEvent(e, function(mouseEvent) {
+                mouseEvent.keys = e.detail.keys; // todo: this was in fin-tap but wasn't here
+                this.fireSyntheticClickEvent(mouseEvent);
+                this.delegateClick(mouseEvent);
+            });
+        });
+
+        this.addInternalEventListener('fin-canvas-mouseup', function(e) {
+            if (self.properties.readOnly) {
+                return;
+            }
+            self.dragging = false;
+            if (self.isScrollingNow()) {
+                self.setScrollingNow(false);
+            }
+            if (self.columnDragAutoScrolling) {
+                self.columnDragAutoScrolling = false;
+            }
+            handleMouseEvent(e, function(mouseEvent) {
+                this.delegateMouseUp(mouseEvent);
+                if (self.mouseDownState) {
+                    self.fireSyntheticButtonPressedEvent(self.mouseDownState);
+                }
+                this.mouseDownState = null;
+                this.fireSyntheticMouseUpEvent(mouseEvent);
+            });
+        });
+
+        this.addInternalEventListener('fin-canvas-dblclick', function(e) {
+            if (self.properties.readOnly) {
+                return;
+            }
+            handleMouseEvent(e, function(mouseEvent) {
+                this.fireSyntheticDoubleClickEvent(mouseEvent, e);
+                this.delegateDoubleClick(mouseEvent);
+            });
+        });
+
+        this.addInternalEventListener('fin-canvas-drag', function(e) {
+            if (self.properties.readOnly) {
+                return;
+            }
+            self.dragging = true;
+            handleMouseEvent(e, self.delegateMouseDrag);
+        });
+
+        this.addInternalEventListener('fin-canvas-keydown', function(e) {
+            if (self.properties.readOnly) {
+                return;
+            }
+            self.fireSyntheticKeydownEvent(e);
+            self.delegateKeyDown(e);
+        });
+
+        this.addInternalEventListener('fin-canvas-keyup', function(e) {
+            if (self.properties.readOnly) {
+                return;
+            }
+            self.fireSyntheticKeyupEvent(e);
+            self.delegateKeyUp(e);
+        });
+
+        this.addInternalEventListener('fin-canvas-wheelmoved', function(e) {
+            handleMouseEvent(e, self.delegateWheelMoved);
+        });
+
+        this.addInternalEventListener('fin-canvas-mouseout', function(e) {
+            if (self.properties.readOnly) {
+                return;
+            }
+            handleMouseEvent(e, self.delegateMouseExit);
+        });
+
+        this.addInternalEventListener('fin-canvas-context-menu', function(e) {
+            handleMouseEvent(e, function(mouseEvent){
+                self.delegateContextMenu(mouseEvent);
+                self.fireSyntheticContextMenuEvent(mouseEvent);
+            });
+        });
+
+        //Register a listener for the copy event so we can copy our selected region to the pastebuffer if conditions are right.
+        document.body.addEventListener('copy', function(evt) {
+            self.checkClipboardCopy(evt);
+        });
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Delegate the wheel moved event to the behavior.
+     * @param {Event} event - The pertinent event.
+     */
+    delegateWheelMoved: function(event) {
+        this.behavior.onWheelMoved(this, event);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Delegate MouseExit to the behavior (model).
+     * @param {Event} event - The pertinent event.
+     */
+    delegateMouseExit: function(event) {
+        this.behavior.handleMouseExit(this, event);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Delegate MouseExit to the behavior (model).
+     * @param {Event} event - The pertinent event.
+     */
+    delegateContextMenu: function(event) {
+        this.behavior.onContextMenu(this, event);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Delegate MouseMove to the behavior (model).
+     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
+     */
+    delegateMouseMove: function(mouseDetails) {
+        this.behavior.onMouseMove(this, mouseDetails);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Delegate mousedown to the behavior (model).
+     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
+     */
+    delegateMouseDown: function(mouseDetails) {
+        this.behavior.handleMouseDown(this, mouseDetails);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Delegate mouseup to the behavior (model).
+     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
+     */
+    delegateMouseUp: function(mouseDetails) {
+        this.behavior.onMouseUp(this, mouseDetails);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Delegate click to the behavior (model).
+     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
+     */
+    delegateClick: function(mouseDetails) {
+        this.behavior.onClick(this, mouseDetails);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Delegate mouseDrag to the behavior (model).
+     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
+     */
+    delegateMouseDrag: function(mouseDetails) {
+        this.behavior.onMouseDrag(this, mouseDetails);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc We've been doubleclicked on. Delegate through the behavior (model).
+     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
+     */
+    delegateDoubleClick: function(mouseDetails) {
+        this.behavior.onDoubleClick(this, mouseDetails);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @summary Generate a function name and call it on self.
+     * @desc This should also be delegated through Behavior keeping the default implementation here though.
+     * @param {event} event - The pertinent event.
+     */
+    delegateKeyDown: function(event) {
+        this.behavior.onKeyDown(this, event);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @summary Generate a function name and call it on self.
+     * @desc This should also be delegated through Behavior keeping the default implementation here though.
+     * @param {event} event - The pertinent event.
+     */
+    delegateKeyUp: function(event) {
+        this.behavior.onKeyUp(this, event);
+    },
+};
+
+var details = [
+    'gridCell',
+    'dataCell',
+    'mousePoint',
+    'keys',
+    'row'
+];
+
+/**
+ *
+ * @param {string} eventName
+ * @param {boolean} [cancelable=false]
+ * @param {object} event
+ * @param {CellEvent|MouseEvent|KeyboardEvent|object} [primitiveEvent]
+ * @returns {undefined|boolean}
+ */
+function dispatchEvent(eventName, cancelable, event, primitiveEvent) {
+    var detail, result;
+
+    if (typeof cancelable !== 'boolean') {
+        primitiveEvent = event; // propmote primitiveEvent to 3rd position
+        event = cancelable; // promote event to 2nd position
+        cancelable = false; // default when omitted
+    }
+
+    if (!event.detail) {
+        event = { detail: event };
+    }
+
+    detail = event.detail;
+
+    if (!detail.grid) { // CellEvent objects already have a (read-only) `grid` prop
+        detail.grid = this;
+    }
+
+    detail.time = Date.now();
+
+    if (primitiveEvent) {
+        if (!detail.primitiveEvent) {
+            detail.primitiveEvent = primitiveEvent;
+        }
+        details.forEach(function(key) {
+            if (key in primitiveEvent && !(key in detail)) {
+                detail[key] = primitiveEvent[key];
+            }
+        });
+        if ('dataRow' in primitiveEvent) {
+            // reference (without invoking) cellEvent's `dataRow` getter when available
+            Object.defineProperty(detail, 'row', { get: function() { return primitiveEvent.dataRow; } });
+        }
+    }
+
+    if (cancelable) {
+        event.cancelable = true;
+    }
+
+    result = this.canvas.dispatchEvent(new CustomEvent(eventName, event));
+
+    if (cancelable) {
+        return result;
+    }
+}
diff --git a/src/lib/fields.js b/src/lib/fields.js
new file mode 100644
index 0000000..5aeccb7
--- /dev/null
+++ b/src/lib/fields.js
@@ -0,0 +1,51 @@
+'use strict';
+
+/**
+ * @name fields
+ * @module
+ */
+
+var REGEXP_META_PREFIX = /^__/, // starts with double underscore
+    REGEXP_WORD_SEPARATORS = /[\s\-_]*([^\s\-_])([^\s\-_]+)/g,
+    REGEXP_CAPITAL_LETTERS = /[A-Z]/g,
+    REGEXP_LOWER_CASE_LETTER = /[a-z]/;
+
+/**
+ * @param {object} hash
+ * @returns {string[]} Member names from `hash` that do _not_ begin with double-underscore.
+ * @memberOf module:fields
+ */
+function getFieldNames(hash) {
+    return Object.keys(hash || []).filter(function(fieldName) {
+        return !REGEXP_META_PREFIX.test(fieldName);
+    });
+}
+
+function capitalize(a, b, c) {
+    return b.toUpperCase() + c;
+}
+
+/**
+ * Separates camel case or white-space-, hypen-, or underscore-separated-words into truly separate words and capitalizing the first letter of each.
+ * @param string
+ * @returns {string}
+ * @memberOf module:fields
+ */
+function titleize(string) {
+    return (REGEXP_LOWER_CASE_LETTER.test(string) ? string : string.toLowerCase())
+        .replace(REGEXP_WORD_SEPARATORS, capitalize)
+        .replace(REGEXP_CAPITAL_LETTERS, ' $&')
+        .trim();
+}
+
+function getSchema(data){
+    return getFieldNames(data && data[0] || {}).map(function(name) {
+        return { name: name, header: titleize(name) };
+    });
+}
+
+module.exports = {
+    getFieldNames: getFieldNames,
+    titleize: titleize,
+    getSchema: getSchema
+};
diff --git a/src/lib/graphics.js b/src/lib/graphics.js
new file mode 100644
index 0000000..bcdee45
--- /dev/null
+++ b/src/lib/graphics.js
@@ -0,0 +1,203 @@
+/* eslint-env browser */
+
+'use strict';
+
+var API;
+
+function clearFill(x, y, width, height, color) {
+    var a = alpha(color);
+    if (a < 1) {
+        // If background is translucent, we must clear the rect before the fillRect
+        // below to prevent mixing with previous frame's render of this cell.
+        this.clearRect(x, y, width, height);
+    }
+    if (a > 0) {
+        this.cache.fillStyle = color;
+        this.fillRect(x, y, width, height);
+    }
+}
+
+var ALPHA_REGEX = /^(transparent|((RGB|HSL)A\(.*,\s*([\d\.]+)\)))$/i;
+// Tried using an `alphaCache` here but it didn't make a measurable difference.
+function alpha(cssColorSpec) {
+    var matches, result;
+
+    if (!cssColorSpec) {
+        // undefined so not visible; treat as transparent
+        result = 0;
+    } else if ((matches = cssColorSpec.match(ALPHA_REGEX)) === null) {
+        // an opaque color (a color spec with no alpha channel)
+        result = 1;
+    } else if (matches[4] === undefined) {
+        // cssColorSpec must have been 'transparent'
+        result = 0;
+    } else {
+        result = Number(matches[4]);
+    }
+
+    return result;
+}
+
+var fontMetrics = {};
+
+/**
+ * Accumulates width of string in pixels, character by character, by chaching character widths and reusing those values when previously cached.
+ *
+ * NOTE: There is a minor measuring error when taking the sum of the pixel widths of individual characters that make up a string vs. the pixel width of the string taken as a whole. This is possibly due to kerning or rounding. The error is typically about 0.1%.
+ * @memberOf module:defaults
+ * @param {CanvasRenderingContext2D} gc
+ * @param {string} string - Text to measure.
+ * @returns {nubmer} Width of string in pixels.
+ */
+function getTextWidth(string) {
+    var metrics = fontMetrics[this.cache.font] = fontMetrics[this.cache.font] || {};
+    string += '';
+    for (var i = 0, sum = 0, len = string.length; i < len; ++i) {
+        var c = string[i];
+        sum += metrics[c] = metrics[c] || this.measureText(c).width;
+    }
+    return sum;
+}
+
+var ELLIPSIS = '\u2026'; // The "" (dot-dot-dot) character
+
+/**
+ * Similar to `getTextWidth` except:
+ * 1. Aborts accumulating when sum exceeds given `width`.
+ * 2. Returns an object containing both the truncated string and the sum (rather than a number primitive containing the sum alone).
+ * @param {CanvasRenderingContext2D} gc
+ * @param {string} string - Text to measure.
+ * @param {number} width - Width of target cell; overflow point.
+ * @param {boolean|null|undefined} truncateTextWithEllipsis - See {@link module:defaults.truncateTextWithEllipsis}.
+ * @param {boolean} [abort=false] - Abort measuring upon overflow. Returned `width` sum will reflect truncated string rather than untruncated string. Note that returned `string` is truncated in either case.
+ * @returns {{string:string,width:number}}
+ * * `object.string` - `undefined` if it fits; truncated version of provided `string` if it does not.
+ * * `object.width` - Width of provided `string` if it fits; width of truncated string if it does not.
+ */
+function getTextWidthTruncated(string, width, truncateTextWithEllipsis, abort) {
+    var metrics = fontMetrics[this.cache.font],
+        truncating = truncateTextWithEllipsis !== undefined,
+        truncString, truncWidth, truncAt;
+
+    if (!metrics) {
+        metrics = fontMetrics[this.cache.font] = {};
+        metrics[ELLIPSIS] = this.measureText(ELLIPSIS).width;
+    }
+
+    string += ''; // convert to string
+    width += truncateTextWithEllipsis === false ? 2 : -1; // fudge for inequality
+    for (var i = 0, sum = 0, len = string.length; i < len; ++i) {
+        var char = string[i];
+        var charWidth = metrics[char] = metrics[char] || this.measureText(char).width;
+        sum += charWidth;
+        if (!truncString && truncating && sum > width) {
+            truncAt = i;
+            switch (truncateTextWithEllipsis) {
+                case true: // truncate sufficient characters to fit ellipsis if possible
+                    truncWidth = sum - charWidth + metrics[ELLIPSIS];
+                    while (truncAt && truncWidth > width) {
+                        truncWidth -= metrics[string[--truncAt]];
+                    }
+                    truncString = truncWidth > width
+                        ? '' // not enough room even for ellipsis
+                        : truncString = string.substr(0, truncAt) + ELLIPSIS;
+                    break;
+                case false: // truncate *before* last partially visible character
+                    truncString = string.substr(0, truncAt);
+                    break;
+                default: // truncate *after* partially visible character
+                    if (++truncAt < string.length) {
+                        truncString = string.substr(0, truncAt);
+                    }
+            }
+            if (abort) { break; }
+        }
+    }
+    return {
+        string: truncString,
+        width: sum
+    };
+}
+
+var fontData = {};
+
+/**
+ * @memberOf module:defaults
+ * @param font
+ * @returns {*}
+ */
+function getTextHeight(font) {
+    var result = fontData[font];
+
+    if (!result) {
+        result = {};
+
+        var text = document.createElement('span');
+        text.textContent = 'Hg';
+        text.style.font = font;
+
+        var block = document.createElement('div');
+        block.style.display = 'inline-block';
+        block.style.width = '1px';
+        block.style.height = '0px';
+
+        var div = document.createElement('div');
+        div.appendChild(text);
+        div.appendChild(block);
+
+        div.style.position = 'absolute';
+        document.body.appendChild(div);
+
+        try {
+
+            block.style.verticalAlign = 'baseline';
+
+            var blockRect = block.getBoundingClientRect();
+            var textRect = text.getBoundingClientRect();
+
+            result.ascent = blockRect.top - textRect.top;
+
+            block.style.verticalAlign = 'bottom';
+            result.height = blockRect.top - textRect.top;
+
+            result.descent = result.height - result.ascent;
+
+        } finally {
+            document.body.removeChild(div);
+        }
+        if (result.height !== 0) {
+            fontData[font] = result;
+        }
+    }
+
+    return result;
+}
+
+function clipSave(conditional, x, y, width, height) {
+    this.conditionalsStack.push(conditional);
+    if (conditional) {
+        this.cache.save();
+        this.beginPath();
+        this.rect(x, y, width, height);
+        this.clip();
+    }
+}
+
+function clipRestore(conditional) {
+    if (this.conditionalsStack.pop()) {
+        this.cache.restore(); // Remove clip region
+    }
+}
+
+API = {
+    clearFill: clearFill,
+    alpha: alpha,
+    getTextWidth: getTextWidth,
+    getTextWidthTruncated: getTextWidthTruncated,
+    getTextHeight: getTextHeight,
+    clipSave: clipSave,
+    clipRestore: clipRestore,
+    truncateTextWithEllipsis: true
+};
+
+module.exports = API;
diff --git a/src/lib/index.js b/src/lib/index.js
new file mode 100644
index 0000000..76a4ba1
--- /dev/null
+++ b/src/lib/index.js
@@ -0,0 +1,10 @@
+'use strict';
+
+module.exports = {
+    cellEventFactory: require('./cellEventFactory'),
+    DataSourceOrigin: require('./DataSourceOrigin'),
+    dynamicProperties: require('./dynamicProperties'),
+    graphics: require('./graphics'),
+    Canvas: require('./Canvas'),
+    fields: require('./fields')
+};
diff --git a/src/lib/polyfills.js b/src/lib/polyfills.js
index 97bed7b..2aff783 100644
--- a/src/lib/polyfills.js
+++ b/src/lib/polyfills.js
@@ -11,7 +11,8 @@
 /* eslint-disable no-extend-native */
 
 // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill
-Math.sign = Math.sign || function(x) {
+// (Safari now supports Math.sign but IE still does not as of v11.)
+Math.sign = Math.sign = function(x) {
     x = +x; // convert to a number
     if (x === 0 || isNaN(x)) {
         return x;
@@ -19,26 +20,44 @@ Math.sign = Math.sign || function(x) {
     return x > 0 ? 1 : -1;
 };
 
-// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
-if (!Array.prototype.findIndex) {
+// Lite version of: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex#Polyfill
+if (typeof Array.prototype.findIndex !== 'function') {
     Array.prototype.findIndex = function(predicate) {
-        if (this == null) {
-            throw new TypeError('Array.prototype.findIndex called on null or undefined');
-        }
-        if (typeof predicate !== 'function') {
-            throw new TypeError('predicate must be a function');
-        }
-        var list = Object(this);
-        var length = list.length >>> 0;
-        var thisArg = arguments[1];
-        var value;
-
-        for (var i = 0; i < length; i++) {
-            value = list[i];
-            if (predicate.call(thisArg, value, i, list)) {
+        var context = arguments[1];
+        for (var i = 0, len = this.length; i < len; i++) {
+            if (predicate.call(context, this[i], i, this)) {
                 return i;
             }
         }
         return -1;
     };
 }
+
+// Simpler version of: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill
+if (typeof Array.prototype.fill !== 'function') {
+    Array.prototype.fill = function(value, start, end) {
+        start = start === undefined ? 0 : start < 0 ? this.length + start : start;
+        end = end === undefined ? this.length : end < 0 ? this.length + end : end;
+        for (var i = start || 0; i < end; ++i) {
+            this[i] = value;
+        }
+        return this;
+    };
+}
+
+// Lite version of: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
+if (typeof Object.assign !== 'function') {
+    Object.assign = function(target) {
+        for (var index = 1; index < arguments.length; index++) {
+            var source = arguments[index];
+            if (source != null) {
+                for (var nextKey in source) {
+                    if (source.hasOwnProperty(nextKey)) {
+                        target[nextKey] = source[nextKey];
+                    }
+                }
+            }
+        }
+        return target;
+    };
+}
diff --git a/src/lib/selection.js b/src/lib/selection.js
new file mode 100644
index 0000000..77696f6
--- /dev/null
+++ b/src/lib/selection.js
@@ -0,0 +1,759 @@
+/* eslint-env browser */
+
+'use strict';
+
+var Rectangle = require('rectangular').Rectangle;
+
+module.exports = {
+    /**
+     * @memberOf Hypergrid#
+     * @returns {boolean} We have any selections.
+     */
+    hasSelections: function() {
+        if (!this.getSelectionModel) {
+            return; // were not fully initialized yet
+        }
+        return this.selectionModel.hasSelections();
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @returns {string} Tab separated value string from the selection and our data.
+     */
+    getSelectionAsTSV: function() {
+        var sm = this.selectionModel;
+        if (sm.hasSelections()) {
+            var selections = this.getSelectionMatrix();
+            selections = selections[selections.length - 1];
+            return this.getMatrixSelectionAsTSV(selections);
+        } else if (sm.hasRowSelections()) {
+            return this.getMatrixSelectionAsTSV(this.getRowSelectionMatrix());
+        } else if (sm.hasColumnSelections()) {
+            return this.getMatrixSelectionAsTSV(this.getColumnSelectionMatrix());
+        }
+    },
+
+    getMatrixSelectionAsTSV: function(selections) {
+        var result = '';
+
+        //only use the data from the last selection
+        if (selections.length) {
+            var width = selections.length,
+                height = selections[0].length,
+                area = width * height,
+                lastCol = width - 1,
+                //Whitespace will only be added on non-singular rows, selections
+                whiteSpaceDelimiterForRow = (height > 1 ? '\n' : '');
+
+            //disallow if selection is too big
+            if (area > 20000) {
+                alert('selection size is too big to copy to the paste buffer'); // eslint-disable-line no-alert
+                return '';
+            }
+
+            for (var h = 0; h < height; h++) {
+                for (var w = 0; w < width; w++) {
+                    result += selections[w][h] + (w < lastCol ? '\t' : whiteSpaceDelimiterForRow);
+                }
+            }
+        }
+
+        return result;
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Clear all the selections.
+     */
+    clearSelections: function() {
+        var keepRowSelections = this.properties.checkboxOnlyRowSelections;
+        this.selectionModel.clear(keepRowSelections);
+        this.clearMouseDown();
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Clear the most recent selection.
+     */
+    clearMostRecentSelection: function() {
+        var keepRowSelections = this.properties.checkboxOnlyRowSelections;
+        this.selectionModel.clearMostRecentSelection(keepRowSelections);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Clear the most recent column selection.
+     */
+    clearMostRecentColumnSelection: function() {
+        this.selectionModel.clearMostRecentColumnSelection();
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Clear the most recent row selection.
+     */
+    clearMostRecentRowSelection: function() {
+        //this.selectionModel.clearMostRecentRowSelection(); // commented off as per GRID-112
+    },
+
+    clearRowSelection: function() {
+        this.selectionModel.clearRowSelection();
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @summary Select given region.
+     * @param {number} ox - origin x
+     * @param {number} oy - origin y
+     * @param {number} ex - extent x
+     * @param {number} ex - extent y
+     */
+    select: function(ox, oy, ex, ey) {
+        if (ox < 0 || oy < 0) {
+            //we don't select negative area
+            //also this means there is no origin mouse down for a selection rect
+            return;
+        }
+        this.selectionModel.select(ox, oy, ex, ey);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @returns {boolean} Given point is selected.
+     * @param {number} x - The horizontal coordinate.
+     * @param {number} y - The vertical coordinate.
+     */
+    isSelected: function(x, y) {
+        return this.selectionModel.isSelected(x, y);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @returns {boolean} The given column is selected anywhere in the entire table.
+     * @param {number} y - The row index.
+     */
+    isCellSelectedInRow: function(y) {
+        return this.selectionModel.isCellSelectedInRow(y);
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @returns {boolean} The given row is selected anywhere in the entire table.
+     * @param {number} x - The column index.
+     */
+    isCellSelectedInColumn: function(x) {
+        return this.selectionModel.isCellSelectedInColumn(x);
+    },
+
+    /**
+     * @param {boolean|number[]|string[]} [hiddenColumns=false] - See {@link Hypergrid~getColumns}.
+     * @returns {{}}
+     * @memberOf Hypergrid#
+     */
+    getRowSelection: function(hiddenColumns) {
+        var column, rows,
+            self = this,
+            selectedRowIndexes = this.selectionModel.getSelectedRows(),
+            columns = getColumns.call(this, hiddenColumns),
+            result = {};
+
+        for (var c = 0, C = columns.length; c < C; c++) {
+            column = columns[c];
+            rows = result[column.name] = new Array(selectedRowIndexes.length);
+            selectedRowIndexes.forEach(getValue);
+        }
+
+        function getValue(selectedRowIndex, j) {
+            var dataRow = self.getRow(selectedRowIndex);
+            rows[j] = valOrFunc(dataRow, column);
+        }
+
+        return result;
+    },
+
+    /**
+     * @param {boolean|number[]|string[]} [hiddenColumns=false] - See {@link Hypergrid~getColumns}.
+     * @returns {Array}
+     * @memberOf Hypergrid#
+     */
+    getRowSelectionMatrix: function(hiddenColumns) {
+        var self = this,
+            selectedRowIndexes = this.selectionModel.getSelectedRows(),
+            columns = getColumns.call(this, hiddenColumns),
+            result = new Array(columns.length);
+
+        for (var c = 0, C = columns.length; c < C; c++) {
+            var column = columns[c];
+            result[c] = new Array(selectedRowIndexes.length);
+            selectedRowIndexes.forEach(getValue);
+        }
+
+        function getValue(selectedRowIndex, r) {
+            var dataRow = self.getRow(selectedRowIndex);
+            result[c][r] = valOrFunc(dataRow, column);
+        }
+
+        return result;
+    },
+
+    getColumnSelectionMatrix: function() {
+        var dataRow,
+            self = this,
+            headerRowCount = this.getHeaderRowCount(),
+            selectedColumnIndexes = this.getSelectedColumns(),
+            numRows = this.getRowCount(),
+            result = new Array(selectedColumnIndexes.length);
+
+        selectedColumnIndexes.forEach(function(selectedColumnIndex, c) {
+            var column = self.behavior.getActiveColumn(selectedColumnIndex),
+                values = result[c] = new Array(numRows);
+
+            for (var r = headerRowCount; r < numRows; r++) {
+                dataRow = self.getRow(r);
+                values[r] = valOrFunc(dataRow, column);
+            }
+        });
+
+        return result;
+    },
+
+    getColumnSelection: function() {
+        var dataRow,
+            self = this,
+            headerRowCount = this.getHeaderRowCount(),
+            selectedColumnIndexes = this.getSelectedColumns(),
+            result = {},
+            rowCount = this.getRowCount();
+
+        selectedColumnIndexes.forEach(function(selectedColumnIndex) {
+            var column = self.behavior.getActiveColumn(selectedColumnIndex),
+                values = result[column.name] = new Array(rowCount);
+
+            for (var r = headerRowCount; r < rowCount; r++) {
+                dataRow = self.getRow(r);
+                values[r] = valOrFunc(dataRow, column);
+            }
+        });
+
+        return result;
+    },
+
+    getSelection: function() {
+        var dataRow,
+            self = this,
+            selections = this.getSelections(),
+            rects = new Array(selections.length);
+
+        selections.forEach(getRect);
+
+        function getRect(selectionRect, i) {
+            var rect = normalizeRect(selectionRect),
+                colCount = rect.extent.x + 1,
+                rowCount = rect.extent.y + 1,
+                columns = {};
+
+            for (var c = 0, x = rect.origin.x; c < colCount; c++, x++) {
+                var column = self.behavior.getActiveColumn(x),
+                    values = columns[column.name] = new Array(rowCount);
+
+                for (var r = 0, y = rect.origin.y; r < rowCount; r++, y++) {
+                    dataRow = self.getRow(y);
+                    values[r] = valOrFunc(dataRow, column);
+                }
+            }
+
+            rects[i] = columns;
+        }
+
+        return rects;
+    },
+
+    getSelectionMatrix: function() {
+        var dataRow,
+            self = this,
+            selections = this.getSelections(),
+            rects = new Array(selections.length);
+
+        selections.forEach(getRect);
+
+        function getRect(selectionRect, i) {
+            var rect = normalizeRect(selectionRect),
+                colCount = rect.extent.x + 1,
+                rowCount = rect.extent.y + 1,
+                rows = [];
+
+            for (var c = 0, x = rect.origin.x; c < colCount; c++, x++) {
+                var values = rows[c] = new Array(rowCount),
+                    column = self.behavior.getActiveColumn(x);
+
+                for (var r = 0, y = rect.origin.y; r < rowCount; r++, y++) {
+                    dataRow = self.getRow(y);
+                    values[r] = valOrFunc(dataRow, column);
+                }
+            }
+
+            rects[i] = rows;
+        }
+
+        return rects;
+    },
+
+    selectCell: function(x, y, silent) {
+        var keepRowSelections = this.properties.checkboxOnlyRowSelections;
+        this.selectionModel.clear(keepRowSelections);
+        this.selectionModel.select(x, y, 0, 0, silent);
+    },
+
+    toggleSelectColumn: function(x, keys) {
+        keys = keys || [];
+        var model = this.selectionModel;
+        var alreadySelected = model.isColumnSelected(x);
+        var hasCTRL = keys.indexOf('CTRL') > -1;
+        var hasSHIFT = keys.indexOf('SHIFT') > -1;
+        if (!hasCTRL && !hasSHIFT) {
+            model.clear();
+            if (!alreadySelected) {
+                model.selectColumn(x);
+            }
+        } else {
+            if (hasCTRL) {
+                if (alreadySelected) {
+                    model.deselectColumn(x);
+                } else {
+                    model.selectColumn(x);
+                }
+            }
+            if (hasSHIFT) {
+                model.clear();
+                model.selectColumn(this.lastEdgeSelection[0], x);
+            }
+        }
+        if (!alreadySelected && !hasSHIFT) {
+            this.lastEdgeSelection[0] = x;
+        }
+        this.repaint();
+        this.fireSyntheticColumnSelectionChangedEvent();
+    },
+
+    toggleSelectRow: function(y, keys) {
+        //we can select the totals rows if they exist, but not rows above that
+        keys = keys || [];
+
+        var sm = this.selectionModel;
+        var alreadySelected = sm.isRowSelected(y);
+        var hasSHIFT = keys.indexOf('SHIFT') >= 0;
+
+        if (alreadySelected) {
+            sm.deselectRow(y);
+        } else {
+            this.singleSelect();
+            sm.selectRow(y);
+        }
+
+        if (hasSHIFT) {
+            sm.clear();
+            sm.selectRow(this.lastEdgeSelection[1], y);
+        }
+
+        if (!alreadySelected && !hasSHIFT) {
+            this.lastEdgeSelection[1] = y;
+        }
+
+        this.repaint();
+    },
+
+    singleSelect: function() {
+        var result = this.properties.singleRowSelectionMode;
+
+        if (result) {
+            this.selectionModel.clearRowSelection();
+        }
+
+        return result;
+    },
+
+    selectViewportCell: function(x, y) {
+        var headerRowCount = this.getHeaderRowCount();
+        x = this.renderer.visibleColumns[x].columnIndex;
+        y = this.renderer.visibleRows[y + headerRowCount].rowIndex;
+        this.clearSelections();
+        this.select(x, y, 0, 0);
+        this.setMouseDown(this.newPoint(x, y));
+        this.setDragExtent(this.newPoint(0, 0));
+        this.repaint();
+    },
+
+    selectToViewportCell: function(x, y) {
+        var selections = this.getSelections();
+        if (selections && selections.length) {
+            var headerRowCount = this.getHeaderRowCount(),
+                selection = selections[0],
+                origin = selection.origin;
+            x = this.renderer.visibleColumns[x].columnIndex;
+            y = this.renderer.visibleRows[y + headerRowCount].rowIndex;
+            this.setDragExtent(this.newPoint(x - origin.x, y - origin.y));
+            this.select(origin.x, origin.y, x - origin.x, y - origin.y);
+            this.repaint();
+        }
+    },
+
+    selectFinalCellOfCurrentRow: function() {
+        var x = this.getColumnCount() - 1,
+            y = this.getSelectedRows()[0],
+            headerRowCount = this.getHeaderRowCount();
+        this.clearSelections();
+        this.scrollBy(this.getColumnCount(), 0);
+        this.select(x, y + headerRowCount, 0, 0);
+        this.setMouseDown(this.newPoint(x, y + headerRowCount));
+        this.setDragExtent(this.newPoint(0, 0));
+        this.repaint();
+    },
+
+    selectToFinalCellOfCurrentRow: function() {
+        var selections = this.getSelections();
+        if (selections && selections.length) {
+            var selection = selections[0],
+                origin = selection.origin,
+                extent = selection.extent,
+                columnCount = this.getColumnCount();
+            this.scrollBy(columnCount, 0);
+
+            this.clearSelections();
+            this.select(origin.x, origin.y, columnCount - origin.x - 1, extent.y);
+
+            this.repaint();
+        }
+    },
+
+    selectFirstCellOfCurrentRow: function() {
+        var x = 0,
+            y = this.getSelectedRows()[0],
+            headerRowCount = this.getHeaderRowCount();
+        this.clearSelections();
+        this.setHScrollValue(0);
+        this.select(x, y + headerRowCount, 0, 0);
+        this.setMouseDown(this.newPoint(x, y + headerRowCount));
+        this.setDragExtent(this.newPoint(0, 0));
+        this.repaint();
+    },
+
+    selectToFirstCellOfCurrentRow: function() {
+        var selections = this.getSelections();
+        if (selections && selections.length) {
+            var selection = selections[0],
+                origin = selection.origin,
+                extent = selection.extent;
+            this.clearSelections();
+            this.select(origin.x, origin.y, -origin.x, extent.y);
+            this.setHScrollValue(0);
+            this.repaint();
+        }
+    },
+
+    selectFinalCell: function() {
+        this.selectCellAndScrollToMakeVisible(this.getColumnCount() - 1, this.getRowCount() - 1);
+        this.repaint();
+    },
+
+    selectToFinalCell: function() {
+        var selections = this.getSelections();
+        if (selections && selections.length) {
+            var selection = selections[0],
+                origin = selection.origin,
+                columnCount = this.getColumnCount(),
+                rowCount = this.getRowCount();
+
+            this.clearSelections();
+            this.select(origin.x, origin.y, columnCount - origin.x - 1, rowCount - origin.y - 1);
+            this.scrollBy(columnCount, rowCount);
+            this.repaint();
+        }
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @returns {object} An object that represents the currently selection row.
+     */
+    getSelectedRow: function() {
+        var sels = this.selectionModel.getSelections();
+        if (sels.length) {
+            var behavior = this.behavior,
+                colCount = this.getColumnCount(),
+                topRow = sels[0].origin.y,
+                row = {
+                    //hierarchy: behavior.getFixedColumnValue(0, topRow)
+                };
+
+            for (var c = 0; c < colCount; c++) {
+                row[behavior.getActiveColumn(c).header] = behavior.getValue(c, topRow);
+            }
+
+            return row;
+        }
+    },
+
+    /**
+     * @memberOf Hypergrid#
+     * @desc Synthesize and dispatch a `fin-selection-changed` event.
+     */
+    selectionChanged: function() {
+        // Project the cell selection into the rows
+        this.selectRowsFromCells();
+
+        // Project the cell selection into the columns
+        this.selectColumnsFromCells();
+
+        var selectionEvent = new CustomEvent('fin-selection-changed', {
+            detail: {
+                rows: this.getSelectedRows(),
+                columns: this.getSelectedColumns(),
+                selections: this.selectionModel.getSelections(),
+            }
+        });
+        this.canvas.dispatchEvent(selectionEvent);
+    },
+
+    isColumnOrRowSelected: function() {
+        return this.selectionModel.isColumnOrRowSelected();
+    },
+    selectColumn: function(x1, x2) {
+        this.selectionModel.selectColumn(x1, x2);
+    },
+    selectRow: function(y1, y2) {
+        var sm = this.selectionModel;
+
+        if (this.singleSelect()) {
+            y1 = y2;
+        } else {
+            // multiple row selection
+            y2 = y2 || y1;
+        }
+
+        sm.selectRow(Math.min(y1, y2), Math.max(y1, y2));
+    },
+
+    selectRowsFromCells: function() {
+        if (!this.properties.checkboxOnlyRowSelections && this.properties.autoSelectRows) {
+            var last;
+
+            if (!this.properties.singleRowSelectionMode) {
+                this.selectionModel.selectRowsFromCells(0, true);
+            } else if ((last = this.selectionModel.getLastSelection())) {
+                this.selectRow(null, last.corner.y);
+            } else {
+                this.clearRowSelection();
+            }
+        }
+    },
+    selectColumnsFromCells: function() {
+        if (this.properties.autoSelectColumns) {
+            this.selectionModel.selectColumnsFromCells();
+        }
+    },
+    getSelectedRows: function() {
+        return this.behavior.getSelectedRows();
+    },
+    getSelectedColumns: function() {
+        return this.behavior.getSelectedColumns();
+    },
+    getSelections: function() {
+        return this.behavior.getSelections();
+    },
+    getLastSelectionType: function() {
+        return this.selectionModel.getLastSelectionType();
+    },
+    isInCurrentSelectionRectangle: function(x, y) {
+        return this.selectionModel.isInCurrentSelectionRectangle(x, y);
+    },
+    selectAllRows: function() {
+        this.selectionModel.selectAllRows();
+    },
+    areAllRowsSelected: function() {
+        return this.selectionModel.areAllRowsSelected();
+    },
+    toggleSelectAllRows: function() {
+        if (this.areAllRowsSelected()) {
+            this.selectionModel.clear();
+        } else {
+            this.selectAllRows();
+        }
+        this.repaint();
+    },
+    isCellSelection: function() {
+        return this.deprecated('isCellSelection()', 'properties.cellSelection', '1.2.2');
+    },
+    isRowSelection: function() {
+        return this.deprecated('isRowSelection()', 'properties.rowSelection', '1.2.2');
+    },
+    isColumnSelection: function() {
+        return this.deprecated('isColumnSelection()', 'properties.columnSelection', '1.2.2');
+    },
+    isSingleRowSelectionMode: function() {
+        return this.deprecated('isSingleRowSelectionMode()', 'properties.singleRowSelectionMode', '1.2.14');
+    },
+
+    /**
+     * @summary Move cell selection by offset.
+     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
+     * @param {number} offsetX - x offset
+     * @param {number} offsetY - y offset
+     * @memberOf Hypergrid#
+     */
+    moveSingleSelect: function(offsetX, offsetY) {
+        var mouseCorner = this.getMouseDown().plus(this.getDragExtent());
+        this.moveToSingleSelect(
+            mouseCorner.x + offsetX,
+            mouseCorner.y + offsetY
+        );
+    },
+
+    /**
+     * @summary Move cell selection by offset.
+     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
+     * @param {number} newX - x coordinate to start at
+     * @param {number} newY - y coordinate to start at
+     * @memberOf Hypergrid#
+     */
+    moveToSingleSelect: function(newX, newY) {
+        var maxColumns = this.getColumnCount() - 1,
+            maxRows = this.getRowCount() - 1,
+
+            maxViewableColumns = this.getVisibleColumnsCount() - 1,
+            maxViewableRows = this.getVisibleRowsCount() - 1;
+
+        if (!this.properties.scrollingEnabled) {
+            maxColumns = Math.min(maxColumns, maxViewableColumns);
+            maxRows = Math.min(maxRows, maxViewableRows);
+        }
+
+        newX = Math.min(maxColumns, Math.max(0, newX));
+        newY = Math.min(maxRows, Math.max(0, newY));
+
+        this.clearSelections();
+        this.select(newX, newY, 0, 0);
+        this.setMouseDown(this.newPoint(newX, newY));
+        this.setDragExtent(this.newPoint(0, 0));
+
+        this.selectCellAndScrollToMakeVisible(newX, newY);
+
+        this.repaint();
+    },
+
+    /** @summary Extend cell selection by offset.
+     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
+     * @param {number} offsetX - x coordinate to start at
+     * @param {number} offsetY - y coordinate to start at
+     * @memberOf Hypergrid#
+     */
+    extendSelect: function(offsetX, offsetY) {
+        var maxColumns = this.getColumnCount() - 1,
+            maxRows = this.getRowCount() - 1,
+
+            maxViewableColumns = this.renderer.visibleColumns.length - 1,
+            maxViewableRows = this.renderer.visibleRows.length - 1,
+
+            origin = this.getMouseDown(),
+            extent = this.getDragExtent(),
+
+            newX = extent.x + offsetX,
+            newY = extent.y + offsetY;
+
+        if (!this.properties.scrollingEnabled) {
+            maxColumns = Math.min(maxColumns, maxViewableColumns);
+            maxRows = Math.min(maxRows, maxViewableRows);
+        }
+
+        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));
+        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));
+
+        this.clearMostRecentSelection();
+        this.select(origin.x, origin.y, newX, newY);
+
+        this.setDragExtent(this.newPoint(newX, newY));
+
+        var colScrolled = this.insureModelColIsVisible(newX + origin.x, offsetX),
+            rowScrolled = this.insureModelRowIsVisible(newY + origin.y, offsetY);
+
+        this.repaint();
+
+        return colScrolled || rowScrolled;
+    },
+
+    /**
+     * @returns {undefined|CellEvent}
+     * @memberOf Hypergrid#
+     */
+    getGridCellFromLastSelection: function() {
+        var cellEvent,
+            sel = this.selectionModel.getLastSelection();
+
+        if (sel) {
+            cellEvent = new this.behavior.CellEvent;
+            cellEvent.resetGridXDataY(sel.origin.x, sel.origin.y);
+        }
+
+        return cellEvent;
+    }
+};
+
+/**
+ * @param {boolean|number[]|string[]} [hiddenColumns=false] - One of:
+ * `false` - Active column list
+ * `true` - All column list
+ * `Array` - Active column list with listed columns prefixed as needed (when not already in the list). Each item in the array may be either:
+ * * `number` - index into all column list
+ * * `string` - name of a column from the all column list
+ * @returns {Column[]}
+ * @memberOf Hypergrid~
+ */
+function getColumns(hiddenColumns) {
+    var columns,
+        allColumns = this.behavior.getColumns(),
+        activeColumns = this.behavior.getActiveColumns();
+
+    if (Array.isArray(hiddenColumns)) {
+        columns = [];
+        hiddenColumns.forEach(function(index) {
+            var key = typeof index === 'number' ? 'index' : 'name',
+                column = allColumns.find(function(column) { return column[key] === index; });
+            if (activeColumns.indexOf(column) < 0) {
+                columns.push(column);
+            }
+        });
+        columns = columns.concat(activeColumns);
+    } else {
+        columns = hiddenColumns ? allColumns : activeColumns;
+    }
+
+    return columns;
+}
+
+function normalizeRect(rect) {
+    var o = rect.origin,
+        c = rect.corner,
+
+        ox = Math.min(o.x, c.x),
+        oy = Math.min(o.y, c.y),
+
+        cx = Math.max(o.x, c.x),
+        cy = Math.max(o.y, c.y);
+
+    return new Rectangle(ox, oy, cx - ox, cy - oy);
+}
+
+/**
+ * @this {dataRowObject}
+ * @param column
+ * @returns {string}
+ */
+function valOrFunc(dataRow, column) {
+    var result, calculator;
+    if (dataRow) {
+        result = dataRow[column.name];
+        calculator = (typeof result)[0] === 'f' && result || column.calculator;
+        if (calculator) {
+            result = calculator(dataRow, column.name);
+        }
+    }
+    return result || result === 0 || result === false ? result : '';
+}
diff --git a/src/lib/stylesheet.js b/src/lib/stylesheet.js
deleted file mode 100644
index 60b4b1c..0000000
--- a/src/lib/stylesheet.js
+++ /dev/null
@@ -1,32 +0,0 @@
-/* eslint-env browser */
-
-'use strict';
-
-var automat = require('automat');
-
-var css = require('../../css');
-
-// note the position of the  first "natural" stylesheet. We will insert our stylesheets before this node.
-var head = document.querySelector('head');
-var refNode = Array.prototype.slice.call(head.children).find(function(child) {
-    return child.tagName === 'STYLE' ||
-        child.tagName === 'LINK' &&
-        child.getAttribute('rel') === 'stylesheet' &&
-        child.getAttribute('type') === 'text/css';
-});
-
-exports.prefix = 'injected-stylesheet-';
-
-exports.inject = function(id, replacements) {
-    var stylesheet = document.querySelector('#' + this.prefix + id);
-
-    if (!stylesheet) {
-        stylesheet = css[id];
-        stylesheet = '<style>\n' + stylesheet + '\n</style>\n';
-        var args = [stylesheet, head, refNode].concat(Array.prototype.slice.call(arguments, 1));
-        stylesheet = automat.append.apply(null, args)[0];
-        stylesheet.id = this.prefix + id;
-    }
-
-    return stylesheet;
-};
diff --git a/src/lib/toFunction.js b/src/lib/toFunction.js
new file mode 100644
index 0000000..3d30c66
--- /dev/null
+++ b/src/lib/toFunction.js
@@ -0,0 +1,44 @@
+'use strict';
+
+/**
+ * @param {function|string} string
+ * @returns {function}
+ * @private
+ */
+module.exports = function(string) {
+    switch (typeof string) {
+        case 'undefined':
+        case 'function':
+            return string;
+        case 'string':
+            break;
+        default:
+            throw 'Expected string, function, or undefined.';
+    }
+
+    var args = string.match(/function\s*\(([^]*?)\)/);
+    if (!args) {
+        throw 'Expected function keyword with formal parameter list.';
+    }
+    args = args[1].split(',').map(function(s, i) {
+        s = s.match(/\s*(\w*)\s*/); // trim each argument
+        if (!s && i) {
+            throw 'Expected formal parameter.';
+        }
+        return s[1];
+    });
+
+    var body = string.match(/{\s*([^]*?)\s*}/);
+    if (!body) {
+        throw 'Expected function body.';
+    }
+    body = body[1];
+
+    if (args.length === 1 && !args[0]) {
+        args[0] = body;
+    } else {
+        args = args.concat(body);
+    }
+
+    return Function.apply(null, args);
+};
diff --git a/src/renderer/bundle-columns.js b/src/renderer/bundle-columns.js
new file mode 100644
index 0000000..efceb17
--- /dev/null
+++ b/src/renderer/bundle-columns.js
@@ -0,0 +1,48 @@
+'use strict';
+
+function bundleColumns(resetCellEvents) {
+    var gridProps = this.grid.properties,
+        vc, visibleColumns = this.visibleColumns,
+        vr, visibleRows = this.visibleRows,
+        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0,
+        r, R = visibleRows.length,
+        p, pool;
+
+    if (resetCellEvents) {
+        pool = this.cellEventPool;
+        for (p = 0, c = c0; c < C; c++) {
+            vc = visibleColumns[c];
+            for (r = 0; r < R; r++, p++) {
+                vr = visibleRows[r];
+                // reset pool member to reflect coordinates of cell in newly shaped grid
+                pool[p].reset(vc, vr);
+            }
+        }
+    }
+
+    var bundle,
+        columnBundles = [],
+        gridPrefillColor = gridProps.backgroundColor,
+        backgroundColor;
+
+    for (c = c0; c < C; c++) {
+        vc = visibleColumns[c];
+        backgroundColor = vc.column.properties.backgroundColor;
+        if (bundle && bundle.backgroundColor === backgroundColor) {
+            bundle.right = vc.right;
+        } else if (backgroundColor === gridPrefillColor) {
+            bundle = undefined;
+        } else {
+            bundle = {
+                backgroundColor: backgroundColor,
+                left: vc.left,
+                right: vc.right
+            };
+            columnBundles.push(bundle);
+        }
+    }
+
+    this.columnBundles = columnBundles;
+}
+
+module.exports = bundleColumns;
diff --git a/src/renderer/bundle-rows.js b/src/renderer/bundle-rows.js
new file mode 100644
index 0000000..24a2158
--- /dev/null
+++ b/src/renderer/bundle-rows.js
@@ -0,0 +1,51 @@
+'use strict';
+
+function bundleRows(resetCellEvents) {
+    var gridProps = this.grid.properties,
+        vc, visibleColumns = this.visibleColumns,
+        vr, visibleRows = this.visibleRows,
+        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0,
+        r, R = visibleRows.length,
+        p, pool;
+
+    if (resetCellEvents) {
+        pool = this.cellEventPool;
+        for (p = 0, r = 0; r < R; r++) {
+            vr = visibleRows[r];
+            for (c = c0; c < C; c++, p++) {
+                vc = visibleColumns[c];
+                // reset pool member to reflect coordinates of cell in newly shaped grid
+                pool[p].reset(vc, vr);
+            }
+        }
+    }
+
+    var bundle, rowBundles = [],
+        gridPrefillColor = gridProps.backgroundColor,
+        rowPropsList = gridProps.rowProperties,
+        rowPrefillColors = Array(R),
+        rowProperties, backgroundColor;
+
+    for (r = 0; r < R; r++) {
+        vr = visibleRows[r]; // first cell in row r
+        rowProperties = vr.subgrid.isData && rowPropsList && rowPropsList[vr.rowIndex % rowPropsList.length];
+        backgroundColor = rowPrefillColors[r] = rowProperties && rowProperties.backgroundColor || gridPrefillColor;
+        if (bundle && bundle.backgroundColor === backgroundColor) {
+            bundle.bottom = vr.bottom;
+        } else if (backgroundColor === gridPrefillColor) {
+            bundle = undefined;
+        } else {
+            bundle = {
+                backgroundColor: backgroundColor,
+                top: vr.top,
+                bottom: vr.bottom
+            };
+            rowBundles.push(bundle);
+        }
+    }
+
+    this.rowBundles = rowBundles;
+    this.rowPrefillColors = rowPrefillColors;
+}
+
+module.exports = bundleRows;
diff --git a/src/renderer/by-cells.js b/src/renderer/by-cells.js
new file mode 100644
index 0000000..06207c8
--- /dev/null
+++ b/src/renderer/by-cells.js
@@ -0,0 +1,91 @@
+'use strict';
+
+var paintCellsByColumnsAndRows = require('./by-columns-and-rows');
+
+/** @summary Render the grid only as needed ("partial render").
+ * @desc Paints all the cells of a grid, one column at a time, but only as needed.
+ *
+ * Paints all the cells of a grid, one row at a time.
+ *
+ * #### On reset
+ *
+ * Defers to {@link Renderer#paintCellsByColumnsAndRows|paintCellsByColumnsAndRows}, which clears the canvas, draws the grid, and draws the grid lines.
+ *
+ * #### On the next call (afer reset)
+ *
+ * First, a background rect is drawn using the grid background color.
+ *
+ * Then, each cell is drawn. If its background differs from the grid background, the background is repainted.
+ *
+ * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
+ * The error message is error-logged to console AND displayed in cell.
+ *
+ * #### On subsequent calls
+ *
+ * Iterates through each cell, calling `_paintCell` with `undefined` prefill color. This signifies partial render to the {@link SimpleCell} cell renderer, which only renders the cell when it's text, font, or colors have changed.
+ *
+ * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
+ *
+ * See also the discussion of clipping in {@link Renderer#paintCellsByColumns|paintCellsByColumns}.
+ * @this {Renderer}
+ * @param {CanvasRenderingContext2D} gc
+ * @memberOf Renderer.prototype
+ */
+function paintCellsAsNeeded(gc) {
+    var grid = this.grid,
+        gridProps = grid.properties,
+        cellEvent,
+        vc, visibleColumns = this.visibleColumns,
+        visibleRows = this.visibleRows,
+        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0, cLast = C - 1,
+        r, R = visibleRows.length,
+        p, pool = this.cellEventPool,
+        preferredWidth,
+        columnClip,
+        // clipToGrid,
+        // viewWidth = C ? visibleColumns[cLast].right : 0,
+        viewHeight = R ? visibleRows[R - 1].bottom : 0;
+
+    if (!C || !R) { return; }
+
+    if (paintCellsAsNeeded.reset) {
+        this.resetAllGridRenderers();
+        paintCellsByColumnsAndRows.call(this, gc);
+        paintCellsAsNeeded.reset = false;
+    }
+
+    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);
+
+    // For each column...
+    for (p = 0, c = c0; c < C; c++) {
+        cellEvent = pool[p]; // first cell in column c
+        vc = cellEvent.visibleColumn;
+
+        // Optionally clip to visible portion of column to prevent text from overflowing to right.
+        columnClip = vc.column.properties.columnClip;
+        gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);
+
+        // For each row of each subgrid (of each column)...
+        for (preferredWidth = r = 0; r < R; r++, p++) {
+            cellEvent = pool[p]; // next cell down the column (redundant for first cell in column)
+
+            try {
+                preferredWidth = Math.max(preferredWidth, this._paintCell(gc, pool[p]));
+            } catch (e) {
+                this.renderErrorCell(e, gc, vc, pool[p].visibleRow);
+            }
+        }
+
+        gc.clipRestore(columnClip);
+
+        cellEvent.column.properties.preferredWidth = Math.round(preferredWidth);
+    }
+
+    // gc.clipRestore(clipToGrid);
+}
+
+paintCellsAsNeeded.key = 'by-cells';
+
+paintCellsAsNeeded.partial = true; // skip painting selectionRegionOverlayColor
+
+module.exports = paintCellsAsNeeded;
diff --git a/src/renderer/by-columns-and-rows.js b/src/renderer/by-columns-and-rows.js
new file mode 100644
index 0000000..057089a
--- /dev/null
+++ b/src/renderer/by-columns-and-rows.js
@@ -0,0 +1,119 @@
+'use strict';
+
+var bundleColumns = require('./bundle-columns');
+var bundleRows = require('./bundle-rows');
+
+/** @summary Render the grid with consolidated row OR column rects.
+ * @desc Paints all the cells of a grid, one column at a time.
+ *
+ * First, a background rect is drawn using the grid background color.
+ *
+ * Then, if there are any rows with their own background color _that differs from the grid background color,_ these are consolidated and the consolidated groups of row backgrounds are all drawn before iterating through cells. These row backgrounds get priority over column backgrounds.
+ *
+ * If there are no such row background rects to draw, the column rects are consolidated and drawn instead (again, before the cells). Note that these column rects are _not_ suitable for clipping overflow text from previous columns. If you have overflow text, either turn on clipping (big performance hit) or turn on one of the `truncateTextWithEllipsis` options.
+ *
+ * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
+ * The error message is error-logged to console AND displayed in cell.
+ *
+ * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
+ *
+ * See also the discussion of clipping in {@link Renderer#paintCellsByColumns|paintCellsByColumns}.
+ * @this {Renderer}
+ * @param {CanvasRenderingContext2D} gc
+ * @memberOf Renderer.prototype
+ */
+function paintCellsByColumnsAndRows(gc) {
+    var grid = this.grid,
+        gridProps = grid.properties,
+        prefillColor, rowPrefillColors, gridPrefillColor = gridProps.backgroundColor,
+        cellEvent,
+        rowBundle, rowBundles,
+        columnBundle, columnBundles,
+        vc, visibleColumns = this.visibleColumns,
+        visibleRows = this.visibleRows,
+        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0, cLast = C - 1,
+        r, R = visibleRows.length,
+        p, pool = this.cellEventPool,
+        preferredWidth,
+        columnClip,
+        // clipToGrid,
+        viewWidth = C ? visibleColumns[C - 1].right : 0,
+        viewHeight = R ? visibleRows[R - 1].bottom : 0;
+
+    gc.clearRect(0, 0, this.bounds.width, this.bounds.height);
+
+    if (!C || !R) { return; }
+
+    if (gc.alpha(gridPrefillColor) > 0) {
+        gc.cache.fillStyle = gridPrefillColor;
+        gc.fillRect(0, 0, viewWidth, viewHeight);
+    }
+
+    if (paintCellsByColumnsAndRows.reset) {
+        this.resetAllGridRenderers();
+        paintCellsByColumnsAndRows.reset = false;
+        bundleRows.call(this, false);
+        bundleColumns.call(this, true);
+    } else if (paintCellsByColumnsAndRows.rebundle) {
+        paintCellsByColumnsAndRows.rebundle = false;
+        bundleColumns.call(this);
+    }
+
+    rowBundles = this.rowBundles;
+    if (rowBundles.length) {
+        rowPrefillColors = this.rowPrefillColors;
+        for (r = rowBundles.length; r--;) {
+            rowBundle = rowBundles[r];
+            gc.clearFill(0, rowBundle.top, viewWidth, rowBundle.bottom - rowBundle.top, rowBundle.backgroundColor);
+        }
+    } else {
+        for (columnBundles = this.columnBundles, c = columnBundles.length; c--;) {
+            columnBundle = columnBundles[c];
+            gc.clearFill(columnBundle.left, 0, columnBundle.right - columnBundle.left, viewHeight, columnBundle.backgroundColor);
+        }
+    }
+
+    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);
+
+    // For each column...
+    for (p = 0, c = c0; c < C; c++) {
+        cellEvent = pool[p];
+        vc = cellEvent.visibleColumn;
+
+        if (!rowPrefillColors) {
+            prefillColor = cellEvent.column.properties.backgroundColor;
+        }
+
+        // Optionally clip to visible portion of column to prevent text from overflowing to right.
+        columnClip = vc.column.properties.columnClip;
+        gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);
+
+        // For each row of each subgrid (of each column)...
+        for (preferredWidth = r = 0; r < R; r++, p++) {
+            if (!pool[p].disabled) {
+                if (rowPrefillColors) {
+                    prefillColor = rowPrefillColors[r];
+                }
+
+                try {
+                    preferredWidth = Math.max(preferredWidth, this._paintCell(gc, pool[p], prefillColor));
+                } catch (e) {
+                    this.renderErrorCell(e, gc, vc, pool[p].visibleRow);
+                }
+            }
+        }
+
+        gc.clipRestore(columnClip);
+
+        cellEvent.column.properties.preferredWidth = Math.round(preferredWidth);
+    }
+
+    // gc.clipRestore(clipToGrid);
+
+    this.paintGridlines(gc);
+}
+
+paintCellsByColumnsAndRows.key = 'by-columns-and-rows';
+paintCellsByColumnsAndRows.rebundle = false; // see rebundleGridRenderers
+
+module.exports = paintCellsByColumnsAndRows;
diff --git a/src/renderer/by-columns-discrete.js b/src/renderer/by-columns-discrete.js
new file mode 100644
index 0000000..b395f79
--- /dev/null
+++ b/src/renderer/by-columns-discrete.js
@@ -0,0 +1,90 @@
+'use strict';
+
+var bundleColumns = require('./bundle-columns');
+
+/** @summary Render the grid with discrete column rects.
+ * @desc Paints all the cells of a grid, one column at a time.
+ *
+ * In this grid renderer, a background rect is _not_ drawn using the grid background color.
+ *
+ * Rather, all columns paint their own background rects, with color defaulting to grid background color.
+ *
+ * The idea of painting each column rect is to "clip" text that might have overflowed from the previous column by painting over it with the background from this column. Only the last column will show overflowing text, and only if the canvas width exceeds the grid width. If this is the case, you can turn on clipping for the last column only by setting `columnClip` to `true` for the last column.
+ *
+ * NOTE: As a convenience feature, setting `columnClip` to `null` will clip only the last column, so simply setting it on the grid (rather than the last column) will have the same effect. This is much more convenient because you don't have to worry about the last column being redefined (moved, hidden, etc).
+ *
+ * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
+ * The error message is error-logged to console AND displayed in cell.
+ *
+ * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
+ *
+ * See also the discussion of clipping in {@link Renderer#paintCellsByColumnsDiscrete|paintCellsByColumnsDiscrete}.
+
+ * @this {Renderer}
+ * @param {CanvasRenderingContext2D} gc
+ * @memberOf Renderer.prototype
+ */
+function paintCellsByColumnsDiscrete(gc) {
+    var grid = this.grid,
+        gridProps = grid.properties,
+        prefillColor,
+        cellEvent,
+        vc, visibleColumns = this.visibleColumns,
+        visibleRows = this.visibleRows,
+        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0, cLast = C - 1,
+        r, R = visibleRows.length,
+        p, pool = this.cellEventPool,
+        preferredWidth,
+        columnClip,
+        // clipToGrid,
+        // viewWidth = C ? visibleColumns[C - 1].right : 0,
+        viewHeight = R ? visibleRows[R - 1].bottom : 0;
+
+    gc.clearRect(0, 0, this.bounds.width, this.bounds.height);
+
+    if (!C || !R) { return; }
+
+    if (paintCellsByColumnsDiscrete.reset) {
+        this.resetAllGridRenderers(['by-columns']);
+        paintCellsByColumnsDiscrete.reset = false;
+        bundleColumns.call(this, true);
+    }
+
+    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);
+
+    // For each column...
+    for (p = 0, c = c0; c < C; c++) {
+        cellEvent = pool[p]; // first cell in column c
+        vc = cellEvent.visibleColumn;
+
+        prefillColor = cellEvent.column.properties.backgroundColor;
+        gc.clearFill(vc.left, 0, vc.width, viewHeight, prefillColor);
+
+        // Optionally clip to visible portion of column to prevent text from overflowing to right.
+        columnClip = vc.column.properties.columnClip;
+        gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);
+
+        // For each row of each subgrid (of each column)...
+        for (preferredWidth = r = 0; r < R; r++, p++) {
+            cellEvent = pool[p]; // next cell down the column (redundant for first cell in column)
+
+            try {
+                preferredWidth = Math.max(preferredWidth, this._paintCell(gc, cellEvent, prefillColor));
+            } catch (e) {
+                this.renderErrorCell(e, gc, vc, cellEvent.visibleRow);
+            }
+        }
+
+        gc.clipRestore(columnClip);
+
+        cellEvent.column.properties.preferredWidth = Math.round(preferredWidth);
+    }
+
+    // gc.clipRestore(clipToGrid);
+
+    this.paintGridlines(gc);
+}
+
+paintCellsByColumnsDiscrete.key = 'by-columns-discrete';
+
+module.exports = paintCellsByColumnsDiscrete;
diff --git a/src/renderer/by-columns.js b/src/renderer/by-columns.js
new file mode 100644
index 0000000..c7bb4e6
--- /dev/null
+++ b/src/renderer/by-columns.js
@@ -0,0 +1,108 @@
+'use strict';
+
+var bundleColumns = require('./bundle-columns');
+
+/** @summary Render the grid with consolidated column rects.
+ * @desc Paints all the cells of a grid, one column at a time.
+ *
+ * First, a background rect is drawn using the grid background color.
+ *
+ * Then, if there are any columns with their own background color _that differs from the grid background color,_ these are consolidated and the consolidated groups of column backgrounds are all drawn before iterating through cells. Note that these column rects are _not_ suitable for clipping overflow text from previous columns. If you have overflow text, either turn on clipping (big performance hit) or turn on one of the `truncateTextWithEllipsis` options.
+ *
+ * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
+ * The error message is error-logged to console AND displayed in cell.
+ *
+ * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
+ *
+ * **Regading clipping.** The reason for clipping is to prevent text from overflowing into the next column. However there is a serious performance cost.
+ *
+ * For performance reasons {@link Renderer#_paintCell|_paintCell} does not set up a clipping region for each cell. However, iff grid property `columnClip` is truthy, this grid renderer will set up a clipping region to prevent text overflow to right. If `columnClip` is `null`, a clipping region will only be set up on the last column. Otherwise, there will be no clipping region.
+ *
+ * The idea of clipping just the last column is because in addition to the optional graphics clipping, we also clip ("truncate") text. Text can be truncated conservatively so it will never overflow. The problem with this is that characters vanish as they hit the right cell boundary, which may or may be obvious depending on font size. Alternatively, text can be truncated so that the overflow will be a maximum of 1 character. This allows partial characters to be rendered. But this is where graphics clipping is required.
+ *
+ * When renderering column by column as this particular renderer does, _and_ when the background color _of the next cell to the right_ is opaque (alpha = 1), clipping can be turned off because each column will _overpaint_ any text that overflowed from the one before. However, any text that overflows the last column will paint into unused canvas region to the right of the grid. This is the _raison d'tre_ for "clip last column only" option mentioned above (when `columnClip` is set to `null`). To avoid even this performance cost (of clipping just the last column), column widths can be set to fill the available canvas.
+ *
+ * Note that text never overflows to left because text starting point is never < 0. The reason we don't clip to the left is for cell renderers that need to re-render to the left to produce a merged cell effect, such as grouped column header.
+
+ * @this {Renderer}
+ * @param {CanvasRenderingContext2D} gc
+ * @memberOf Renderer.prototype
+ */
+function paintCellsByColumns(gc) {
+    var grid = this.grid,
+        gridProps = grid.properties,
+        prefillColor, gridPrefillColor = gridProps.backgroundColor,
+        cellEvent,
+        columnBundle, columnBundles,
+        vc, visibleColumns = this.visibleColumns,
+        visibleRows = this.visibleRows,
+        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0, cLast = C - 1,
+        r, R = visibleRows.length,
+        p, pool = this.cellEventPool,
+        preferredWidth,
+        columnClip,
+        // clipToGrid,
+        viewWidth = C ? visibleColumns[cLast].right : 0,
+        viewHeight = R ? visibleRows[R - 1].bottom : 0;
+
+    gc.clearRect(0, 0, this.bounds.width, this.bounds.height);
+
+    if (!C || !R) { return; }
+
+    if (gc.alpha(gridPrefillColor) > 0) {
+        gc.cache.fillStyle = gridPrefillColor;
+        gc.fillRect(0, 0, viewWidth, viewHeight);
+    }
+
+    if (paintCellsByColumns.reset) {
+        this.resetAllGridRenderers(['by-columns-discrete']);
+        paintCellsByColumns.reset = false;
+        bundleColumns.call(this, true);
+    } else if (paintCellsByColumns.rebundle) {
+        paintCellsByColumns.rebundle = false;
+        bundleColumns.call(this);
+    }
+
+    for (columnBundles = this.columnBundles, c = columnBundles.length; c--;) {
+        columnBundle = columnBundles[c];
+        gc.clearFill(columnBundle.left, 0, columnBundle.right - columnBundle.left, viewHeight, columnBundle.backgroundColor);
+    }
+
+    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);
+
+    // For each column...
+    for (p = 0, c = c0; c < C; c++) {
+        cellEvent = pool[p]; // first cell in column c
+        vc = cellEvent.visibleColumn;
+
+        prefillColor = cellEvent.column.properties.backgroundColor;
+
+        // Optionally clip to visible portion of column to prevent text from overflowing to right.
+        columnClip = vc.column.properties.columnClip;
+        gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);
+
+        // For each row of each subgrid (of each column)...
+        for (preferredWidth = r = 0; r < R; r++, p++) {
+            cellEvent = pool[p]; // next cell down the column (redundant for first cell in column)
+
+            try {
+                preferredWidth = Math.max(preferredWidth, this._paintCell(gc, cellEvent, prefillColor));
+            } catch (e) {
+                this.renderErrorCell(e, gc, vc, cellEvent.visibleRow);
+            }
+        }
+
+        gc.clipRestore(columnClip);
+
+        cellEvent.column.properties.preferredWidth = Math.round(preferredWidth);
+    }
+
+    // gc.clipRestore(clipToGrid);
+
+    this.paintGridlines(gc);
+}
+
+paintCellsByColumns.key = 'by-columns';
+paintCellsByColumns.rebundle = false; // see rebundleGridRenderers
+
+module.exports = paintCellsByColumns;
diff --git a/src/renderer/by-rows.js b/src/renderer/by-rows.js
new file mode 100644
index 0000000..33acd2c
--- /dev/null
+++ b/src/renderer/by-rows.js
@@ -0,0 +1,106 @@
+'use strict';
+
+var bundleRows = require('./bundle-rows');
+
+/** @summary Render the grid.
+ * @desc _**NOTE:** This grid renderer is not as performant as the others and it's use is not recommended if you care about performance. The reasons for the wanting performance are unclear, possibly having to do with the way Chrome optimizes access to the column objects?_
+ *
+ * Paints all the cells of a grid, one row at a time.
+ *
+ * First, a background rect is drawn using the grid background color.
+ *
+ * Then, if there are any rows with their own background color _that differs from the grid background color,_ these are consolidated and the consolidated groups of row backgrounds are all drawn before iterating through cells.
+ *
+ * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
+ * The error message is error-logged to console AND displayed in cell.
+ *
+ * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
+ *
+ * See also the discussion of clipping in {@link Renderer#paintCellsByColumns|paintCellsByColumns}.
+ * @this {Renderer}
+ * @param {CanvasRenderingContext2D} gc
+ * @memberOf Renderer.prototype
+ */
+function paintCellsByRows(gc) {
+    var grid = this.grid,
+        gridProps = grid.properties,
+        prefillColor, rowPrefillColors, gridPrefillColor = gridProps.backgroundColor,
+        cellEvent,
+        rowBundle, rowBundles = this.rowBundles,
+        vc, visibleColumns = this.visibleColumns,
+        vr, visibleRows = this.visibleRows,
+        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0, cLast = C - 1,
+        r, R = visibleRows.length,
+        p, pool = this.cellEventPool,
+        preferredWidth = Array(C - c0).fill(0),
+        columnClip,
+        // clipToGrid,
+        viewWidth = C ? visibleColumns[C - 1].right : 0,
+        viewHeight = R ? visibleRows[R - 1].bottom : 0,
+        lineWidth = gridProps.lineWidth,
+        lineColor = gridProps.lineColor;
+
+    gc.clearRect(0, 0, this.bounds.width, this.bounds.height);
+
+    if (!C || !R) { return; }
+
+    if (gc.alpha(gridPrefillColor) > 0) {
+        gc.cache.fillStyle = gridPrefillColor;
+        gc.fillRect(0, 0, viewWidth, viewHeight);
+    }
+
+    if (paintCellsByRows.reset) {
+        this.resetAllGridRenderers();
+        paintCellsByRows.reset = false;
+        bundleRows.call(this, true);
+    }
+
+    rowPrefillColors = this.rowPrefillColors;
+
+    for (r = rowBundles.length; r--;) {
+        rowBundle = rowBundles[r];
+        gc.clearFill(0, rowBundle.top, viewWidth, rowBundle.bottom - rowBundle.top, rowBundle.backgroundColor);
+    }
+
+    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);
+
+    // For each row of each subgrid...
+    for (p = 0, r = 0; r < R; r++) {
+        prefillColor = rowPrefillColors[r];
+
+        if (gridProps.gridLinesH) {
+            gc.cache.fillStyle = lineColor;
+            gc.fillRect(0, pool[p].visibleRow.bottom, viewWidth, lineWidth);
+        }
+
+        // For each column (of each row)...
+        for (c = c0; c < C; c++, p++) {
+            cellEvent = pool[p]; // next cell across the row (redundant for first cell in row)
+            vc = cellEvent.visibleColumn;
+
+            // Optionally clip to visible portion of column to prevent text from overflowing to right.
+            columnClip = vc.column.properties.columnClip;
+            gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);
+
+            try {
+                preferredWidth[c] = Math.max(preferredWidth[c], this._paintCell(gc, cellEvent, prefillColor));
+            } catch (e) {
+                this.renderErrorCell(e, gc, vc, vr);
+            }
+
+            gc.clipRestore(columnClip);
+        }
+    }
+
+    // gc.clipRestore(clipToGrid);
+
+    this.paintGridlines(gc);
+
+    for (c = c0; c < C; c++) {
+        visibleColumns[c].column.properties.preferredWidth = Math.round(preferredWidth[c]);
+    }
+}
+
+paintCellsByRows.key = 'by-rows';
+
+module.exports = paintCellsByRows;
diff --git a/src/renderer/index.js b/src/renderer/index.js
new file mode 100644
index 0000000..2e131ab
--- /dev/null
+++ b/src/renderer/index.js
@@ -0,0 +1,1222 @@
+/* eslint-env browser */
+/* global requestAnimationFrame */
+
+'use strict';
+
+var Base = require('../Base');
+var images = require('../../images/index');
+
+
+var visibleColumnPropertiesDescriptor = {
+    find: {
+        // Like Array.prototype.find except searches negative indexes as well.
+        value: function(iteratee, context) {
+            for (var i = -1; i in this; --i); // eslint-disable-line curly
+            while (++i) {
+                if (iteratee.call(context, this[i], i, this)) {
+                    return this[i];
+                }
+            }
+            return Array.prototype.find.call(this, iteratee, context);
+        }
+    }
+};
+
+
+/** @typedef {object} CanvasRenderingContext2D
+ * @see [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
+ */
+
+/** @typedef {object} visibleColumnDescriptor
+ * @property {number} index - A back reference to the element's array index in {@link Renderer#visibleColumns}.
+ * @property {number} columnIndex - Dereferences {@link Behavior#columns}, the subset of _active_ columns, specifying which column to show in that position.
+ * @property {number} left - Pixel coordinate of the left edge of this column, rounded to nearest integer.
+ * @property {number} right - Pixel coordinate of the right edge of this column, rounded to nearest integer.
+ * @property {number} width - Width of this column in pixels, rounded to nearest integer.
+ */
+
+/** @typedef {object} visibleRowDescriptor
+ * @property {number} index - A back reference to the element's array index in {@link Renderer#visibleRows}.
+ * @property {number} rowIndex - Local vertical row coordinate within the subgrid to which the row belongs, adjusted for scrolling.
+ * @property {dataModelAPI} subgrid - A reference to the subgrid to which the row belongs.
+ * @property {number} top - Pixel coordinate of the top edge of this row, rounded to nearest integer.
+ * @property {number} bottom - Pixel coordinate of the bottom edge of this row, rounded to nearest integer.
+ * @property {number} height - Height of this row in pixels, rounded to nearest integer.
+ */
+
+/**
+ * @constructor
+ * @desc fin-hypergrid-renderer is the canvas enabled top level sub component that handles the renderering of the Grid.
+ *
+ * It relies on two other external subprojects
+ *
+ * 1. fin-canvas: a wrapper to provide a simpler interface to the HTML5 canvas component
+ * 2. rectangular: a small npm module providing Point and Rectangle objects
+ *
+ * The fin-hypergrid-renderer is in a unique position to provide critical functionality to the fin-hypergrid in a hightly performant manner.
+ * Because it MUST iterate over all the visible cells it can store various bits of information that can be encapsulated as a service for consumption by the fin-hypergrid component.
+ *
+ * Instances of this object have basically four main functions.
+ *
+ * 1. render fixed row headers
+ * 2. render fixed col headers
+ * 3. render main data cells
+ * 4. render grid lines
+ *
+ * Same parameters as {@link Renderer#initialize|initialize}, which is called by this constructor.
+ *
+ */
+var Renderer = Base.extend('Renderer', {
+
+    //the shared single item "pooled" cell object for drawing each cell
+    cell: {
+        x: 0,
+        y: 0,
+        width: 0,
+        height: 0
+    },
+
+    scrollHeight: 0,
+
+    viewHeight: 0,
+
+    reset: function() {
+        this.bounds = {
+            width: 0,
+            height: 0
+        };
+
+        /**
+         * Represents the ordered set of visible columns. Array size is always the exact number of visible columns, the last of which may only be partially visible.
+         *
+         * This sequence of elements' `columnIndex` values assumes one of three patterns. Which pattern is base on the following two questions:
+         * * Are there "fixed" columns on the left?
+         * * Is the grid horizontally scrolled?
+         *
+         * The set of `columnIndex` values consists of:
+         * 1. The first element will be -1 if the row handle column is being rendered.
+         * 2. A zero-based list of consecutive of integers representing the fixed columns (if any).
+         * 3. An n-based list of consecutive of integers representing the scrollable columns (where n = number of fixed columns + the number of columns scrolled off to the left).
+         * @type {visibleColumnDescriptor}
+         */
+        this.visibleColumns = Object.defineProperties([], visibleColumnPropertiesDescriptor);
+
+        /**
+         * Represents the ordered set of visible rows. Array size is always the exact number of visible rows.
+         *
+         * The sequence of elements' `rowIndex` values is local to each subgrid.
+         * * **For each non-scrollable subgrid:** The sequence is a zero-based list of consecutive integers.
+         * * **For the scrollable subgrid:**
+         *   1. A zero-based list of consecutive of integers representing the fixed rows (if any).
+         *   2. An n-based list of consecutive of integers representing the scrollable rows (where n = number of fixed rows + the number of rows scrolled off the top).
+         *
+         * Note that non-scrollable subgrids can come both before _and_ after the scrollable subgrid.
+         * @type {visibleRowDescriptor}
+         */
+        this.visibleRows = [];
+
+        this.insertionBounds = [];
+
+        this.cellEventPool = [];
+    },
+
+    /**
+     * @summary Constructor logic
+     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
+     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
+     * @memberOf Renderer.prototype
+     */
+    initialize: function(grid) {
+        this.grid = grid;
+
+        // typically grid properties won't exist yet
+        this.setGridRenderer(this.properties.gridRenderer || 'by-columns-and-rows');
+
+        this.reset();
+    },
+
+    gridRenderers: {},
+
+    registerGridRenderer: function(gridRenderer, name) {
+        this.gridRenderers[name || gridRenderer.key] = gridRenderer;
+    },
+
+    setGridRenderer: function(key) {
+        var paintCells = this.gridRenderers[key];
+
+        if (!paintCells) {
+            throw new this.HypergridError('Unregistered grid renderer "' + key + '"');
+        }
+
+        if (paintCells !== this.paintCells) {
+            this.paintCells = paintCells;
+            this.paintCells.reset = true;
+        }
+    },
+
+    resetAllGridRenderers: function(blackList) {
+        // Notify renderers that grid shape has changed
+        Object.keys(this.gridRenderers).forEach(function(key) {
+            this.gridRenderers[key].reset = !blackList || blackList.indexOf(key) < 0;
+        }, this);
+    },
+
+    /**
+     * Certain renderers that pre-bundle column rects based on columns' background colors need to re-bundle when columns' background colors change. This method sets the `rebundle` property to `true` for those renderers that have that property.
+     */
+    rebundleGridRenderers: function() {
+        Object.keys(this.gridRenderers).forEach(function(key) {
+            if ('rebundle' in this.gridRenderers[key]) {
+                this.gridRenderers[key].rebundle = true;
+            }
+        }, this);
+    },
+
+    /**
+     * This function creates several data structures:
+     * * {@link Renderer#visibleColumns}
+     * Original comment:
+     * "this function computes the grid coordinates used for extremely fast iteration over
+     * painting the grid cells. this function is very fast, for thousand rows X 100 columns
+     * on a modest machine taking usually 0ms and no more that 3 ms."
+     */
+    computeCellsBounds: function() {
+
+        //var startTime = Date.now();
+
+        var scrollTop = this.getScrollTop(),
+            scrollLeft = this.getScrollLeft(),
+
+            fixedColumnCount = this.grid.getFixedColumnCount(),
+            fixedRowCount = this.grid.getFixedRowCount(),
+
+            bounds = this.getBounds(),
+            grid = this.grid,
+            behavior = grid.behavior,
+            editorCellEvent = grid.cellEditor && grid.cellEditor.event,
+
+            vcEd, xEd,
+            vrEd, yEd,
+            sgEd, isSubgridEd,
+
+            insertionBoundsCursor = 0,
+            previousInsertionBoundsCursorValue = 0,
+
+            lineWidth = grid.properties.lineWidth,
+
+            start = grid.properties.showRowNumbers ? -1 : 0,
+            x, X, // horizontal pixel loop index and limit
+            y, Y, // vertical pixel loop index and limit
+            c, C, // column loop index and limit
+            g, G, // subgrid loop index and limit
+            r, R, // row loop index and limitrows in current subgrid
+            subrows, // rows in subgrid g
+            base, // sum of rows for all subgrids so far
+            subgrids = behavior.subgrids,
+            subgrid,
+            rowIndex,
+            scrollableSubgrid,
+            footerHeight,
+            vx, vy,
+            vr, vc,
+            width, height,
+            firstVX, lastVX,
+            firstVY, lastVY,
+            topR,
+            xSpaced, widthSpaced, heightSpaced; // adjusted for cell spacing
+
+        if (editorCellEvent) {
+            xEd = editorCellEvent.gridCell.x;
+            yEd = editorCellEvent.dataCell.y;
+            sgEd = editorCellEvent.subgrid;
+        }
+
+        this.scrollHeight = 0;
+
+        this.visibleColumns.length = 0;
+        this.visibleRows.length = 0;
+
+        this.visibleColumnsByIndex = []; // array because number of columns will always be reasonable
+        this.visibleRowsByDataRowIndex = {}; // hash because keyed by (fixed and) scrolled row indexes
+
+        this.insertionBounds = [];
+
+        for (
+            x = 0, c = start, C = this.grid.getColumnCount(), X = bounds.width || grid.canvas.width;
+            c < C && x <= X;
+            c++
+        ) {
+            vx = c;
+            if (c >= fixedColumnCount) {
+                lastVX = vx += scrollLeft;
+                if (firstVX === undefined) {
+                    firstVX = lastVX;
+                }
+            }
+            if (vx >= C) {
+                break; // scrolled beyond last column
+            }
+
+            width = Math.ceil(behavior.getColumnWidth(vx));
+
+            xSpaced = x ? x + lineWidth : x;
+            widthSpaced = x ? width - lineWidth : width;
+            this.visibleColumns[c] = this.visibleColumnsByIndex[vx] = vc = {
+                index: c,
+                columnIndex: vx,
+                column: behavior.getActiveColumn(vx),
+                left: xSpaced,
+                width: widthSpaced,
+                right: xSpaced + widthSpaced
+            };
+            if (xEd === vx) {
+                vcEd = vc;
+            }
+
+            x += width;
+
+            insertionBoundsCursor += Math.round(width / 2) + previousInsertionBoundsCursorValue;
+            this.insertionBounds.push(insertionBoundsCursor);
+            previousInsertionBoundsCursorValue = Math.round(width / 2);
+        }
+
+        // get height of total number of rows in all subgrids following the data subgrid
+        footerHeight = grid.properties.defaultRowHeight *
+            subgrids.reduce(function(rows, subgrid) {
+                if (scrollableSubgrid) {
+                    rows += subgrid.getRowCount();
+                } else {
+                    scrollableSubgrid = subgrid.isData;
+                }
+                return rows;
+            }, 0);
+
+        for (
+            base = r = g = y = 0, G = subgrids.length, Y = bounds.height - footerHeight;
+            g < G;
+            g++, base += subrows
+        ) {
+            subgrid = subgrids[g];
+            subrows = subgrid.getRowCount();
+            scrollableSubgrid = subgrid.isData;
+            isSubgridEd = (sgEd === subgrid);
+            topR = r;
+
+            // For each row of each subgrid...
+            for (R = r + subrows; r < R && y < Y; r++) {
+                vy = r;
+                if (scrollableSubgrid && r >= fixedRowCount) {
+                    vy += scrollTop;
+                    lastVY = vy - base;
+                    if (firstVY === undefined) {
+                        firstVY = lastVY;
+                    }
+                    if (vy >= R) {
+                        break; // scrolled beyond last row
+                    }
+                }
+
+                rowIndex = vy - base;
+                height = behavior.getRowHeight(rowIndex, subgrid);
+
+                heightSpaced = height - lineWidth;
+                this.visibleRows[r] = vr = {
+                    index: r,
+                    subgrid: subgrid,
+                    rowIndex: rowIndex,
+                    top: y,
+                    height: heightSpaced,
+                    bottom: y + heightSpaced
+                };
+
+                if (scrollableSubgrid) {
+                    this.visibleRowsByDataRowIndex[vy - base] = vr;
+                }
+
+                if (isSubgridEd && yEd === rowIndex) {
+                    vrEd = vr;
+                }
+
+                y += height;
+            }
+
+            if (scrollableSubgrid) {
+                subrows = r - topR;
+                Y += footerHeight;
+            }
+        }
+
+        if (editorCellEvent) {
+            editorCellEvent.visibleColumn = vcEd;
+            editorCellEvent.visibleRow = vrEd;
+            editorCellEvent.gridCell.y = vrEd && vrEd.index;
+            editorCellEvent._bounds = null;
+        }
+
+        this.viewHeight = Y;
+
+        this.dataWindow = this.grid.newRectangle(firstVX, firstVY, lastVX - firstVX, lastVY - firstVY);
+
+        // Resize CellEvent pool
+        var pool = this.cellEventPool,
+            previousLength = pool.length,
+            P = (this.visibleColumns.length - start) * this.visibleRows.length;
+
+        if (P > previousLength) {
+            pool.length = P; // grow pool to accommodate more cells
+        }
+        for (var p = previousLength; p < P; p++) {
+            pool[p] = new behavior.CellEvent; // instantiate new members
+        }
+
+        this.resetAllGridRenderers();
+    },
+
+    /**
+     * CAUTION: Keep in place! Used by {@link Canvas}.
+     * @memberOf Renderer.prototype
+     * @returns {Object} The current grid properties object.
+     */
+    get properties() {
+        return this.grid.properties;
+    },
+
+    /**
+     * Previously used by fin-canvas.
+     * @memberOf Renderer.prototype
+     * @returns {Object} a property value at a key, delegates to the grid
+     * @deprecated
+     */
+    resolveProperty: function(key) {
+        this.deprecated('resolveProperty', 'The .resolveProperty(key) method is deprecated as of v1.2.10 in favor of the .grid.properties object dereferenced with [key]. (Will be removed in a future release.)');
+        return this.properties[key];
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @summary Notify the fin-hypergrid every time we've repainted.
+     * @desc This is the entry point from fin-canvas.
+     * @param {CanvasRenderingContext2D} gc
+     */
+    paint: function(gc) {
+        if (this.grid.canvas) {
+            this.renderGrid(gc);
+            this.grid.gridRenderedNotification();
+        }
+    },
+
+    tickNotification: function() {
+        this.grid.tickNotification();
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {number} Answer how many rows we rendered
+     */
+    getVisibleRowsCount: function() {
+        return this.visibleRows.length - 1;
+    },
+
+    getVisibleScrollHeight: function() {
+        return this.viewHeight - this.grid.getFixedRowsHeight();
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {number[]} Rows we just rendered.
+     */
+    getVisibleRows: function() {
+        this.deprecated('getVisibleRows', 'The getVisibleRows() method has been deprecated as of v1.2.0. (Will be removed in a future version.) Previously returned the this.visibleRows array but because this.visibleRows is no longer a simple array of integers but is now an array of objects, it now returns an array mapped to this.visibleRows[*].rowIndex. Note however that this mapping is not equivalent to what this method previously returned because while each object\'s .rowIndex property is still adjusted for scrolling within the data subgrid, the index is now local to (zero-based within) each subgrid');
+        return this.visibleRows.map(function(vr) { return vr.rowIndex; });
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {number} Number of columns we just rendered.
+     */
+    getVisibleColumnsCount: function() {
+        return this.visibleColumns.length - 1;
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {number} Columns we just rendered.
+     */
+    getVisibleColumns: function() {
+        this.deprecated('visibleColumns', 'The getVisibleColumns() method has been deprecated as of v1.2.0. (Will be removed in a future version.) Previously returned the this.visibleColumns but because this.visibleColumns is no longer a simple array of integers but is now an array of objects, it now returns an array mapped to the equivalent visibleColumns[*].columnIndex.');
+        return this.visibleColumns.map(function(vc) { return vc.columnIndex; });
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @param {CellEvent|number} x - CellEvent object or grid column coordinate.
+     * @param {number} [y] - Grid row coordinate. Omit if `xOrCellEvent` is a CellEvent.
+     * @returns {Rectangle} Bounding rect of cell with the given coordinates.
+     */
+    getBoundsOfCell: function(x, y) {
+        var vc = this.visibleColumns[x],
+            vr = this.visibleRows[y];
+
+        return {
+            x: vc.left,
+            y: vr.top,
+            width: vc.width,
+            height: vr.height
+        };
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @desc answer the column index under the coordinate at pixelX
+     * @param {number} pixelX - The horizontal coordinate.
+     * @returns {number} The column index under the coordinate at pixelX.
+     */
+    getColumnFromPixelX: function(pixelX) {
+        var width = 0,
+            fixedColumnCount = this.grid.getFixedColumnCount(),
+            scrollLeft = this.grid.getHScrollValue(),
+            visibleColumns = this.visibleColumns;
+
+        for (var c = 1; c < visibleColumns.length - 1; c++) {
+            width = visibleColumns[c].left - (visibleColumns[c].left - visibleColumns[c - 1].left) / 2;
+            if (pixelX < width) {
+                if (c > fixedColumnCount) {
+                    c += scrollLeft;
+                }
+                return c - 1;
+            }
+        }
+        if (c > fixedColumnCount) {
+            c += scrollLeft;
+        }
+        return c - 1;
+    },
+
+
+    /**
+     * @memberOf Renderer.prototype
+     * @desc Answer specific data cell coordinates given mouse coordinates in pixels.
+     * @param {Point} point
+     * @returns {Point} Cell coordinates
+     */
+    getGridCellFromMousePoint: function(point) {
+
+        var x = point.x,
+            y = point.y,
+            isPseudoRow = false,
+            isPseudoCol = false,
+            vrs = this.visibleRows,
+            vcs = this.visibleColumns,
+            firstColumn = vcs[this.properties.showRowNumbers ? -1 : 0],
+            inFirstColumn = x < firstColumn.right,
+            vc = inFirstColumn ? firstColumn : vcs.find(function(vc) { return x < vc.right; }),
+            vr = vrs.find(function(vr) { return y < vr.bottom; }),
+            result = {fake: false};
+
+        //default to last row and col
+        if (vr) {
+            isPseudoRow = false;
+        } else {
+            vr = vrs[vrs.length - 1];
+            isPseudoRow = true;
+        }
+
+        if (vc) {
+            isPseudoCol = false;
+        } else {
+            vc = vcs[vcs.length - 1];
+            isPseudoCol = true;
+        }
+
+        var mousePoint = this.grid.newPoint(x - vc.left, y - vr.top),
+            cellEvent = new this.grid.behavior.CellEvent(vc.columnIndex, vr.index);
+
+        // cellEvent.visibleColumn = vc;
+        // cellEvent.visibleRow = vr;
+
+        result.cellEvent = Object.defineProperty(cellEvent, 'mousePoint', {value: mousePoint});
+
+        if (isPseudoCol || isPseudoRow) {
+            result.fake = true;
+            this.grid.beCursor(null);
+        }
+
+        return result;
+    },
+
+    /**
+     * @summary Get the visibility of the column matching the provided grid column index.
+     * @desc Requested column may not be visible due to being scrolled out of view.
+     * @memberOf Renderer.prototype
+     * @summary Determines if a column is visible.
+     * @param {number} columnIndex - the column index
+     * @returns {boolean} The given column is visible.
+     */
+    isColumnVisible: function(columnIndex) {
+        return !!this.getVisibleColumn(columnIndex);
+    },
+
+    /**
+     * @summary Get the "visible column" object matching the provided grid column index.
+     * @desc Requested column may not be visible due to being scrolled out of view.
+     * @memberOf Renderer.prototype
+     * @summary Find a visible column object.
+     * @param {number} columnIndex - The grid column index.
+     * @returns {object|undefined} The given column if visible or `undefined` if not.
+     */
+    getVisibleColumn: function(columnIndex) {
+        return this.visibleColumns.find(function(vc) {
+            return vc.columnIndex === columnIndex;
+        });
+    },
+
+    /**
+     * @summary Get the visibility of the column matching the provided data column index.
+     * @desc Requested column may not be visible due to being scrolled out of view or if the column is inactive.
+     * @memberOf Renderer.prototype
+     * @summary Determines if a column is visible.
+     * @param {number} columnIndex - the column index
+     * @returns {boolean} The given column is visible.
+     */
+    isDataColumnVisible: function(columnIndex) {
+        return !!this.getVisibleDataColumn(columnIndex);
+    },
+
+    /**
+     * @summary Get the "visible column" object matching the provided data column index.
+     * @desc Requested column may not be visible due to being scrolled out of view or if the column is inactive.
+     * @memberOf Renderer.prototype
+     * @summary Find a visible column object.
+     * @param {number} columnIndex - The grid column index.
+     * @returns {object|undefined} The given column if visible or `undefined` if not.
+     */
+    getVisibleDataColumn: function(columnIndex) {
+        return this.visibleColumns.find(function(vc) {
+            return vc.column.index === columnIndex;
+        });
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {number} The width x coordinate of the last rendered column
+     */
+    getFinalVisibleColumnBoundary: function() {
+        var chop = this.isLastColumnVisible() ? 2 : 1;
+        var colWall = this.visibleColumns[this.visibleColumns.length - chop].right;
+        return Math.min(colWall, this.getBounds().width);
+    },
+
+    /**
+     * @summary Get the visibility of the row matching the provided grid row index.
+     * @desc Requested row may not be visible due to being outside the bounds of the rendered grid.
+     * @memberOf Renderer.prototype
+     * @summary Determines visibility of a row.
+     * @param {number} rowIndex - The grid row index.
+     * @returns {boolean} The given row is visible.
+     */
+    isRowVisible: function(rowIndex) {
+        return !!this.visibleRows[rowIndex];
+    },
+
+    /**
+     * @summary Get the "visible row" object matching the provided grid row index.
+     * @desc Requested row may not be visible due to being outside the bounds of the rendered grid.
+     * @memberOf Renderer.prototype
+     * @summary Find a visible row object.
+     * @param {number} rowIndex - The grid row index.
+     * @returns {object|undefined} The given row if visible or `undefined` if not.
+     */
+    getVisibleRow: function(rowIndex) {
+        return this.visibleRows[rowIndex];
+    },
+
+    /**
+     * @summary Get the visibility of the row matching the provided data row index.
+     * @desc Requested row may not be visible due to being scrolled out of view.
+     * @memberOf Renderer.prototype
+     * @summary Determines visibility of a row.
+     * @param {number} rowIndex - The data row index.
+     * @param {dataModelAPI} [subgrid=this.behavior.subgrids.data]
+     * @returns {boolean} The given row is visible.
+     */
+    isDataRowVisible: function(rowIndex, subgrid) {
+        return !!this.getVisibleDataRow(rowIndex, subgrid);
+    },
+
+    /**
+     * @summary Get the "visible row" object matching the provided data row index.
+     * @desc Requested row may not be visible due to being scrolled out of view.
+     * @memberOf Renderer.prototype
+     * @summary Find a visible row object.
+     * @param {number} rowIndex - The data row index within the given subgrid.
+     * @param {dataModelAPI} [subgrid=this.behavior.subgrids.data]
+     * @returns {object|undefined} The given row if visible or `undefined` if not.
+     */
+    getVisibleDataRow: function(rowIndex, subgrid) {
+        subgrid = subgrid || this.grid.behavior.subgrids.lookup.data;
+        return this.visibleRows.find(function(vr) {
+            return vr.subgrid === subgrid && vr.rowIndex === rowIndex;
+        });
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @summary Determines if a cell is selected.
+     * @param {number} x - the x cell coordinate
+     * @param {number} y - the y cell coordinate*
+     * @returns {boolean} The given cell is fully visible.
+     */
+    isSelected: function(x, y) {
+        return this.grid.isSelected(x, y);
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @desc This is the main forking of the renderering task.
+     * @param {CanvasRenderingContext2D} gc
+     */
+    renderGrid: function(gc) {
+        gc.beginPath();
+
+        this.buttonCells = {};
+        this.paintCells(gc);
+        resetNumberColumnWidth(gc, this.grid.behavior);
+
+        this.renderOverrides(gc);
+
+        this.renderLastSelection(gc);
+
+        gc.closePath();
+    },
+
+    renderLastSelection: function(gc) {
+        var selections = this.grid.selectionModel.getSelections();
+        if (!selections || selections.length === 0) {
+            return;
+        }
+
+        var selection = this.grid.selectionModel.getLastSelection();
+        if (selection.origin.x === -1) {
+            // no selected area, lets exit
+            return;
+        }
+
+        var vci = this.visibleColumnsByIndex,
+            vri = this.visibleRowsByDataRowIndex,
+            lastColumn = this.visibleColumns[this.visibleColumns.length - 1], // last column in scrollable section
+            lastRow = vri[this.dataWindow.corner.y]; // last row in scrollable data section
+        if (
+            !lastColumn || !lastRow ||
+            selection.origin.x > lastColumn.columnIndex ||
+            selection.origin.y > lastRow.rowIndex
+        ) {
+            // selection area begins to right or below grid
+            return;
+        }
+
+        var vcOrigin = vci[selection.origin.x],
+            vcCorner = vci[selection.corner.x],
+            vrOrigin = vri[selection.origin.y],
+            vrCorner = vri[selection.corner.y];
+        if (
+            !(vcOrigin || vcCorner) || // entire selection scrolled out of view to left of scrollable region
+            !(vrOrigin || vrCorner)    // entire selection scrolled out of view above scrollable region
+        ) {
+            return;
+        }
+
+        var gridProps = this.properties;
+        vcOrigin = vcOrigin || this.visibleColumns[gridProps.fixedColumnCount];
+        vrOrigin = vrOrigin || this.visibleRows[gridProps.fixedRowCount];
+        vcCorner = vcCorner || (selection.corner.x > lastColumn.columnIndex ? lastColumn : vci[gridProps.fixedColumnCount - 1]);
+        vrCorner = vrCorner || (selection.corner.y > lastRow.rowIndex ? lastRow : vri[gridProps.fixedRowCount - 1]);
+
+        // Render the selection model around the bounds
+        var config = {
+            bounds: {
+                x: vcOrigin.left,
+                y: vrOrigin.top,
+                width: vcCorner.right - vcOrigin.left,
+                height: vrCorner.bottom - vrOrigin.top
+            },
+            selectionRegionOverlayColor: this.paintCells.partial ? 'transparent' : gridProps.selectionRegionOverlayColor,
+            selectionRegionOutlineColor: gridProps.selectionRegionOutlineColor
+        };
+        this.grid.cellRenderers.get('lastselection').paint(gc, config);
+        if (this.paintCells.key === 'by-cells') {
+            this.paintCells.reset = true; // fixes GRID-490
+        }
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @desc iterate the renderering overrides and manifest each
+     * @param {CanvasRenderingContext2D} gc
+     */
+    renderOverrides: function(gc) {
+        var cache = this.grid.renderOverridesCache;
+        for (var key in cache) {
+            if (cache.hasOwnProperty(key)) {
+                var override = cache[key];
+                if (override) {
+                    this.renderOverride(gc, override);
+                }
+            }
+        }
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @desc copy each overrides specified area to it's target and blank out the source area
+     * @param {CanvasRenderingContext2D} gc
+     * @param {OverrideObject} override - an object with details contain an area and a target context
+     */
+    renderOverride: function(gc, override) {
+        //lets blank out the drag row
+        var hdpiRatio = override.hdpiratio;
+        var startX = override.startX; //hdpiRatio * edges[override.columnIndex];
+        var width = override.width + 1;
+        var height = override.height;
+        var targetCTX = override.ctx;
+        var imgData = gc.getImageData(startX, 0, Math.round(width * hdpiRatio), Math.round(height * hdpiRatio));
+        targetCTX.putImageData(imgData, 0, 0);
+        gc.cache.fillStyle = this.properties.backgroundColor2;
+        gc.fillRect(Math.round(startX / hdpiRatio), 0, width, height);
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {number} Current vertical scroll value.
+     */
+    getScrollTop: function() {
+        return this.grid.getVScrollValue();
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {number} Current horizontal scroll value.
+     */
+    getScrollLeft: function() {
+        return this.grid.getHScrollValue();
+    },
+
+    getColumnEdges: function() {
+        this.deprecated('columnEdges', 'The getColumnEdges() mehtod has been deprecated as of version 1.2.0 in favor of visibleColumns[*].top. (Will be removed in a future version.) Note however that columnEdges had one additional element (representing the right edge of the last visible column) which visibleColumns lacks. Instead you can reference visibleColumns[*].bottom.');
+        return this.visibleColumns.map(function(vc) { return vc.left; }).concat([this.visibleColumns[this.visibleColumns.length - 1].right]);
+    },
+
+    getRowEdges: function() {
+        this.deprecated('rowEdges', 'The getRowEdges() method has been deprecated as of version 1.2.0 in favor of visibleRows[*].top. (Will be removed in a future version.) Note however that rowEdges had one additional element (representing the bottom edge of the last visible row) which visibleRows lacks. Instead you can reference visibleRows[*].bottom.');
+        return this.visibleRows.map(function(vr) { return vr.top; }).concat([this.visibleRows[this.visibleRows.length - 1].bottom]);
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {boolean} The last col was rendered (is visible)
+     */
+    isLastColumnVisible: function() {
+        var lastColumnIndex = this.grid.getColumnCount() - 1;
+        return !!this.visibleColumns.find(function(vc) { return vc.columnIndex === lastColumnIndex; });
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {number} The rendered column width at index
+     */
+    getRenderedWidth: function(index) {
+        var result,
+            columns = this.visibleColumns;
+
+        if (index >= columns.length) {
+            result = columns[columns.length - 1].right;
+        } else {
+            result = columns[index].left;
+        }
+
+        return result;
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {number} The rendered row height at index
+     */
+    getRenderedHeight: function(index) {
+        var result,
+            rows = this.visibleRows;
+
+        if (index >= rows.length) {
+            var last = rows[rows.length - 1];
+            result = last.bottom;
+        } else {
+            result = rows[index].top;
+        }
+
+        return result;
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {fin-canvas} my [fin-canvas](https://github.com/stevewirts/fin-canvas)
+     */
+    getCanvas: function() {
+        return this.deprecated('getCanvas()', 'grid.canvas', '1.2.2');
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {boolean} User is currently dragging a column for reordering.
+     */
+    isDraggingColumn: function() {
+        return this.grid.isDraggingColumn();
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {number} The row to go to for a page up.
+     */
+    getPageUpRow: function() {
+        var grid = this.grid,
+            scrollHeight = this.getVisibleScrollHeight(),
+            top = this.dataWindow.origin.y - this.properties.fixedRowCount - 1,
+            scanHeight = 0;
+        while (scanHeight < scrollHeight && top >= 0) {
+            scanHeight += grid.getRowHeight(top);
+            top--;
+        }
+        return top + 1;
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @returns {number} The row to goto for a page down.
+     */
+    getPageDownRow: function() {
+        return this.dataWindow.corner.y - this.properties.fixedRowCount + 1;
+    },
+
+    renderErrorCell: function(err, gc, vc, vr) {
+        var message = err && (err.message || err) || 'Unknown error.',
+            bounds = { x: vc.left, y: vr.top, width: vc.width, height: vr.height },
+            config = { bounds: bounds };
+
+        console.error(message);
+
+        gc.cache.save(); // define clipping region
+        gc.beginPath();
+        gc.rect(bounds.x, bounds.y, bounds.width, bounds.height);
+        gc.clip();
+
+        this.grid.cellRenderers.get('errorcell').paint(gc, config, message);
+
+        gc.cache.restore(); // discard clipping region
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @desc We opted to not paint borders for each cell as that was extremely expensive. Instead we draw grid lines here.
+     * @param {CanvasRenderingContext2D} gc
+     */
+    paintGridlines: function(gc) {
+        var visibleColumns = this.visibleColumns, C = visibleColumns.length,
+            visibleRows = this.visibleRows, R = visibleRows.length;
+
+        if (C && R) {
+            var gridProps = this.properties,
+                lineWidth = gridProps.lineWidth,
+                lineColor = gridProps.lineColor;
+
+            if (gridProps.gridLinesV) {
+                gc.cache.fillStyle = lineColor;
+                var viewHeight = visibleRows[R - 1].bottom,
+                    c = gridProps.showRowNumbers ? -1 : 0;
+                if (gridProps.gridBorderLeft) {
+                    gc.fillRect(visibleColumns[c].left, 0, lineWidth, viewHeight);
+                }
+                for (c += 1; c < C; c++) {
+                    gc.fillRect(visibleColumns[c].left - lineWidth, 0, lineWidth, viewHeight);
+                }
+                if (gridProps.gridBorderRight) {
+                    gc.fillRect(visibleColumns[c - 1].right + 1 - lineWidth, 0, lineWidth, viewHeight);
+                }
+            }
+
+            if (gridProps.gridLinesH) {
+                gc.cache.fillStyle = lineColor;
+                var viewWidth = visibleColumns[C - 1].right;
+                if (gridProps.gridBorderTop) {
+                    gc.fillRect(0, visibleRows[0].top, viewWidth, lineWidth);
+                }
+                if (!gridProps.gridBorderBottom) {
+                    R -= 1;
+                }
+                if (gridProps.gridBorderRight) {
+                    viewWidth += lineWidth;
+                }
+                for (var r = 0; r < R; r++) {
+                    gc.fillRect(0, visibleRows[r].bottom, viewWidth, lineWidth);
+                }
+            }
+        }
+    },
+
+    /**
+     * @memberOf Renderer.prototype
+     * @param {CanvasRenderingContext2D} gc
+     * @param x
+     * @param y
+     */
+    paintCell: function(gc, x, y) {
+        gc.moveTo(0, 0);
+
+        var c = this.visibleColumns[x].index, // todo refac
+            r = this.visibleRows[y].index;
+
+        if (c) { //something is being viewed at at the moment (otherwise returns undefined)
+            this._paintCell(gc, c, r);
+        }
+    },
+
+    /**
+     * @summary Render a single cell.
+     * @desc IMPORTANT NOTE: Do not change the line below with the comment "SEE IMPORTANT NOTE ABOVE" without careful performance testing. Building the config object from cell properties object produced much slower rendering times. The original line was:
+     * ```javascript
+     *     config = Object.create(cellEvent.columnProperties),
+     * ```
+     * Cell properties object came into play when `cellEvent.properties` getter which returns cell properties object when there is one (else it returns column properties object). The reason seemed to be that doing so caused optimization to fail on the cell renderer function. The work-around was to always build the `config` object from the column properties object, and then _copy_ the "own" cell properties onto it. The current line is:
+     * ```javascript
+     *     config = Object.assign(Object.create(cellEvent.columnProperties), cellEvent.cellOwnProperties),
+     * ```
+     * We kept the cell properties object prototype in place (extended from column properties) for other logic.
+     * @param {CanvasRenderingContext2D} gc
+     * @param {CellEvent} cellEvent
+     * @param {string} [prefillColor] If omitted, this is a partial renderer; all other renderers must provide this.
+     * @returns {number} Preferred width of renndered cell.
+     * @private
+     * @memberOf Renderer
+     */
+    _paintCell: function(gc, cellEvent, prefillColor) {
+        var grid = this.grid,
+            selectionModel = grid.selectionModel,
+            behavior = grid.behavior,
+            subgrid = cellEvent.subgrid,
+
+            isHandleColumn = cellEvent.isHandleColumn,
+            isHierarchyColumn = cellEvent.isHierarchyColumn,
+            isColumnSelected = cellEvent.isColumnSelected,
+
+            isDataRow = cellEvent.isDataRow,
+            isRowSelected = cellEvent.isRowSelected,
+            isCellSelected = cellEvent.isCellSelected,
+
+            isHeaderRow = cellEvent.isHeaderRow,
+            isFilterRow = cellEvent.isFilterRow,
+
+            isRowHandleOrHierarchyColumn = isHandleColumn || isHierarchyColumn,
+            isUserDataArea = !isRowHandleOrHierarchyColumn && isDataRow,
+
+            config = Object.assign(Object.create(cellEvent.columnProperties), cellEvent.cellOwnProperties), // SEE IMPORTANT NOTE ABOVE
+            x = (config.gridCell = cellEvent.gridCell).x,
+            r = (config.dataCell = cellEvent.dataCell).y,
+
+            format,
+            isSelected;
+
+        if (isHandleColumn) {
+            isSelected = isRowSelected || selectionModel.isCellSelectedInRow(r);
+            config.halign = 'right';
+        } else if (isHierarchyColumn) {
+            isSelected = isRowSelected || selectionModel.isCellSelectedInRow(r);
+            config.halign = 'left';
+        } else if (isDataRow) {
+            isSelected = isCellSelected || isRowSelected || isColumnSelected;
+            format = config.format;
+
+            // Iff we have a defined rowProperties array, apply it to config, treating it as a repeating pattern, keyed to row index.
+            // Note that Object.assign will ignore undefined.
+            var row = cellEvent.columnProperties.rowProperties;
+            Object.assign(config, row && row[cellEvent.dataCell.y % row.length]);
+        } else {
+            format = subgrid.format || config.format; // subgrid format can override column format
+            if (isFilterRow) {
+                isSelected = false;
+            } else if (isColumnSelected) {
+                isSelected = true;
+            } else {
+                isSelected = selectionModel.isCellSelectedInColumn(x); // header or summary or other non-meta
+            }
+        }
+
+        // Set cell contents:
+        // * For all cells: set `config.value` (writable property)
+        // * For cells outside of row handle column: also set `config.dataRow` for use by valOrFunc
+        if (!isHandleColumn) {
+            config.dataRow = cellEvent.dataRow;
+            config.value = cellEvent.value;
+        } else {
+            config.isHandleColumn = true;
+            if (isDataRow) {
+                // row handle for a data row
+                config.value = r + 1; // row number is 1-based
+            } else if (isHeaderRow) {
+                // row handle for header row: gets "master" checkbox
+                config.allRowsSelected = selectionModel.areAllRowsSelected();
+            }
+        }
+
+        config.isSelected = isSelected;
+        config.isDataColumn = !isRowHandleOrHierarchyColumn;
+        config.isDataRow = isDataRow;
+        config.isHeaderRow = isHeaderRow;
+        config.isFilterRow = isFilterRow;
+        config.isUserDataArea = isUserDataArea;
+        config.isColumnHovered = cellEvent.isColumnHovered;
+        config.isRowHovered = cellEvent.isRowHovered;
+        config.isCellHovered = cellEvent.isCellHovered;
+        config.bounds = cellEvent.bounds;
+        config.isCellSelected = isCellSelected;
+        config.isRowSelected = isRowSelected;
+        config.isColumnSelected = isColumnSelected;
+        config.isInCurrentSelectionRectangle = selectionModel.isInCurrentSelectionRectangle(x, r);
+        config.prefillColor = prefillColor;
+
+        if (grid.mouseDownState) {
+            config.mouseDown = grid.mouseDownState.gridCell.equals(cellEvent.gridCell);
+        }
+
+        // compute value if a calculator
+        if (isUserDataArea && !(config.value && config.value.constructor === Array)) { // fastest array determination
+            config.value = config.exec(config.value);
+        }
+
+        // This call's dataModel.getCell which developer can override to:
+        // * mutate the (writable) properties of `config`
+        // * mutate cell renderer choice (instance of which is returned)
+        var cellRenderer = behavior.dataModel.getCell(config, config.renderer);
+
+        // Overwrite possibly mutated cell properties, if requested to do so by `getCell` override
+        if (cellEvent.cellOwnProperties && config.reapplyCellProperties) {
+            Object.assign(config, cellEvent.cellOwnProperties);
+        }
+
+        behavior.cellPropertiesPrePaintNotification(config);
+
+        //allow the renderer to identify itself if it's a button
+        config.buttonCells = this.buttonCells;
+
+        config.formatValue = grid.getFormatter(format);
+
+        // Following supports partial render>
+        config.snapshot = cellEvent.snapshot;
+        config.minWidth = cellEvent.minWidth; // in case `paint` aborts before setting `minWidth`
+
+        // Render the cell
+        cellRenderer.paint(gc, config);
+
+        // Following supports partial render:
+        cellEvent.snapshot = config.snapshot;
+        cellEvent.minWidth = config.minWidth;
+
+        return config.minWidth;
+    },
+
+    /**
+     * @param {number|CellEvent} colIndexOrCellEvent - This is the "data" x coordinate.
+     * @param {number} [rowIndex] - This is the "data" y coordinate. Omit if `colIndexOrCellEvent` is a `CellEvent`.
+     * @param {dataModelAPI} [dataModel=this.grid.behavior.dataModel] Omit if `colIndexOrCellEvent` is a `CellEvent`.
+     * @returns {CellEvent} The matching `CellEvent` object from the renderer's pool. Returns `undefined` if the requested cell is not currently visible (due to being scrolled out of view).
+     */
+    findCell: function(colIndexOrCellEvent, rowIndex, dataModel) {
+        var colIndex, cellEvent,
+            pool = this.cellEventPool;
+
+        if (typeof colIndexOrCellEvent === 'object') {
+            // colIndexOrCellEvent is a cell event object
+            dataModel = rowIndex;
+            rowIndex = colIndexOrCellEvent.visibleRow.rowIndex;
+            colIndex = colIndexOrCellEvent.column.index;
+        } else {
+            colIndex = colIndexOrCellEvent;
+        }
+
+        dataModel = dataModel || this.grid.behavior.dataModel;
+
+        for (var p = 0, len = this.visibleColumns.length * this.visibleRows.length; p < len; ++p) {
+            cellEvent = pool[p];
+            if (
+                cellEvent.subgrid === dataModel &&
+                cellEvent.column.index === colIndex &&
+                cellEvent.visibleRow.rowIndex === rowIndex
+            ) {
+                return cellEvent;
+            }
+        }
+    },
+
+    /**
+     * Resets the cell properties cache in the matching `CellEvent` object from the renderer's pool. This will insure that a new cell properties object will be known to the renderer. (Normally, the cache is not reset until the pool is updated by the next call to {@link Renderer#computeCellBounds}).
+     * @param {number|CellEvent} xOrCellEvent
+     * @param {number} [y]
+     * @param {dataModelAPI} [dataModel=this.grid.behavior.dataModel]
+     * @returns {CellEvent} The matching `CellEvent` object.
+     */
+    resetCellPropertiesCache: function(xOrCellEvent, y, dataModel) {
+        var cellEvent = this.findCell.apply(this, arguments);
+        if (cellEvent) { cellEvent._cellOwnProperties = undefined; }
+        return cellEvent;
+    },
+
+    resetAllCellPropertiesCaches: function() {
+        this.cellEventPool.forEach(function(cellEvent) {
+            cellEvent._cellOwnProperties = undefined;
+        });
+    },
+
+    isViewableButton: function(c, r) {
+        var key = c + ',' + r;
+        return this.buttonCells[key] === true;
+    },
+
+    getBounds: function() {
+        return this.bounds;
+    },
+
+    setBounds: function(bounds) {
+        return (this.bounds = bounds);
+    },
+
+    setInfo: function(message) {
+        var width;
+        if (this.visibleColumns.length) {
+            width = this.visibleColumns[this.visibleColumns.length - 1].right;
+        }
+        this.grid.canvas.setInfo(message, width);
+    }
+});
+
+function resetNumberColumnWidth(gc, behavior) {
+    var rowCount = behavior.dataModel.getRowCount(),
+        columnProperties = behavior.getColumnProperties(-1),
+        cellProperties = columnProperties.rowHeader,
+        padding = 2 * columnProperties.cellPadding,
+        iconWidth = columnProperties.preferredWidth = Math.max(
+            images.checked ? images.checked.width : 0,
+            images.unchecked ? images.unchecked.width : 0
+        );
+
+    gc.cache.font = cellProperties.foregroundSelectionFont.indexOf('bold ') >= 0
+        ? cellProperties.foregroundSelectionFont : cellProperties.font;
+
+    columnProperties.preferredWidth = iconWidth + padding + gc.getTextWidth(rowCount);
+
+    if (columnProperties.width === undefined) {
+        columnProperties.width = columnProperties.preferredWidth;
+    }
+}
+
+Renderer.prototype.registerGridRenderer(require('./by-cells'));
+Renderer.prototype.registerGridRenderer(require('./by-columns'));
+Renderer.prototype.registerGridRenderer(require('./by-columns-discrete'));
+Renderer.prototype.registerGridRenderer(require('./by-columns-and-rows'));
+Renderer.prototype.registerGridRenderer(require('./by-rows'));
+
+module.exports = Renderer;
